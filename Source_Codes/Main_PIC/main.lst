CCS PCH C Compiler, Version 5.050, 43599               06-Sep-24 16:35

               Filename:   C:\Users\cholab-12\OneDrive - Kyushu Institute Of Technolgy\Leopard Project\Software\MAIN PIC\main.lst

               ROM used:   114442 bytes (87%)
                           Largest free fragment is 16612
               RAM used:   3023 (84%) at main() level
                           3469 (97%) worst case
               Stack used: 9 locations (7 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   1B1A4
*
00008:  GOTO   00F2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  BTFSS  FF2.5
0006E:  GOTO   0078
00072:  BTFSC  FF2.2
00074:  GOTO   4332
00078:  BTFSS  F9D.5
0007A:  GOTO   0084
0007E:  BTFSC  F9E.5
00080:  GOTO   2152
00084:  BTFSS  F61.5
00086:  GOTO   0090
0008A:  BTFSC  FA6.5
0008C:  GOTO   3BAC
00090:  BTFSS  F61.7
00092:  GOTO   009C
00096:  BTFSC  FA6.7
00098:  GOTO   3F7C
0009C:  MOVFF  0E,00
000A0:  MOVFF  0F,01
000A4:  MOVFF  10,02
000A8:  MOVFF  11,03
000AC:  MOVFF  0C,FE9
000B0:  MOVFF  07,FEA
000B4:  BSF    07.7
000B6:  MOVFF  08,FE1
000BA:  MOVFF  09,FE2
000BE:  MOVFF  0A,FD9
000C2:  MOVFF  0B,FDA
000C6:  MOVFF  12,FF3
000CA:  MOVFF  13,FF4
000CE:  MOVFF  14,FFA
000D2:  MOVFF  15,FF5
000D6:  MOVFF  16,FF6
000DA:  MOVFF  17,FF7
000DE:  MOVFF  18,FF8
000E2:  MOVFF  19,FFB
000E6:  MOVF   04,W
000E8:  MOVFF  06,FE0
000EC:  MOVFF  05,FD8
000F0:  RETFIE 0
000F2:  MOVLB  0
000F4:  MOVFF  FE9,21
000F8:  MOVFF  FEA,1C
000FC:  MOVFF  FE1,1D
00100:  MOVFF  FE2,1E
00104:  MOVFF  FD9,1F
00108:  MOVFF  FDA,20
0010C:  MOVFF  FF3,27
00110:  MOVFF  FF4,28
00114:  MOVFF  FFA,29
00118:  MOVFF  FF5,2A
0011C:  MOVFF  FF6,2B
00120:  MOVFF  FF7,2C
00124:  MOVFF  FF8,2D
00128:  MOVFF  FFB,2E
0012C:  MOVFF  00,23
00130:  MOVFF  01,24
00134:  MOVFF  02,25
00138:  MOVFF  03,26
0013C:  BTFSS  FA3.5
0013E:  GOTO   0148
00142:  BTFSC  FA4.5
00144:  GOTO   37CE
00148:  MOVFF  23,00
0014C:  MOVFF  24,01
00150:  MOVFF  25,02
00154:  MOVFF  26,03
00158:  MOVFF  21,FE9
0015C:  MOVFF  1C,FEA
00160:  BSF    1C.7
00162:  MOVFF  1D,FE1
00166:  MOVFF  1E,FE2
0016A:  MOVFF  1F,FD9
0016E:  MOVFF  20,FDA
00172:  MOVFF  27,FF3
00176:  MOVFF  28,FF4
0017A:  MOVFF  29,FFA
0017E:  MOVFF  2A,FF5
00182:  MOVFF  2B,FF6
00186:  MOVFF  2C,FF7
0018A:  MOVFF  2D,FF8
0018E:  MOVFF  2E,FFB
00192:  RETFIE 1
.................... #include "device.h" 
.................... #ifndef DEVICE_H 
.................... #define DEVICE_H 
....................  
.................... // For the real case ---------------------------------------------------------------------- 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
00194:  CLRF   FF7
00196:  ADDLW  A8
00198:  MOVWF  FF6
0019A:  MOVLW  01
0019C:  ADDWFC FF7,F
0019E:  MOVLW  00
001A0:  MOVWF  FF8
001A2:  TBLRD*+
001A4:  MOVF   FF5,W
001A6:  RETURN 0
001A8:  DATA B0,A0
001AA:  DATA 00,00
001AC:  DATA 00,00
001AE:  DATA 00,00
001B0:  DATA 00,00
001B2:  DATA 00,00
001B4:  DATA 00,00
001B6:  DATA 00,00
001B8:  DATA 00,00
001BA:  DATA 00,00
001BC:  DATA 00,00
001BE:  DATA 00,00
001C0:  DATA 00,00
001C2:  DATA 00,00
001C4:  DATA 00,00
001C6:  DATA 00,00
001C8:  DATA 00,00
001CA:  DATA 00,B1
001CC:  CLRF   FF7
001CE:  ADDLW  E0
001D0:  MOVWF  FF6
001D2:  MOVLW  01
001D4:  ADDWFC FF7,F
001D6:  MOVLW  00
001D8:  MOVWF  FF8
001DA:  TBLRD*+
001DC:  MOVF   FF5,W
001DE:  RETURN 0
001E0:  DATA B0,A2
001E2:  DATA 00,00
001E4:  DATA 00,00
001E6:  DATA 00,00
001E8:  DATA 00,00
001EA:  DATA 00,00
001EC:  DATA 00,00
001EE:  DATA 00,00
001F0:  DATA 00,00
001F2:  DATA 00,00
001F4:  DATA 00,00
001F6:  DATA 00,00
001F8:  DATA 00,00
001FA:  DATA 00,00
001FC:  DATA 00,00
001FE:  DATA 00,00
00200:  DATA 00,00
00202:  DATA 00,B1
00204:  CLRF   FF7
00206:  ADDLW  18
00208:  MOVWF  FF6
0020A:  MOVLW  02
0020C:  ADDWFC FF7,F
0020E:  MOVLW  00
00210:  MOVWF  FF8
00212:  TBLRD*+
00214:  MOVF   FF5,W
00216:  RETURN 0
00218:  DATA 0B,06
0021A:  DATA 1D,06
0021C:  DATA E8,03
0021E:  DATA E8,03
00220:  DATA E8,03
00222:  DATA 10,27
00224:  DATA 13,00
00226:  DATA 00,00
00228:  DATA 00,00
0022A:  DATA 00,00
0022C:  DATA 20,21
0022E:  DATA 00,00
00230:  DATA 00,00
00232:  DATA 00,00
00234:  DATA 00,00
00236:  DATA 30,31
00238:  DATA 00,00
0023A:  DATA 00,00
0023C:  DATA 00,00
0023E:  DATA 00,00
00240:  DATA 40,41
00242:  DATA 00,0C
00244:  CLRF   FF7
00246:  ADDLW  58
00248:  MOVWF  FF6
0024A:  MOVLW  02
0024C:  ADDWFC FF7,F
0024E:  MOVLW  00
00250:  MOVWF  FF8
00252:  TBLRD*+
00254:  MOVF   FF5,W
00256:  RETURN 0
00258:  DATA 0B,06
0025A:  DATA 1D,03
0025C:  DATA 00,00
0025E:  DATA 00,00
00260:  DATA 00,00
00262:  DATA 10,11
00264:  DATA 00,00
00266:  DATA 00,00
00268:  DATA 00,00
0026A:  DATA 00,00
0026C:  DATA 20,21
0026E:  DATA 00,00
00270:  DATA 00,00
00272:  DATA 00,00
00274:  DATA 00,00
00276:  DATA 30,31
00278:  DATA 00,00
0027A:  DATA 00,00
0027C:  DATA 00,00
0027E:  DATA 00,00
00280:  DATA 40,41
00282:  DATA 00,0C
00284:  CLRF   FF7
00286:  ADDLW  98
00288:  MOVWF  FF6
0028A:  MOVLW  02
0028C:  ADDWFC FF7,F
0028E:  MOVLW  00
00290:  MOVWF  FF8
00292:  TBLRD*+
00294:  MOVF   FF5,W
00296:  RETURN 0
00298:  DATA 0B,06
0029A:  DATA 36,00
0029C:  DATA 00,00
0029E:  DATA 00,00
002A0:  DATA 00,00
002A2:  DATA 10,11
002A4:  DATA 00,00
002A6:  DATA 00,00
002A8:  DATA 00,00
002AA:  DATA 00,00
002AC:  DATA 20,21
002AE:  DATA 00,00
002B0:  DATA 00,00
002B2:  DATA 00,00
002B4:  DATA 00,00
002B6:  DATA 30,31
002B8:  DATA 00,00
002BA:  DATA 00,00
002BC:  DATA 00,00
002BE:  DATA 00,00
002C0:  DATA 40,41
002C2:  DATA 00,0C
002C4:  CLRF   FF7
002C6:  ADDLW  D8
002C8:  MOVWF  FF6
002CA:  MOVLW  02
002CC:  ADDWFC FF7,F
002CE:  MOVLW  00
002D0:  MOVWF  FF8
002D2:  TBLRD*+
002D4:  MOVF   FF5,W
002D6:  RETURN 0
002D8:  DATA 0B,06
002DA:  DATA 37,00
002DC:  DATA 00,00
002DE:  DATA 00,00
002E0:  DATA 00,10
002E2:  DATA 11,00
002E4:  DATA 00,00
002E6:  DATA 00,00
002E8:  DATA 00,00
002EA:  DATA 00,00
002EC:  DATA 20,21
002EE:  DATA 00,00
002F0:  DATA 00,00
002F2:  DATA 00,00
002F4:  DATA 00,00
002F6:  DATA 30,31
002F8:  DATA 00,00
002FA:  DATA 00,00
002FC:  DATA 00,00
002FE:  DATA 00,00
00300:  DATA 40,41
00302:  DATA 00,0C
00304:  CLRF   FF7
00306:  ADDLW  18
00308:  MOVWF  FF6
0030A:  MOVLW  03
0030C:  ADDWFC FF7,F
0030E:  MOVLW  00
00310:  MOVWF  FF8
00312:  TBLRD*+
00314:  MOVF   FF5,W
00316:  RETURN 0
00318:  DATA 0B,06
0031A:  DATA 38,00
0031C:  DATA 00,00
0031E:  DATA 00,00
00320:  DATA 00,00
00322:  DATA 10,11
00324:  DATA 00,00
00326:  DATA 00,00
00328:  DATA 00,00
0032A:  DATA 00,00
0032C:  DATA 20,21
0032E:  DATA 00,00
00330:  DATA 00,00
00332:  DATA 00,00
00334:  DATA 00,00
00336:  DATA 30,31
00338:  DATA 00,00
0033A:  DATA 00,00
0033C:  DATA 00,00
0033E:  DATA 00,00
00340:  DATA 40,41
00342:  DATA 00,0C
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 0B,06
0035A:  DATA 3A,02
0035C:  DATA 00,01
0035E:  DATA 00,00
00360:  DATA 00,00
00362:  DATA 10,11
00364:  DATA 00,00
00366:  DATA 00,00
00368:  DATA 00,00
0036A:  DATA 00,00
0036C:  DATA 20,21
0036E:  DATA 00,00
00370:  DATA 00,00
00372:  DATA 00,00
00374:  DATA 00,00
00376:  DATA 30,31
00378:  DATA 00,00
0037A:  DATA 00,00
0037C:  DATA 00,00
0037E:  DATA 00,00
00380:  DATA 40,41
00382:  DATA 00,0C
00384:  CLRF   FF7
00386:  ADDLW  98
00388:  MOVWF  FF6
0038A:  MOVLW  03
0038C:  ADDWFC FF7,F
0038E:  MOVLW  00
00390:  MOVWF  FF8
00392:  TBLRD*+
00394:  MOVF   FF5,W
00396:  RETURN 0
00398:  DATA 0B,06
0039A:  DATA 3A,01
0039C:  DATA 00,00
0039E:  DATA 00,00
003A0:  DATA 00,00
003A2:  DATA 10,11
003A4:  DATA 00,00
003A6:  DATA 00,00
003A8:  DATA 00,00
003AA:  DATA 00,00
003AC:  DATA 20,21
003AE:  DATA 00,00
003B0:  DATA 00,00
003B2:  DATA 00,00
003B4:  DATA 00,00
003B6:  DATA 30,31
003B8:  DATA 00,00
003BA:  DATA 00,00
003BC:  DATA 00,00
003BE:  DATA 00,00
003C0:  DATA 40,41
003C2:  DATA 00,0C
003C4:  CLRF   FF7
003C6:  ADDLW  D8
003C8:  MOVWF  FF6
003CA:  MOVLW  03
003CC:  ADDWFC FF7,F
003CE:  MOVLW  00
003D0:  MOVWF  FF8
003D2:  TBLRD*+
003D4:  MOVF   FF5,W
003D6:  RETURN 0
003D8:  DATA B0,A4
003DA:  DATA 00,00
003DC:  DATA 00,00
003DE:  DATA 00,00
003E0:  DATA 00,00
003E2:  DATA 00,00
003E4:  DATA 00,00
003E6:  DATA 00,00
003E8:  DATA 00,00
003EA:  DATA 00,00
003EC:  DATA 00,00
003EE:  DATA 00,00
003F0:  DATA 00,00
003F2:  DATA 00,00
003F4:  DATA 00,00
003F6:  DATA 00,00
003F8:  DATA 00,00
003FA:  DATA 00,B1
003FC:  MOVFF  FEC,FFA
00400:  MOVFF  FEC,FFB
00404:  MOVF   FED,F
00406:  MOVF   FED,F
00408:  MOVFF  FEF,FE8
0040C:  MOVWF  FF9
0040E:  RETURN 0
00410:  DATA 62,6F
00412:  DATA 6F,74
00414:  DATA 5F,66
00416:  DATA 6C,61
00418:  DATA 67,20
0041A:  DATA 3D,20
0041C:  DATA 25,30
0041E:  DATA 32,58
00420:  DATA 0D,0A
00422:  DATA 00,00
00424:  DATA 6C,65
00426:  DATA 61,70
00428:  DATA 5F,73
0042A:  DATA 65,63
0042C:  DATA 6F,6E
0042E:  DATA 64,73
00430:  DATA 20,3D
00432:  DATA 20,25
00434:  DATA 64,0D
00436:  DATA 0A,00
00438:  DATA 61,64
0043A:  DATA 63,73
0043C:  DATA 5F,6F
0043E:  DATA 6E,5F
00440:  DATA 6F,66
00442:  DATA 66,20
00444:  DATA 3D,20
00446:  DATA 25,75
00448:  DATA 0D,0A
0044A:  DATA 00,00
0044C:  DATA 4D,43
0044E:  DATA 50,5F
00450:  DATA 6F,6E
00452:  DATA 5F,6F
00454:  DATA 66,66
00456:  DATA 20,3D
00458:  DATA 20,25
0045A:  DATA 75,0D
0045C:  DATA 0A,00
0045E:  DATA 67,70
00460:  DATA 73,5F
00462:  DATA 74,69
00464:  DATA 6D,65
00466:  DATA 5F,73
00468:  DATA 79,6E
0046A:  DATA 63,5F
0046C:  DATA 73,74
0046E:  DATA 61,74
00470:  DATA 65,20
00472:  DATA 3D,20
00474:  DATA 25,75
00476:  DATA 0D,0A
00478:  DATA 00,00
0047A:  DATA 61,64
0047C:  DATA 63,73
0047E:  DATA 5F,69
00480:  DATA 6E,69
00482:  DATA 74,69
00484:  DATA 61,6C
00486:  DATA 5F,76
00488:  DATA 61,6C
0048A:  DATA 75,65
0048C:  DATA 20,3D
0048E:  DATA 20,25
00490:  DATA 64,0D
00492:  DATA 0A,00
00494:  DATA 63,77
00496:  DATA 5F,6D
00498:  DATA 6F,64
0049A:  DATA 65,20
0049C:  DATA 3D,20
0049E:  DATA 25,75
004A0:  DATA 0D,0A
004A2:  DATA 00,00
004A4:  DATA 68,65
004A6:  DATA 61,74
004A8:  DATA 65,72
004AA:  DATA 5F,72
004AC:  DATA 65,66
004AE:  DATA 5F,74
004B0:  DATA 65,6D
004B2:  DATA 70,65
004B4:  DATA 72,61
004B6:  DATA 74,75
004B8:  DATA 72,65
004BA:  DATA 20,3D
004BC:  DATA 20,25
004BE:  DATA 30,34
004C0:  DATA 6C,58
004C2:  DATA 0D,0A
004C4:  DATA 00,00
004C6:  DATA 68,65
004C8:  DATA 61,74
004CA:  DATA 65,72
004CC:  DATA 5F,72
004CE:  DATA 65,66
004D0:  DATA 5F,76
004D2:  DATA 6F,6C
004D4:  DATA 74,61
004D6:  DATA 67,65
004D8:  DATA 20,3D
004DA:  DATA 20,25
004DC:  DATA 30,34
004DE:  DATA 6C,58
004E0:  DATA 0D,0A
004E2:  DATA 00,00
004E4:  DATA 6F,70
004E6:  DATA 65,72
004E8:  DATA 61,5F
004EA:  DATA 62,6F
004EC:  DATA 6F,74
004EE:  DATA 5F,64
004F0:  DATA 75,72
004F2:  DATA 61,74
004F4:  DATA 69,6F
004F6:  DATA 6E,20
004F8:  DATA 3D,20
004FA:  DATA 25,75
004FC:  DATA 73,0D
004FE:  DATA 0A,00
00500:  DATA 72,65
00502:  DATA 6C,61
00504:  DATA 79,5F
00506:  DATA 6F,6E
00508:  DATA 5F,6F
0050A:  DATA 66,66
0050C:  DATA 20,3D
0050E:  DATA 20,25
00510:  DATA 75,0D
00512:  DATA 0A,00
00514:  DATA 63,61
00516:  DATA 6D,65
00518:  DATA 72,61
0051A:  DATA 5F,70
0051C:  DATA 61,72
0051E:  DATA 61,6D
00520:  DATA 65,74
00522:  DATA 65,72
00524:  DATA 73,20
00526:  DATA 3D,20
00528:  DATA 00,00
0052A:  DATA 7C,4D
0052C:  DATA 55,58
0052E:  DATA 20,63
00530:  DATA 68,61
00532:  DATA 6E,67
00534:  DATA 65,64
00536:  DATA 20,74
00538:  DATA 6F,20
0053A:  DATA 25,73
0053C:  DATA 7C,00
0053E:  DATA 0D,0A
00540:  DATA 44,61
00542:  DATA 79,20
00544:  DATA 6F,66
00546:  DATA 20,74
00548:  DATA 68,65
0054A:  DATA 20,79
0054C:  DATA 65,61
0054E:  DATA 72,20
00550:  DATA 3D,20
00552:  DATA 25,6C
00554:  DATA 75,0D
00556:  DATA 0A,00
00558:  DATA 43,61
0055A:  DATA 6E,64
0055C:  DATA 69,64
0055E:  DATA 61,74
00560:  DATA 65,20
00562:  DATA 74,65
00564:  DATA 6C,65
00566:  DATA 6D,65
00568:  DATA 74,72
0056A:  DATA 79,20
0056C:  DATA 61,64
0056E:  DATA 64,72
00570:  DATA 65,73
00572:  DATA 73,20
00574:  DATA 3D,20
00576:  DATA 30,78
00578:  DATA 25,38
0057A:  DATA 6C,58
0057C:  DATA 0D,0A
0057E:  DATA 00,00
00580:  DATA 49,6E
00582:  DATA 69,74
00584:  DATA 69,61
00586:  DATA 6C,20
00588:  DATA 74,65
0058A:  DATA 6C,65
0058C:  DATA 6D,65
0058E:  DATA 74,72
00590:  DATA 79,20
00592:  DATA 61,64
00594:  DATA 64,72
00596:  DATA 65,73
00598:  DATA 73,20
0059A:  DATA 3D,20
0059C:  DATA 30,78
0059E:  DATA 25,38
005A0:  DATA 6C,58
005A2:  DATA 0D,0A
005A4:  DATA 00,00
005A6:  DATA 43,75
005A8:  DATA 72,72
005AA:  DATA 65,6E
005AC:  DATA 74,20
005AE:  DATA 74,65
005B0:  DATA 6C,65
005B2:  DATA 6D,65
005B4:  DATA 74,72
005B6:  DATA 79,20
005B8:  DATA 61,64
005BA:  DATA 64,72
005BC:  DATA 65,73
005BE:  DATA 73,20
005C0:  DATA 3D,20
005C2:  DATA 30,78
005C4:  DATA 25,38
005C6:  DATA 6C,58
005C8:  DATA 0D,0A
005CA:  DATA 00,00
005CC:  DATA 54,65
005CE:  DATA 6C,65
005D0:  DATA 6D,65
005D2:  DATA 74,72
005D4:  DATA 79,20
005D6:  DATA 73,69
005D8:  DATA 7A,65
005DA:  DATA 20,3D
005DC:  DATA 20,25
005DE:  DATA 75,0D
005E0:  DATA 0A,00
005E2:  DATA 4C,61
005E4:  DATA 73,74
005E6:  DATA 20,74
005E8:  DATA 65,6C
005EA:  DATA 65,6D
005EC:  DATA 65,74
005EE:  DATA 72,79
005F0:  DATA 20,61
005F2:  DATA 64,64
005F4:  DATA 72,65
005F6:  DATA 73,73
005F8:  DATA 20,3D
005FA:  DATA 20,30
005FC:  DATA 78,25
005FE:  DATA 38,6C
00600:  DATA 58,0D
00602:  DATA 0A,00
00604:  DATA 4C,6F
00606:  DATA 67,3A
00608:  DATA 20,30
0060A:  DATA 78,25
0060C:  DATA 30,38
0060E:  DATA 6C,58
00610:  DATA 20,3D
00612:  DATA 3E,20
00614:  DATA 30,78
00616:  DATA 25,30
00618:  DATA 38,6C
0061A:  DATA 58,00
0061C:  DATA 57,61
0061E:  DATA 72,6E
00620:  DATA 69,6E
00622:  DATA 67,3A
00624:  DATA 20,6D
00626:  DATA 75,78
00628:  DATA 20,72
0062A:  DATA 65,73
0062C:  DATA 65,72
0062E:  DATA 76,61
00630:  DATA 74,69
00632:  DATA 6F,6E
00634:  DATA 20,74
00636:  DATA 69,6D
00638:  DATA 65,20
0063A:  DATA 74,6F
0063C:  DATA 6F,20
0063E:  DATA 6C,6F
00640:  DATA 6E,67
00642:  DATA 21,00
00644:  DATA 43,68
00646:  DATA 61,6E
00648:  DATA 67,65
0064A:  DATA 64,20
0064C:  DATA 4D,55
0064E:  DATA 58,20
00650:  DATA 74,6F
00652:  DATA 20,70
00654:  DATA 6F,73
00656:  DATA 69,74
00658:  DATA 69,6F
0065A:  DATA 6E,20
0065C:  DATA 25,64
0065E:  DATA 00,00
00660:  DATA 50,61
00662:  DATA 67,65
00664:  DATA 20,30
00666:  DATA 20,44
00668:  DATA 65,73
0066A:  DATA 65,72
0066C:  DATA 69,61
0066E:  DATA 6C,69
00670:  DATA 7A,65
00672:  DATA 64,20
00674:  DATA 44,61
00676:  DATA 74,61
00678:  DATA 3A,0D
0067A:  DATA 0A,00
0067C:  DATA 42,61
0067E:  DATA 74,74
00680:  DATA 65,72
00682:  DATA 79,20
00684:  DATA 56,6F
00686:  DATA 6C,74
00688:  DATA 61,67
0068A:  DATA 65,20
0068C:  DATA 28,52
0068E:  DATA 53,54
00690:  DATA 20,52
00692:  DATA 41,57
00694:  DATA 20,76
00696:  DATA 6F,6C
00698:  DATA 74,61
0069A:  DATA 67,65
0069C:  DATA 29,3A
0069E:  DATA 20,25
006A0:  DATA 75,0D
006A2:  DATA 0A,00
006A4:  DATA 42,61
006A6:  DATA 74,74
006A8:  DATA 65,72
006AA:  DATA 79,20
006AC:  DATA 43,75
006AE:  DATA 72,72
006B0:  DATA 65,6E
006B2:  DATA 74,3A
006B4:  DATA 20,25
006B6:  DATA 75,0D
006B8:  DATA 0A,00
006BA:  DATA 42,61
006BC:  DATA 74,74
006BE:  DATA 65,72
006C0:  DATA 79,20
006C2:  DATA 54,65
006C4:  DATA 6D,70
006C6:  DATA 65,72
006C8:  DATA 61,74
006CA:  DATA 75,72
006CC:  DATA 65,3A
006CE:  DATA 20,25
006D0:  DATA 75,0D
006D2:  DATA 0A,00
006D4:  DATA 43,50
006D6:  DATA 4C,44
006D8:  DATA 20,54
006DA:  DATA 65,6D
006DC:  DATA 70,65
006DE:  DATA 72,61
006E0:  DATA 74,75
006E2:  DATA 72,65
006E4:  DATA 3A,20
006E6:  DATA 25,75
006E8:  DATA 0D,0A
006EA:  DATA 00,00
006EC:  DATA 53,6F
006EE:  DATA 6C,61
006F0:  DATA 72,20
006F2:  DATA 43,65
006F4:  DATA 6C,6C
006F6:  DATA 20,53
006F8:  DATA 41,50
006FA:  DATA 20,2B
006FC:  DATA 5A,20
006FE:  DATA 28,2B
00700:  DATA 59,20
00702:  DATA 75,6E
00704:  DATA 64,65
00706:  DATA 70,6C
00708:  DATA 2E,29
0070A:  DATA 3A,20
0070C:  DATA 25,75
0070E:  DATA 0D,0A
00710:  DATA 00,00
00712:  DATA 53,6F
00714:  DATA 6C,61
00716:  DATA 72,20
00718:  DATA 43,65
0071A:  DATA 6C,6C
0071C:  DATA 20,2B
0071E:  DATA 59,3A
00720:  DATA 20,25
00722:  DATA 75,0D
00724:  DATA 0A,00
00726:  DATA 53,6F
00728:  DATA 6C,61
0072A:  DATA 72,20
0072C:  DATA 43,65
0072E:  DATA 6C,6C
00730:  DATA 20,2B
00732:  DATA 58,3A
00734:  DATA 20,25
00736:  DATA 75,0D
00738:  DATA 0A,00
0073A:  DATA 53,6F
0073C:  DATA 6C,61
0073E:  DATA 72,20
00740:  DATA 43,65
00742:  DATA 6C,6C
00744:  DATA 20,2D
00746:  DATA 59,3A
00748:  DATA 20,25
0074A:  DATA 75,0D
0074C:  DATA 0A,00
0074E:  DATA 53,6F
00750:  DATA 6C,61
00752:  DATA 72,20
00754:  DATA 43,65
00756:  DATA 6C,6C
00758:  DATA 20,53
0075A:  DATA 41,50
0075C:  DATA 20,2B
0075E:  DATA 5A,20
00760:  DATA 28,2D
00762:  DATA 59,20
00764:  DATA 75,6E
00766:  DATA 64,65
00768:  DATA 70,6C
0076A:  DATA 2E,29
0076C:  DATA 3A,20
0076E:  DATA 25,75
00770:  DATA 0D,0A
00772:  DATA 00,00
00774:  DATA 53,6F
00776:  DATA 6C,61
00778:  DATA 72,20
0077A:  DATA 43,65
0077C:  DATA 6C,6C
0077E:  DATA 20,2D
00780:  DATA 5A,3A
00782:  DATA 20,25
00784:  DATA 75,0D
00786:  DATA 0A,00
00788:  DATA 53,63
0078A:  DATA 68,65
0078C:  DATA 64,75
0078E:  DATA 6C,65
00790:  DATA 64,20
00792:  DATA 63,6F
00794:  DATA 6D,6D
00796:  DATA 61,6E
00798:  DATA 64,73
0079A:  DATA 20,69
0079C:  DATA 6E,20
0079E:  DATA 6D,65
007A0:  DATA 6D,6F
007A2:  DATA 72,79
007A4:  DATA 3A,20
007A6:  DATA 25,75
007A8:  DATA 0D,0A
007AA:  DATA 00,00
007AC:  DATA 42,61
007AE:  DATA 74,74
007B0:  DATA 65,72
007B2:  DATA 79,20
007B4:  DATA 48,65
007B6:  DATA 61,74
007B8:  DATA 65,72
007BA:  DATA 20,46
007BC:  DATA 6C,61
007BE:  DATA 67,3A
007C0:  DATA 20,25
007C2:  DATA 75,0D
007C4:  DATA 0A,00
007C6:  DATA 4B,69
007C8:  DATA 6C,6C
007CA:  DATA 20,53
007CC:  DATA 77,69
007CE:  DATA 74,63
007D0:  DATA 68,20
007D2:  DATA 4D,61
007D4:  DATA 69,6E
007D6:  DATA 20,50
007D8:  DATA 49,43
007DA:  DATA 3A,20
007DC:  DATA 25,75
007DE:  DATA 0D,0A
007E0:  DATA 00,00
007E2:  DATA 4B,69
007E4:  DATA 6C,6C
007E6:  DATA 20,53
007E8:  DATA 77,69
007EA:  DATA 74,63
007EC:  DATA 68,20
007EE:  DATA 45,50
007F0:  DATA 53,3A
007F2:  DATA 20,25
007F4:  DATA 75,0D
007F6:  DATA 0A,00
007F8:  DATA 41,44
007FA:  DATA 43,53
007FC:  DATA 20,6D
007FE:  DATA 6F,64
00800:  DATA 65,3A
00802:  DATA 20,25
00804:  DATA 75,0D
00806:  DATA 0A,00
00808:  DATA 46,6F
0080A:  DATA 72,6D
0080C:  DATA 61,74
0080E:  DATA 20,69
00810:  DATA 64,65
00812:  DATA 6E,74
00814:  DATA 69,66
00816:  DATA 69,65
00818:  DATA 72,3A
0081A:  DATA 20,25
0081C:  DATA 75,0D
0081E:  DATA 0A,00
00820:  DATA 50,61
00822:  DATA 67,65
00824:  DATA 20,31
00826:  DATA 20,44
00828:  DATA 65,73
0082A:  DATA 65,72
0082C:  DATA 69,61
0082E:  DATA 6C,69
00830:  DATA 7A,65
00832:  DATA 64,20
00834:  DATA 44,61
00836:  DATA 74,61
00838:  DATA 3A,0D
0083A:  DATA 0A,00
0083C:  DATA 47,79
0083E:  DATA 72,6F
00840:  DATA 20,58
00842:  DATA 20,61
00844:  DATA 78,69
00846:  DATA 73,3A
00848:  DATA 20,25
0084A:  DATA 75,0D
0084C:  DATA 0A,00
0084E:  DATA 47,79
00850:  DATA 72,6F
00852:  DATA 20,2D
00854:  DATA 59,20
00856:  DATA 61,78
00858:  DATA 69,73
0085A:  DATA 3A,20
0085C:  DATA 25,75
0085E:  DATA 0D,0A
00860:  DATA 00,00
00862:  DATA 47,79
00864:  DATA 72,6F
00866:  DATA 20,2D
00868:  DATA 5A,20
0086A:  DATA 61,78
0086C:  DATA 69,73
0086E:  DATA 3A,20
00870:  DATA 25,75
00872:  DATA 0D,0A
00874:  DATA 00,00
00876:  DATA 4D,61
00878:  DATA 67,6E
0087A:  DATA 65,74
0087C:  DATA 6F,6D
0087E:  DATA 65,74
00880:  DATA 65,72
00882:  DATA 20,58
00884:  DATA 3A,20
00886:  DATA 25,75
00888:  DATA 0D,0A
0088A:  DATA 00,00
0088C:  DATA 4D,61
0088E:  DATA 67,6E
00890:  DATA 65,74
00892:  DATA 6F,6D
00894:  DATA 65,74
00896:  DATA 65,72
00898:  DATA 20,59
0089A:  DATA 3A,20
0089C:  DATA 25,75
0089E:  DATA 0D,0A
008A0:  DATA 00,00
008A2:  DATA 4D,61
008A4:  DATA 67,6E
008A6:  DATA 65,74
008A8:  DATA 6F,6D
008AA:  DATA 65,74
008AC:  DATA 65,72
008AE:  DATA 20,5A
008B0:  DATA 3A,20
008B2:  DATA 25,75
008B4:  DATA 0D,0A
008B6:  DATA 00,00
008B8:  DATA 53,75
008BA:  DATA 62,73
008BC:  DATA 79,73
008BE:  DATA 74,65
008C0:  DATA 6D,73
008C2:  DATA 20,63
008C4:  DATA 6F,6D
008C6:  DATA 6D,75
008C8:  DATA 6E,69
008CA:  DATA 63,61
008CC:  DATA 74,69
008CE:  DATA 6E,67
008D0:  DATA 3A,20
008D2:  DATA 25,75
008D4:  DATA 0D,0A
008D6:  DATA 00,00
008D8:  DATA 54,69
008DA:  DATA 6D,65
008DC:  DATA 20,61
008DE:  DATA 66,74
008E0:  DATA 65,72
008E2:  DATA 20,6C
008E4:  DATA 61,73
008E6:  DATA 74,20
008E8:  DATA 72,65
008EA:  DATA 73,65
008EC:  DATA 74,20
008EE:  DATA 28,68
008F0:  DATA 6F,75
008F2:  DATA 72,73
008F4:  DATA 29,3A
008F6:  DATA 20,25
008F8:  DATA 75,0D
008FA:  DATA 0A,00
008FC:  DATA 46,6F
008FE:  DATA 72,6D
00900:  DATA 61,74
00902:  DATA 20,69
00904:  DATA 64,65
00906:  DATA 6E,74
00908:  DATA 69,66
0090A:  DATA 69,65
0090C:  DATA 72,3A
0090E:  DATA 20,25
00910:  DATA 75,0D
00912:  DATA 0A,00
00914:  DATA 43,57
00916:  DATA 3A,20
00918:  DATA 30,78
0091A:  DATA 00,00
0091C:  DATA 20,30
0091E:  DATA 78,00
00920:  DATA 4D,55
00922:  DATA 58,20
00924:  DATA 63,68
00926:  DATA 61,6E
00928:  DATA 67,65
0092A:  DATA 20,66
0092C:  DATA 61,69
0092E:  DATA 6C,65
00930:  DATA 64,21
00932:  DATA 00,00
00934:  DATA 4D,43
00936:  DATA 50,49
00938:  DATA 43,20
0093A:  DATA 63,6D
0093C:  DATA 64,3A
0093E:  DATA 20,00
00940:  DATA 4D,55
00942:  DATA 58,20
00944:  DATA 63,68
00946:  DATA 61,6E
00948:  DATA 67,65
0094A:  DATA 20,66
0094C:  DATA 61,69
0094E:  DATA 6C,65
00950:  DATA 64,21
00952:  DATA 00,00
00954:  DATA 4D,55
00956:  DATA 58,20
00958:  DATA 63,68
0095A:  DATA 61,6E
0095C:  DATA 67,65
0095E:  DATA 20,66
00960:  DATA 61,69
00962:  DATA 6C,65
00964:  DATA 64,21
00966:  DATA 00,00
00968:  DATA 4D,55
0096A:  DATA 58,20
0096C:  DATA 63,68
0096E:  DATA 61,6E
00970:  DATA 67,65
00972:  DATA 20,66
00974:  DATA 61,69
00976:  DATA 6C,65
00978:  DATA 64,21
0097A:  DATA 00,00
0097C:  DATA 4D,55
0097E:  DATA 58,20
00980:  DATA 63,68
00982:  DATA 61,6E
00984:  DATA 67,65
00986:  DATA 20,66
00988:  DATA 61,69
0098A:  DATA 6C,65
0098C:  DATA 64,21
0098E:  DATA 00,00
00990:  DATA 4D,55
00992:  DATA 58,20
00994:  DATA 63,68
00996:  DATA 61,6E
00998:  DATA 67,65
0099A:  DATA 20,66
0099C:  DATA 61,69
0099E:  DATA 6C,65
009A0:  DATA 64,21
009A2:  DATA 00,00
009A4:  DATA 53,54
009A6:  DATA 4D,20
009A8:  DATA 52,41
009AA:  DATA 57,20
009AC:  DATA 43,4D
009AE:  DATA 44,3A
009B0:  DATA 20,00
009B2:  DATA 4D,55
009B4:  DATA 58,20
009B6:  DATA 63,68
009B8:  DATA 61,6E
009BA:  DATA 67,65
009BC:  DATA 20,66
009BE:  DATA 61,69
009C0:  DATA 6C,65
009C2:  DATA 64,21
009C4:  DATA 00,00
009C6:  DATA 4D,55
009C8:  DATA 58,20
009CA:  DATA 63,68
009CC:  DATA 61,6E
009CE:  DATA 67,65
009D0:  DATA 20,66
009D2:  DATA 61,69
009D4:  DATA 6C,65
009D6:  DATA 64,21
009D8:  DATA 00,00
009DA:  DATA 4D,55
009DC:  DATA 58,20
009DE:  DATA 63,68
009E0:  DATA 61,6E
009E2:  DATA 67,65
009E4:  DATA 20,66
009E6:  DATA 61,69
009E8:  DATA 6C,65
009EA:  DATA 64,21
009EC:  DATA 00,00
009EE:  DATA 4D,55
009F0:  DATA 58,20
009F2:  DATA 63,68
009F4:  DATA 61,6E
009F6:  DATA 67,65
009F8:  DATA 20,66
009FA:  DATA 61,69
009FC:  DATA 6C,65
009FE:  DATA 64,21
00A00:  DATA 00,00
00A02:  DATA 53,65
00A04:  DATA 6E,64
00A06:  DATA 69,6E
00A08:  DATA 67,20
00A0A:  DATA 63,6F
00A0C:  DATA 6D,6D
00A0E:  DATA 61,6E
00A10:  DATA 64,20
00A12:  DATA 25,30
00A14:  DATA 32,58
00A16:  DATA 20,25
00A18:  DATA 64,20
00A1A:  DATA 74,69
00A1C:  DATA 6D,65
00A1E:  DATA 73,20
00A20:  DATA 74,6F
00A22:  DATA 20,41
00A24:  DATA 44,43
00A26:  DATA 53,2E
00A28:  DATA 0D,0A
00A2A:  DATA 00,00
00A2C:  DATA 20,28
00A2E:  DATA 61,74
00A30:  DATA 74,65
00A32:  DATA 6D,70
00A34:  DATA 74,20
00A36:  DATA 25,64
00A38:  DATA 29,0D
00A3A:  DATA 0A,00
00A3C:  DATA 4D,55
00A3E:  DATA 58,20
00A40:  DATA 63,68
00A42:  DATA 61,6E
00A44:  DATA 67,65
00A46:  DATA 20,66
00A48:  DATA 61,69
00A4A:  DATA 6C,65
00A4C:  DATA 64,21
00A4E:  DATA 00,00
00A50:  DATA 4D,55
00A52:  DATA 58,20
00A54:  DATA 63,68
00A56:  DATA 61,6E
00A58:  DATA 67,65
00A5A:  DATA 20,66
00A5C:  DATA 61,69
00A5E:  DATA 6C,65
00A60:  DATA 64,21
00A62:  DATA 00,00
00A64:  DATA 53,54
00A66:  DATA 4D,33
00A68:  DATA 32,20
00A6A:  DATA 63,6F
00A6C:  DATA 6D,6D
00A6E:  DATA 61,6E
00A70:  DATA 64,20
00A72:  DATA 28,38
00A74:  DATA 2F,31
00A76:  DATA 36,29
00A78:  DATA 00,00
00A7A:  DATA 4D,55
00A7C:  DATA 58,20
00A7E:  DATA 63,68
00A80:  DATA 61,6E
00A82:  DATA 67,65
00A84:  DATA 20,66
00A86:  DATA 61,69
00A88:  DATA 6C,65
00A8A:  DATA 64,21
00A8C:  DATA 00,00
00A8E:  DATA 53,54
00A90:  DATA 4D,33
00A92:  DATA 32,20
00A94:  DATA 63,6F
00A96:  DATA 6D,6D
00A98:  DATA 61,6E
00A9A:  DATA 64,20
00A9C:  DATA 28,33
00A9E:  DATA 32,29
00AA0:  DATA 20,70
00AA2:  DATA 61,72
00AA4:  DATA 74,20
00AA6:  DATA 25,64
00AA8:  DATA 2E,20
00AAA:  DATA 00,00
00AAC:  DATA 4D,55
00AAE:  DATA 58,20
00AB0:  DATA 63,68
00AB2:  DATA 61,6E
00AB4:  DATA 67,65
00AB6:  DATA 20,66
00AB8:  DATA 61,69
00ABA:  DATA 6C,65
00ABC:  DATA 64,21
00ABE:  DATA 00,00
00AC0:  DATA 53,54
00AC2:  DATA 4D,33
00AC4:  DATA 32,20
00AC6:  DATA 63,6F
00AC8:  DATA 6D,6D
00ACA:  DATA 61,6E
00ACC:  DATA 64,20
00ACE:  DATA 28,33
00AD0:  DATA 32,29
00AD2:  DATA 20,70
00AD4:  DATA 61,72
00AD6:  DATA 74,20
00AD8:  DATA 25,64
00ADA:  DATA 2E,20
00ADC:  DATA 00,00
00ADE:  DATA 4D,55
00AE0:  DATA 58,20
00AE2:  DATA 63,68
00AE4:  DATA 61,6E
00AE6:  DATA 67,65
00AE8:  DATA 20,66
00AEA:  DATA 61,69
00AEC:  DATA 6C,65
00AEE:  DATA 64,21
00AF0:  DATA 00,00
00AF2:  DATA 41,44
00AF4:  DATA 43,53
00AF6:  DATA 3A,20
00AF8:  DATA 00,00
00AFA:  DATA 4D,6F
00AFC:  DATA 64,65
00AFE:  DATA 3D,25
00B00:  DATA 58,20
00B02:  DATA 7C,20
00B04:  DATA 00,00
00B06:  DATA 4D,55
00B08:  DATA 58,20
00B0A:  DATA 63,68
00B0C:  DATA 61,6E
00B0E:  DATA 67,65
00B10:  DATA 20,66
00B12:  DATA 61,69
00B14:  DATA 6C,65
00B16:  DATA 64,21
00B18:  DATA 00,00
00B1A:  DATA 0D,0A
00B1C:  DATA 4E,65
00B1E:  DATA 77,20
00B20:  DATA 74,69
00B22:  DATA 6D,65
00B24:  DATA 3A,20
00B26:  DATA 25,30
00B28:  DATA 34,6C
00B2A:  DATA 64,2F
00B2C:  DATA 25,30
00B2E:  DATA 32,64
00B30:  DATA 2F,25
00B32:  DATA 30,32
00B34:  DATA 64,20
00B36:  DATA 25,30
00B38:  DATA 32,64
00B3A:  DATA 3A,25
00B3C:  DATA 30,32
00B3E:  DATA 64,3A
00B40:  DATA 25,30
00B42:  DATA 32,64
00B44:  DATA 00,00
00B46:  DATA 55,70
00B48:  DATA 6C,69
00B4A:  DATA 6E,6B
00B4C:  DATA 3A,20
00B4E:  DATA 00,00
00B50:  DATA 20,56
00B52:  DATA 61,6C
00B54:  DATA 69,64
00B56:  DATA 20,75
00B58:  DATA 70,6C
00B5A:  DATA 69,6E
00B5C:  DATA 6B,00
00B5E:  DATA 20,49
00B60:  DATA 6E,76
00B62:  DATA 61,6C
00B64:  DATA 69,64
00B66:  DATA 20,28
00B68:  DATA 25,64
00B6A:  DATA 29,20
00B6C:  DATA 6F,72
00B6E:  DATA 20,69
00B70:  DATA 64,65
00B72:  DATA 6E,74
00B74:  DATA 69,63
00B76:  DATA 61,6C
00B78:  DATA 20,28
00B7A:  DATA 25,64
00B7C:  DATA 29,20
00B7E:  DATA 75,70
00B80:  DATA 6C,69
00B82:  DATA 6E,6B
00B84:  DATA 2E,00
00B86:  DATA 43,4F
00B88:  DATA 4D,3A
00B8A:  DATA 20,00
00B8C:  DATA 20,4E
00B8E:  DATA 65,77
00B90:  DATA 20,74
00B92:  DATA 69,6D
00B94:  DATA 65,3A
00B96:  DATA 20,25
00B98:  DATA 30,34
00B9A:  DATA 6C,64
00B9C:  DATA 2F,25
00B9E:  DATA 30,32
00BA0:  DATA 64,2F
00BA2:  DATA 25,30
00BA4:  DATA 32,64
00BA6:  DATA 20,25
00BA8:  DATA 30,32
00BAA:  DATA 64,3A
00BAC:  DATA 25,30
00BAE:  DATA 32,64
00BB0:  DATA 3A,25
00BB2:  DATA 30,32
00BB4:  DATA 64,28
00BB6:  DATA 30,78
00BB8:  DATA 25,30
00BBA:  DATA 38,6C
00BBC:  DATA 58,29
00BBE:  DATA 20,00
00BC0:  DATA 4C,65
00BC2:  DATA 61,70
00BC4:  DATA 3A,20
00BC6:  DATA 25,64
00BC8:  DATA 20,47
00BCA:  DATA 50,53
00BCC:  DATA 20,73
00BCE:  DATA 79,6E
00BD0:  DATA 63,3A
00BD2:  DATA 20,30
00BD4:  DATA 78,25
00BD6:  DATA 30,32
00BD8:  DATA 58,00
00BDA:  DATA 0D,0A
00BDC:  DATA 20,20
00BDE:  DATA 20,20
00BE0:  DATA 20,20
00BE2:  DATA 20,20
00BE4:  DATA 20,66
00BE6:  DATA 65,64
00BE8:  DATA 63,62
00BEA:  DATA 61,39
00BEC:  DATA 38,37
00BEE:  DATA 36,35
00BF0:  DATA 34,33
00BF2:  DATA 32,31
00BF4:  DATA 30,00
00BF6:  DATA 0D,0A
00BF8:  DATA 74,72
00BFA:  DATA 69,73
00BFC:  DATA 5F,61
00BFE:  DATA 20,3D
00C00:  DATA 20,00
00C02:  DATA 0D,0A
00C04:  DATA 74,72
00C06:  DATA 69,73
00C08:  DATA 5F,62
00C0A:  DATA 20,3D
00C0C:  DATA 20,00
00C0E:  DATA 0D,0A
00C10:  DATA 74,72
00C12:  DATA 69,73
00C14:  DATA 5F,63
00C16:  DATA 20,3D
00C18:  DATA 20,00
00C1A:  DATA 0D,0A
00C1C:  DATA 74,72
00C1E:  DATA 69,73
00C20:  DATA 5F,64
00C22:  DATA 20,3D
00C24:  DATA 20,00
00C26:  DATA 0D,0A
00C28:  DATA 74,72
00C2A:  DATA 69,73
00C2C:  DATA 5F,65
00C2E:  DATA 20,3D
00C30:  DATA 20,00
00C32:  DATA 0D,0A
00C34:  DATA 74,72
00C36:  DATA 69,73
00C38:  DATA 5F,66
00C3A:  DATA 20,3D
00C3C:  DATA 20,00
00C3E:  DATA 0D,0A
00C40:  DATA 74,72
00C42:  DATA 69,73
00C44:  DATA 5F,67
00C46:  DATA 20,3D
00C48:  DATA 20,00
00C4A:  DATA 2A,25
00C4C:  DATA 30,34
00C4E:  DATA 6C,58
00C50:  DATA 20,3D
00C52:  DATA 20,25
00C54:  DATA 30,38
00C56:  DATA 6C,58
00C58:  DATA 00,00
00C5A:  DATA 43,68
00C5C:  DATA 61,6E
00C5E:  DATA 67,69
00C60:  DATA 6E,67
00C62:  DATA 20,76
00C64:  DATA 61,72
00C66:  DATA 69,61
00C68:  DATA 62,6C
00C6A:  DATA 65,20
00C6C:  DATA 61,74
00C6E:  DATA 20,30
00C70:  DATA 78,25
00C72:  DATA 30,34
00C74:  DATA 58,2C
00C76:  DATA 20,73
00C78:  DATA 69,7A
00C7A:  DATA 65,20
00C7C:  DATA 25,64
00C7E:  DATA 20,74
00C80:  DATA 6F,20
00C82:  DATA 30,78
00C84:  DATA 25,30
00C86:  DATA 38,4C
00C88:  DATA 58,00
00C8A:  DATA 44,65
00C8C:  DATA 70,6C
00C8E:  DATA 6F,79
00C90:  DATA 69,6E
00C92:  DATA 67,20
00C94:  DATA 55,48
00C96:  DATA 46,20
00C98:  DATA 41,6E
00C9A:  DATA 74,65
00C9C:  DATA 6E,6E
00C9E:  DATA 61,20
00CA0:  DATA 66,6F
00CA2:  DATA 72,20
00CA4:  DATA 25,64
00CA6:  DATA 73,2E
00CA8:  DATA 2E,2E
00CAA:  DATA 20,00
00CAC:  DATA 44,6F
00CAE:  DATA 6E,65
00CB0:  DATA 21,0D
00CB2:  DATA 0A,00
00CB4:  DATA 57,61
00CB6:  DATA 69,74
00CB8:  DATA 69,6E
00CBA:  DATA 67,20
00CBC:  DATA 31,30
00CBE:  DATA 73,20
00CC0:  DATA 66,6F
00CC2:  DATA 72,20
00CC4:  DATA 72,65
00CC6:  DATA 73,65
00CC8:  DATA 74,2E
00CCA:  DATA 2E,2E
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 0D,0A
00CD2:  DATA 48,65
00CD4:  DATA 78,20
00CD6:  DATA 64,75
00CD8:  DATA 6D,70
00CDA:  DATA 20,73
00CDC:  DATA 74,61
00CDE:  DATA 72,74
00CE0:  DATA 00,00
00CE2:  DATA 0D,0A
00CE4:  DATA 48,65
00CE6:  DATA 78,20
00CE8:  DATA 64,75
00CEA:  DATA 6D,70
00CEC:  DATA 20,65
00CEE:  DATA 6E,64
00CF0:  DATA 0D,0A
00CF2:  DATA 00,00
00CF4:  DATA 6D,65
00CF6:  DATA 6D,63
00CF8:  DATA 70,79
00CFA:  DATA 20,6F
00CFC:  DATA 72,69
00CFE:  DATA 67,3D
00D00:  DATA 25,64
00D02:  DATA 2C,64
00D04:  DATA 65,73
00D06:  DATA 74,3D
00D08:  DATA 25,64
00D0A:  DATA 2C,74
00D0C:  DATA 6F,5F
00D0E:  DATA 61,64
00D10:  DATA 64,72
00D12:  DATA 3D,25
00D14:  DATA 6C,58
00D16:  DATA 2C,66
00D18:  DATA 72,6F
00D1A:  DATA 6D,5F
00D1C:  DATA 61,64
00D1E:  DATA 64,72
00D20:  DATA 3D,25
00D22:  DATA 6C,58
00D24:  DATA 2C,73
00D26:  DATA 69,7A
00D28:  DATA 65,3D
00D2A:  DATA 25,6C
00D2C:  DATA 58,2C
00D2E:  DATA 6D,6F
00D30:  DATA 64,65
00D32:  DATA 3D,25
00D34:  DATA 64,00
00D36:  DATA 57,61
00D38:  DATA 69,74
00D3A:  DATA 69,6E
00D3C:  DATA 67,20
00D3E:  DATA 66,6F
00D40:  DATA 72,20
00D42:  DATA 78,6D
00D44:  DATA 6F,64
00D46:  DATA 65,6D
00D48:  DATA 20,74
00D4A:  DATA 72,61
00D4C:  DATA 6E,73
00D4E:  DATA 66,65
00D50:  DATA 72,2E
00D52:  DATA 2E,2E
00D54:  DATA 00,00
00D56:  DATA 4D,55
00D58:  DATA 58,20
00D5A:  DATA 63,68
00D5C:  DATA 61,6E
00D5E:  DATA 67,65
00D60:  DATA 20,66
00D62:  DATA 61,69
00D64:  DATA 6C,65
00D66:  DATA 64,21
00D68:  DATA 00,00
00D6A:  DATA 4D,55
00D6C:  DATA 58,20
00D6E:  DATA 63,68
00D70:  DATA 61,6E
00D72:  DATA 67,65
00D74:  DATA 20,66
00D76:  DATA 61,69
00D78:  DATA 6C,65
00D7A:  DATA 64,21
00D7C:  DATA 00,00
00D7E:  DATA 0A,72
00D80:  DATA 78,2C
00D82:  DATA 25,30
00D84:  DATA 35,6C
00D86:  DATA 75,0A
00D88:  DATA 00,00
00D8A:  DATA 52,65
00D8C:  DATA 63,65
00D8E:  DATA 69,76
00D90:  DATA 69,6E
00D92:  DATA 67,20
00D94:  DATA 78,6D
00D96:  DATA 6F,64
00D98:  DATA 65,6D
00D9A:  DATA 20,64
00D9C:  DATA 61,74
00D9E:  DATA 61,2E
00DA0:  DATA 2E,2E
00DA2:  DATA 00,00
00DA4:  DATA 4D,55
00DA6:  DATA 58,20
00DA8:  DATA 63,68
00DAA:  DATA 61,6E
00DAC:  DATA 67,65
00DAE:  DATA 20,66
00DB0:  DATA 61,69
00DB2:  DATA 6C,65
00DB4:  DATA 64,21
00DB6:  DATA 00,00
00DB8:  DATA 4D,55
00DBA:  DATA 58,20
00DBC:  DATA 63,68
00DBE:  DATA 61,6E
00DC0:  DATA 67,65
00DC2:  DATA 20,66
00DC4:  DATA 61,69
00DC6:  DATA 6C,65
00DC8:  DATA 64,21
00DCA:  DATA 00,00
00DCC:  DATA 4D,55
00DCE:  DATA 58,20
00DD0:  DATA 63,68
00DD2:  DATA 61,6E
00DD4:  DATA 67,65
00DD6:  DATA 20,66
00DD8:  DATA 61,69
00DDA:  DATA 6C,65
00DDC:  DATA 64,21
00DDE:  DATA 00,00
00DE0:  DATA 4D,55
00DE2:  DATA 58,20
00DE4:  DATA 63,68
00DE6:  DATA 61,6E
00DE8:  DATA 67,65
00DEA:  DATA 20,66
00DEC:  DATA 61,69
00DEE:  DATA 6C,65
00DF0:  DATA 64,21
00DF2:  DATA 00,00
00DF4:  DATA 6D,65
00DF6:  DATA 6D,63
00DF8:  DATA 70,79
00DFA:  DATA 20,6F
00DFC:  DATA 72,69
00DFE:  DATA 67,3D
00E00:  DATA 25,64
00E02:  DATA 2C,64
00E04:  DATA 65,73
00E06:  DATA 74,3D
00E08:  DATA 25,64
00E0A:  DATA 2C,74
00E0C:  DATA 6F,5F
00E0E:  DATA 61,64
00E10:  DATA 64,72
00E12:  DATA 3D,25
00E14:  DATA 6C,58
00E16:  DATA 2C,66
00E18:  DATA 72,6F
00E1A:  DATA 6D,5F
00E1C:  DATA 61,64
00E1E:  DATA 64,72
00E20:  DATA 3D,25
00E22:  DATA 6C,58
00E24:  DATA 2C,73
00E26:  DATA 69,7A
00E28:  DATA 65,3D
00E2A:  DATA 25,6C
00E2C:  DATA 58,0D
00E2E:  DATA 0A,00
00E30:  DATA 4D,61
00E32:  DATA 69,6E
00E34:  DATA 20,50
00E36:  DATA 49,43
00E38:  DATA 20,72
00E3A:  DATA 65,73
00E3C:  DATA 65,74
00E3E:  DATA 20,64
00E40:  DATA 65,74
00E42:  DATA 65,63
00E44:  DATA 74,65
00E46:  DATA 64,2E
00E48:  DATA 00,00
00E4A:  DATA 53,61
00E4C:  DATA 76,69
00E4E:  DATA 6E,67
00E50:  DATA 20,74
00E52:  DATA 65,6C
00E54:  DATA 65,6D
00E56:  DATA 65,74
00E58:  DATA 72,79
00E5A:  DATA 20,64
00E5C:  DATA 61,74
00E5E:  DATA 61,3A
00E60:  DATA 20,00
00E62:  DATA 41,64
00E64:  DATA 64,72
00E66:  DATA 3A,20
00E68:  DATA 30,78
00E6A:  DATA 25,30
00E6C:  DATA 38,6C
00E6E:  DATA 58,20
00E70:  DATA 00,00
00E72:  DATA 53,6B
00E74:  DATA 69,70
00E76:  DATA 70,69
00E78:  DATA 6E,67
00E7A:  DATA 20,73
00E7C:  DATA 61,76
00E7E:  DATA 69,6E
00E80:  DATA 67,20
00E82:  DATA 74,65
00E84:  DATA 6C,65
00E86:  DATA 6D,65
00E88:  DATA 74,72
00E8A:  DATA 79,20
00E8C:  DATA 64,61
00E8E:  DATA 74,61
00E90:  DATA 2E,00
00E92:  DATA 52,45
00E94:  DATA 53,45
00E96:  DATA 54,3A
00E98:  DATA 20,00
00E9A:  DATA 0D,0A
00E9C:  DATA 57,61
00E9E:  DATA 72,6E
00EA0:  DATA 69,6E
00EA2:  DATA 67,3A
00EA4:  DATA 20,61
00EA6:  DATA 20,73
00EA8:  DATA 63,68
00EAA:  DATA 65,64
00EAC:  DATA 75,6C
00EAE:  DATA 65,64
00EB0:  DATA 20,63
00EB2:  DATA 6F,6D
00EB4:  DATA 6D,61
00EB6:  DATA 6E,64
00EB8:  DATA 20,28
00EBA:  DATA 25,30
00EBC:  DATA 32,58
00EBE:  DATA 20,25
00EC0:  DATA 30,32
00EC2:  DATA 58,29
00EC4:  DATA 20,69
00EC6:  DATA 6E,20
00EC8:  DATA 66,6C
00ECA:  DATA 61,73
00ECC:  DATA 68,20
00ECE:  DATA 6D,65
00ED0:  DATA 6D,6F
00ED2:  DATA 72,79
00ED4:  DATA 20,77
00ED6:  DATA 61,73
00ED8:  DATA 20,73
00EDA:  DATA 63,68
00EDC:  DATA 65,64
00EDE:  DATA 75,6C
00EE0:  DATA 65,64
00EE2:  DATA 20,74
00EE4:  DATA 6F,20
00EE6:  DATA 72,75
00EE8:  DATA 6E,20
00EEA:  DATA 69,6E
00EEC:  DATA 20,61
00EEE:  DATA 20,70
00EF0:  DATA 61,73
00EF2:  DATA 74,20
00EF4:  DATA 64,61
00EF6:  DATA 74,65
00EF8:  DATA 2F,74
00EFA:  DATA 69,6D
00EFC:  DATA 65,20
00EFE:  DATA 61,6E
00F00:  DATA 64,20
00F02:  DATA 77,61
00F04:  DATA 73,20
00F06:  DATA 6D,61
00F08:  DATA 72,6B
00F0A:  DATA 65,64
00F0C:  DATA 20,61
00F0E:  DATA 73,20
00F10:  DATA 63,6F
00F12:  DATA 6D,70
00F14:  DATA 6C,65
00F16:  DATA 74,65
00F18:  DATA 2E,0D
00F1A:  DATA 0A,00
00F1C:  DATA 20,4E
00F1E:  DATA 65,77
00F20:  DATA 20,74
00F22:  DATA 69,6D
00F24:  DATA 65,3A
00F26:  DATA 20,25
00F28:  DATA 30,34
00F2A:  DATA 6C,64
00F2C:  DATA 2F,25
00F2E:  DATA 30,32
00F30:  DATA 64,2F
00F32:  DATA 25,30
00F34:  DATA 32,64
00F36:  DATA 20,25
00F38:  DATA 30,32
00F3A:  DATA 64,3A
00F3C:  DATA 25,30
00F3E:  DATA 32,64
00F40:  DATA 3A,25
00F42:  DATA 30,32
00F44:  DATA 64,20
00F46:  DATA 28,30
00F48:  DATA 78,25
00F4A:  DATA 30,38
00F4C:  DATA 6C,58
00F4E:  DATA 29,00
00F50:  DATA 4D,55
00F52:  DATA 58,20
00F54:  DATA 63,68
00F56:  DATA 61,6E
00F58:  DATA 67,65
00F5A:  DATA 20,66
00F5C:  DATA 61,69
00F5E:  DATA 6C,65
00F60:  DATA 64,21
00F62:  DATA 00,00
00F64:  DATA 57,61
00F66:  DATA 69,74
00F68:  DATA 69,6E
00F6A:  DATA 67,20
00F6C:  DATA 66,6F
00F6E:  DATA 72,20
00F70:  DATA 32,34
00F72:  DATA 68,20
00F74:  DATA 72,65
00F76:  DATA 73,65
00F78:  DATA 74,2E
00F7A:  DATA 2E,2E
00F7C:  DATA 0D,0A
00F7E:  DATA 00,00
00F80:  DATA 4E,6F
00F82:  DATA 20,32
00F84:  DATA 34,68
00F86:  DATA 20,72
00F88:  DATA 65,73
00F8A:  DATA 65,74
00F8C:  DATA 20,68
00F8E:  DATA 61,70
00F90:  DATA 70,65
00F92:  DATA 6E,65
00F94:  DATA 64,2C
00F96:  DATA 20,64
00F98:  DATA 6F,69
00F9A:  DATA 6E,67
00F9C:  DATA 20,73
00F9E:  DATA 6F,66
00FA0:  DATA 74,20
00FA2:  DATA 72,65
00FA4:  DATA 73,65
00FA6:  DATA 74,20
00FA8:  DATA 69,6E
00FAA:  DATA 73,74
00FAC:  DATA 65,61
00FAE:  DATA 64,2E
00FB0:  DATA 0D,0A
00FB2:  DATA 00,00
00FB4:  DATA 52,65
00FB6:  DATA 73,65
00FB8:  DATA 74,20
00FBA:  DATA 50,49
00FBC:  DATA 43,20
00FBE:  DATA 74,69
00FC0:  DATA 6D,65
00FC2:  DATA 20,63
00FC4:  DATA 68,61
00FC6:  DATA 6E,67
00FC8:  DATA 65,20
00FCA:  DATA 41,43
00FCC:  DATA 4B,2E
00FCE:  DATA 00,00
00FD0:  DATA 45,50
00FD2:  DATA 53,3A
00FD4:  DATA 20,00
00FD6:  DATA 56,3D
00FD8:  DATA 25,66
00FDA:  DATA 2C,20
00FDC:  DATA 43,3D
00FDE:  DATA 25,66
00FE0:  DATA 2C,20
00FE2:  DATA 54,3D
00FE4:  DATA 25,66
00FE6:  DATA 20,7C
00FE8:  DATA 20,00
00FEA:  DATA 20,4E
00FEC:  DATA 65,77
00FEE:  DATA 20,54
00FF0:  DATA 3D,30
00FF2:  DATA 78,25
00FF4:  DATA 30,34
00FF6:  DATA 6C,58
00FF8:  DATA 2C,20
00FFA:  DATA 56,3D
00FFC:  DATA 30,78
00FFE:  DATA 25,30
01000:  DATA 34,6C
01002:  DATA 58,20
01004:  DATA 7C,20
01006:  DATA 00,00
01008:  DATA 45,50
0100A:  DATA 53,20
0100C:  DATA 63,6D
0100E:  DATA 64,3A
01010:  DATA 20,00
01012:  DATA 4E,65
01014:  DATA 77,20
01016:  DATA 54,3D
01018:  DATA 30,78
0101A:  DATA 25,30
0101C:  DATA 34,6C
0101E:  DATA 58,2C
01020:  DATA 20,56
01022:  DATA 3D,30
01024:  DATA 78,25
01026:  DATA 30,34
01028:  DATA 6C,58
0102A:  DATA 00,00
0102C:  DATA 52,65
0102E:  DATA 63,65
01030:  DATA 69,76
01032:  DATA 65,64
01034:  DATA 20,61
01036:  DATA 64,63
01038:  DATA 73,20
0103A:  DATA 72,61
0103C:  DATA 77,20
0103E:  DATA 63,6F
01040:  DATA 6D,6D
01042:  DATA 61,6E
01044:  DATA 64,20
01046:  DATA 70,61
01048:  DATA 72,74
0104A:  DATA 20,61
0104C:  DATA 2E,00
0104E:  DATA 52,65
01050:  DATA 63,65
01052:  DATA 69,76
01054:  DATA 65,64
01056:  DATA 20,61
01058:  DATA 64,63
0105A:  DATA 73,20
0105C:  DATA 72,61
0105E:  DATA 77,20
01060:  DATA 63,6F
01062:  DATA 6D,6D
01064:  DATA 61,6E
01066:  DATA 64,20
01068:  DATA 70,61
0106A:  DATA 72,74
0106C:  DATA 20,62
0106E:  DATA 2E,00
01070:  DATA 4D,55
01072:  DATA 58,20
01074:  DATA 63,68
01076:  DATA 61,6E
01078:  DATA 67,65
0107A:  DATA 20,66
0107C:  DATA 61,69
0107E:  DATA 6C,65
01080:  DATA 64,21
01082:  DATA 00,00
01084:  DATA 52,65
01086:  DATA 63,65
01088:  DATA 69,76
0108A:  DATA 65,64
0108C:  DATA 20,61
0108E:  DATA 64,63
01090:  DATA 73,20
01092:  DATA 72,61
01094:  DATA 77,20
01096:  DATA 70,61
01098:  DATA 72,74
0109A:  DATA 20,63
0109C:  DATA 2E,20
0109E:  DATA 50,61
010A0:  DATA 72,74
010A2:  DATA 20,61
010A4:  DATA 20,70
010A6:  DATA 61,69
010A8:  DATA 72,69
010AA:  DATA 6E,67
010AC:  DATA 20,65
010AE:  DATA 72,72
010B0:  DATA 6F,72
010B2:  DATA 2E,00
010B4:  DATA 52,65
010B6:  DATA 63,65
010B8:  DATA 69,76
010BA:  DATA 65,64
010BC:  DATA 20,61
010BE:  DATA 64,63
010C0:  DATA 73,20
010C2:  DATA 72,61
010C4:  DATA 77,20
010C6:  DATA 70,61
010C8:  DATA 72,74
010CA:  DATA 20,63
010CC:  DATA 2E,20
010CE:  DATA 50,61
010D0:  DATA 72,74
010D2:  DATA 20,62
010D4:  DATA 20,70
010D6:  DATA 61,69
010D8:  DATA 72,69
010DA:  DATA 6E,67
010DC:  DATA 20,65
010DE:  DATA 72,72
010E0:  DATA 6F,72
010E2:  DATA 2E,00
010E4:  DATA 52,65
010E6:  DATA 63,65
010E8:  DATA 69,76
010EA:  DATA 65,64
010EC:  DATA 20,61
010EE:  DATA 64,63
010F0:  DATA 73,20
010F2:  DATA 72,61
010F4:  DATA 77,20
010F6:  DATA 70,61
010F8:  DATA 72,74
010FA:  DATA 20,63
010FC:  DATA 2E,20
010FE:  DATA 50,61
01100:  DATA 69,72
01102:  DATA 69,6E
01104:  DATA 67,20
01106:  DATA 6F,6B
01108:  DATA 2E,00
0110A:  DATA 44,65
0110C:  DATA 70,6C
0110E:  DATA 6F,79
01110:  DATA 69,6E
01112:  DATA 67,20
01114:  DATA 53,41
01116:  DATA 50,20
01118:  DATA 66,6F
0111A:  DATA 72,20
0111C:  DATA 25,64
0111E:  DATA 73,2E
01120:  DATA 2E,2E
01122:  DATA 20,00
01124:  DATA 44,6F
01126:  DATA 6E,65
01128:  DATA 21,0D
0112A:  DATA 0A,00
0112C:  DATA 44,65
0112E:  DATA 70,6C
01130:  DATA 6F,79
01132:  DATA 69,6E
01134:  DATA 67,20
01136:  DATA 53,4D
01138:  DATA 41,20
0113A:  DATA 66,6F
0113C:  DATA 72,20
0113E:  DATA 25,64
01140:  DATA 73,2E
01142:  DATA 2E,2E
01144:  DATA 20,00
01146:  DATA 44,6F
01148:  DATA 6E,65
0114A:  DATA 21,0D
0114C:  DATA 0A,00
0114E:  DATA 4D,55
01150:  DATA 58,20
01152:  DATA 63,68
01154:  DATA 61,6E
01156:  DATA 67,65
01158:  DATA 20,66
0115A:  DATA 61,69
0115C:  DATA 6C,65
0115E:  DATA 64,21
01160:  DATA 00,00
01162:  DATA 0D,0A
01164:  DATA 41,74
01166:  DATA 74,65
01168:  DATA 6D,70
0116A:  DATA 74,20
0116C:  DATA 25,64
0116E:  DATA 0D,0A
01170:  DATA 00,00
01172:  DATA 52,65
01174:  DATA 61,64
01176:  DATA 79,20
01178:  DATA 74,6F
0117A:  DATA 20,72
0117C:  DATA 65,63
0117E:  DATA 65,69
01180:  DATA 76,65
01182:  DATA 20,61
01184:  DATA 63,6B
01186:  DATA 6E,6F
01188:  DATA 77,6C
0118A:  DATA 65,64
0118C:  DATA 67,65
0118E:  DATA 6D,65
01190:  DATA 6E,74
01192:  DATA 20,66
01194:  DATA 72,6F
01196:  DATA 6D,20
01198:  DATA 53,45
0119A:  DATA 4C,2E
0119C:  DATA 2E,2E
0119E:  DATA 20,0D
011A0:  DATA 0A,00
011A2:  DATA 57,61
011A4:  DATA 69,74
011A6:  DATA 69,6E
011A8:  DATA 67,20
011AA:  DATA 66,6F
011AC:  DATA 72,20
011AE:  DATA 61,63
011B0:  DATA 6B,6E
011B2:  DATA 6F,77
011B4:  DATA 6C,65
011B6:  DATA 64,67
011B8:  DATA 65,6D
011BA:  DATA 65,6E
011BC:  DATA 74,2E
011BE:  DATA 2E,2E
011C0:  DATA 20,0D
011C2:  DATA 0A,00
011C4:  DATA 41,63
011C6:  DATA 6B,20
011C8:  DATA 3D,20
011CA:  DATA 25,58
011CC:  DATA 20,7C
011CE:  DATA 20,0D
011D0:  DATA 0A,00
011D2:  DATA 46,61
011D4:  DATA 69,6C
011D6:  DATA 65,64
011D8:  DATA 20,74
011DA:  DATA 6F,20
011DC:  DATA 67,65
011DE:  DATA 74,20
011E0:  DATA 61,6E
011E2:  DATA 20,61
011E4:  DATA 63,6B
011E6:  DATA 20,61
011E8:  DATA 66,74
011EA:  DATA 65,72
011EC:  DATA 20,25
011EE:  DATA 64,20
011F0:  DATA 74,72
011F2:  DATA 69,65
011F4:  DATA 73,2E
011F6:  DATA 0D,0A
011F8:  DATA 00,00
011FA:  DATA 4D,55
011FC:  DATA 58,20
011FE:  DATA 63,68
01200:  DATA 61,6E
01202:  DATA 67,65
01204:  DATA 20,66
01206:  DATA 61,69
01208:  DATA 6C,65
0120A:  DATA 64,21
0120C:  DATA 00,00
0120E:  DATA 0D,0A
01210:  DATA 0D,0A
01212:  DATA 41,74
01214:  DATA 74,65
01216:  DATA 6D,70
01218:  DATA 74,20
0121A:  DATA 25,64
0121C:  DATA 0D,0A
0121E:  DATA 00,00
01220:  DATA 52,65
01222:  DATA 61,64
01224:  DATA 79,20
01226:  DATA 74,6F
01228:  DATA 20,72
0122A:  DATA 65,63
0122C:  DATA 65,69
0122E:  DATA 76,65
01230:  DATA 20,61
01232:  DATA 63,6B
01234:  DATA 6E,6F
01236:  DATA 77,6C
01238:  DATA 65,64
0123A:  DATA 67,65
0123C:  DATA 6D,65
0123E:  DATA 6E,74
01240:  DATA 20,66
01242:  DATA 72,6F
01244:  DATA 6D,20
01246:  DATA 53,45
01248:  DATA 4C,2E
0124A:  DATA 2E,2E
0124C:  DATA 20,0D
0124E:  DATA 0A,00
01250:  DATA 57,61
01252:  DATA 69,74
01254:  DATA 69,6E
01256:  DATA 67,20
01258:  DATA 66,6F
0125A:  DATA 72,20
0125C:  DATA 61,63
0125E:  DATA 6B,6E
01260:  DATA 6F,77
01262:  DATA 6C,65
01264:  DATA 64,67
01266:  DATA 65,6D
01268:  DATA 65,6E
0126A:  DATA 74,2E
0126C:  DATA 2E,2E
0126E:  DATA 20,0D
01270:  DATA 0A,00
01272:  DATA 41,63
01274:  DATA 6B,20
01276:  DATA 3D,20
01278:  DATA 25,58
0127A:  DATA 20,7C
0127C:  DATA 20,0D
0127E:  DATA 0A,00
01280:  DATA 46,61
01282:  DATA 69,6C
01284:  DATA 65,64
01286:  DATA 20,74
01288:  DATA 6F,20
0128A:  DATA 67,65
0128C:  DATA 74,20
0128E:  DATA 61,6E
01290:  DATA 20,61
01292:  DATA 63,6B
01294:  DATA 20,61
01296:  DATA 66,74
01298:  DATA 65,72
0129A:  DATA 20,25
0129C:  DATA 64,20
0129E:  DATA 74,72
012A0:  DATA 69,65
012A2:  DATA 73,2E
012A4:  DATA 0D,0A
012A6:  DATA 00,00
012A8:  DATA 4D,55
012AA:  DATA 58,20
012AC:  DATA 63,68
012AE:  DATA 61,6E
012B0:  DATA 67,65
012B2:  DATA 20,66
012B4:  DATA 61,69
012B6:  DATA 6C,65
012B8:  DATA 64,21
012BA:  DATA 00,00
012BC:  DATA 50,61
012BE:  DATA 72,74
012C0:  DATA 20,6E
012C2:  DATA 6F,2E
012C4:  DATA 20,25
012C6:  DATA 64,3A
012C8:  DATA 20,00
012CA:  DATA 0D,0A
012CC:  DATA 53,61
012CE:  DATA 76,69
012D0:  DATA 6E,67
012D2:  DATA 20,53
012D4:  DATA 45,4C
012D6:  DATA 20,5A
012D8:  DATA 45,53
012DA:  DATA 20,64
012DC:  DATA 61,74
012DE:  DATA 61,3A
012E0:  DATA 20,00
012E2:  DATA 41,64
012E4:  DATA 64,72
012E6:  DATA 3A,20
012E8:  DATA 30,78
012EA:  DATA 25,30
012EC:  DATA 38,6C
012EE:  DATA 58,20
012F0:  DATA 00,00
012F2:  DATA 46,61
012F4:  DATA 69,6C
012F6:  DATA 65,64
012F8:  DATA 20,74
012FA:  DATA 6F,20
012FC:  DATA 67,65
012FE:  DATA 74,20
01300:  DATA 64,61
01302:  DATA 74,61
01304:  DATA 20,66
01306:  DATA 72,6F
01308:  DATA 6D,20
0130A:  DATA 53,45
0130C:  DATA 4C,2E
0130E:  DATA 0D,0A
01310:  DATA 00,00
01312:  DATA 4D,55
01314:  DATA 58,20
01316:  DATA 63,68
01318:  DATA 61,6E
0131A:  DATA 67,65
0131C:  DATA 20,66
0131E:  DATA 61,69
01320:  DATA 6C,65
01322:  DATA 64,21
01324:  DATA 00,00
01326:  DATA 0D,0A
01328:  DATA 41,74
0132A:  DATA 74,65
0132C:  DATA 6D,70
0132E:  DATA 74,20
01330:  DATA 25,64
01332:  DATA 0D,0A
01334:  DATA 00,00
01336:  DATA 52,65
01338:  DATA 61,64
0133A:  DATA 79,20
0133C:  DATA 74,6F
0133E:  DATA 20,72
01340:  DATA 65,63
01342:  DATA 65,69
01344:  DATA 76,65
01346:  DATA 20,61
01348:  DATA 63,6B
0134A:  DATA 6E,6F
0134C:  DATA 77,6C
0134E:  DATA 65,64
01350:  DATA 67,65
01352:  DATA 6D,65
01354:  DATA 6E,74
01356:  DATA 20,66
01358:  DATA 72,6F
0135A:  DATA 6D,20
0135C:  DATA 53,45
0135E:  DATA 4C,2E
01360:  DATA 2E,2E
01362:  DATA 20,0D
01364:  DATA 0A,00
01366:  DATA 57,61
01368:  DATA 69,74
0136A:  DATA 69,6E
0136C:  DATA 67,20
0136E:  DATA 66,6F
01370:  DATA 72,20
01372:  DATA 61,63
01374:  DATA 6B,6E
01376:  DATA 6F,77
01378:  DATA 6C,65
0137A:  DATA 64,67
0137C:  DATA 65,6D
0137E:  DATA 65,6E
01380:  DATA 74,2E
01382:  DATA 2E,2E
01384:  DATA 20,0D
01386:  DATA 0A,00
01388:  DATA 41,63
0138A:  DATA 6B,20
0138C:  DATA 3D,20
0138E:  DATA 25,58
01390:  DATA 20,7C
01392:  DATA 20,0D
01394:  DATA 0A,00
01396:  DATA 46,61
01398:  DATA 69,6C
0139A:  DATA 65,64
0139C:  DATA 20,74
0139E:  DATA 6F,20
013A0:  DATA 67,65
013A2:  DATA 74,20
013A4:  DATA 61,6E
013A6:  DATA 20,61
013A8:  DATA 63,6B
013AA:  DATA 20,61
013AC:  DATA 66,74
013AE:  DATA 65,72
013B0:  DATA 20,25
013B2:  DATA 64,20
013B4:  DATA 74,72
013B6:  DATA 69,65
013B8:  DATA 73,2E
013BA:  DATA 0D,0A
013BC:  DATA 00,00
013BE:  DATA 4D,55
013C0:  DATA 58,20
013C2:  DATA 63,68
013C4:  DATA 61,6E
013C6:  DATA 67,65
013C8:  DATA 20,66
013CA:  DATA 61,69
013CC:  DATA 6C,65
013CE:  DATA 64,21
013D0:  DATA 00,00
013D2:  DATA 0D,0A
013D4:  DATA 41,74
013D6:  DATA 74,65
013D8:  DATA 6D,70
013DA:  DATA 74,20
013DC:  DATA 25,64
013DE:  DATA 0D,0A
013E0:  DATA 00,00
013E2:  DATA 52,65
013E4:  DATA 61,64
013E6:  DATA 79,20
013E8:  DATA 74,6F
013EA:  DATA 20,72
013EC:  DATA 65,63
013EE:  DATA 65,69
013F0:  DATA 76,65
013F2:  DATA 20,61
013F4:  DATA 63,6B
013F6:  DATA 6E,6F
013F8:  DATA 77,6C
013FA:  DATA 65,64
013FC:  DATA 67,65
013FE:  DATA 6D,65
01400:  DATA 6E,74
01402:  DATA 20,66
01404:  DATA 72,6F
01406:  DATA 6D,20
01408:  DATA 53,45
0140A:  DATA 4C,2E
0140C:  DATA 2E,2E
0140E:  DATA 20,0D
01410:  DATA 0A,00
01412:  DATA 57,61
01414:  DATA 69,74
01416:  DATA 69,6E
01418:  DATA 67,20
0141A:  DATA 66,6F
0141C:  DATA 72,20
0141E:  DATA 61,63
01420:  DATA 6B,6E
01422:  DATA 6F,77
01424:  DATA 6C,65
01426:  DATA 64,67
01428:  DATA 65,6D
0142A:  DATA 65,6E
0142C:  DATA 74,2E
0142E:  DATA 2E,2E
01430:  DATA 20,0D
01432:  DATA 0A,00
01434:  DATA 41,63
01436:  DATA 6B,20
01438:  DATA 3D,20
0143A:  DATA 25,58
0143C:  DATA 20,7C
0143E:  DATA 20,0D
01440:  DATA 0A,00
01442:  DATA 46,61
01444:  DATA 69,6C
01446:  DATA 65,64
01448:  DATA 20,74
0144A:  DATA 6F,20
0144C:  DATA 67,65
0144E:  DATA 74,20
01450:  DATA 61,6E
01452:  DATA 20,61
01454:  DATA 63,6B
01456:  DATA 20,61
01458:  DATA 66,74
0145A:  DATA 65,72
0145C:  DATA 20,25
0145E:  DATA 64,20
01460:  DATA 74,72
01462:  DATA 69,65
01464:  DATA 73,2E
01466:  DATA 0D,0A
01468:  DATA 00,00
0146A:  DATA 4D,55
0146C:  DATA 58,20
0146E:  DATA 63,68
01470:  DATA 61,6E
01472:  DATA 67,65
01474:  DATA 20,66
01476:  DATA 61,69
01478:  DATA 6C,65
0147A:  DATA 64,21
0147C:  DATA 00,00
0147E:  DATA 50,61
01480:  DATA 72,74
01482:  DATA 20,6E
01484:  DATA 6F,2E
01486:  DATA 20,25
01488:  DATA 64,3A
0148A:  DATA 20,00
0148C:  DATA 0D,0A
0148E:  DATA 53,61
01490:  DATA 76,69
01492:  DATA 6E,67
01494:  DATA 20,53
01496:  DATA 45,4C
01498:  DATA 20,52
0149A:  DATA 45,46
0149C:  DATA 20,64
0149E:  DATA 61,74
014A0:  DATA 61,3A
014A2:  DATA 20,00
014A4:  DATA 41,64
014A6:  DATA 64,72
014A8:  DATA 3A,20
014AA:  DATA 30,78
014AC:  DATA 25,30
014AE:  DATA 38,6C
014B0:  DATA 58,20
014B2:  DATA 00,00
014B4:  DATA 46,61
014B6:  DATA 69,6C
014B8:  DATA 65,64
014BA:  DATA 20,74
014BC:  DATA 6F,20
014BE:  DATA 67,65
014C0:  DATA 74,20
014C2:  DATA 64,61
014C4:  DATA 74,61
014C6:  DATA 20,66
014C8:  DATA 72,6F
014CA:  DATA 6D,20
014CC:  DATA 53,45
014CE:  DATA 4C,2E
014D0:  DATA 0D,0A
014D2:  DATA 00,00
014D4:  DATA 4D,55
014D6:  DATA 58,20
014D8:  DATA 63,68
014DA:  DATA 61,6E
014DC:  DATA 67,65
014DE:  DATA 20,66
014E0:  DATA 61,69
014E2:  DATA 6C,65
014E4:  DATA 64,21
014E6:  DATA 00,00
014E8:  DATA 69,4D
014EA:  DATA 54,51
014EC:  DATA 20,44
014EE:  DATA 69,70
014F0:  DATA 6F,6C
014F2:  DATA 65,20
014F4:  DATA 41,63
014F6:  DATA 74,69
014F8:  DATA 76,61
014FA:  DATA 74,69
014FC:  DATA 6F,6E
014FE:  DATA 2E,2E
01500:  DATA 2E,2E
01502:  DATA 2E,2E
01504:  DATA 2E,0D
01506:  DATA 0A,00
01508:  DATA 4D,55
0150A:  DATA 58,20
0150C:  DATA 63,68
0150E:  DATA 61,6E
01510:  DATA 67,65
01512:  DATA 20,66
01514:  DATA 61,69
01516:  DATA 6C,65
01518:  DATA 64,21
0151A:  DATA 00,00
0151C:  DATA 69,4D
0151E:  DATA 54,51
01520:  DATA 20,4E
01522:  DATA 6F,20
01524:  DATA 4F,70
01526:  DATA 65,61
01528:  DATA 72,74
0152A:  DATA 69,6F
0152C:  DATA 6E,2E
0152E:  DATA 2E,2E
01530:  DATA 2E,2E
01532:  DATA 2E,2E
01534:  DATA 0D,0A
01536:  DATA 00,00
01538:  DATA 4D,55
0153A:  DATA 58,20
0153C:  DATA 63,68
0153E:  DATA 61,6E
01540:  DATA 67,65
01542:  DATA 20,66
01544:  DATA 61,69
01546:  DATA 6C,65
01548:  DATA 64,21
0154A:  DATA 00,00
0154C:  DATA 52,57
0154E:  DATA 20,33
01550:  DATA 76,33
01552:  DATA 20,45
01554:  DATA 6E,61
01556:  DATA 62,6C
01558:  DATA 65,2E
0155A:  DATA 2E,2E
0155C:  DATA 2E,2E
0155E:  DATA 2E,2E
01560:  DATA 0D,0A
01562:  DATA 00,00
01564:  DATA 4D,55
01566:  DATA 58,20
01568:  DATA 63,68
0156A:  DATA 61,6E
0156C:  DATA 67,65
0156E:  DATA 20,66
01570:  DATA 61,69
01572:  DATA 6C,65
01574:  DATA 64,21
01576:  DATA 00,00
01578:  DATA 52,57
0157A:  DATA 20,4D
0157C:  DATA 6F,74
0157E:  DATA 6F,72
01580:  DATA 20,45
01582:  DATA 6E,61
01584:  DATA 62,6C
01586:  DATA 65,2E
01588:  DATA 2E,2E
0158A:  DATA 2E,2E
0158C:  DATA 2E,2E
0158E:  DATA 0D,0A
01590:  DATA 00,00
01592:  DATA 4D,55
01594:  DATA 58,20
01596:  DATA 63,68
01598:  DATA 61,6E
0159A:  DATA 67,65
0159C:  DATA 20,66
0159E:  DATA 61,69
015A0:  DATA 6C,65
015A2:  DATA 64,21
015A4:  DATA 00,00
015A6:  DATA 52,57
015A8:  DATA 20,45
015AA:  DATA 6E,61
015AC:  DATA 62,6C
015AE:  DATA 65,2E
015B0:  DATA 2E,2E
015B2:  DATA 2E,2E
015B4:  DATA 2E,0D
015B6:  DATA 0A,00
015B8:  DATA 4D,55
015BA:  DATA 58,20
015BC:  DATA 63,68
015BE:  DATA 61,6E
015C0:  DATA 67,65
015C2:  DATA 20,66
015C4:  DATA 61,69
015C6:  DATA 6C,65
015C8:  DATA 64,21
015CA:  DATA 00,00
015CC:  DATA 52,57
015CE:  DATA 20,53
015D0:  DATA 70,65
015D2:  DATA 65,64
015D4:  DATA 2E,2E
015D6:  DATA 2E,2E
015D8:  DATA 2E,2E
015DA:  DATA 2E,0D
015DC:  DATA 0A,00
015DE:  DATA 4D,55
015E0:  DATA 58,20
015E2:  DATA 63,68
015E4:  DATA 61,6E
015E6:  DATA 67,65
015E8:  DATA 20,66
015EA:  DATA 61,69
015EC:  DATA 6C,65
015EE:  DATA 64,21
015F0:  DATA 00,00
015F2:  DATA 52,57
015F4:  DATA 20,52
015F6:  DATA 65,73
015F8:  DATA 65,74
015FA:  DATA 2E,2E
015FC:  DATA 2E,2E
015FE:  DATA 2E,2E
01600:  DATA 2E,0D
01602:  DATA 0A,00
01604:  DATA 4D,43
01606:  DATA 50,3A
01608:  DATA 20,00
0160A:  DATA 6F,70
0160C:  DATA 65,72
0160E:  DATA 61,5F
01610:  DATA 35,76
01612:  DATA 35,5F
01614:  DATA 64,63
01616:  DATA 5F,64
01618:  DATA 63,20
0161A:  DATA 3D,20
0161C:  DATA 25,75
0161E:  DATA 2C,20
01620:  DATA 00,00
01622:  DATA 6F,70
01624:  DATA 65,72
01626:  DATA 61,5F
01628:  DATA 6F,63
0162A:  DATA 70,31
0162C:  DATA 20,3D
0162E:  DATA 20,25
01630:  DATA 75,2C
01632:  DATA 20,00
01634:  DATA 6F,70
01636:  DATA 65,72
01638:  DATA 61,5F
0163A:  DATA 6F,63
0163C:  DATA 70,32
0163E:  DATA 20,3D
01640:  DATA 20,25
01642:  DATA 75,2C
01644:  DATA 20,00
01646:  DATA 73,65
01648:  DATA 6C,5F
0164A:  DATA 63,6F
0164C:  DATA 6D,5F
0164E:  DATA 70,72
01650:  DATA 20,3D
01652:  DATA 20,25
01654:  DATA 75,2C
01656:  DATA 20,00
01658:  DATA 73,65
0165A:  DATA 6C,5F
0165C:  DATA 63,6F
0165E:  DATA 6D,5F
01660:  DATA 72,65
01662:  DATA 73,20
01664:  DATA 3D,20
01666:  DATA 25,75
01668:  DATA 2C,20
0166A:  DATA 00,00
0166C:  DATA 73,65
0166E:  DATA 6C,5F
01670:  DATA 63,6F
01672:  DATA 6D,5F
01674:  DATA 70,67
01676:  DATA 20,3D
01678:  DATA 20,25
0167A:  DATA 75,2C
0167C:  DATA 20,00
0167E:  DATA 73,65
01680:  DATA 6C,5F
01682:  DATA 63,6F
01684:  DATA 6D,5F
01686:  DATA 66,6C
01688:  DATA 61,67
0168A:  DATA 20,3D
0168C:  DATA 20,25
0168E:  DATA 75,2C
01690:  DATA 20,00
01692:  DATA 74,6D
01694:  DATA 63,72
01696:  DATA 31,5F
01698:  DATA 6F,63
0169A:  DATA 70,20
0169C:  DATA 3D,20
0169E:  DATA 25,75
016A0:  DATA 2C,20
016A2:  DATA 00,00
016A4:  DATA 74,6D
016A6:  DATA 63,72
016A8:  DATA 32,5F
016AA:  DATA 6F,63
016AC:  DATA 70,20
016AE:  DATA 3D,20
016B0:  DATA 25,75
016B2:  DATA 2C,20
016B4:  DATA 00,00
016B6:  DATA 73,65
016B8:  DATA 6C,5F
016BA:  DATA 73,74
016BC:  DATA 61,74
016BE:  DATA 75,73
016C0:  DATA 20,3D
016C2:  DATA 20,25
016C4:  DATA 75,20
016C6:  DATA 7C,20
016C8:  DATA 00,00
016CA:  DATA 4D,55
016CC:  DATA 58,20
016CE:  DATA 63,68
016D0:  DATA 61,6E
016D2:  DATA 67,65
016D4:  DATA 20,66
016D6:  DATA 61,69
016D8:  DATA 6C,65
016DA:  DATA 64,21
016DC:  DATA 00,00
016DE:  DATA 52,65
016E0:  DATA 63,65
016E2:  DATA 69,76
016E4:  DATA 65,64
016E6:  DATA 20,4F
016E8:  DATA 50,45
016EA:  DATA 52,41
016EC:  DATA 20,47
016EE:  DATA 41,20
016F0:  DATA 70,61
016F2:  DATA 72,74
016F4:  DATA 20,61
016F6:  DATA 3A,20
016F8:  DATA 00,00
016FA:  DATA 52,65
016FC:  DATA 63,65
016FE:  DATA 69,76
01700:  DATA 65,64
01702:  DATA 20,4F
01704:  DATA 50,45
01706:  DATA 52,41
01708:  DATA 20,70
0170A:  DATA 61,72
0170C:  DATA 74,20
0170E:  DATA 62,3A
01710:  DATA 20,00
01712:  DATA 20,53
01714:  DATA 63,68
01716:  DATA 65,64
01718:  DATA 75,6C
0171A:  DATA 69,6E
0171C:  DATA 67,20
0171E:  DATA 63,6F
01720:  DATA 6D,6D
01722:  DATA 61,6E
01724:  DATA 64,73
01726:  DATA 2E,2E
01728:  DATA 2E,00
0172A:  DATA 52,65
0172C:  DATA 63,65
0172E:  DATA 69,76
01730:  DATA 65,64
01732:  DATA 20,4F
01734:  DATA 50,45
01736:  DATA 52,41
01738:  DATA 20,63
0173A:  DATA 6F,6D
0173C:  DATA 6D,61
0173E:  DATA 6E,64
01740:  DATA 3A,20
01742:  DATA 00,00
01744:  DATA 20,53
01746:  DATA 63,68
01748:  DATA 65,64
0174A:  DATA 75,6C
0174C:  DATA 69,6E
0174E:  DATA 67,20
01750:  DATA 63,6F
01752:  DATA 6D,6D
01754:  DATA 61,6E
01756:  DATA 64,73
01758:  DATA 2E,2E
0175A:  DATA 2E,00
0175C:  DATA 4F,50
0175E:  DATA 45,52
01760:  DATA 41,20
01762:  DATA 63,6F
01764:  DATA 70,79
01766:  DATA 20,63
01768:  DATA 6F,6D
0176A:  DATA 6D,61
0176C:  DATA 6E,64
0176E:  DATA 3A,20
01770:  DATA 00,00
01772:  DATA 54,75
01774:  DATA 72,6E
01776:  DATA 69,6E
01778:  DATA 67,20
0177A:  DATA 6F,6E
0177C:  DATA 20,4F
0177E:  DATA 50,45
01780:  DATA 52,41
01782:  DATA 2E,2E
01784:  DATA 2E,00
01786:  DATA 43,6F
01788:  DATA 70,79
0178A:  DATA 69,6E
0178C:  DATA 67,20
0178E:  DATA 64,61
01790:  DATA 74,61
01792:  DATA 20,66
01794:  DATA 72,6F
01796:  DATA 6D,20
01798:  DATA 4F,50
0179A:  DATA 45,52
0179C:  DATA 41,20
0179E:  DATA 74,6F
017A0:  DATA 20,4D
017A2:  DATA 69,73
017A4:  DATA 73,69
017A6:  DATA 6F,6E
017A8:  DATA 20,53
017AA:  DATA 46,4D
017AC:  DATA 2E,2E
017AE:  DATA 2E,00
017B0:  DATA 45,72
017B2:  DATA 72,6F
017B4:  DATA 72,3A
017B6:  DATA 20,6D
017B8:  DATA 75,78
017BA:  DATA 20,64
017BC:  DATA 69,64
017BE:  DATA 20,6E
017C0:  DATA 6F,74
017C2:  DATA 20,63
017C4:  DATA 68,61
017C6:  DATA 6E,67
017C8:  DATA 65,21
017CA:  DATA 00,00
017CC:  DATA 53,65
017CE:  DATA 6E,64
017D0:  DATA 69,6E
017D2:  DATA 67,20
017D4:  DATA 4F,50
017D6:  DATA 45,52
017D8:  DATA 41,20
017DA:  DATA 74,75
017DC:  DATA 72,6E
017DE:  DATA 20,6F
017E0:  DATA 66,66
017E2:  DATA 20,63
017E4:  DATA 6F,6D
017E6:  DATA 6D,61
017E8:  DATA 6E,64
017EA:  DATA 2E,2E
017EC:  DATA 2E,0D
017EE:  DATA 0A,00
017F0:  DATA 54,75
017F2:  DATA 72,6E
017F4:  DATA 69,6E
017F6:  DATA 67,20
017F8:  DATA 6F,66
017FA:  DATA 66,20
017FC:  DATA 4F,50
017FE:  DATA 45,52
01800:  DATA 41,20
01802:  DATA 61,6E
01804:  DATA 64,20
01806:  DATA 63,6F
01808:  DATA 70,79
0180A:  DATA 69,6E
0180C:  DATA 67,20
0180E:  DATA 64,61
01810:  DATA 74,61
01812:  DATA 20,66
01814:  DATA 72,6F
01816:  DATA 6D,20
01818:  DATA 4D,69
0181A:  DATA 73,73
0181C:  DATA 69,6F
0181E:  DATA 6E,20
01820:  DATA 53,46
01822:  DATA 4D,20
01824:  DATA 74,6F
01826:  DATA 20,43
01828:  DATA 4F,4D
0182A:  DATA 20,53
0182C:  DATA 46,4D
0182E:  DATA 2E,2E
01830:  DATA 2E,00
01832:  DATA 49,6E
01834:  DATA 76,61
01836:  DATA 6C,69
01838:  DATA 64,20
0183A:  DATA 73,74
0183C:  DATA 61,74
0183E:  DATA 65,21
01840:  DATA 00,00
01842:  DATA 57,61
01844:  DATA 69,74
01846:  DATA 69,6E
01848:  DATA 67,20
0184A:  DATA 66,6F
0184C:  DATA 72,20
0184E:  DATA 41,44
01850:  DATA 43,53
01852:  DATA 20,63
01854:  DATA 6F,70
01856:  DATA 79,2E
01858:  DATA 2E,2E
0185A:  DATA 00,00
0185C:  DATA 57,61
0185E:  DATA 69,74
01860:  DATA 69,6E
01862:  DATA 67,20
01864:  DATA 66,6F
01866:  DATA 72,20
01868:  DATA 52,45
0186A:  DATA 4C,41
0186C:  DATA 59,20
0186E:  DATA 63,6F
01870:  DATA 70,79
01872:  DATA 2E,2E
01874:  DATA 2E,00
01876:  DATA 57,61
01878:  DATA 69,74
0187A:  DATA 69,6E
0187C:  DATA 67,20
0187E:  DATA 66,6F
01880:  DATA 72,20
01882:  DATA 54,4D
01884:  DATA 43,52
01886:  DATA 20,42
01888:  DATA 34,20
0188A:  DATA 63,6F
0188C:  DATA 70,79
0188E:  DATA 2E,2E
01890:  DATA 2E,00
01892:  DATA 57,61
01894:  DATA 69,74
01896:  DATA 69,6E
01898:  DATA 67,20
0189A:  DATA 66,6F
0189C:  DATA 72,20
0189E:  DATA 54,4D
018A0:  DATA 43,52
018A2:  DATA 20,4E
018A4:  DATA 20,63
018A6:  DATA 6F,70
018A8:  DATA 79,2E
018AA:  DATA 2E,2E
018AC:  DATA 00,00
018AE:  DATA 57,61
018B0:  DATA 69,74
018B2:  DATA 69,6E
018B4:  DATA 67,20
018B6:  DATA 66,6F
018B8:  DATA 72,20
018BA:  DATA 72,65
018BC:  DATA 73,65
018BE:  DATA 74,74
018C0:  DATA 69,6E
018C2:  DATA 67,20
018C4:  DATA 61,6C
018C6:  DATA 6C,20
018C8:  DATA 70,6F
018CA:  DATA 77,65
018CC:  DATA 72,20
018CE:  DATA 6C,69
018D0:  DATA 6E,65
018D2:  DATA 73,2E
018D4:  DATA 2E,2E
018D6:  DATA 0D,0A
018D8:  DATA 00,00
018DA:  DATA 4D,55
018DC:  DATA 58,20
018DE:  DATA 63,68
018E0:  DATA 61,6E
018E2:  DATA 67,65
018E4:  DATA 20,66
018E6:  DATA 61,69
018E8:  DATA 6C,65
018EA:  DATA 64,21
018EC:  DATA 00,00
018EE:  DATA 54,58
018F0:  DATA 20,00
018F2:  DATA 4F,46
018F4:  DATA 46,20
018F6:  DATA 7C,20
018F8:  DATA 00,00
018FA:  DATA 4F,4E
018FC:  DATA 20,7C
018FE:  DATA 20,00
01900:  DATA 4D,55
01902:  DATA 58,20
01904:  DATA 63,68
01906:  DATA 61,6E
01908:  DATA 67,65
0190A:  DATA 20,66
0190C:  DATA 61,69
0190E:  DATA 6C,65
01910:  DATA 64,21
01912:  DATA 00,00
01914:  DATA 52,50
01916:  DATA 49,20
01918:  DATA 4F,46
0191A:  DATA 46,20
0191C:  DATA 7C,20
0191E:  DATA 00,00
01920:  DATA 52,50
01922:  DATA 49,20
01924:  DATA 4F,4E
01926:  DATA 20,7C
01928:  DATA 20,00
0192A:  DATA 52,50
0192C:  DATA 49,20
0192E:  DATA 53,4F
01930:  DATA 46,54
01932:  DATA 20,7C
01934:  DATA 20,00
01936:  DATA 4D,55
01938:  DATA 58,20
0193A:  DATA 63,68
0193C:  DATA 61,6E
0193E:  DATA 67,65
01940:  DATA 20,66
01942:  DATA 61,69
01944:  DATA 6C,65
01946:  DATA 64,21
01948:  DATA 00,00
0194A:  DATA 0D,0A
0194C:  DATA 52,50
0194E:  DATA 69,20
01950:  DATA 63,6F
01952:  DATA 6D,6D
01954:  DATA 61,6E
01956:  DATA 64,3A
01958:  DATA 20,63
0195A:  DATA 6C,65
0195C:  DATA 61,6E
0195E:  DATA 5F,75
01960:  DATA 70,0D
01962:  DATA 0A,00
01964:  DATA 4D,55
01966:  DATA 58,20
01968:  DATA 63,68
0196A:  DATA 61,6E
0196C:  DATA 67,65
0196E:  DATA 20,66
01970:  DATA 61,69
01972:  DATA 6C,65
01974:  DATA 64,21
01976:  DATA 00,00
01978:  DATA 0D,0A
0197A:  DATA 52,50
0197C:  DATA 69,20
0197E:  DATA 63,6F
01980:  DATA 6D,6D
01982:  DATA 61,6E
01984:  DATA 64,3A
01986:  DATA 20,63
01988:  DATA 6C,65
0198A:  DATA 61,6E
0198C:  DATA 5F,6C
0198E:  DATA 6F,67
01990:  DATA 66,69
01992:  DATA 6C,65
01994:  DATA 0D,0A
01996:  DATA 00,00
01998:  DATA 52,45
0199A:  DATA 4C,41
0199C:  DATA 59,3A
0199E:  DATA 20,54
019A0:  DATA 73,3D
019A2:  DATA 25,6C
019A4:  DATA 58,2C
019A6:  DATA 20,53
019A8:  DATA 74,78
019AA:  DATA 3D,25
019AC:  DATA 64,2C
019AE:  DATA 20,52
019B0:  DATA 70,3D
019B2:  DATA 25,64
019B4:  DATA 20,7C
019B6:  DATA 20,00
019B8:  DATA 20,53
019BA:  DATA 74,78
019BC:  DATA 20,2D
019BE:  DATA 3E,20
019C0:  DATA 25,64
019C2:  DATA 00,00
019C4:  DATA 20,52
019C6:  DATA 70,69
019C8:  DATA 20,2D
019CA:  DATA 3E,20
019CC:  DATA 25,64
019CE:  DATA 00,00
019D0:  DATA 54,4D
019D2:  DATA 43,52
019D4:  DATA 31,3A
019D6:  DATA 20,00
019D8:  DATA 54,4D
019DA:  DATA 43,52
019DC:  DATA 32,3A
019DE:  DATA 20,00
019E0:  DATA 4D,55
019E2:  DATA 58,20
019E4:  DATA 63,68
019E6:  DATA 61,6E
019E8:  DATA 67,65
019EA:  DATA 20,66
019EC:  DATA 61,69
019EE:  DATA 6C,65
019F0:  DATA 64,21
019F2:  DATA 00,00
019F4:  DATA 4D,55
019F6:  DATA 58,20
019F8:  DATA 63,68
019FA:  DATA 61,6E
019FC:  DATA 67,65
019FE:  DATA 20,66
01A00:  DATA 61,69
01A02:  DATA 6C,65
01A04:  DATA 64,21
01A06:  DATA 00,00
01A08:  DATA 4D,55
01A0A:  DATA 58,20
01A0C:  DATA 63,68
01A0E:  DATA 61,6E
01A10:  DATA 67,65
01A12:  DATA 20,66
01A14:  DATA 61,69
01A16:  DATA 6C,65
01A18:  DATA 64,21
01A1A:  DATA 00,00
01A1C:  DATA 55,6E
01A1E:  DATA 65,78
01A20:  DATA 70,65
01A22:  DATA 63,74
01A24:  DATA 65,64
01A26:  DATA 20,63
01A28:  DATA 6F,6D
01A2A:  DATA 6D,61
01A2C:  DATA 6E,64
01A2E:  DATA 20,49
01A30:  DATA 44,21
01A32:  DATA 00,00
01A34:  DATA 4D,55
01A36:  DATA 58,20
01A38:  DATA 63,68
01A3A:  DATA 61,6E
01A3C:  DATA 67,65
01A3E:  DATA 20,66
01A40:  DATA 61,69
01A42:  DATA 6C,65
01A44:  DATA 64,21
01A46:  DATA 00,00
01A48:  DATA 52,65
01A4A:  DATA 76,65
01A4C:  DATA 72,74
01A4E:  DATA 69,6E
01A50:  DATA 67,20
01A52:  DATA 73,2D
01A54:  DATA 62,61
01A56:  DATA 6E,64
01A58:  DATA 20,63
01A5A:  DATA 6F,6E
01A5C:  DATA 66,69
01A5E:  DATA 67,75
01A60:  DATA 72,61
01A62:  DATA 74,69
01A64:  DATA 6F,6E
01A66:  DATA 2E,2E
01A68:  DATA 2E,20
01A6A:  DATA 00,00
01A6C:  DATA 4D,55
01A6E:  DATA 58,20
01A70:  DATA 63,68
01A72:  DATA 61,6E
01A74:  DATA 67,65
01A76:  DATA 20,66
01A78:  DATA 61,69
01A7A:  DATA 6C,65
01A7C:  DATA 64,21
01A7E:  DATA 00,00
01A80:  DATA 53,63
01A82:  DATA 68,65
01A84:  DATA 64,75
01A86:  DATA 6C,65
01A88:  DATA 64,20
01A8A:  DATA 54,69
01A8C:  DATA 6D,65
01A8E:  DATA 3A,20
01A90:  DATA 25,30
01A92:  DATA 34,6C
01A94:  DATA 64,2F
01A96:  DATA 25,30
01A98:  DATA 32,64
01A9A:  DATA 2F,25
01A9C:  DATA 30,32
01A9E:  DATA 64,20
01AA0:  DATA 25,30
01AA2:  DATA 32,64
01AA4:  DATA 3A,25
01AA6:  DATA 30,32
01AA8:  DATA 64,3A
01AAA:  DATA 25,30
01AAC:  DATA 32,64
01AAE:  DATA 20,28
01AB0:  DATA 30,78
01AB2:  DATA 25,30
01AB4:  DATA 38,6C
01AB6:  DATA 58,29
01AB8:  DATA 0D,0A
01ABA:  DATA 00,00
01ABC:  DATA 44,6F
01ABE:  DATA 77,6E
01AC0:  DATA 6C,69
01AC2:  DATA 6E,6B
01AC4:  DATA 20,54
01AC6:  DATA 69,6D
01AC8:  DATA 65,6F
01ACA:  DATA 75,74
01ACC:  DATA 3A,20
01ACE:  DATA 25,6C
01AD0:  DATA 75,0D
01AD2:  DATA 0A,00
01AD4:  DATA 41,44
01AD6:  DATA 43,53
01AD8:  DATA 20,4D
01ADA:  DATA 6F,64
01ADC:  DATA 65,3A
01ADE:  DATA 20,25
01AE0:  DATA 75,0D
01AE2:  DATA 0A,00
01AE4:  DATA 53,74
01AE6:  DATA 61,72
01AE8:  DATA 74,69
01AEA:  DATA 6E,67
01AEC:  DATA 20,73
01AEE:  DATA 2D,62
01AF0:  DATA 61,6E
01AF2:  DATA 64,20
01AF4:  DATA 64,6F
01AF6:  DATA 77,6E
01AF8:  DATA 6C,69
01AFA:  DATA 6E,6B
01AFC:  DATA 20,72
01AFE:  DATA 6F,75
01B00:  DATA 74,69
01B02:  DATA 6E,65
01B04:  DATA 2E,0D
01B06:  DATA 0A,00
01B08:  DATA 53,63
01B0A:  DATA 68,65
01B0C:  DATA 64,75
01B0E:  DATA 6C,69
01B10:  DATA 6E,67
01B12:  DATA 20,73
01B14:  DATA 2D,62
01B16:  DATA 61,6E
01B18:  DATA 64,20
01B1A:  DATA 44,4C
01B1C:  DATA 20,63
01B1E:  DATA 6F,6D
01B20:  DATA 6D,61
01B22:  DATA 6E,64
01B24:  DATA 2E,00
01B26:  DATA 4D,55
01B28:  DATA 58,20
01B2A:  DATA 63,68
01B2C:  DATA 61,6E
01B2E:  DATA 67,65
01B30:  DATA 20,66
01B32:  DATA 61,69
01B34:  DATA 6C,65
01B36:  DATA 64,21
01B38:  DATA 00,00
01B3A:  DATA 44,6F
01B3C:  DATA 77,6E
01B3E:  DATA 6C,69
01B40:  DATA 6E,6B
01B42:  DATA 20,54
01B44:  DATA 69,6D
01B46:  DATA 65,6F
01B48:  DATA 75,74
01B4A:  DATA 3A,20
01B4C:  DATA 25,6C
01B4E:  DATA 75,0D
01B50:  DATA 0A,00
01B52:  DATA 41,44
01B54:  DATA 43,53
01B56:  DATA 20,4D
01B58:  DATA 6F,64
01B5A:  DATA 65,3A
01B5C:  DATA 20,25
01B5E:  DATA 75,0D
01B60:  DATA 0A,00
01B62:  DATA 46,69
01B64:  DATA 6C,65
01B66:  DATA 20,4E
01B68:  DATA 75,6D
01B6A:  DATA 62,65
01B6C:  DATA 72,3A
01B6E:  DATA 20,25
01B70:  DATA 6C,75
01B72:  DATA 0D,0A
01B74:  DATA 00,00
01B76:  DATA 46,69
01B78:  DATA 72,73
01B7A:  DATA 74,20
01B7C:  DATA 50,61
01B7E:  DATA 63,6B
01B80:  DATA 65,74
01B82:  DATA 3A,20
01B84:  DATA 25,6C
01B86:  DATA 75,0D
01B88:  DATA 0A,00
01B8A:  DATA 45,6E
01B8C:  DATA 64,20
01B8E:  DATA 50,61
01B90:  DATA 63,6B
01B92:  DATA 65,74
01B94:  DATA 3A,20
01B96:  DATA 25,6C
01B98:  DATA 75,0D
01B9A:  DATA 0A,00
01B9C:  DATA 4E,75
01B9E:  DATA 6D,62
01BA0:  DATA 65,72
01BA2:  DATA 20,6F
01BA4:  DATA 66,20
01BA6:  DATA 52,65
01BA8:  DATA 70,65
01BAA:  DATA 74,69
01BAC:  DATA 74,69
01BAE:  DATA 6F,6E
01BB0:  DATA 73,3A
01BB2:  DATA 20,25
01BB4:  DATA 75,0D
01BB6:  DATA 0A,00
01BB8:  DATA 42,69
01BBA:  DATA 74,72
01BBC:  DATA 61,74
01BBE:  DATA 65,3A
01BC0:  DATA 20,00
01BC2:  DATA 31,30
01BC4:  DATA 6B,62
01BC6:  DATA 70,73
01BC8:  DATA 0D,0A
01BCA:  DATA 00,00
01BCC:  DATA 32,30
01BCE:  DATA 6B,62
01BD0:  DATA 70,73
01BD2:  DATA 0D,0A
01BD4:  DATA 00,00
01BD6:  DATA 32,35
01BD8:  DATA 6B,62
01BDA:  DATA 70,73
01BDC:  DATA 0D,0A
01BDE:  DATA 00,00
01BE0:  DATA 35,30
01BE2:  DATA 6B,62
01BE4:  DATA 70,73
01BE6:  DATA 0D,0A
01BE8:  DATA 00,00
01BEA:  DATA 36,34
01BEC:  DATA 6B,62
01BEE:  DATA 70,73
01BF0:  DATA 0D,0A
01BF2:  DATA 00,00
01BF4:  DATA 31,30
01BF6:  DATA 30,6B
01BF8:  DATA 62,70
01BFA:  DATA 73,0D
01BFC:  DATA 0A,00
01BFE:  DATA 32,35
01C00:  DATA 30,6B
01C02:  DATA 62,70
01C04:  DATA 73,0D
01C06:  DATA 0A,00
01C08:  DATA 35,30
01C0A:  DATA 30,6B
01C0C:  DATA 62,70
01C0E:  DATA 73,0D
01C10:  DATA 0A,00
01C12:  DATA 50,6F
01C14:  DATA 77,65
01C16:  DATA 72,3A
01C18:  DATA 20,25
01C1A:  DATA 75,0D
01C1C:  DATA 0A,00
01C1E:  DATA 44,65
01C20:  DATA 6C,61
01C22:  DATA 79,20
01C24:  DATA 42,65
01C26:  DATA 66,6F
01C28:  DATA 72,65
01C2A:  DATA 20,54
01C2C:  DATA 78,3A
01C2E:  DATA 20,25
01C30:  DATA 75,0D
01C32:  DATA 0A,00
01C34:  DATA 49,6D
01C36:  DATA 61,67
01C38:  DATA 65,20
01C3A:  DATA 73,65
01C3C:  DATA 71,2E
01C3E:  DATA 20,73
01C40:  DATA 74,61
01C42:  DATA 72,74
01C44:  DATA 3A,20
01C46:  DATA 25,75
01C48:  DATA 0D,0A
01C4A:  DATA 00,00
01C4C:  DATA 49,6D
01C4E:  DATA 61,67
01C50:  DATA 65,20
01C52:  DATA 73,65
01C54:  DATA 71,2E
01C56:  DATA 20,65
01C58:  DATA 6E,64
01C5A:  DATA 3A,20
01C5C:  DATA 25,75
01C5E:  DATA 0D,0A
01C60:  DATA 00,00
01C62:  DATA 54,79
01C64:  DATA 70,65
01C66:  DATA 3A,20
01C68:  DATA 25,75
01C6A:  DATA 0D,0A
01C6C:  DATA 00,00
01C6E:  DATA 43,61
01C70:  DATA 6D,65
01C72:  DATA 72,61
01C74:  DATA 20,53
01C76:  DATA 65,6C
01C78:  DATA 65,63
01C7A:  DATA 74,69
01C7C:  DATA 6F,6E
01C7E:  DATA 3A,20
01C80:  DATA 25,75
01C82:  DATA 25,75
01C84:  DATA 25,75
01C86:  DATA 0D,0A
01C88:  DATA 00,00
01C8A:  DATA 4D,55
01C8C:  DATA 58,20
01C8E:  DATA 63,68
01C90:  DATA 61,6E
01C92:  DATA 67,65
01C94:  DATA 20,66
01C96:  DATA 61,69
01C98:  DATA 6C,65
01C9A:  DATA 64,21
01C9C:  DATA 00,00
01C9E:  DATA 20,53
01CA0:  DATA 2D,62
01CA2:  DATA 61,6E
01CA4:  DATA 64,20
01CA6:  DATA 74,65
01CA8:  DATA 73,74
01CAA:  DATA 20,63
01CAC:  DATA 6F,6D
01CAE:  DATA 6D,61
01CB0:  DATA 6E,64
01CB2:  DATA 3A,20
01CB4:  DATA 00,00
01CB6:  DATA 31,30
01CB8:  DATA 6B,62
01CBA:  DATA 70,73
01CBC:  DATA 2C,20
01CBE:  DATA 00,00
01CC0:  DATA 32,30
01CC2:  DATA 6B,62
01CC4:  DATA 70,73
01CC6:  DATA 2C,20
01CC8:  DATA 00,00
01CCA:  DATA 32,35
01CCC:  DATA 6B,62
01CCE:  DATA 70,73
01CD0:  DATA 2C,20
01CD2:  DATA 00,00
01CD4:  DATA 35,30
01CD6:  DATA 6B,62
01CD8:  DATA 70,73
01CDA:  DATA 2C,20
01CDC:  DATA 00,00
01CDE:  DATA 36,34
01CE0:  DATA 6B,62
01CE2:  DATA 70,73
01CE4:  DATA 2C,20
01CE6:  DATA 00,00
01CE8:  DATA 31,30
01CEA:  DATA 30,6B
01CEC:  DATA 62,70
01CEE:  DATA 73,2C
01CF0:  DATA 20,00
01CF2:  DATA 32,35
01CF4:  DATA 30,6B
01CF6:  DATA 62,70
01CF8:  DATA 73,2C
01CFA:  DATA 20,00
01CFC:  DATA 35,30
01CFE:  DATA 30,6B
01D00:  DATA 62,70
01D02:  DATA 73,2C
01D04:  DATA 20,00
01D06:  DATA 69,6E
01D08:  DATA 76,61
01D0A:  DATA 6C,69
01D0C:  DATA 64,20
01D0E:  DATA 62,69
01D10:  DATA 74,72
01D12:  DATA 61,74
01D14:  DATA 65,2E
01D16:  DATA 00,00
01D18:  DATA 6C,6F
01D1A:  DATA 77,20
01D1C:  DATA 70,6F
01D1E:  DATA 77,65
01D20:  DATA 72,2E
01D22:  DATA 00,00
01D24:  DATA 68,69
01D26:  DATA 67,68
01D28:  DATA 20,70
01D2A:  DATA 6F,77
01D2C:  DATA 65,72
01D2E:  DATA 2E,00
01D30:  DATA 69,6E
01D32:  DATA 76,61
01D34:  DATA 6C,69
01D36:  DATA 64,20
01D38:  DATA 70,6F
01D3A:  DATA 77,65
01D3C:  DATA 72,2E
01D3E:  DATA 00,00
01D40:  DATA 4D,55
01D42:  DATA 58,20
01D44:  DATA 63,68
01D46:  DATA 61,6E
01D48:  DATA 67,65
01D4A:  DATA 20,66
01D4C:  DATA 61,69
01D4E:  DATA 6C,65
01D50:  DATA 64,21
01D52:  DATA 00,00
01D54:  DATA 53,74
01D56:  DATA 61,74
01D58:  DATA 65,3A
01D5A:  DATA 20,73
01D5C:  DATA 63,68
01D5E:  DATA 65,64
01D60:  DATA 75,6C
01D62:  DATA 65,0A
01D64:  DATA 00,00
01D66:  DATA 53,74
01D68:  DATA 61,74
01D6A:  DATA 65,3A
01D6C:  DATA 20,69
01D6E:  DATA 6E,69
01D70:  DATA 74,69
01D72:  DATA 61,6C
01D74:  DATA 20,61
01D76:  DATA 64,63
01D78:  DATA 73,20
01D7A:  DATA 6D,6F
01D7C:  DATA 64,65
01D7E:  DATA 0A,00
01D80:  DATA 53,74
01D82:  DATA 61,74
01D84:  DATA 65,3A
01D86:  DATA 20,74
01D88:  DATA 75,72
01D8A:  DATA 6E,20
01D8C:  DATA 6F,6E
01D8E:  DATA 20,73
01D90:  DATA 75,62
01D92:  DATA 73,79
01D94:  DATA 73,74
01D96:  DATA 65,6D
01D98:  DATA 0A,00
01D9A:  DATA 53,74
01D9C:  DATA 61,74
01D9E:  DATA 65,3A
01DA0:  DATA 20,73
01DA2:  DATA 65,6E
01DA4:  DATA 64,20
01DA6:  DATA 75,70
01DA8:  DATA 6C,69
01DAA:  DATA 6E,6B
01DAC:  DATA 20,63
01DAE:  DATA 6F,6D
01DB0:  DATA 6D,61
01DB2:  DATA 6E,64
01DB4:  DATA 0A,00
01DB6:  DATA 53,74
01DB8:  DATA 61,74
01DBA:  DATA 65,3A
01DBC:  DATA 20,74
01DBE:  DATA 75,72
01DC0:  DATA 6E,20
01DC2:  DATA 6F,66
01DC4:  DATA 66,20
01DC6:  DATA 73,75
01DC8:  DATA 62,73
01DCA:  DATA 79,73
01DCC:  DATA 74,65
01DCE:  DATA 6D,20
01DD0:  DATA 73,6F
01DD2:  DATA 66,74
01DD4:  DATA 0A,00
01DD6:  DATA 53,74
01DD8:  DATA 61,74
01DDA:  DATA 65,3A
01DDC:  DATA 20,74
01DDE:  DATA 75,72
01DE0:  DATA 6E,20
01DE2:  DATA 6F,66
01DE4:  DATA 66,20
01DE6:  DATA 73,75
01DE8:  DATA 62,73
01DEA:  DATA 79,73
01DEC:  DATA 74,65
01DEE:  DATA 6D,20
01DF0:  DATA 68,61
01DF2:  DATA 72,64
01DF4:  DATA 0A,00
01DF6:  DATA 53,74
01DF8:  DATA 61,74
01DFA:  DATA 65,3A
01DFC:  DATA 20,65
01DFE:  DATA 6E,64
01E00:  DATA 0A,00
01E02:  DATA 55,6E
01E04:  DATA 6B,6E
01E06:  DATA 6F,77
01E08:  DATA 6E,20
01E0A:  DATA 73,74
01E0C:  DATA 61,74
01E0E:  DATA 65,0A
01E10:  DATA 00,00
01E12:  DATA 49,6E
01E14:  DATA 76,61
01E16:  DATA 6C,69
01E18:  DATA 64,20
01E1A:  DATA 73,74
01E1C:  DATA 61,74
01E1E:  DATA 65,21
01E20:  DATA 00,00
01E22:  DATA 43,61
01E24:  DATA 6D,65
01E26:  DATA 72,61
01E28:  DATA 20,63
01E2A:  DATA 61,70
01E2C:  DATA 74,75
01E2E:  DATA 72,65
01E30:  DATA 20,63
01E32:  DATA 6F,6E
01E34:  DATA 66,69
01E36:  DATA 67,75
01E38:  DATA 72,61
01E3A:  DATA 74,69
01E3C:  DATA 6F,6E
01E3E:  DATA 3A,0D
01E40:  DATA 0A,43
01E42:  DATA 61,6D
01E44:  DATA 65,72
01E46:  DATA 61,20
01E48:  DATA 53,65
01E4A:  DATA 6C,65
01E4C:  DATA 63,74
01E4E:  DATA 69,6F
01E50:  DATA 6E,3A
01E52:  DATA 20,25
01E54:  DATA 75,2C
01E56:  DATA 20,25
01E58:  DATA 75,2C
01E5A:  DATA 20,25
01E5C:  DATA 75,0D
01E5E:  DATA 0A,53
01E60:  DATA 65,71
01E62:  DATA 75,65
01E64:  DATA 6E,74
01E66:  DATA 69,61
01E68:  DATA 6C,20
01E6A:  DATA 50,69
01E6C:  DATA 63,74
01E6E:  DATA 75,72
01E70:  DATA 65,73
01E72:  DATA 3A,20
01E74:  DATA 25,75
01E76:  DATA 0D,0A
01E78:  DATA 49,6E
01E7A:  DATA 74,65
01E7C:  DATA 72,76
01E7E:  DATA 61,6C
01E80:  DATA 20,42
01E82:  DATA 65,74
01E84:  DATA 77,65
01E86:  DATA 65,6E
01E88:  DATA 20,50
01E8A:  DATA 69,63
01E8C:  DATA 74,75
01E8E:  DATA 72,65
01E90:  DATA 73,3A
01E92:  DATA 20,25
01E94:  DATA 75,20
01E96:  DATA 73,65
01E98:  DATA 63,6F
01E9A:  DATA 6E,64
01E9C:  DATA 73,0D
01E9E:  DATA 0A,53
01EA0:  DATA 68,75
01EA2:  DATA 74,74
01EA4:  DATA 65,72
01EA6:  DATA 20,53
01EA8:  DATA 70,65
01EAA:  DATA 65,64
01EAC:  DATA 73,3A
01EAE:  DATA 20,25
01EB0:  DATA 6C,75
01EB2:  DATA 2C,20
01EB4:  DATA 25,6C
01EB6:  DATA 75,2C
01EB8:  DATA 20,25
01EBA:  DATA 6C,75
01EBC:  DATA 20,28
01EBE:  DATA 6D,69
01EC0:  DATA 63,72
01EC2:  DATA 6F,73
01EC4:  DATA 65,63
01EC6:  DATA 6F,6E
01EC8:  DATA 64,73
01ECA:  DATA 29,0D
01ECC:  DATA 0A,00
01ECE:  DATA 44,65
01ED0:  DATA 6C,61
01ED2:  DATA 79,3A
01ED4:  DATA 20,25
01ED6:  DATA 6C,75
01ED8:  DATA 0D,0A
01EDA:  DATA 00,00
01EDC:  DATA 43,61
01EDE:  DATA 6D,65
01EE0:  DATA 72,61
01EE2:  DATA 20,53
01EE4:  DATA 65,6C
01EE6:  DATA 65,63
01EE8:  DATA 74,69
01EEA:  DATA 6F,6E
01EEC:  DATA 3A,20
01EEE:  DATA 25,75
01EF0:  DATA 25,75
01EF2:  DATA 25,75
01EF4:  DATA 0D,0A
01EF6:  DATA 00,00
01EF8:  DATA 44,65
01EFA:  DATA 6C,61
01EFC:  DATA 79,3A
01EFE:  DATA 20,25
01F00:  DATA 6C,75
01F02:  DATA 0D,0A
01F04:  DATA 00,00
01F06:  DATA 56,69
01F08:  DATA 64,65
01F0A:  DATA 6F,20
01F0C:  DATA 63,61
01F0E:  DATA 70,74
01F10:  DATA 75,72
01F12:  DATA 65,20
01F14:  DATA 63,6F
01F16:  DATA 6D,6D
01F18:  DATA 61,6E
01F1A:  DATA 64,3A
01F1C:  DATA 0D,0A
01F1E:  DATA 43,61
01F20:  DATA 6D,65
01F22:  DATA 72,61
01F24:  DATA 20,53
01F26:  DATA 65,6C
01F28:  DATA 65,63
01F2A:  DATA 74,69
01F2C:  DATA 6F,6E
01F2E:  DATA 3A,20
01F30:  DATA 25,75
01F32:  DATA 25,75
01F34:  DATA 25,75
01F36:  DATA 0D,0A
01F38:  DATA 54,69
01F3A:  DATA 6D,65
01F3C:  DATA 6F,75
01F3E:  DATA 74,3A
01F40:  DATA 20,25
01F42:  DATA 75,2C
01F44:  DATA 20,25
01F46:  DATA 75,2C
01F48:  DATA 20,25
01F4A:  DATA 75,20
01F4C:  DATA 73,65
01F4E:  DATA 63,6F
01F50:  DATA 6E,64
01F52:  DATA 73,0D
01F54:  DATA 0A,00
01F56:  DATA 44,65
01F58:  DATA 6C,61
01F5A:  DATA 79,3A
01F5C:  DATA 20,25
01F5E:  DATA 6C,75
01F60:  DATA 0D,0A
01F62:  DATA 00,00
01F64:  DATA 43,61
01F66:  DATA 6D,65
01F68:  DATA 72,61
01F6A:  DATA 20,63
01F6C:  DATA 61,70
01F6E:  DATA 74,75
01F70:  DATA 72,65
01F72:  DATA 20,63
01F74:  DATA 6F,6E
01F76:  DATA 66,69
01F78:  DATA 67,75
01F7A:  DATA 72,61
01F7C:  DATA 74,69
01F7E:  DATA 6F,6E
01F80:  DATA 20,63
01F82:  DATA 6F,6D
01F84:  DATA 6D,61
01F86:  DATA 6E,64
01F88:  DATA 2C,20
01F8A:  DATA 73,61
01F8C:  DATA 76,69
01F8E:  DATA 6E,67
01F90:  DATA 20,63
01F92:  DATA 6F,6E
01F94:  DATA 66,69
01F96:  DATA 67,75
01F98:  DATA 72,61
01F9A:  DATA 74,69
01F9C:  DATA 6F,6E
01F9E:  DATA 2E,2E
01FA0:  DATA 2E,00
01FA2:  DATA 20,64
01FA4:  DATA 6F,6E
01FA6:  DATA 65,21
01FA8:  DATA 00,00
01FAA:  DATA 43,61
01FAC:  DATA 6D,65
01FAE:  DATA 72,61
01FB0:  DATA 20,63
01FB2:  DATA 61,70
01FB4:  DATA 74,75
01FB6:  DATA 72,65
01FB8:  DATA 20,63
01FBA:  DATA 6F,6D
01FBC:  DATA 6D,61
01FBE:  DATA 6E,64
01FC0:  DATA 2C,20
01FC2:  DATA 73,74
01FC4:  DATA 61,72
01FC6:  DATA 74,69
01FC8:  DATA 6E,67
01FCA:  DATA 20,73
01FCC:  DATA 74,61
01FCE:  DATA 74,65
01FD0:  DATA 20,6D
01FD2:  DATA 61,63
01FD4:  DATA 68,69
01FD6:  DATA 6E,65
01FD8:  DATA 2E,2E
01FDA:  DATA 2E,00
01FDC:  DATA 43,61
01FDE:  DATA 6D,65
01FE0:  DATA 72,61
01FE2:  DATA 20,69
01FE4:  DATA 6D,61
01FE6:  DATA 67,65
01FE8:  DATA 20,74
01FEA:  DATA 72,61
01FEC:  DATA 6E,73
01FEE:  DATA 66,6F
01FF0:  DATA 72,6D
01FF2:  DATA 61,74
01FF4:  DATA 69,6F
01FF6:  DATA 6E,20
01FF8:  DATA 63,6F
01FFA:  DATA 6D,6D
01FFC:  DATA 61,6E
01FFE:  DATA 64,2C
02000:  DATA 20,73
02002:  DATA 74,61
02004:  DATA 72,74
02006:  DATA 69,6E
02008:  DATA 67,20
0200A:  DATA 73,74
0200C:  DATA 61,74
0200E:  DATA 65,20
02010:  DATA 6D,61
02012:  DATA 63,68
02014:  DATA 69,6E
02016:  DATA 65,2E
02018:  DATA 2E,2E
0201A:  DATA 00,00
0201C:  DATA 43,61
0201E:  DATA 6D,65
02020:  DATA 72,61
02022:  DATA 20,69
02024:  DATA 6D,61
02026:  DATA 67,65
02028:  DATA 20,76
0202A:  DATA 69,64
0202C:  DATA 65,6F
0202E:  DATA 20,63
02030:  DATA 6F,6D
02032:  DATA 6D,61
02034:  DATA 6E,64
02036:  DATA 2C,20
02038:  DATA 73,74
0203A:  DATA 61,72
0203C:  DATA 74,69
0203E:  DATA 6E,67
02040:  DATA 20,73
02042:  DATA 74,61
02044:  DATA 74,65
02046:  DATA 20,6D
02048:  DATA 61,63
0204A:  DATA 68,69
0204C:  DATA 6E,65
0204E:  DATA 2E,2E
02050:  DATA 2E,00
02052:  DATA 58,4D
02054:  DATA 4F,44
02056:  DATA 45,4D
02058:  DATA 20,63
0205A:  DATA 6F,70
0205C:  DATA 79,20
0205E:  DATA 63,6F
02060:  DATA 6D,6D
02062:  DATA 61,6E
02064:  DATA 64,20
02066:  DATA 52,50
02068:  DATA 69,20
0206A:  DATA 74,6F
0206C:  DATA 20,62
0206E:  DATA 75,73
02070:  DATA 2C,20
02072:  DATA 73,74
02074:  DATA 61,72
02076:  DATA 74,69
02078:  DATA 6E,67
0207A:  DATA 20,73
0207C:  DATA 74,61
0207E:  DATA 74,65
02080:  DATA 20,6D
02082:  DATA 61,63
02084:  DATA 68,69
02086:  DATA 6E,65
02088:  DATA 2E,2E
0208A:  DATA 2E,00
0208C:  DATA 49,6E
0208E:  DATA 6E,65
02090:  DATA 72,20
02092:  DATA 63,6F
02094:  DATA 6D,6D
02096:  DATA 61,6E
02098:  DATA 64,20
0209A:  DATA 6E,6F
0209C:  DATA 74,20
0209E:  DATA 69,6D
020A0:  DATA 70,6C
020A2:  DATA 65,6D
020A4:  DATA 65,6E
020A6:  DATA 74,65
020A8:  DATA 64,2E
020AA:  DATA 00,00
020AC:  DATA 25,30
020AE:  DATA 34,6C
020B0:  DATA 64,2F
020B2:  DATA 25,30
020B4:  DATA 32,64
020B6:  DATA 2F,25
020B8:  DATA 30,32
020BA:  DATA 64,20
020BC:  DATA 25,30
020BE:  DATA 32,64
020C0:  DATA 3A,25
020C2:  DATA 30,32
020C4:  DATA 64,3A
020C6:  DATA 25,30
020C8:  DATA 32,64
020CA:  DATA 20,7C
020CC:  DATA 20,25
020CE:  DATA 30,32
020D0:  DATA 64,20
020D2:  DATA 7C,20
020D4:  DATA 25,30
020D6:  DATA 32,58
020D8:  DATA 20,25
020DA:  DATA 30,32
020DC:  DATA 58,20
020DE:  DATA 7C,20
020E0:  DATA 00,00
020E2:  DATA 20,28
020E4:  DATA 25,73
020E6:  DATA 20,52
020E8:  DATA 3A,25
020EA:  DATA 30,32
020EC:  DATA 58,29
020EE:  DATA 00,00
020F0:  DATA 49,6E
020F2:  DATA 69,74
020F4:  DATA 69,61
020F6:  DATA 6C,69
020F8:  DATA 7A,69
020FA:  DATA 6E,67
020FC:  DATA 20,66
020FE:  DATA 6C,61
02100:  DATA 73,68
02102:  DATA 20,6D
02104:  DATA 65,6D
02106:  DATA 6F,72
02108:  DATA 79,2E
0210A:  DATA 2E,2E
0210C:  DATA 0D,0A
0210E:  DATA 00,00
02110:  DATA 52,65
02112:  DATA 74,72
02114:  DATA 69,65
02116:  DATA 76,69
02118:  DATA 6E,67
0211A:  DATA 20,61
0211C:  DATA 64,64
0211E:  DATA 72,65
02120:  DATA 73,73
02122:  DATA 65,73
02124:  DATA 20,66
02126:  DATA 72,6F
02128:  DATA 6D,20
0212A:  DATA 66,6C
0212C:  DATA 61,73
0212E:  DATA 68,20
02130:  DATA 6D,65
02132:  DATA 6D,6F
02134:  DATA 72,79
02136:  DATA 2E,2E
02138:  DATA 2E,0D
0213A:  DATA 0A,00
*
04340:  DATA 4E,6F
04342:  DATA 20,32
04344:  DATA 34,68
04346:  DATA 20,72
04348:  DATA 65,73
0434A:  DATA 65,74
0434C:  DATA 20,68
0434E:  DATA 61,70
04350:  DATA 70,65
04352:  DATA 6E,65
04354:  DATA 64,2C
04356:  DATA 20,64
04358:  DATA 6F,69
0435A:  DATA 6E,67
0435C:  DATA 20,73
0435E:  DATA 6F,66
04360:  DATA 74,20
04362:  DATA 72,65
04364:  DATA 73,65
04366:  DATA 74,20
04368:  DATA 69,6E
0436A:  DATA 73,74
0436C:  DATA 65,61
0436E:  DATA 64,2E
04370:  DATA 0D,0A
04372:  DATA 00,00
04374:  DATA 0D,0A
04376:  DATA 20,20
04378:  DATA 5F,20
0437A:  DATA 20,20
0437C:  DATA 20,5F
0437E:  DATA 5F,5F
04380:  DATA 20,20
04382:  DATA 5F,5F
04384:  DATA 5F,20
04386:  DATA 20,5F
04388:  DATA 5F,5F
0438A:  DATA 20,20
0438C:  DATA 20,5F
0438E:  DATA 20,20
04390:  DATA 20,20
04392:  DATA 5F,5F
04394:  DATA 5F,20
04396:  DATA 20,5F
04398:  DATA 5F,20
0439A:  DATA 20,20
0439C:  DATA 20,20
0439E:  DATA 5F,5F
043A0:  DATA 5F,20
043A2:  DATA 20,20
043A4:  DATA 20,20
043A6:  DATA 20,20
043A8:  DATA 5F,20
043AA:  DATA 20,20
043AC:  DATA 20,20
043AE:  DATA 20,20
043B0:  DATA 5F,20
043B2:  DATA 5F,20
043B4:  DATA 5F,20
043B6:  DATA 5F,20
043B8:  DATA 20,20
043BA:  DATA 20,20
043BC:  DATA 20,20
043BE:  DATA 0D,0A
043C0:  DATA 00,00
043C2:  DATA 20,7C
043C4:  DATA 20,7C
043C6:  DATA 20,20
043C8:  DATA 7C,20
043CA:  DATA 5F,5F
043CC:  DATA 7C,7C
043CE:  DATA 20,5F
043D0:  DATA 20,7C
043D2:  DATA 7C,20
043D4:  DATA 5F,20
043D6:  DATA 5C,20
043D8:  DATA 2F,20
043DA:  DATA 5C,20
043DC:  DATA 20,7C
043DE:  DATA 20,5F
043E0:  DATA 20,5C
043E2:  DATA 7C,20
043E4:  DATA 20,5C
043E6:  DATA 20,20
043E8:  DATA 20,2F
043EA:  DATA 20,5F
043EC:  DATA 5F,7C
043EE:  DATA 20,5F
043F0:  DATA 5F,20
043F2:  DATA 5F,7C
043F4:  DATA 20,7C
043F6:  DATA 5F,20
043F8:  DATA 5F,5F
043FA:  DATA 5F,7C
043FC:  DATA 20,7C
043FE:  DATA 20,28
04400:  DATA 5F,29
04402:  DATA 20,7C
04404:  DATA 5F,20
04406:  DATA 5F,5F
04408:  DATA 5F,20
0440A:  DATA 0D,0A
0440C:  DATA 00,00
0440E:  DATA 20,7C
04410:  DATA 20,7C
04412:  DATA 5F,20
04414:  DATA 7C,20
04416:  DATA 5F,7C
04418:  DATA 20,7C
0441A:  DATA 7C,5F
0441C:  DATA 7C,7C
0441E:  DATA 7C,5F
04420:  DATA 5F,5F
04422:  DATA 2F,2F
04424:  DATA 20,5F
04426:  DATA 20,5C
04428:  DATA 20,7C
0442A:  DATA 20,20
0442C:  DATA 20,2F
0442E:  DATA 7C,7C
04430:  DATA 20,20
04432:  DATA 7C,20
04434:  DATA 20,5C
04436:  DATA 5F,5F
04438:  DATA 20,5C
0443A:  DATA 2F,20
0443C:  DATA 5F,60
0443E:  DATA 20,7C
04440:  DATA 20,20
04442:  DATA 5F,2F
04444:  DATA 20,2D
04446:  DATA 5F,29
04448:  DATA 20,7C
0444A:  DATA 20,7C
0444C:  DATA 20,7C
0444E:  DATA 20,20
04450:  DATA 5F,2F
04452:  DATA 20,2D
04454:  DATA 5F,29
04456:  DATA 0D,0A
04458:  DATA 00,00
0445A:  DATA 20,7C
0445C:  DATA 5F,5F
0445E:  DATA 5F,7C
04460:  DATA 7C,5F
04462:  DATA 5F,5F
04464:  DATA 7C,7C
04466:  DATA 5F,5F
04468:  DATA 5F,7C
0446A:  DATA 7C,5F
0446C:  DATA 7C,20
0446E:  DATA 2F,5F
04470:  DATA 2F,20
04472:  DATA 5C,5F
04474:  DATA 5C,7C
04476:  DATA 5F,5C
04478:  DATA 5F,5C
0447A:  DATA 7C,5F
0447C:  DATA 5F,2F
0447E:  DATA 20,20
04480:  DATA 20,7C
04482:  DATA 5F,5F
04484:  DATA 5F,2F
04486:  DATA 5C,5F
04488:  DATA 5F,2C
0448A:  DATA 5F,7C
0448C:  DATA 5C,5F
0448E:  DATA 5F,5C
04490:  DATA 5F,5F
04492:  DATA 5F,7C
04494:  DATA 5F,7C
04496:  DATA 5F,7C
04498:  DATA 5F,7C
0449A:  DATA 5C,5F
0449C:  DATA 5F,5C
0449E:  DATA 5F,5F
044A0:  DATA 5F,7C
044A2:  DATA 0D,0A
044A4:  DATA 0D,0A
044A6:  DATA 00,00
044A8:  DATA 43,6F
044AA:  DATA 6D,70
044AC:  DATA 69,6C
044AE:  DATA 65,64
044B0:  DATA 20,6F
044B2:  DATA 6E,3A
044B4:  DATA 20,30
044B6:  DATA 36,2D
044B8:  DATA 53,65
044BA:  DATA 70,2D
044BC:  DATA 32,34
044BE:  DATA 20,31
044C0:  DATA 36,3A
044C2:  DATA 33,34
044C4:  DATA 3A,35
044C6:  DATA 36,0D
044C8:  DATA 0A,0D
044CA:  DATA 0A,00
044CC:  DATA 3E,20
044CE:  DATA 49,6E
044D0:  DATA 76,61
044D2:  DATA 6C,69
044D4:  DATA 64,20
044D6:  DATA 63,6C
044D8:  DATA 6F,63
044DA:  DATA 6B,2C
044DC:  DATA 20,72
044DE:  DATA 65,63
044E0:  DATA 6F,76
044E2:  DATA 65,72
044E4:  DATA 69,6E
044E6:  DATA 67,2E
044E8:  DATA 2E,2E
044EA:  DATA 0D,0A
044EC:  DATA 00,00
*
04534:  TBLRD*+
04536:  MOVF   FF5,F
04538:  BZ    455A
0453A:  MOVFF  FF6,CBE
0453E:  MOVFF  FF7,CBF
04542:  MOVFF  FF8,CC0
04546:  MOVFF  FF5,D6A
0454A:  RCALL  44EE
0454C:  MOVFF  CBE,FF6
04550:  MOVFF  CBF,FF7
04554:  MOVFF  CC0,FF8
04558:  BRA    4534
0455A:  RETURN 0
0455C:  MOVWF  00
0455E:  SWAPF  00,W
04560:  ANDLW  0F
04562:  MULLW  0A
04564:  MOVF   00,W
04566:  ANDLW  0F
04568:  ADDWF  FF3,W
0456A:  RETURN 0
0456C:  RETURN 0
0456E:  MOVLB  C
04570:  CLRF   xB9
04572:  CLRF   xBA
04574:  MOVLW  01
04576:  MOVWF  xBB
04578:  CLRF   FDA
0457A:  CLRF   FD9
0457C:  MOVLW  0C
0457E:  MOVWF  xBE
04580:  MOVLW  B1
04582:  MOVWF  xBD
04584:  MOVLW  0C
04586:  MOVWF  FEA
04588:  MOVLW  B5
0458A:  MOVWF  FE9
0458C:  MOVFF  CBE,FE2
04590:  MOVFF  CBD,FE1
04594:  MOVFF  CBB,CBC
04598:  BCF    FD8.0
0459A:  MOVF   FE5,W
0459C:  MULWF  FEE
0459E:  MOVF   FF3,W
045A0:  ADDWFC xB9,F
045A2:  MOVF   FF4,W
045A4:  ADDWFC xBA,F
045A6:  DECFSZ xBC,F
045A8:  BRA    4598
045AA:  MOVFF  CB9,FDE
045AE:  MOVFF  CBA,CB9
045B2:  CLRF   xBA
045B4:  BTFSC  FD8.0
045B6:  INCF   xBA,F
045B8:  INCF   xBD,F
045BA:  BTFSC  FD8.2
045BC:  INCF   xBE,F
045BE:  INCF   xBB,F
045C0:  MOVF   xBB,W
045C2:  SUBLW  05
045C4:  BNZ   4584
045C6:  MOVLB  0
045C8:  RETURN 0
045CA:  CLRF   01
045CC:  CLRF   02
045CE:  CLRF   00
045D0:  CLRF   03
045D2:  MOVLB  C
045D4:  MOVF   x91,W
045D6:  BNZ   45DC
045D8:  MOVF   x90,W
045DA:  BZ    460C
045DC:  MOVLW  10
045DE:  MOVWF  x92
045E0:  BCF    FD8.0
045E2:  RLCF   x8E,F
045E4:  RLCF   x8F,F
045E6:  RLCF   00,F
045E8:  RLCF   03,F
045EA:  MOVF   x91,W
045EC:  SUBWF  03,W
045EE:  BNZ   45F4
045F0:  MOVF   x90,W
045F2:  SUBWF  00,W
045F4:  BNC   4604
045F6:  MOVF   x90,W
045F8:  SUBWF  00,F
045FA:  BTFSS  FD8.0
045FC:  DECF   03,F
045FE:  MOVF   x91,W
04600:  SUBWF  03,F
04602:  BSF    FD8.0
04604:  RLCF   01,F
04606:  RLCF   02,F
04608:  DECFSZ x92,F
0460A:  BRA    45E0
0460C:  MOVLB  0
0460E:  RETURN 0
*
04698:  MOVLB  C
0469A:  MOVF   xC5,W
0469C:  CLRF   01
0469E:  SUBWF  xC4,W
046A0:  BC    46A8
046A2:  MOVFF  CC4,00
046A6:  BRA    46C0
046A8:  CLRF   00
046AA:  MOVLW  08
046AC:  MOVWF  xC6
046AE:  RLCF   xC4,F
046B0:  RLCF   00,F
046B2:  MOVF   xC5,W
046B4:  SUBWF  00,W
046B6:  BTFSC  FD8.0
046B8:  MOVWF  00
046BA:  RLCF   01,F
046BC:  DECFSZ xC6,F
046BE:  BRA    46AE
046C0:  MOVLB  0
046C2:  RETURN 0
*
04726:  BTFSC  FD8.1
04728:  BRA    4732
0472A:  MOVLW  0C
0472C:  MOVWF  FEA
0472E:  MOVLW  9A
04730:  MOVWF  FE9
04732:  MOVLB  C
04734:  MOVF   x95,W
04736:  XORWF  x99,W
04738:  ANDLW  80
0473A:  MOVWF  x9F
0473C:  BTFSS  x95.7
0473E:  BRA    4756
04740:  COMF   x92,F
04742:  COMF   x93,F
04744:  COMF   x94,F
04746:  COMF   x95,F
04748:  INCF   x92,F
0474A:  BTFSC  FD8.2
0474C:  INCF   x93,F
0474E:  BTFSC  FD8.2
04750:  INCF   x94,F
04752:  BTFSC  FD8.2
04754:  INCF   x95,F
04756:  BTFSS  x99.7
04758:  BRA    4770
0475A:  COMF   x96,F
0475C:  COMF   x97,F
0475E:  COMF   x98,F
04760:  COMF   x99,F
04762:  INCF   x96,F
04764:  BTFSC  FD8.2
04766:  INCF   x97,F
04768:  BTFSC  FD8.2
0476A:  INCF   x98,F
0476C:  BTFSC  FD8.2
0476E:  INCF   x99,F
04770:  CLRF   00
04772:  CLRF   01
04774:  CLRF   02
04776:  CLRF   03
04778:  CLRF   x9A
0477A:  CLRF   x9B
0477C:  CLRF   x9C
0477E:  CLRF   x9D
04780:  MOVF   x99,W
04782:  IORWF  x98,W
04784:  IORWF  x97,W
04786:  IORWF  x96,W
04788:  BZ    47E2
0478A:  MOVLW  20
0478C:  MOVWF  x9E
0478E:  BCF    FD8.0
04790:  RLCF   x92,F
04792:  RLCF   x93,F
04794:  RLCF   x94,F
04796:  RLCF   x95,F
04798:  RLCF   x9A,F
0479A:  RLCF   x9B,F
0479C:  RLCF   x9C,F
0479E:  RLCF   x9D,F
047A0:  MOVF   x99,W
047A2:  SUBWF  x9D,W
047A4:  BNZ   47B6
047A6:  MOVF   x98,W
047A8:  SUBWF  x9C,W
047AA:  BNZ   47B6
047AC:  MOVF   x97,W
047AE:  SUBWF  x9B,W
047B0:  BNZ   47B6
047B2:  MOVF   x96,W
047B4:  SUBWF  x9A,W
047B6:  BNC   47D6
047B8:  MOVF   x96,W
047BA:  SUBWF  x9A,F
047BC:  MOVF   x97,W
047BE:  BTFSS  FD8.0
047C0:  INCFSZ x97,W
047C2:  SUBWF  x9B,F
047C4:  MOVF   x98,W
047C6:  BTFSS  FD8.0
047C8:  INCFSZ x98,W
047CA:  SUBWF  x9C,F
047CC:  MOVF   x99,W
047CE:  BTFSS  FD8.0
047D0:  INCFSZ x99,W
047D2:  SUBWF  x9D,F
047D4:  BSF    FD8.0
047D6:  RLCF   00,F
047D8:  RLCF   01,F
047DA:  RLCF   02,F
047DC:  RLCF   03,F
047DE:  DECFSZ x9E,F
047E0:  BRA    478E
047E2:  BTFSS  x9F.7
047E4:  BRA    47FC
047E6:  COMF   00,F
047E8:  COMF   01,F
047EA:  COMF   02,F
047EC:  COMF   03,F
047EE:  INCF   00,F
047F0:  BTFSC  FD8.2
047F2:  INCF   01,F
047F4:  BTFSC  FD8.2
047F6:  INCF   02,F
047F8:  BTFSC  FD8.2
047FA:  INCF   03,F
047FC:  MOVFF  C9A,FEF
04800:  MOVFF  C9B,FEC
04804:  MOVFF  C9C,FEC
04808:  MOVFF  C9D,FEC
0480C:  MOVLB  0
0480E:  RETURN 0
*
04D06:  MOVLB  C
04D08:  MOVF   xC3,W
04D0A:  MULWF  xC5
04D0C:  MOVFF  FF3,01
04D10:  MOVFF  FF4,00
04D14:  MULWF  xC6
04D16:  MOVF   FF3,W
04D18:  ADDWF  00,F
04D1A:  MOVF   xC4,W
04D1C:  MULWF  xC5
04D1E:  MOVF   FF3,W
04D20:  ADDWFC 00,W
04D22:  MOVWF  02
04D24:  MOVLB  0
04D26:  RETURN 0
*
0511C:  MOVWF  00
0511E:  SWAPF  00,W
05120:  ADDWF  00,W
05122:  ANDLW  0F
05124:  BTFSC  FD8.1
05126:  ADDLW  16
05128:  DAW   
0512A:  BTFSC  00.4
0512C:  ADDLW  15
0512E:  BTFSC  00.5
05130:  ADDLW  30
05132:  BTFSC  00.6
05134:  ADDLW  60
05136:  BTFSC  00.7
05138:  ADDLW  20
0513A:  DAW   
0513C:  RETURN 0
0513E:  RETURN 0
*
05222:  TSTFSZ 01
05224:  BRA    522C
05226:  TSTFSZ 02
05228:  BRA    522E
0522A:  BRA    523A
0522C:  INCF   02,F
0522E:  MOVFF  00,FEE
05232:  DECFSZ 01,F
05234:  BRA    522E
05236:  DECFSZ 02,F
05238:  BRA    522E
0523A:  RETURN 0
*
05290:  TBLRD*+
05292:  MOVFF  FF6,CC2
05296:  MOVFF  FF7,CC3
0529A:  MOVFF  FF8,CC4
0529E:  MOVFF  FF5,D6A
052A2:  CALL   44EE
052A6:  MOVFF  CC2,FF6
052AA:  MOVFF  CC3,FF7
052AE:  MOVFF  CC4,FF8
052B2:  MOVLB  C
052B4:  DECFSZ xC1,F
052B6:  BRA    52BA
052B8:  BRA    52BE
052BA:  MOVLB  0
052BC:  BRA    5290
052BE:  MOVLB  0
052C0:  RETURN 0
052C2:  MOVF   FEF,F
052C4:  BZ    52E6
052C6:  MOVFF  FEA,CC2
052CA:  MOVFF  FE9,CC1
052CE:  MOVFF  FEF,D6A
052D2:  CALL   44EE
052D6:  MOVFF  CC2,FEA
052DA:  MOVFF  CC1,FE9
052DE:  INCF   FE9,F
052E0:  BTFSC  FD8.2
052E2:  INCF   FEA,F
052E4:  BRA    52C2
052E6:  RETURN 0
*
053D6:  MOVLB  D
053D8:  MOVF   x68,W
053DA:  ANDLW  07
053DC:  MOVWF  00
053DE:  RRCF   x68,W
053E0:  MOVWF  01
053E2:  RRCF   01,F
053E4:  RRCF   01,F
053E6:  MOVLW  1F
053E8:  ANDWF  01,F
053EA:  MOVF   01,W
053EC:  ADDWF  x6A,W
053EE:  MOVWF  FE9
053F0:  MOVLW  00
053F2:  ADDWFC x6B,W
053F4:  MOVWF  FEA
053F6:  CLRF   01
053F8:  INCF   01,F
053FA:  INCF   00,F
053FC:  BRA    5400
053FE:  RLCF   01,F
05400:  DECFSZ 00,F
05402:  BRA    53FE
05404:  MOVF   x69,F
05406:  BZ    540E
05408:  MOVF   01,W
0540A:  IORWF  FEF,F
0540C:  BRA    5414
0540E:  COMF   01,F
05410:  MOVF   01,W
05412:  ANDWF  FEF,F
05414:  MOVLB  0
05416:  RETURN 0
*
05852:  BTFSC  FD8.1
05854:  BRA    585E
05856:  MOVLW  0C
05858:  MOVWF  FEA
0585A:  MOVLW  B8
0585C:  MOVWF  FE9
0585E:  CLRF   00
05860:  CLRF   01
05862:  CLRF   02
05864:  CLRF   03
05866:  MOVLB  C
05868:  CLRF   xB8
0586A:  CLRF   xB9
0586C:  CLRF   xBA
0586E:  CLRF   xBB
05870:  MOVF   xB7,W
05872:  IORWF  xB6,W
05874:  IORWF  xB5,W
05876:  IORWF  xB4,W
05878:  BZ    58D2
0587A:  MOVLW  20
0587C:  MOVWF  xBC
0587E:  BCF    FD8.0
05880:  RLCF   xB0,F
05882:  RLCF   xB1,F
05884:  RLCF   xB2,F
05886:  RLCF   xB3,F
05888:  RLCF   xB8,F
0588A:  RLCF   xB9,F
0588C:  RLCF   xBA,F
0588E:  RLCF   xBB,F
05890:  MOVF   xB7,W
05892:  SUBWF  xBB,W
05894:  BNZ   58A6
05896:  MOVF   xB6,W
05898:  SUBWF  xBA,W
0589A:  BNZ   58A6
0589C:  MOVF   xB5,W
0589E:  SUBWF  xB9,W
058A0:  BNZ   58A6
058A2:  MOVF   xB4,W
058A4:  SUBWF  xB8,W
058A6:  BNC   58C6
058A8:  MOVF   xB4,W
058AA:  SUBWF  xB8,F
058AC:  MOVF   xB5,W
058AE:  BTFSS  FD8.0
058B0:  INCFSZ xB5,W
058B2:  SUBWF  xB9,F
058B4:  MOVF   xB6,W
058B6:  BTFSS  FD8.0
058B8:  INCFSZ xB6,W
058BA:  SUBWF  xBA,F
058BC:  MOVF   xB7,W
058BE:  BTFSS  FD8.0
058C0:  INCFSZ xB7,W
058C2:  SUBWF  xBB,F
058C4:  BSF    FD8.0
058C6:  RLCF   00,F
058C8:  RLCF   01,F
058CA:  RLCF   02,F
058CC:  RLCF   03,F
058CE:  DECFSZ xBC,F
058D0:  BRA    587E
058D2:  MOVFF  CB8,FEF
058D6:  MOVFF  CB9,FEC
058DA:  MOVFF  CBA,FEC
058DE:  MOVFF  CBB,FEC
058E2:  MOVLB  0
058E4:  RETURN 0
*
059CA:  MOVFF  FEA,C7D
059CE:  MOVFF  FE9,C7C
059D2:  MOVLB  C
059D4:  SWAPF  x76,W
059D6:  IORLW  F0
059D8:  MOVWF  x78
059DA:  ADDWF  x78,F
059DC:  ADDLW  E2
059DE:  MOVWF  x79
059E0:  ADDLW  32
059E2:  MOVWF  x7B
059E4:  MOVF   x76,W
059E6:  ANDLW  0F
059E8:  ADDWF  x79,F
059EA:  ADDWF  x79,F
059EC:  ADDWF  x7B,F
059EE:  ADDLW  E9
059F0:  MOVWF  x7A
059F2:  ADDWF  x7A,F
059F4:  ADDWF  x7A,F
059F6:  SWAPF  x75,W
059F8:  ANDLW  0F
059FA:  ADDWF  x7A,F
059FC:  ADDWF  x7B,F
059FE:  RLCF   x7A,F
05A00:  RLCF   x7B,F
05A02:  COMF   x7B,F
05A04:  RLCF   x7B,F
05A06:  MOVF   x75,W
05A08:  ANDLW  0F
05A0A:  ADDWF  x7B,F
05A0C:  RLCF   x78,F
05A0E:  MOVLW  07
05A10:  MOVWF  x77
05A12:  MOVLW  0A
05A14:  DECF   x7A,F
05A16:  ADDWF  x7B,F
05A18:  BNC   5A14
05A1A:  DECF   x79,F
05A1C:  ADDWF  x7A,F
05A1E:  BNC   5A1A
05A20:  DECF   x78,F
05A22:  ADDWF  x79,F
05A24:  BNC   5A20
05A26:  DECF   x77,F
05A28:  ADDWF  x78,F
05A2A:  BNC   5A26
05A2C:  MOVLW  0C
05A2E:  MOVWF  FEA
05A30:  MOVLW  77
05A32:  MOVWF  FE9
05A34:  MOVLW  07
05A36:  ANDWF  x7C,W
05A38:  BCF    x7C.6
05A3A:  ADDWF  FE9,F
05A3C:  MOVLW  00
05A3E:  ADDWFC FEA,F
05A40:  MOVF   FE9,W
05A42:  SUBLW  7B
05A44:  BNZ   5A4E
05A46:  MOVF   FEA,W
05A48:  SUBLW  0C
05A4A:  BNZ   5A4E
05A4C:  BSF    x7C.6
05A4E:  MOVF   FEF,W
05A50:  MOVWF  00
05A52:  BNZ   5A64
05A54:  BTFSC  x7C.6
05A56:  BRA    5A64
05A58:  BTFSC  x7C.4
05A5A:  BRA    5A88
05A5C:  BTFSC  x7C.3
05A5E:  BRA    5A64
05A60:  MOVLW  20
05A62:  BRA    5A6A
05A64:  BSF    x7C.3
05A66:  BCF    x7C.4
05A68:  MOVLW  30
05A6A:  ADDWF  00,F
05A6C:  MOVFF  FEA,C76
05A70:  MOVFF  FE9,C75
05A74:  MOVFF  00,D6A
05A78:  MOVLB  0
05A7A:  CALL   44EE
05A7E:  MOVFF  C76,FEA
05A82:  MOVFF  C75,FE9
05A86:  MOVLB  C
05A88:  MOVF   FEE,W
05A8A:  BTFSS  x7C.6
05A8C:  BRA    5A40
05A8E:  MOVLB  0
05A90:  RETURN 0
05A92:  MOVLB  C
05A94:  BTFSC  xC0.7
05A96:  BRA    5ABC
05A98:  MOVLW  0F
05A9A:  MOVWF  00
05A9C:  SWAPF  xBF,W
05A9E:  ANDWF  00,F
05AA0:  MOVLW  0A
05AA2:  SUBWF  00,W
05AA4:  BC    5AAC
05AA6:  MOVLW  30
05AA8:  ADDWF  00,F
05AAA:  BRA    5AB0
05AAC:  MOVF   xC0,W
05AAE:  ADDWF  00,F
05AB0:  MOVFF  00,D6A
05AB4:  MOVLB  0
05AB6:  CALL   44EE
05ABA:  MOVLB  C
05ABC:  MOVLW  0F
05ABE:  ANDWF  xBF,F
05AC0:  MOVLW  0A
05AC2:  SUBWF  xBF,W
05AC4:  BC    5ACA
05AC6:  MOVLW  30
05AC8:  BRA    5ACE
05ACA:  BCF    xC0.7
05ACC:  MOVF   xC0,W
05ACE:  ADDWF  xBF,F
05AD0:  MOVFF  CBF,D6A
05AD4:  MOVLB  0
05AD6:  CALL   44EE
05ADA:  RETURN 0
05ADC:  MOVF   01,W
05ADE:  MOVFF  C78,CC4
05AE2:  MOVLW  64
05AE4:  MOVLB  C
05AE6:  MOVWF  xC5
05AE8:  MOVLB  0
05AEA:  CALL   4698
05AEE:  MOVFF  00,C78
05AF2:  MOVF   01,W
05AF4:  MOVLW  30
05AF6:  BNZ   5B08
05AF8:  MOVLB  C
05AFA:  BTFSS  x79.1
05AFC:  BRA    5B1E
05AFE:  BTFSC  x79.3
05B00:  BRA    5B1E
05B02:  BTFSC  x79.4
05B04:  MOVLW  20
05B06:  BRA    5B10
05B08:  MOVLB  C
05B0A:  BCF    x79.3
05B0C:  BCF    x79.4
05B0E:  BSF    x79.0
05B10:  ADDWF  01,F
05B12:  MOVFF  01,D6A
05B16:  MOVLB  0
05B18:  CALL   44EE
05B1C:  MOVLB  C
05B1E:  MOVFF  C78,CC4
05B22:  MOVLW  0A
05B24:  MOVWF  xC5
05B26:  MOVLB  0
05B28:  CALL   4698
05B2C:  MOVFF  00,C78
05B30:  MOVF   01,W
05B32:  MOVLW  30
05B34:  BNZ   5B46
05B36:  MOVLB  C
05B38:  BTFSC  x79.3
05B3A:  BRA    5B52
05B3C:  BTFSS  x79.0
05B3E:  BRA    5B52
05B40:  BTFSC  x79.4
05B42:  MOVLW  20
05B44:  MOVLB  0
05B46:  ADDWF  01,F
05B48:  MOVFF  01,D6A
05B4C:  CALL   44EE
05B50:  MOVLB  C
05B52:  MOVLW  30
05B54:  ADDWF  x78,F
05B56:  MOVFF  C78,D6A
05B5A:  MOVLB  0
05B5C:  CALL   44EE
05B60:  RETURN 0
*
073A8:  MOVLW  20
073AA:  MOVLB  C
073AC:  BTFSS  xBF.4
073AE:  MOVLW  30
073B0:  MOVWF  xC0
073B2:  MOVFF  CBE,00
073B6:  BTFSS  xBE.7
073B8:  BRA    73CA
073BA:  COMF   00,F
073BC:  INCF   00,F
073BE:  MOVFF  00,CBE
073C2:  MOVLW  2D
073C4:  MOVWF  xC0
073C6:  BSF    xBF.7
073C8:  BSF    xBF.0
073CA:  MOVF   01,W
073CC:  MOVFF  CBE,CC4
073D0:  MOVLW  64
073D2:  MOVWF  xC5
073D4:  MOVLB  0
073D6:  CALL   4698
073DA:  MOVFF  00,CBE
073DE:  MOVLW  30
073E0:  ADDWF  01,W
073E2:  MOVLB  C
073E4:  MOVWF  xC1
073E6:  MOVFF  CBE,CC4
073EA:  MOVLW  0A
073EC:  MOVWF  xC5
073EE:  MOVLB  0
073F0:  CALL   4698
073F4:  MOVLW  30
073F6:  ADDWF  00,W
073F8:  MOVLB  C
073FA:  MOVWF  xC3
073FC:  MOVLW  30
073FE:  ADDWF  01,W
07400:  MOVWF  xC2
07402:  MOVFF  CC0,00
07406:  MOVLW  30
07408:  SUBWF  xC1,W
0740A:  BZ    7414
0740C:  BSF    xBF.1
0740E:  BTFSC  xBF.7
07410:  BSF    xBF.2
07412:  BRA    7438
07414:  MOVFF  CC0,CC1
07418:  MOVLW  20
0741A:  MOVWF  xC0
0741C:  MOVLW  30
0741E:  SUBWF  xC2,W
07420:  BZ    742A
07422:  BSF    xBF.0
07424:  BTFSC  xBF.7
07426:  BSF    xBF.1
07428:  BRA    7438
0742A:  BTFSS  FD8.2
0742C:  BSF    xBF.0
0742E:  BNZ   7438
07430:  MOVFF  CC1,CC2
07434:  MOVLW  20
07436:  MOVWF  xC1
07438:  BTFSC  xBF.2
0743A:  BRA    7446
0743C:  BTFSC  xBF.1
0743E:  BRA    7450
07440:  BTFSC  xBF.0
07442:  BRA    745A
07444:  BRA    7464
07446:  MOVFF  CC0,D6A
0744A:  MOVLB  0
0744C:  CALL   44EE
07450:  MOVFF  CC1,D6A
07454:  MOVLB  0
07456:  CALL   44EE
0745A:  MOVFF  CC2,D6A
0745E:  MOVLB  0
07460:  CALL   44EE
07464:  MOVFF  CC3,D6A
07468:  MOVLB  0
0746A:  CALL   44EE
0746E:  RETURN 0
*
07894:  MOVFF  FEA,C6D
07898:  MOVFF  FE9,C6C
0789C:  MOVLB  C
0789E:  BTFSS  x66.7
078A0:  BRA    78B2
078A2:  BSF    x6C.7
078A4:  BTFSS  x6C.4
078A6:  INCF   x6C,F
078A8:  COMF   x65,F
078AA:  COMF   x66,F
078AC:  INCF   x65,F
078AE:  BTFSC  FD8.2
078B0:  INCF   x66,F
078B2:  SWAPF  x66,W
078B4:  IORLW  F0
078B6:  MOVWF  x68
078B8:  ADDWF  x68,F
078BA:  ADDLW  E2
078BC:  MOVWF  x69
078BE:  ADDLW  32
078C0:  MOVWF  x6B
078C2:  MOVF   x66,W
078C4:  ANDLW  0F
078C6:  ADDWF  x69,F
078C8:  ADDWF  x69,F
078CA:  ADDWF  x6B,F
078CC:  ADDLW  E9
078CE:  MOVWF  x6A
078D0:  ADDWF  x6A,F
078D2:  ADDWF  x6A,F
078D4:  SWAPF  x65,W
078D6:  ANDLW  0F
078D8:  ADDWF  x6A,F
078DA:  ADDWF  x6B,F
078DC:  RLCF   x6A,F
078DE:  RLCF   x6B,F
078E0:  COMF   x6B,F
078E2:  RLCF   x6B,F
078E4:  MOVF   x65,W
078E6:  ANDLW  0F
078E8:  ADDWF  x6B,F
078EA:  RLCF   x68,F
078EC:  MOVLW  07
078EE:  MOVWF  x67
078F0:  MOVLW  0A
078F2:  DECF   x6A,F
078F4:  ADDWF  x6B,F
078F6:  BNC   78F2
078F8:  DECF   x69,F
078FA:  ADDWF  x6A,F
078FC:  BNC   78F8
078FE:  DECF   x68,F
07900:  ADDWF  x69,F
07902:  BNC   78FE
07904:  DECF   x67,F
07906:  ADDWF  x68,F
07908:  BNC   7904
0790A:  MOVLW  0C
0790C:  MOVWF  FEA
0790E:  MOVLW  67
07910:  MOVWF  FE9
07912:  MOVLW  07
07914:  ANDWF  x6C,W
07916:  BCF    x6C.6
07918:  MOVF   FED,F
0791A:  ANDWF  x6C,W
0791C:  BNZ   792C
0791E:  BTFSC  x6C.4
07920:  MOVF   FEE,F
07922:  BTFSC  x6C.4
07924:  BRA    792C
07926:  MOVLW  20
07928:  MOVWF  00
0792A:  BRA    796E
0792C:  ADDWF  FE9,F
0792E:  MOVLW  00
07930:  ADDWFC FEA,F
07932:  MOVF   FE9,W
07934:  SUBLW  6B
07936:  BNZ   7940
07938:  MOVF   FEA,W
0793A:  SUBLW  0C
0793C:  BNZ   7940
0793E:  BSF    x6C.6
07940:  MOVF   FEF,W
07942:  MOVWF  00
07944:  BNZ   7956
07946:  BTFSC  x6C.6
07948:  BRA    7956
0794A:  BTFSC  x6C.4
0794C:  BRA    798A
0794E:  BTFSC  x6C.3
07950:  BRA    7956
07952:  MOVLW  20
07954:  BRA    796C
07956:  BTFSS  x6C.7
07958:  BRA    7966
0795A:  MOVLW  2D
0795C:  MOVWF  00
0795E:  MOVF   FED,W
07960:  BCF    x6C.6
07962:  BCF    x6C.7
07964:  BRA    796E
07966:  BSF    x6C.3
07968:  BCF    x6C.4
0796A:  MOVLW  30
0796C:  ADDWF  00,F
0796E:  MOVFF  FEA,C66
07972:  MOVFF  FE9,C65
07976:  MOVFF  00,D6A
0797A:  MOVLB  0
0797C:  CALL   44EE
07980:  MOVFF  C66,FEA
07984:  MOVFF  C65,FE9
07988:  MOVLB  C
0798A:  MOVF   FEE,W
0798C:  BTFSS  x6C.6
0798E:  BRA    7932
07990:  MOVLB  0
07992:  RETURN 0
07994:  MOVLW  20
07996:  MOVLB  C
07998:  BTFSS  x66.4
0799A:  MOVLW  30
0799C:  MOVWF  x67
0799E:  MOVFF  C65,00
079A2:  BTFSS  x65.7
079A4:  BRA    79B6
079A6:  COMF   00,F
079A8:  INCF   00,F
079AA:  MOVFF  00,C65
079AE:  MOVLW  2D
079B0:  MOVWF  x67
079B2:  BSF    x66.7
079B4:  BSF    x66.0
079B6:  MOVF   01,W
079B8:  MOVFF  C65,CC4
079BC:  MOVLW  64
079BE:  MOVWF  xC5
079C0:  MOVLB  0
079C2:  CALL   4698
079C6:  MOVFF  00,C65
079CA:  MOVLW  30
079CC:  ADDWF  01,W
079CE:  MOVLB  C
079D0:  MOVWF  x68
079D2:  MOVFF  C65,CC4
079D6:  MOVLW  0A
079D8:  MOVWF  xC5
079DA:  MOVLB  0
079DC:  CALL   4698
079E0:  MOVLW  30
079E2:  ADDWF  00,W
079E4:  MOVLB  C
079E6:  MOVWF  x6A
079E8:  MOVLW  30
079EA:  ADDWF  01,W
079EC:  MOVWF  x69
079EE:  MOVFF  C67,00
079F2:  MOVLW  30
079F4:  SUBWF  x68,W
079F6:  BZ    7A00
079F8:  BSF    x66.1
079FA:  BTFSC  x66.7
079FC:  BSF    x66.2
079FE:  BRA    7A24
07A00:  BTFSC  x66.2
07A02:  BRA    7A24
07A04:  MOVFF  C67,C68
07A08:  BTFSC  x66.1
07A0A:  BRA    7A14
07A0C:  MOVLW  30
07A0E:  SUBWF  x69,W
07A10:  BZ    7A1A
07A12:  BSF    x66.0
07A14:  BTFSC  x66.7
07A16:  BSF    x66.1
07A18:  BRA    7A24
07A1A:  BTFSS  FD8.2
07A1C:  BSF    x66.0
07A1E:  BTFSC  FD8.2
07A20:  MOVFF  C68,C69
07A24:  BTFSC  x66.2
07A26:  BRA    7A32
07A28:  BTFSC  x66.1
07A2A:  BRA    7A3C
07A2C:  BTFSC  x66.0
07A2E:  BRA    7A46
07A30:  BRA    7A50
07A32:  MOVFF  C67,D6A
07A36:  MOVLB  0
07A38:  CALL   44EE
07A3C:  MOVFF  C68,D6A
07A40:  MOVLB  0
07A42:  CALL   44EE
07A46:  MOVFF  C69,D6A
07A4A:  MOVLB  0
07A4C:  CALL   44EE
07A50:  MOVFF  C6A,D6A
07A54:  MOVLB  0
07A56:  CALL   44EE
07A5A:  RETURN 0
*
0A320:  TBLRD*+
0A322:  MOVFF  FF6,CA5
0A326:  MOVFF  FF7,CA6
0A32A:  MOVFF  FF8,CA7
0A32E:  MOVF   FF5,W
0A330:  BTFSS  F9E.4
0A332:  BRA    A330
0A334:  MOVWF  FAD
0A336:  MOVFF  CA5,FF6
0A33A:  MOVFF  CA6,FF7
0A33E:  MOVFF  CA7,FF8
0A342:  MOVLB  C
0A344:  DECFSZ xA4,F
0A346:  BRA    A34A
0A348:  BRA    A34E
0A34A:  MOVLB  0
0A34C:  BRA    A320
0A34E:  MOVLB  0
0A350:  GOTO   A7C8 (RETURN)
0A354:  MOVF   FE9,W
0A356:  MOVLB  C
0A358:  MOVWF  xA8
0A35A:  MOVLW  3B
0A35C:  MOVWF  xAF
0A35E:  MOVLW  9A
0A360:  MOVWF  xAE
0A362:  MOVLW  CA
0A364:  MOVWF  xAD
0A366:  CLRF   xAC
0A368:  MOVLW  0A
0A36A:  MOVWF  xAA
0A36C:  BSF    FD8.1
0A36E:  MOVLW  0C
0A370:  MOVWF  FEA
0A372:  MOVLW  A4
0A374:  MOVWF  FE9
0A376:  MOVFF  CA7,CB3
0A37A:  MOVFF  CA6,CB2
0A37E:  MOVFF  CA5,CB1
0A382:  MOVFF  CA4,CB0
0A386:  MOVFF  CAF,CB7
0A38A:  MOVFF  CAE,CB6
0A38E:  MOVFF  CAD,CB5
0A392:  MOVFF  CAC,CB4
0A396:  MOVLB  0
0A398:  CALL   5852
0A39C:  MOVF   01,W
0A39E:  MOVF   00,F
0A3A0:  BNZ   A3C8
0A3A2:  MOVLB  C
0A3A4:  MOVF   xAA,W
0A3A6:  XORLW  01
0A3A8:  BTFSS  FD8.2
0A3AA:  BRA    A3B0
0A3AC:  MOVLB  0
0A3AE:  BRA    A3C8
0A3B0:  MOVF   xA8,W
0A3B2:  BZ    A3CC
0A3B4:  ANDLW  0F
0A3B6:  SUBWF  xAA,W
0A3B8:  BZ    A3BC
0A3BA:  BC    A3D8
0A3BC:  BTFSC  xA8.7
0A3BE:  BRA    A3D8
0A3C0:  BTFSC  xA8.6
0A3C2:  BRA    A3CC
0A3C4:  MOVLW  20
0A3C6:  BRA    A3CE
0A3C8:  MOVLB  C
0A3CA:  CLRF   xA8
0A3CC:  MOVLW  30
0A3CE:  ADDWF  00,F
0A3D0:  MOVF   00,W
0A3D2:  BTFSS  F9E.4
0A3D4:  BRA    A3D2
0A3D6:  MOVWF  FAD
0A3D8:  BCF    FD8.1
0A3DA:  MOVFF  CAF,CB3
0A3DE:  MOVFF  CAE,CB2
0A3E2:  MOVFF  CAD,CB1
0A3E6:  MOVFF  CAC,CB0
0A3EA:  CLRF   xB7
0A3EC:  CLRF   xB6
0A3EE:  CLRF   xB5
0A3F0:  MOVLW  0A
0A3F2:  MOVWF  xB4
0A3F4:  MOVLB  0
0A3F6:  CALL   5852
0A3FA:  MOVFF  03,CAF
0A3FE:  MOVFF  02,CAE
0A402:  MOVFF  01,CAD
0A406:  MOVFF  00,CAC
0A40A:  MOVLB  C
0A40C:  DECFSZ xAA,F
0A40E:  BRA    A36C
0A410:  MOVLB  0
0A412:  GOTO   A7DE (RETURN)
*
0EFF2:  MOVLW  8E
0EFF4:  MOVWF  00
0EFF6:  MOVFF  CA8,01
0EFFA:  MOVFF  CA7,02
0EFFE:  CLRF   03
0F000:  MOVF   01,F
0F002:  BNZ   F016
0F004:  MOVFF  02,01
0F008:  CLRF   02
0F00A:  MOVLW  08
0F00C:  SUBWF  00,F
0F00E:  MOVF   01,F
0F010:  BNZ   F016
0F012:  CLRF   00
0F014:  BRA    F026
0F016:  BCF    FD8.0
0F018:  BTFSC  01.7
0F01A:  BRA    F024
0F01C:  RLCF   02,F
0F01E:  RLCF   01,F
0F020:  DECF   00,F
0F022:  BRA    F016
0F024:  BCF    01.7
0F026:  RETURN 0
0F028:  MOVFF  CA4,CAB
0F02C:  MOVLB  C
0F02E:  MOVF   xA8,W
0F030:  XORWF  xAB,F
0F032:  BTFSS  xAB.7
0F034:  BRA    F040
0F036:  BCF    FD8.2
0F038:  BCF    FD8.0
0F03A:  BTFSC  xA4.7
0F03C:  BSF    FD8.0
0F03E:  BRA    F09E
0F040:  MOVFF  CA4,CAB
0F044:  MOVFF  CA7,CAC
0F048:  MOVF   xA3,W
0F04A:  SUBWF  xAC,F
0F04C:  BZ    F05A
0F04E:  BTFSS  xAB.7
0F050:  BRA    F09E
0F052:  MOVF   FD8,W
0F054:  XORLW  01
0F056:  MOVWF  FD8
0F058:  BRA    F09E
0F05A:  MOVFF  CA8,CAC
0F05E:  MOVF   xA4,W
0F060:  SUBWF  xAC,F
0F062:  BZ    F070
0F064:  BTFSS  xAB.7
0F066:  BRA    F09E
0F068:  MOVF   FD8,W
0F06A:  XORLW  01
0F06C:  MOVWF  FD8
0F06E:  BRA    F09E
0F070:  MOVFF  CA9,CAC
0F074:  MOVF   xA5,W
0F076:  SUBWF  xAC,F
0F078:  BZ    F086
0F07A:  BTFSS  xAB.7
0F07C:  BRA    F09E
0F07E:  MOVF   FD8,W
0F080:  XORLW  01
0F082:  MOVWF  FD8
0F084:  BRA    F09E
0F086:  MOVFF  CAA,CAC
0F08A:  MOVF   xA6,W
0F08C:  SUBWF  xAC,F
0F08E:  BZ    F09C
0F090:  BTFSS  xAB.7
0F092:  BRA    F09E
0F094:  MOVF   FD8,W
0F096:  XORLW  01
0F098:  MOVWF  FD8
0F09A:  BRA    F09E
0F09C:  BCF    FD8.0
0F09E:  MOVLB  0
0F0A0:  RETURN 0
0F0A2:  MOVLB  C
0F0A4:  MOVF   x9C,W
0F0A6:  BTFSC  FD8.2
0F0A8:  BRA    F1F4
0F0AA:  MOVWF  xA8
0F0AC:  MOVF   xA0,W
0F0AE:  BTFSC  FD8.2
0F0B0:  BRA    F1F4
0F0B2:  SUBWF  xA8,F
0F0B4:  BNC   F0C0
0F0B6:  MOVLW  7F
0F0B8:  ADDWF  xA8,F
0F0BA:  BTFSC  FD8.0
0F0BC:  BRA    F1F4
0F0BE:  BRA    F0CC
0F0C0:  MOVLW  81
0F0C2:  SUBWF  xA8,F
0F0C4:  BTFSS  FD8.0
0F0C6:  BRA    F1F4
0F0C8:  BTFSC  FD8.2
0F0CA:  BRA    F1F4
0F0CC:  MOVFF  CA8,00
0F0D0:  CLRF   01
0F0D2:  CLRF   02
0F0D4:  CLRF   03
0F0D6:  CLRF   xA7
0F0D8:  MOVFF  C9D,CA6
0F0DC:  BSF    xA6.7
0F0DE:  MOVFF  C9E,CA5
0F0E2:  MOVFF  C9F,CA4
0F0E6:  MOVLW  19
0F0E8:  MOVWF  xA8
0F0EA:  MOVF   xA3,W
0F0EC:  SUBWF  xA4,F
0F0EE:  BC    F10A
0F0F0:  MOVLW  01
0F0F2:  SUBWF  xA5,F
0F0F4:  BC    F10A
0F0F6:  SUBWF  xA6,F
0F0F8:  BC    F10A
0F0FA:  SUBWF  xA7,F
0F0FC:  BC    F10A
0F0FE:  INCF   xA7,F
0F100:  INCF   xA6,F
0F102:  INCF   xA5,F
0F104:  MOVF   xA3,W
0F106:  ADDWF  xA4,F
0F108:  BRA    F15A
0F10A:  MOVF   xA2,W
0F10C:  SUBWF  xA5,F
0F10E:  BC    F134
0F110:  MOVLW  01
0F112:  SUBWF  xA6,F
0F114:  BC    F134
0F116:  SUBWF  xA7,F
0F118:  BC    F134
0F11A:  INCF   xA7,F
0F11C:  INCF   xA6,F
0F11E:  MOVF   xA2,W
0F120:  ADDWF  xA5,F
0F122:  MOVF   xA3,W
0F124:  ADDWF  xA4,F
0F126:  BNC   F15A
0F128:  INCF   xA5,F
0F12A:  BNZ   F15A
0F12C:  INCF   xA6,F
0F12E:  BNZ   F15A
0F130:  INCF   xA7,F
0F132:  BRA    F15A
0F134:  MOVF   xA1,W
0F136:  IORLW  80
0F138:  SUBWF  xA6,F
0F13A:  BC    F158
0F13C:  MOVLW  01
0F13E:  SUBWF  xA7,F
0F140:  BC    F158
0F142:  INCF   xA7,F
0F144:  MOVF   xA1,W
0F146:  IORLW  80
0F148:  ADDWF  xA6,F
0F14A:  MOVF   xA2,W
0F14C:  ADDWF  xA5,F
0F14E:  BNC   F122
0F150:  INCF   xA6,F
0F152:  BNZ   F122
0F154:  INCF   xA7,F
0F156:  BRA    F122
0F158:  BSF    03.0
0F15A:  DECFSZ xA8,F
0F15C:  BRA    F160
0F15E:  BRA    F176
0F160:  BCF    FD8.0
0F162:  RLCF   xA4,F
0F164:  RLCF   xA5,F
0F166:  RLCF   xA6,F
0F168:  RLCF   xA7,F
0F16A:  BCF    FD8.0
0F16C:  RLCF   03,F
0F16E:  RLCF   02,F
0F170:  RLCF   01,F
0F172:  RLCF   xA9,F
0F174:  BRA    F0EA
0F176:  BTFSS  xA9.0
0F178:  BRA    F186
0F17A:  BCF    FD8.0
0F17C:  RRCF   01,F
0F17E:  RRCF   02,F
0F180:  RRCF   03,F
0F182:  RRCF   xA9,F
0F184:  BRA    F18A
0F186:  DECF   00,F
0F188:  BZ    F1F4
0F18A:  BTFSC  xA9.7
0F18C:  BRA    F1CA
0F18E:  BCF    FD8.0
0F190:  RLCF   xA4,F
0F192:  RLCF   xA5,F
0F194:  RLCF   xA6,F
0F196:  RLCF   xA7,F
0F198:  MOVF   xA3,W
0F19A:  SUBWF  xA4,F
0F19C:  BC    F1AC
0F19E:  MOVLW  01
0F1A0:  SUBWF  xA5,F
0F1A2:  BC    F1AC
0F1A4:  SUBWF  xA6,F
0F1A6:  BC    F1AC
0F1A8:  SUBWF  xA7,F
0F1AA:  BNC   F1E0
0F1AC:  MOVF   xA2,W
0F1AE:  SUBWF  xA5,F
0F1B0:  BC    F1BC
0F1B2:  MOVLW  01
0F1B4:  SUBWF  xA6,F
0F1B6:  BC    F1BC
0F1B8:  SUBWF  xA7,F
0F1BA:  BNC   F1E0
0F1BC:  MOVF   xA1,W
0F1BE:  IORLW  80
0F1C0:  SUBWF  xA6,F
0F1C2:  BC    F1CA
0F1C4:  MOVLW  01
0F1C6:  SUBWF  xA7,F
0F1C8:  BNC   F1E0
0F1CA:  INCF   03,F
0F1CC:  BNZ   F1E0
0F1CE:  INCF   02,F
0F1D0:  BNZ   F1E0
0F1D2:  INCF   01,F
0F1D4:  BNZ   F1E0
0F1D6:  INCF   00,F
0F1D8:  BZ    F1F4
0F1DA:  RRCF   01,F
0F1DC:  RRCF   02,F
0F1DE:  RRCF   03,F
0F1E0:  MOVFF  C9D,CA8
0F1E4:  MOVF   xA1,W
0F1E6:  XORWF  xA8,F
0F1E8:  BTFSS  xA8.7
0F1EA:  BRA    F1F0
0F1EC:  BSF    01.7
0F1EE:  BRA    F1FC
0F1F0:  BCF    01.7
0F1F2:  BRA    F1FC
0F1F4:  CLRF   00
0F1F6:  CLRF   01
0F1F8:  CLRF   02
0F1FA:  CLRF   03
0F1FC:  MOVLB  0
0F1FE:  RETURN 0
0F200:  MOVLW  8E
0F202:  MOVWF  00
0F204:  MOVLB  C
0F206:  MOVF   xA3,W
0F208:  SUBWF  00,F
0F20A:  MOVFF  CA4,02
0F20E:  MOVFF  CA5,01
0F212:  BSF    02.7
0F214:  MOVF   00,F
0F216:  BZ    F22A
0F218:  BCF    FD8.0
0F21A:  MOVF   02,F
0F21C:  BNZ   F222
0F21E:  MOVF   01,F
0F220:  BZ    F22A
0F222:  RRCF   02,F
0F224:  RRCF   01,F
0F226:  DECFSZ 00,F
0F228:  BRA    F218
0F22A:  BTFSS  xA4.7
0F22C:  BRA    F238
0F22E:  COMF   01,F
0F230:  COMF   02,F
0F232:  INCF   01,F
0F234:  BTFSC  FD8.2
0F236:  INCF   02,F
0F238:  MOVLB  0
0F23A:  RETURN 0
0F23C:  MOVLB  C
0F23E:  MOVF   xA3,W
0F240:  BTFSC  FD8.2
0F242:  BRA    F326
0F244:  MOVWF  00
0F246:  MOVF   xA7,W
0F248:  BTFSC  FD8.2
0F24A:  BRA    F326
0F24C:  ADDWF  00,F
0F24E:  BNC   F258
0F250:  MOVLW  81
0F252:  ADDWF  00,F
0F254:  BC    F326
0F256:  BRA    F260
0F258:  MOVLW  7F
0F25A:  SUBWF  00,F
0F25C:  BNC   F326
0F25E:  BZ    F326
0F260:  MOVFF  CA4,CAB
0F264:  MOVF   xA8,W
0F266:  XORWF  xAB,F
0F268:  BSF    xA4.7
0F26A:  BSF    xA8.7
0F26C:  MOVF   xA6,W
0F26E:  MULWF  xAA
0F270:  MOVFF  FF4,CAD
0F274:  MOVF   xA5,W
0F276:  MULWF  xA9
0F278:  MOVFF  FF4,03
0F27C:  MOVFF  FF3,CAC
0F280:  MULWF  xAA
0F282:  MOVF   FF3,W
0F284:  ADDWF  xAD,F
0F286:  MOVF   FF4,W
0F288:  ADDWFC xAC,F
0F28A:  MOVLW  00
0F28C:  ADDWFC 03,F
0F28E:  MOVF   xA6,W
0F290:  MULWF  xA9
0F292:  MOVF   FF3,W
0F294:  ADDWF  xAD,F
0F296:  MOVF   FF4,W
0F298:  ADDWFC xAC,F
0F29A:  MOVLW  00
0F29C:  CLRF   02
0F29E:  ADDWFC 03,F
0F2A0:  ADDWFC 02,F
0F2A2:  MOVF   xA4,W
0F2A4:  MULWF  xAA
0F2A6:  MOVF   FF3,W
0F2A8:  ADDWF  xAC,F
0F2AA:  MOVF   FF4,W
0F2AC:  ADDWFC 03,F
0F2AE:  MOVLW  00
0F2B0:  ADDWFC 02,F
0F2B2:  MOVF   xA4,W
0F2B4:  MULWF  xA9
0F2B6:  MOVF   FF3,W
0F2B8:  ADDWF  03,F
0F2BA:  MOVF   FF4,W
0F2BC:  ADDWFC 02,F
0F2BE:  MOVLW  00
0F2C0:  CLRF   01
0F2C2:  ADDWFC 01,F
0F2C4:  MOVF   xA6,W
0F2C6:  MULWF  xA8
0F2C8:  MOVF   FF3,W
0F2CA:  ADDWF  xAC,F
0F2CC:  MOVF   FF4,W
0F2CE:  ADDWFC 03,F
0F2D0:  MOVLW  00
0F2D2:  ADDWFC 02,F
0F2D4:  ADDWFC 01,F
0F2D6:  MOVF   xA5,W
0F2D8:  MULWF  xA8
0F2DA:  MOVF   FF3,W
0F2DC:  ADDWF  03,F
0F2DE:  MOVF   FF4,W
0F2E0:  ADDWFC 02,F
0F2E2:  MOVLW  00
0F2E4:  ADDWFC 01,F
0F2E6:  MOVF   xA4,W
0F2E8:  MULWF  xA8
0F2EA:  MOVF   FF3,W
0F2EC:  ADDWF  02,F
0F2EE:  MOVF   FF4,W
0F2F0:  ADDWFC 01,F
0F2F2:  INCF   00,F
0F2F4:  BTFSC  01.7
0F2F6:  BRA    F302
0F2F8:  RLCF   xAC,F
0F2FA:  RLCF   03,F
0F2FC:  RLCF   02,F
0F2FE:  RLCF   01,F
0F300:  DECF   00,F
0F302:  MOVLW  00
0F304:  BTFSS  xAC.7
0F306:  BRA    F31C
0F308:  INCF   03,F
0F30A:  ADDWFC 02,F
0F30C:  ADDWFC 01,F
0F30E:  MOVF   01,W
0F310:  BNZ   F31C
0F312:  MOVF   02,W
0F314:  BNZ   F31C
0F316:  MOVF   03,W
0F318:  BNZ   F31C
0F31A:  INCF   00,F
0F31C:  BTFSC  xAB.7
0F31E:  BSF    01.7
0F320:  BTFSS  xAB.7
0F322:  BCF    01.7
0F324:  BRA    F32E
0F326:  CLRF   00
0F328:  CLRF   01
0F32A:  CLRF   02
0F32C:  CLRF   03
0F32E:  MOVLB  0
0F330:  RETURN 0
0F332:  MOVLW  80
0F334:  BTFSS  FD8.1
0F336:  BRA    F33C
0F338:  MOVLB  C
0F33A:  XORWF  xAC,F
0F33C:  MOVLB  C
0F33E:  CLRF   xB1
0F340:  CLRF   xB2
0F342:  MOVFF  CA8,CB0
0F346:  MOVF   xAC,W
0F348:  XORWF  xB0,F
0F34A:  MOVF   xA7,W
0F34C:  BTFSC  FD8.2
0F34E:  BRA    F50E
0F350:  MOVWF  xAF
0F352:  MOVWF  00
0F354:  MOVF   xAB,W
0F356:  BTFSC  FD8.2
0F358:  BRA    F520
0F35A:  SUBWF  xAF,F
0F35C:  BTFSC  FD8.2
0F35E:  BRA    F466
0F360:  BNC   F3DE
0F362:  MOVFF  CAC,CB5
0F366:  BSF    xB5.7
0F368:  MOVFF  CAD,CB4
0F36C:  MOVFF  CAE,CB3
0F370:  CLRF   xB2
0F372:  BCF    FD8.0
0F374:  RRCF   xB5,F
0F376:  RRCF   xB4,F
0F378:  RRCF   xB3,F
0F37A:  RRCF   xB2,F
0F37C:  DECFSZ xAF,F
0F37E:  BRA    F370
0F380:  BTFSS  xB0.7
0F382:  BRA    F38A
0F384:  BSF    xB1.0
0F386:  BRA    F548
0F388:  BCF    xB1.0
0F38A:  BCF    xAF.0
0F38C:  BSF    xB1.4
0F38E:  MOVLW  0C
0F390:  MOVWF  FEA
0F392:  MOVLW  AA
0F394:  MOVWF  FE9
0F396:  BRA    F56E
0F398:  BCF    xB1.4
0F39A:  BTFSC  xB0.7
0F39C:  BRA    F3B2
0F39E:  BTFSS  xAF.0
0F3A0:  BRA    F3C8
0F3A2:  RRCF   xB5,F
0F3A4:  RRCF   xB4,F
0F3A6:  RRCF   xB3,F
0F3A8:  RRCF   xB2,F
0F3AA:  INCF   00,F
0F3AC:  BTFSC  FD8.2
0F3AE:  BRA    F53E
0F3B0:  BRA    F3C8
0F3B2:  BTFSC  xB5.7
0F3B4:  BRA    F3CE
0F3B6:  BCF    FD8.0
0F3B8:  RLCF   xB2,F
0F3BA:  RLCF   xB3,F
0F3BC:  RLCF   xB4,F
0F3BE:  RLCF   xB5,F
0F3C0:  DECF   00,F
0F3C2:  BTFSC  FD8.2
0F3C4:  BRA    F53E
0F3C6:  BRA    F3B2
0F3C8:  BSF    xB1.6
0F3CA:  BRA    F4A6
0F3CC:  BCF    xB1.6
0F3CE:  MOVFF  CA8,CB0
0F3D2:  BTFSS  xA8.7
0F3D4:  BRA    F3DA
0F3D6:  BSF    xB5.7
0F3D8:  BRA    F530
0F3DA:  BCF    xB5.7
0F3DC:  BRA    F530
0F3DE:  MOVFF  CAB,CAF
0F3E2:  MOVFF  CAB,00
0F3E6:  MOVF   xA7,W
0F3E8:  SUBWF  xAF,F
0F3EA:  MOVFF  CA8,CB5
0F3EE:  BSF    xB5.7
0F3F0:  MOVFF  CA9,CB4
0F3F4:  MOVFF  CAA,CB3
0F3F8:  CLRF   xB2
0F3FA:  BCF    FD8.0
0F3FC:  RRCF   xB5,F
0F3FE:  RRCF   xB4,F
0F400:  RRCF   xB3,F
0F402:  RRCF   xB2,F
0F404:  DECFSZ xAF,F
0F406:  BRA    F3F8
0F408:  BTFSS  xB0.7
0F40A:  BRA    F412
0F40C:  BSF    xB1.1
0F40E:  BRA    F548
0F410:  BCF    xB1.1
0F412:  BCF    xAF.0
0F414:  BSF    xB1.5
0F416:  MOVLW  0C
0F418:  MOVWF  FEA
0F41A:  MOVLW  AE
0F41C:  MOVWF  FE9
0F41E:  BRA    F56E
0F420:  BCF    xB1.5
0F422:  BTFSC  xB0.7
0F424:  BRA    F43A
0F426:  BTFSS  xAF.0
0F428:  BRA    F450
0F42A:  RRCF   xB5,F
0F42C:  RRCF   xB4,F
0F42E:  RRCF   xB3,F
0F430:  RRCF   xB2,F
0F432:  INCF   00,F
0F434:  BTFSC  FD8.2
0F436:  BRA    F53E
0F438:  BRA    F450
0F43A:  BTFSC  xB5.7
0F43C:  BRA    F456
0F43E:  BCF    FD8.0
0F440:  RLCF   xB2,F
0F442:  RLCF   xB3,F
0F444:  RLCF   xB4,F
0F446:  RLCF   xB5,F
0F448:  DECF   00,F
0F44A:  BTFSC  FD8.2
0F44C:  BRA    F53E
0F44E:  BRA    F43A
0F450:  BSF    xB1.7
0F452:  BRA    F4A6
0F454:  BCF    xB1.7
0F456:  MOVFF  CAC,CB0
0F45A:  BTFSS  xAC.7
0F45C:  BRA    F462
0F45E:  BSF    xB5.7
0F460:  BRA    F530
0F462:  BCF    xB5.7
0F464:  BRA    F530
0F466:  MOVFF  CAC,CB5
0F46A:  BSF    xB5.7
0F46C:  MOVFF  CAD,CB4
0F470:  MOVFF  CAE,CB3
0F474:  BTFSS  xB0.7
0F476:  BRA    F480
0F478:  BCF    xB5.7
0F47A:  BSF    xB1.2
0F47C:  BRA    F548
0F47E:  BCF    xB1.2
0F480:  CLRF   xB2
0F482:  BCF    xAF.0
0F484:  MOVLW  0C
0F486:  MOVWF  FEA
0F488:  MOVLW  AA
0F48A:  MOVWF  FE9
0F48C:  BRA    F56E
0F48E:  BTFSC  xB0.7
0F490:  BRA    F4CA
0F492:  MOVFF  CA8,CB0
0F496:  BTFSS  xAF.0
0F498:  BRA    F4A6
0F49A:  RRCF   xB5,F
0F49C:  RRCF   xB4,F
0F49E:  RRCF   xB3,F
0F4A0:  RRCF   xB2,F
0F4A2:  INCF   00,F
0F4A4:  BZ    F53E
0F4A6:  BTFSS  xB2.7
0F4A8:  BRA    F4C0
0F4AA:  INCF   xB3,F
0F4AC:  BNZ   F4C0
0F4AE:  INCF   xB4,F
0F4B0:  BNZ   F4C0
0F4B2:  INCF   xB5,F
0F4B4:  BNZ   F4C0
0F4B6:  RRCF   xB5,F
0F4B8:  RRCF   xB4,F
0F4BA:  RRCF   xB3,F
0F4BC:  INCF   00,F
0F4BE:  BZ    F53E
0F4C0:  BTFSC  xB1.6
0F4C2:  BRA    F3CC
0F4C4:  BTFSC  xB1.7
0F4C6:  BRA    F454
0F4C8:  BRA    F502
0F4CA:  MOVLW  80
0F4CC:  XORWF  xB5,F
0F4CE:  BTFSS  xB5.7
0F4D0:  BRA    F4DA
0F4D2:  BRA    F548
0F4D4:  MOVFF  CAC,CB0
0F4D8:  BRA    F4EE
0F4DA:  MOVFF  CA8,CB0
0F4DE:  MOVF   xB5,F
0F4E0:  BNZ   F4EE
0F4E2:  MOVF   xB4,F
0F4E4:  BNZ   F4EE
0F4E6:  MOVF   xB3,F
0F4E8:  BNZ   F4EE
0F4EA:  CLRF   00
0F4EC:  BRA    F530
0F4EE:  BTFSC  xB5.7
0F4F0:  BRA    F502
0F4F2:  BCF    FD8.0
0F4F4:  RLCF   xB2,F
0F4F6:  RLCF   xB3,F
0F4F8:  RLCF   xB4,F
0F4FA:  RLCF   xB5,F
0F4FC:  DECFSZ 00,F
0F4FE:  BRA    F4EE
0F500:  BRA    F53E
0F502:  BTFSS  xB0.7
0F504:  BRA    F50A
0F506:  BSF    xB5.7
0F508:  BRA    F530
0F50A:  BCF    xB5.7
0F50C:  BRA    F530
0F50E:  MOVFF  CAB,00
0F512:  MOVFF  CAC,CB5
0F516:  MOVFF  CAD,CB4
0F51A:  MOVFF  CAE,CB3
0F51E:  BRA    F530
0F520:  MOVFF  CA7,00
0F524:  MOVFF  CA8,CB5
0F528:  MOVFF  CA9,CB4
0F52C:  MOVFF  CAA,CB3
0F530:  MOVFF  CB5,01
0F534:  MOVFF  CB4,02
0F538:  MOVFF  CB3,03
0F53C:  BRA    F5A6
0F53E:  CLRF   00
0F540:  CLRF   01
0F542:  CLRF   02
0F544:  CLRF   03
0F546:  BRA    F5A6
0F548:  CLRF   xB2
0F54A:  COMF   xB3,F
0F54C:  COMF   xB4,F
0F54E:  COMF   xB5,F
0F550:  COMF   xB2,F
0F552:  INCF   xB2,F
0F554:  BNZ   F560
0F556:  INCF   xB3,F
0F558:  BNZ   F560
0F55A:  INCF   xB4,F
0F55C:  BNZ   F560
0F55E:  INCF   xB5,F
0F560:  BTFSC  xB1.0
0F562:  BRA    F388
0F564:  BTFSC  xB1.1
0F566:  BRA    F410
0F568:  BTFSC  xB1.2
0F56A:  BRA    F47E
0F56C:  BRA    F4D4
0F56E:  MOVF   FEF,W
0F570:  ADDWF  xB3,F
0F572:  BNC   F57E
0F574:  INCF   xB4,F
0F576:  BNZ   F57E
0F578:  INCF   xB5,F
0F57A:  BTFSC  FD8.2
0F57C:  BSF    xAF.0
0F57E:  MOVF   FED,F
0F580:  MOVF   FEF,W
0F582:  ADDWF  xB4,F
0F584:  BNC   F58C
0F586:  INCF   xB5,F
0F588:  BTFSC  FD8.2
0F58A:  BSF    xAF.0
0F58C:  MOVF   FED,F
0F58E:  MOVF   FEF,W
0F590:  BTFSC  FEF.7
0F592:  BRA    F596
0F594:  XORLW  80
0F596:  ADDWF  xB5,F
0F598:  BTFSC  FD8.0
0F59A:  BSF    xAF.0
0F59C:  BTFSC  xB1.4
0F59E:  BRA    F398
0F5A0:  BTFSC  xB1.5
0F5A2:  BRA    F420
0F5A4:  BRA    F48E
0F5A6:  MOVLB  0
0F5A8:  RETURN 0
*
0FA96:  MOVLW  8E
0FA98:  MOVWF  00
0FA9A:  MOVFF  C9A,01
0FA9E:  MOVFF  C99,02
0FAA2:  CLRF   03
0FAA4:  BTFSS  01.7
0FAA6:  BRA    FAB2
0FAA8:  COMF   01,F
0FAAA:  COMF   02,F
0FAAC:  INCF   02,F
0FAAE:  BNZ   FAB2
0FAB0:  INCF   01,F
0FAB2:  MOVF   01,F
0FAB4:  BNZ   FAC8
0FAB6:  MOVFF  02,01
0FABA:  CLRF   02
0FABC:  MOVLW  08
0FABE:  SUBWF  00,F
0FAC0:  MOVF   01,F
0FAC2:  BNZ   FAC8
0FAC4:  CLRF   00
0FAC6:  BRA    FAE4
0FAC8:  BCF    FD8.0
0FACA:  BTFSC  01.7
0FACC:  BRA    FAD6
0FACE:  RLCF   02,F
0FAD0:  RLCF   01,F
0FAD2:  DECF   00,F
0FAD4:  BRA    FAC8
0FAD6:  MOVLB  C
0FAD8:  BTFSS  x9A.7
0FADA:  BRA    FAE0
0FADC:  MOVLB  0
0FADE:  BRA    FAE4
0FAE0:  BCF    01.7
0FAE2:  MOVLB  0
0FAE4:  RETURN 0
*
0FE76:  MOVLB  C
0FE78:  MOVF   x75,W
0FE7A:  SUBLW  B6
0FE7C:  MOVWF  x75
0FE7E:  CLRF   03
0FE80:  MOVFF  C76,C79
0FE84:  BSF    x76.7
0FE86:  BCF    FD8.0
0FE88:  RRCF   x76,F
0FE8A:  RRCF   x77,F
0FE8C:  RRCF   x78,F
0FE8E:  RRCF   03,F
0FE90:  RRCF   02,F
0FE92:  RRCF   01,F
0FE94:  RRCF   00,F
0FE96:  DECFSZ x75,F
0FE98:  BRA    FE86
0FE9A:  BTFSS  x79.7
0FE9C:  BRA    FEB4
0FE9E:  COMF   00,F
0FEA0:  COMF   01,F
0FEA2:  COMF   02,F
0FEA4:  COMF   03,F
0FEA6:  INCF   00,F
0FEA8:  BTFSC  FD8.2
0FEAA:  INCF   01,F
0FEAC:  BTFSC  FD8.2
0FEAE:  INCF   02,F
0FEB0:  BTFSC  FD8.2
0FEB2:  INCF   03,F
0FEB4:  MOVLB  0
0FEB6:  RETURN 0
0FEB8:  MOVF   FE9,W
0FEBA:  MOVLB  C
0FEBC:  MOVWF  x71
0FEBE:  MOVLW  3B
0FEC0:  MOVWF  x78
0FEC2:  MOVLW  9A
0FEC4:  MOVWF  x77
0FEC6:  MOVLW  CA
0FEC8:  MOVWF  x76
0FECA:  CLRF   x75
0FECC:  MOVLW  0A
0FECE:  MOVWF  x73
0FED0:  BSF    FD8.1
0FED2:  MOVLW  0C
0FED4:  MOVWF  FEA
0FED6:  MOVLW  6D
0FED8:  MOVWF  FE9
0FEDA:  MOVFF  C70,CB3
0FEDE:  MOVFF  C6F,CB2
0FEE2:  MOVFF  C6E,CB1
0FEE6:  MOVFF  C6D,CB0
0FEEA:  MOVFF  C78,CB7
0FEEE:  MOVFF  C77,CB6
0FEF2:  MOVFF  C76,CB5
0FEF6:  MOVFF  C75,CB4
0FEFA:  MOVLB  0
0FEFC:  CALL   5852
0FF00:  MOVF   01,W
0FF02:  MOVF   00,F
0FF04:  BNZ   FF2C
0FF06:  MOVLB  C
0FF08:  MOVF   x73,W
0FF0A:  XORLW  01
0FF0C:  BTFSS  FD8.2
0FF0E:  BRA    FF14
0FF10:  MOVLB  0
0FF12:  BRA    FF2C
0FF14:  MOVF   x71,W
0FF16:  BZ    FF30
0FF18:  ANDLW  0F
0FF1A:  SUBWF  x73,W
0FF1C:  BZ    FF20
0FF1E:  BC    FF40
0FF20:  BTFSC  x71.7
0FF22:  BRA    FF40
0FF24:  BTFSC  x71.6
0FF26:  BRA    FF30
0FF28:  MOVLW  20
0FF2A:  BRA    FF32
0FF2C:  MOVLB  C
0FF2E:  CLRF   x71
0FF30:  MOVLW  30
0FF32:  ADDWF  00,F
0FF34:  MOVFF  00,D6A
0FF38:  MOVLB  0
0FF3A:  CALL   44EE
0FF3E:  MOVLB  C
0FF40:  BCF    FD8.1
0FF42:  MOVFF  C78,CB3
0FF46:  MOVFF  C77,CB2
0FF4A:  MOVFF  C76,CB1
0FF4E:  MOVFF  C75,CB0
0FF52:  CLRF   xB7
0FF54:  CLRF   xB6
0FF56:  CLRF   xB5
0FF58:  MOVLW  0A
0FF5A:  MOVWF  xB4
0FF5C:  MOVLB  0
0FF5E:  CALL   5852
0FF62:  MOVFF  03,C78
0FF66:  MOVFF  02,C77
0FF6A:  MOVFF  01,C76
0FF6E:  MOVFF  00,C75
0FF72:  MOVLB  C
0FF74:  DECFSZ x73,F
0FF76:  BRA    FED0
0FF78:  MOVLB  0
0FF7A:  RETURN 0
*
14C3A:  ADDWF  FE8,W
14C3C:  CLRF   FF7
14C3E:  RLCF   FF7,F
14C40:  ADDLW  5B
14C42:  MOVWF  FF6
14C44:  MOVLW  4C
14C46:  ADDWFC FF7,F
14C48:  MOVLW  01
14C4A:  MOVWF  FF8
14C4C:  MOVWF  FFB
14C4E:  TBLRD*-
14C50:  MOVF   FF5,W
14C52:  MOVWF  FFA
14C54:  TBLRD*
14C56:  MOVF   FF5,W
14C58:  MOVWF  FF9
14C5A:  DATA 06,49
14C5C:  DATA 1A,49
14C5E:  DATA 2E,49
14C60:  DATA 42,49
14C62:  DATA 56,49
14C64:  DATA 6A,49
14C66:  DATA 7E,49
14C68:  DATA 92,49
*
174D0:  MOVF   FE9,W
174D2:  MOVLB  C
174D4:  MOVWF  x5C
174D6:  MOVF   x5B,W
174D8:  MOVWF  x5E
174DA:  BZ    17514
174DC:  MOVFF  C5A,CA6
174E0:  MOVFF  C59,CA5
174E4:  MOVFF  C58,CA4
174E8:  MOVFF  C57,CA3
174EC:  CLRF   xAA
174EE:  CLRF   xA9
174F0:  MOVLW  20
174F2:  MOVWF  xA8
174F4:  MOVLW  82
174F6:  MOVWF  xA7
174F8:  MOVLB  0
174FA:  CALL   F23C
174FE:  MOVFF  03,C5A
17502:  MOVFF  02,C59
17506:  MOVFF  01,C58
1750A:  MOVFF  00,C57
1750E:  MOVLB  C
17510:  DECFSZ x5E,F
17512:  BRA    174DC
17514:  MOVFF  C5A,C78
17518:  MOVFF  C59,C77
1751C:  MOVFF  C58,C76
17520:  MOVFF  C57,C75
17524:  MOVLB  0
17526:  CALL   FE76
1752A:  MOVFF  03,C5A
1752E:  MOVFF  02,C59
17532:  MOVFF  01,C58
17536:  MOVFF  00,C57
1753A:  MOVLB  C
1753C:  BTFSS  x5A.7
1753E:  BRA    1755A
17540:  DECF   x5C,F
17542:  BSF    x5C.5
17544:  COMF   x57,F
17546:  COMF   x58,F
17548:  COMF   x59,F
1754A:  COMF   x5A,F
1754C:  INCF   x57,F
1754E:  BTFSC  FD8.2
17550:  INCF   x58,F
17552:  BTFSC  FD8.2
17554:  INCF   x59,F
17556:  BTFSC  FD8.2
17558:  INCF   x5A,F
1755A:  MOVLW  3B
1755C:  MOVWF  x63
1755E:  MOVLW  9A
17560:  MOVWF  x62
17562:  MOVLW  CA
17564:  MOVWF  x61
17566:  CLRF   x60
17568:  MOVLW  0A
1756A:  MOVWF  x5E
1756C:  MOVF   x5B,W
1756E:  BTFSC  FD8.2
17570:  INCF   x5C,F
17572:  BSF    FD8.1
17574:  MOVLW  0C
17576:  MOVWF  FEA
17578:  MOVLW  57
1757A:  MOVWF  FE9
1757C:  MOVFF  C5A,CB3
17580:  MOVFF  C59,CB2
17584:  MOVFF  C58,CB1
17588:  MOVFF  C57,CB0
1758C:  MOVFF  C63,CB7
17590:  MOVFF  C62,CB6
17594:  MOVFF  C61,CB5
17598:  MOVFF  C60,CB4
1759C:  MOVLB  0
1759E:  CALL   5852
175A2:  MOVF   01,W
175A4:  MOVF   00,F
175A6:  BNZ   175CE
175A8:  MOVLB  C
175AA:  INCF   x5B,W
175AC:  SUBWF  x5E,W
175AE:  BTFSS  FD8.2
175B0:  BRA    175B6
175B2:  MOVLB  0
175B4:  BRA    175CE
175B6:  MOVF   x5C,W
175B8:  BZ    175D4
175BA:  ANDLW  0F
175BC:  SUBWF  x5E,W
175BE:  BZ    175C2
175C0:  BC    17650
175C2:  BTFSC  x5C.7
175C4:  BRA    17650
175C6:  BTFSC  x5C.6
175C8:  BRA    175D4
175CA:  MOVLW  20
175CC:  BRA    17642
175CE:  MOVLW  20
175D0:  MOVLB  C
175D2:  ANDWF  x5C,F
175D4:  BTFSS  x5C.5
175D6:  BRA    175F8
175D8:  BCF    x5C.5
175DA:  MOVF   x5B,W
175DC:  BTFSS  FD8.2
175DE:  DECF   x5C,F
175E0:  MOVF   00,W
175E2:  MOVWF  x5C
175E4:  MOVLW  2D
175E6:  MOVLB  D
175E8:  MOVWF  x6A
175EA:  MOVLB  0
175EC:  CALL   44EE
175F0:  MOVLB  C
175F2:  MOVF   x5C,W
175F4:  MOVWF  00
175F6:  CLRF   x5C
175F8:  MOVF   x5B,W
175FA:  SUBWF  x5E,W
175FC:  BNZ   1761A
175FE:  MOVF   00,W
17600:  MOVWF  x5C
17602:  MOVLW  2E
17604:  MOVLB  D
17606:  MOVWF  x6A
17608:  MOVLB  0
1760A:  CALL   44EE
1760E:  MOVLB  C
17610:  MOVF   x5C,W
17612:  MOVWF  00
17614:  MOVLW  20
17616:  ANDWF  x5C,F
17618:  MOVLW  00
1761A:  MOVLW  30
1761C:  BTFSS  x5C.5
1761E:  BRA    17642
17620:  BCF    x5C.5
17622:  MOVF   x5B,W
17624:  BTFSS  FD8.2
17626:  DECF   x5C,F
17628:  MOVF   00,W
1762A:  MOVWF  x5C
1762C:  MOVLW  2D
1762E:  MOVLB  D
17630:  MOVWF  x6A
17632:  MOVLB  0
17634:  CALL   44EE
17638:  MOVLB  C
1763A:  MOVF   x5C,W
1763C:  MOVWF  00
1763E:  CLRF   x5C
17640:  MOVLW  30
17642:  ADDWF  00,F
17644:  MOVFF  00,D6A
17648:  MOVLB  0
1764A:  CALL   44EE
1764E:  MOVLB  C
17650:  BCF    FD8.1
17652:  MOVFF  C63,CB3
17656:  MOVFF  C62,CB2
1765A:  MOVFF  C61,CB1
1765E:  MOVFF  C60,CB0
17662:  CLRF   xB7
17664:  CLRF   xB6
17666:  CLRF   xB5
17668:  MOVLW  0A
1766A:  MOVWF  xB4
1766C:  MOVLB  0
1766E:  CALL   5852
17672:  MOVFF  03,C63
17676:  MOVFF  02,C62
1767A:  MOVFF  01,C61
1767E:  MOVFF  00,C60
17682:  MOVLB  C
17684:  DECFSZ x5E,F
17686:  BRA    17572
17688:  MOVLB  0
1768A:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #FUSES NOWDT NOBROWNOUT SOSC_DIG 
.................... #use delay(crystal = 16Mhz, clock = 16Mhz) // For crystal 
*
05266:  MOVLW  0D
05268:  MOVWF  FEA
0526A:  MOVLW  52
0526C:  MOVWF  FE9
0526E:  MOVF   FEF,W
05270:  BZ    528E
05272:  MOVLW  05
05274:  MOVWF  01
05276:  CLRF   00
05278:  DECFSZ 00,F
0527A:  BRA    5278
0527C:  DECFSZ 01,F
0527E:  BRA    5276
05280:  MOVLW  2E
05282:  MOVWF  00
05284:  DECFSZ 00,F
05286:  BRA    5284
05288:  BRA    528A
0528A:  DECFSZ FEF,F
0528C:  BRA    5272
0528E:  RETURN 0
....................  
.................... #device HIGH_INTS = TRUE 
....................  
.................... #pin_select TX1 = PIN_G2 
.................... #pin_select RX1 = PIN_G3 
.................... #use rs232(baud = 115200, parity = N, UART1, bits = 8, stream = MSN, ERRORS) // UART to Mission 
*
0213C:  BTFSS  F9E.5
0213E:  BRA    213C
02140:  MOVFF  FAB,30
02144:  MOVFF  FAE,01
02148:  BTFSS  30.1
0214A:  BRA    2150
0214C:  BCF    FAB.4
0214E:  BSF    FAB.4
02150:  RETURN 0
*
05464:  BTFSS  F9E.4
05466:  BRA    5464
05468:  MOVWF  FAD
0546A:  RETURN 0
....................  
.................... #pin_select TX2 = PIN_D3 
.................... #pin_select RX2 = PIN_D2 
.................... #use rs232(baud = 9600, parity = N, UART2, bits = 8, stream = COMM, ERRORS) // COM PIC 
*
037B4:  BTFSS  FA4.5
037B6:  BRA    37B4
037B8:  MOVLB  F
037BA:  MOVFF  F33,30
037BE:  MOVFF  F1E,01
037C2:  BTFSS  30.1
037C4:  BRA    37CA
037C6:  BCF    x33.4
037C8:  BSF    x33.4
037CA:  MOVLB  0
037CC:  RETURN 0
*
05422:  BTFSS  FA4.4
05424:  BRA    5422
05426:  MOVLB  F
05428:  MOVWF  x1D
0542A:  MOVLB  0
0542C:  RETURN 0
....................  
.................... #pin_select TX3 = PIN_E5 
.................... #pin_select RX3 = PIN_E4 
.................... #use rs232(baud = 9600, parity = N, UART3, bits = 8, stream = FAB, ERRORS) // FAB PIC is EPS1 PIC 
*
03B92:  BTFSS  FA6.5
03B94:  BRA    3B92
03B96:  MOVLB  F
03B98:  MOVFF  F2F,30
03B9C:  MOVFF  F2A,01
03BA0:  BTFSS  30.1
03BA2:  BRA    3BA8
03BA4:  BCF    x2F.4
03BA6:  BSF    x2F.4
03BA8:  MOVLB  0
03BAA:  RETURN 0
*
05438:  BTFSS  FA6.4
0543A:  BRA    5438
0543C:  MOVLB  F
0543E:  MOVWF  x29
05440:  MOVLB  0
05442:  RETURN 0
....................  
.................... #pin_select TX4 = PIN_E3 
.................... #pin_select RX4 = PIN_F2 
.................... #use rs232(baud = 19200, parity = N, UART4, bits = 8, stream = RST, ERRORS) // RESET PIC 
*
03F62:  BTFSS  FA6.7
03F64:  BRA    3F62
03F66:  MOVLB  E
03F68:  MOVFF  EFF,30
03F6C:  MOVFF  EFA,01
03F70:  BTFSS  30.1
03F72:  BRA    3F78
03F74:  BCF    xFF.4
03F76:  BSF    xFF.4
03F78:  MOVLB  0
03F7A:  RETURN 0
*
0544E:  BTFSS  FA6.6
05450:  BRA    544E
05452:  MOVLB  E
05454:  MOVWF  xF9
05456:  MOVLB  0
05458:  RETURN 0
....................  
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PC, ERRORS)     // DEBUG 
*
044EE:  BCF    F94.6
044F0:  BCF    F8B.6
044F2:  MOVLW  08
044F4:  MOVWF  01
044F6:  BRA    44F8
044F8:  NOP   
044FA:  BSF    01.7
044FC:  BRA    451E
044FE:  BCF    01.7
04500:  MOVLB  D
04502:  RRCF   x6A,F
04504:  MOVLB  0
04506:  BTFSC  FD8.0
04508:  BSF    F8B.6
0450A:  BTFSS  FD8.0
0450C:  BCF    F8B.6
0450E:  BSF    01.6
04510:  BRA    451E
04512:  BCF    01.6
04514:  DECFSZ 01,F
04516:  BRA    4500
04518:  BRA    451A
0451A:  NOP   
0451C:  BSF    F8B.6
0451E:  MOVLW  84
04520:  MOVWF  FE9
04522:  DECFSZ FE9,F
04524:  BRA    4522
04526:  BRA    4528
04528:  NOP   
0452A:  BTFSC  01.7
0452C:  BRA    44FE
0452E:  BTFSC  01.6
04530:  BRA    4512
04532:  RETURN 0
*
05564:  BSF    F94.7
05566:  BTFSC  F82.7
05568:  BRA    5566
0556A:  MOVLW  08
0556C:  MOVWF  00
0556E:  MOVLB  D
05570:  CLRF   x68
05572:  BSF    00.7
05574:  BRA    5592
05576:  BCF    00.7
05578:  BRA    5592
0557A:  BCF    FD8.0
0557C:  BTFSC  F82.7
0557E:  BSF    FD8.0
05580:  RRCF   x68,F
05582:  BSF    00.6
05584:  BRA    5592
05586:  BCF    00.6
05588:  DECFSZ 00,F
0558A:  BRA    557A
0558C:  MOVFF  D68,01
05590:  BRA    55AA
05592:  MOVLW  84
05594:  BTFSC  00.7
05596:  MOVLW  24
05598:  MOVWF  01
0559A:  DECFSZ 01,F
0559C:  BRA    559A
0559E:  BRA    55A0
055A0:  BTFSC  00.7
055A2:  BRA    5576
055A4:  BTFSC  00.6
055A6:  BRA    5586
055A8:  BRA    557A
055AA:  MOVLB  0
055AC:  RETURN 0
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_G0, rcv = PIN_G1, bits = 8, stream = MCP_SW, ERRORS) // MAIN to Mission Control PIC 
....................  
.................... #use spi(MASTER, CLK = PIN_E1, DI = PIN_E0, DO = PIN_E6, BAUD = 1000000, BITS = 8, STREAM = MAIN_FM, MODE = 0)    // MAIN flash memory port 
*
054C2:  MOVLB  D
054C4:  MOVF   x6B,W
054C6:  SUBLW  08
054C8:  BZ    54D2
054CA:  MOVWF  x6C
054CC:  RLCF   x6A,F
054CE:  DECFSZ x6C,F
054D0:  BRA    54CC
054D2:  BSF    F96.0
054D4:  BCF    F96.6
054D6:  BCF    F96.1
054D8:  BCF    F8D.1
054DA:  MOVFF  D6B,D6C
054DE:  BTFSS  x6A.7
054E0:  BCF    F8D.6
054E2:  BTFSC  x6A.7
054E4:  BSF    F8D.6
054E6:  RLCF   x6A,F
054E8:  BSF    F8D.1
054EA:  RLCF   01,F
054EC:  BTFSS  F84.0
054EE:  BCF    01.0
054F0:  BTFSC  F84.0
054F2:  BSF    01.0
054F4:  BCF    F8D.1
054F6:  DECFSZ x6C,F
054F8:  BRA    54DE
054FA:  MOVLB  0
054FC:  RETURN 0
.................... #use spi(MASTER, CLK = PIN_B2, DI = PIN_B5, DO = PIN_B4, BAUD = 1000000, BITS = 8, STREAM = COM_FM, MODE = 0)     // COM flash memory port 
*
05476:  MOVLB  D
05478:  MOVF   x6B,W
0547A:  SUBLW  08
0547C:  BZ    5486
0547E:  MOVWF  x6C
05480:  RLCF   x6A,F
05482:  DECFSZ x6C,F
05484:  BRA    5480
05486:  BSF    F93.5
05488:  BCF    F93.4
0548A:  BCF    F93.2
0548C:  BCF    F8A.2
0548E:  MOVFF  D6B,D6C
05492:  BTFSS  x6A.7
05494:  BCF    F8A.4
05496:  BTFSC  x6A.7
05498:  BSF    F8A.4
0549A:  RLCF   x6A,F
0549C:  BSF    F8A.2
0549E:  RLCF   01,F
054A0:  BTFSS  F81.5
054A2:  BCF    01.0
054A4:  BTFSC  F81.5
054A6:  BSF    01.0
054A8:  BCF    F8A.2
054AA:  DECFSZ x6C,F
054AC:  BRA    5492
054AE:  MOVLB  0
054B0:  RETURN 0
.................... #use spi(MASTER, CLK = PIN_A3, DI = PIN_A0, DO = PIN_A1, BAUD = 1000000, BITS = 8, STREAM = MISSION_FM, MODE = 0) // MISSION flash memory port 
*
0550E:  MOVLB  D
05510:  MOVF   x6B,W
05512:  SUBLW  08
05514:  BZ    551E
05516:  MOVWF  x6C
05518:  RLCF   x6A,F
0551A:  DECFSZ x6C,F
0551C:  BRA    5518
0551E:  BSF    F92.0
05520:  BCF    F92.1
05522:  BCF    F92.3
05524:  BCF    F89.3
05526:  MOVFF  D6B,D6C
0552A:  BTFSS  x6A.7
0552C:  BCF    F89.1
0552E:  BTFSC  x6A.7
05530:  BSF    F89.1
05532:  RLCF   x6A,F
05534:  BSF    F89.3
05536:  RLCF   01,F
05538:  BTFSS  F80.0
0553A:  BCF    01.0
0553C:  BTFSC  F80.0
0553E:  BSF    01.0
05540:  BCF    F89.3
05542:  DECFSZ x6C,F
05544:  BRA    552A
05546:  MOVLB  0
05548:  RETURN 0
....................  
.................... #define SEL_ZES MSN 
.................... #define TMCR1 MSN 
.................... #define ADCS MSN 
.................... #define TMCR2 MSN 
.................... #define OPERA MSN 
.................... #define MCPIC MSN 
.................... #define PCIB MSN 
.................... #define SEL_REF MSN 
....................  
.................... #define MUX_SEL_COM_SHARED_FM PIN_C5 // Low = Main PIC; High = COM PIC 
.................... #define MUX_SEL_MSN_SHARED_FM PIN_A5 // Low = Main PIC; High = Mission 
.................... #define OCP_EN_ADCS PIN_F7           // ADCS board enable 
.................... #define OCP_EN_MCP PIN_D6            // DIO (MainPIC_to_MCPIC) changed to initialy being high. 
.................... #define OCP_EN_RELAY PIN_G0          // DIO (On_off_MainPIC_to_Relay) 
....................  
.................... #define DIO_BURNER_ANTENNA PIN_G4 // DIO (Burner Circuit UHF Antenna) 
.................... #define DIO_BURNER_SAP PIN_C2     // DIO (Burner Circuit SAP Deployment) 
.................... #define DIO_BURNER_SMA PIN_F5     // DIO (Burner Circuit SMA Heater) 
....................  
.................... #define MUX_CPLD_SEL_0 PIN_D7 
.................... #define MUX_CPLD_SEL_1 PIN_D5 
.................... #define MUX_CPLD_SEL_2 PIN_F6 
....................  
.................... #define OBC_KILL_DIO PIN_A4 
....................  
.................... #use timer(timer = 1, tick = 1ms, bits = 16, noisr) 
....................  
.................... #endif // !DEVICE_H 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
0C9F4:  MOVFF  C5F,C65
0C9F8:  MOVFF  C5E,C64
0C9FC:  MOVFF  C61,C67
0CA00:  MOVFF  C60,C66
0CA04:  MOVLB  C
0CA06:  MOVF   x63,F
0CA08:  BNZ   CA10
0CA0A:  MOVF   x62,W
0CA0C:  SUBLW  00
0CA0E:  BC    CA70
.................... { 
....................    if(*su1!=*su2) 
0CA10:  MOVFF  C64,FE9
0CA14:  MOVFF  C65,FEA
0CA18:  MOVFF  FEF,C68
0CA1C:  MOVFF  C67,03
0CA20:  MOVFF  C66,FE9
0CA24:  MOVFF  C67,FEA
0CA28:  MOVF   FEF,W
0CA2A:  SUBWF  x68,W
0CA2C:  BZ    CA5A
....................       return ((*su1<*su2)?-1:1); 
0CA2E:  MOVFF  C65,03
0CA32:  MOVFF  C64,FE9
0CA36:  MOVFF  03,FEA
0CA3A:  MOVFF  FEF,C68
0CA3E:  MOVFF  C67,03
0CA42:  MOVFF  C66,FE9
0CA46:  MOVFF  C67,FEA
0CA4A:  MOVF   FEF,W
0CA4C:  SUBWF  x68,W
0CA4E:  BC    CA54
0CA50:  MOVLW  FF
0CA52:  BRA    CA56
0CA54:  MOVLW  01
0CA56:  MOVWF  01
0CA58:  BRA    CA74
0CA5A:  INCF   x64,F
0CA5C:  BTFSC  FD8.2
0CA5E:  INCF   x65,F
0CA60:  INCF   x66,F
0CA62:  BTFSC  FD8.2
0CA64:  INCF   x67,F
0CA66:  MOVF   x62,W
0CA68:  BTFSC  FD8.2
0CA6A:  DECF   x63,F
0CA6C:  DECF   x62,F
0CA6E:  BRA    CA06
.................... } 
.................... return 0; 
0CA70:  MOVLW  00
0CA72:  MOVWF  01
0CA74:  MOVLB  0
0CA76:  GOTO   CB20 (RETURN)
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #ifndef DEVICE_H 
.................... #define DEVICE_H 
....................  
.................... // For the real case ---------------------------------------------------------------------- 
.................... #include <18F67J94.h> 
....................  
.................... #FUSES NOWDT NOBROWNOUT SOSC_DIG 
.................... #use delay(crystal = 16Mhz, clock = 16Mhz) // For crystal 
....................  
.................... #device HIGH_INTS = TRUE 
....................  
.................... #pin_select TX1 = PIN_G2 
.................... #pin_select RX1 = PIN_G3 
.................... #use rs232(baud = 115200, parity = N, UART1, bits = 8, stream = MSN, ERRORS) // UART to Mission 
....................  
.................... #pin_select TX2 = PIN_D3 
.................... #pin_select RX2 = PIN_D2 
.................... #use rs232(baud = 9600, parity = N, UART2, bits = 8, stream = COMM, ERRORS) // COM PIC 
....................  
.................... #pin_select TX3 = PIN_E5 
.................... #pin_select RX3 = PIN_E4 
.................... #use rs232(baud = 9600, parity = N, UART3, bits = 8, stream = FAB, ERRORS) // FAB PIC is EPS1 PIC 
....................  
.................... #pin_select TX4 = PIN_E3 
.................... #pin_select RX4 = PIN_F2 
.................... #use rs232(baud = 19200, parity = N, UART4, bits = 8, stream = RST, ERRORS) // RESET PIC 
....................  
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PC, ERRORS)     // DEBUG 
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_G0, rcv = PIN_G1, bits = 8, stream = MCP_SW, ERRORS) // MAIN to Mission Control PIC 
....................  
.................... #use spi(MASTER, CLK = PIN_E1, DI = PIN_E0, DO = PIN_E6, BAUD = 1000000, BITS = 8, STREAM = MAIN_FM, MODE = 0)    // MAIN flash memory port 
.................... #use spi(MASTER, CLK = PIN_B2, DI = PIN_B5, DO = PIN_B4, BAUD = 1000000, BITS = 8, STREAM = COM_FM, MODE = 0)     // COM flash memory port 
.................... #use spi(MASTER, CLK = PIN_A3, DI = PIN_A0, DO = PIN_A1, BAUD = 1000000, BITS = 8, STREAM = MISSION_FM, MODE = 0) // MISSION flash memory port 
....................  
.................... #define SEL_ZES MSN 
.................... #define TMCR1 MSN 
.................... #define ADCS MSN 
.................... #define TMCR2 MSN 
.................... #define OPERA MSN 
.................... #define MCPIC MSN 
.................... #define PCIB MSN 
.................... #define SEL_REF MSN 
....................  
.................... #define MUX_SEL_COM_SHARED_FM PIN_C5 // Low = Main PIC; High = COM PIC 
.................... #define MUX_SEL_MSN_SHARED_FM PIN_A5 // Low = Main PIC; High = Mission 
.................... #define OCP_EN_ADCS PIN_F7           // ADCS board enable 
.................... #define OCP_EN_MCP PIN_D6            // DIO (MainPIC_to_MCPIC) changed to initialy being high. 
.................... #define OCP_EN_RELAY PIN_G0          // DIO (On_off_MainPIC_to_Relay) 
....................  
.................... #define DIO_BURNER_ANTENNA PIN_G4 // DIO (Burner Circuit UHF Antenna) 
.................... #define DIO_BURNER_SAP PIN_C2     // DIO (Burner Circuit SAP Deployment) 
.................... #define DIO_BURNER_SMA PIN_F5     // DIO (Burner Circuit SMA Heater) 
....................  
.................... #define MUX_CPLD_SEL_0 PIN_D7 
.................... #define MUX_CPLD_SEL_1 PIN_D5 
.................... #define MUX_CPLD_SEL_2 PIN_F6 
....................  
.................... #define OBC_KILL_DIO PIN_A4 
....................  
.................... #use timer(timer = 1, tick = 1ms, bits = 16, noisr) 
....................  
.................... #endif // !DEVICE_H 
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
*
07470:  MOVLW  10
07472:  MOVWF  FF6
07474:  MOVLW  04
07476:  MOVWF  FF7
07478:  MOVLW  00
0747A:  MOVWF  FF8
0747C:  MOVLW  0C
0747E:  MOVLB  C
07480:  MOVWF  xC1
07482:  MOVLB  0
07484:  CALL   5290
07488:  MOVFF  FF,CBF
0748C:  MOVLW  37
0748E:  MOVLB  C
07490:  MOVWF  xC0
07492:  MOVLB  0
07494:  CALL   5A92
07498:  MOVLW  0D
0749A:  MOVLB  D
0749C:  MOVWF  x6A
0749E:  MOVLB  0
074A0:  CALL   44EE
074A4:  MOVLW  0A
074A6:  MOVLB  D
074A8:  MOVWF  x6A
074AA:  MOVLB  0
074AC:  CALL   44EE
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
074B0:  MOVLW  24
074B2:  MOVWF  FF6
074B4:  MOVLW  04
074B6:  MOVWF  FF7
074B8:  MOVLW  00
074BA:  MOVWF  FF8
074BC:  MOVLW  0F
074BE:  MOVLB  C
074C0:  MOVWF  xC1
074C2:  MOVLB  0
074C4:  CALL   5290
074C8:  MOVFF  100,CBE
074CC:  MOVLW  18
074CE:  MOVLB  C
074D0:  MOVWF  xBF
074D2:  MOVLB  0
074D4:  RCALL  73A8
074D6:  MOVLW  0D
074D8:  MOVLB  D
074DA:  MOVWF  x6A
074DC:  MOVLB  0
074DE:  CALL   44EE
074E2:  MOVLW  0A
074E4:  MOVLB  D
074E6:  MOVWF  x6A
074E8:  MOVLB  0
074EA:  CALL   44EE
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
074EE:  MOVLW  38
074F0:  MOVWF  FF6
074F2:  MOVLW  04
074F4:  MOVWF  FF7
074F6:  MOVLW  00
074F8:  MOVWF  FF8
074FA:  MOVLW  0E
074FC:  MOVLB  C
074FE:  MOVWF  xC1
07500:  MOVLB  0
07502:  CALL   5290
07506:  MOVFF  101,C78
0750A:  MOVLW  1B
0750C:  MOVLB  C
0750E:  MOVWF  x79
07510:  MOVLB  0
07512:  CALL   5ADC
07516:  MOVLW  0D
07518:  MOVLB  D
0751A:  MOVWF  x6A
0751C:  MOVLB  0
0751E:  CALL   44EE
07522:  MOVLW  0A
07524:  MOVLB  D
07526:  MOVWF  x6A
07528:  MOVLB  0
0752A:  CALL   44EE
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
0752E:  MOVLW  4C
07530:  MOVWF  FF6
07532:  MOVLW  04
07534:  MOVWF  FF7
07536:  MOVLW  00
07538:  MOVWF  FF8
0753A:  MOVLW  0D
0753C:  MOVLB  C
0753E:  MOVWF  xC1
07540:  MOVLB  0
07542:  CALL   5290
07546:  MOVFF  102,C78
0754A:  MOVLW  1B
0754C:  MOVLB  C
0754E:  MOVWF  x79
07550:  MOVLB  0
07552:  CALL   5ADC
07556:  MOVLW  0D
07558:  MOVLB  D
0755A:  MOVWF  x6A
0755C:  MOVLB  0
0755E:  CALL   44EE
07562:  MOVLW  0A
07564:  MOVLB  D
07566:  MOVWF  x6A
07568:  MOVLB  0
0756A:  CALL   44EE
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
0756E:  MOVLW  5E
07570:  MOVWF  FF6
07572:  MOVLW  04
07574:  MOVWF  FF7
07576:  MOVLW  00
07578:  MOVWF  FF8
0757A:  MOVLW  16
0757C:  MOVLB  C
0757E:  MOVWF  xC1
07580:  MOVLB  0
07582:  CALL   5290
07586:  MOVFF  103,C78
0758A:  MOVLW  1B
0758C:  MOVLB  C
0758E:  MOVWF  x79
07590:  MOVLB  0
07592:  CALL   5ADC
07596:  MOVLW  0D
07598:  MOVLB  D
0759A:  MOVWF  x6A
0759C:  MOVLB  0
0759E:  CALL   44EE
075A2:  MOVLW  0A
075A4:  MOVLB  D
075A6:  MOVWF  x6A
075A8:  MOVLB  0
075AA:  CALL   44EE
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
075AE:  MOVLW  7A
075B0:  MOVWF  FF6
075B2:  MOVLW  04
075B4:  MOVWF  FF7
075B6:  MOVLW  00
075B8:  MOVWF  FF8
075BA:  MOVLW  15
075BC:  MOVLB  C
075BE:  MOVWF  xC1
075C0:  MOVLB  0
075C2:  CALL   5290
075C6:  MOVFF  104,CBE
075CA:  MOVLW  18
075CC:  MOVLB  C
075CE:  MOVWF  xBF
075D0:  MOVLB  0
075D2:  RCALL  73A8
075D4:  MOVLW  0D
075D6:  MOVLB  D
075D8:  MOVWF  x6A
075DA:  MOVLB  0
075DC:  CALL   44EE
075E0:  MOVLW  0A
075E2:  MOVLB  D
075E4:  MOVWF  x6A
075E6:  MOVLB  0
075E8:  CALL   44EE
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
075EC:  MOVLW  94
075EE:  MOVWF  FF6
075F0:  MOVLW  04
075F2:  MOVWF  FF7
075F4:  MOVLW  00
075F6:  MOVWF  FF8
075F8:  MOVLW  0A
075FA:  MOVLB  C
075FC:  MOVWF  xC1
075FE:  MOVLB  0
07600:  CALL   5290
07604:  MOVFF  105,C78
07608:  MOVLW  1B
0760A:  MOVLB  C
0760C:  MOVWF  x79
0760E:  MOVLB  0
07610:  CALL   5ADC
07614:  MOVLW  0D
07616:  MOVLB  D
07618:  MOVWF  x6A
0761A:  MOVLB  0
0761C:  CALL   44EE
07620:  MOVLW  0A
07622:  MOVLB  D
07624:  MOVWF  x6A
07626:  MOVLB  0
07628:  CALL   44EE
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
0762C:  MOVLW  A4
0762E:  MOVWF  FF6
07630:  MOVLW  04
07632:  MOVWF  FF7
07634:  MOVLW  00
07636:  MOVWF  FF8
07638:  MOVLW  19
0763A:  MOVLB  C
0763C:  MOVWF  xC1
0763E:  MOVLB  0
07640:  CALL   5290
07644:  MOVFF  107,CBF
07648:  MOVLW  37
0764A:  MOVLB  C
0764C:  MOVWF  xC0
0764E:  MOVLB  0
07650:  CALL   5A92
07654:  MOVFF  106,CBF
07658:  MOVLW  37
0765A:  MOVLB  C
0765C:  MOVWF  xC0
0765E:  MOVLB  0
07660:  CALL   5A92
07664:  MOVLW  0D
07666:  MOVLB  D
07668:  MOVWF  x6A
0766A:  MOVLB  0
0766C:  CALL   44EE
07670:  MOVLW  0A
07672:  MOVLB  D
07674:  MOVWF  x6A
07676:  MOVLB  0
07678:  CALL   44EE
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
0767C:  MOVLW  C6
0767E:  MOVWF  FF6
07680:  MOVLW  04
07682:  MOVWF  FF7
07684:  MOVLW  00
07686:  MOVWF  FF8
07688:  MOVLW  15
0768A:  MOVLB  C
0768C:  MOVWF  xC1
0768E:  MOVLB  0
07690:  CALL   5290
07694:  MOVFF  109,CBF
07698:  MOVLW  37
0769A:  MOVLB  C
0769C:  MOVWF  xC0
0769E:  MOVLB  0
076A0:  CALL   5A92
076A4:  MOVFF  108,CBF
076A8:  MOVLW  37
076AA:  MOVLB  C
076AC:  MOVWF  xC0
076AE:  MOVLB  0
076B0:  CALL   5A92
076B4:  MOVLW  0D
076B6:  MOVLB  D
076B8:  MOVWF  x6A
076BA:  MOVLB  0
076BC:  CALL   44EE
076C0:  MOVLW  0A
076C2:  MOVLB  D
076C4:  MOVWF  x6A
076C6:  MOVLB  0
076C8:  CALL   44EE
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
076CC:  MOVLW  E4
076CE:  MOVWF  FF6
076D0:  MOVLW  04
076D2:  MOVWF  FF7
076D4:  MOVLW  00
076D6:  MOVWF  FF8
076D8:  MOVLW  16
076DA:  MOVLB  C
076DC:  MOVWF  xC1
076DE:  MOVLB  0
076E0:  CALL   5290
076E4:  MOVFF  10A,C78
076E8:  MOVLW  1B
076EA:  MOVLB  C
076EC:  MOVWF  x79
076EE:  MOVLB  0
076F0:  CALL   5ADC
076F4:  MOVLW  FC
076F6:  MOVWF  FF6
076F8:  MOVLW  04
076FA:  MOVWF  FF7
076FC:  MOVLW  00
076FE:  MOVWF  FF8
07700:  MOVLW  03
07702:  MOVLB  C
07704:  MOVWF  xC1
07706:  MOVLB  0
07708:  CALL   5290
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
0770C:  MOVLW  00
0770E:  MOVWF  FF6
07710:  MOVLW  05
07712:  MOVWF  FF7
07714:  MOVLW  00
07716:  MOVWF  FF8
07718:  MOVLW  0F
0771A:  MOVLB  C
0771C:  MOVWF  xC1
0771E:  MOVLB  0
07720:  CALL   5290
07724:  MOVFF  10B,C78
07728:  MOVLW  1B
0772A:  MOVLB  C
0772C:  MOVWF  x79
0772E:  MOVLB  0
07730:  CALL   5ADC
07734:  MOVLW  0D
07736:  MOVLB  D
07738:  MOVWF  x6A
0773A:  MOVLB  0
0773C:  CALL   44EE
07740:  MOVLW  0A
07742:  MOVLB  D
07744:  MOVWF  x6A
07746:  MOVLB  0
07748:  CALL   44EE
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
0774C:  MOVLW  14
0774E:  MOVWF  FF6
07750:  MOVLW  05
07752:  MOVWF  FF7
07754:  MOVLW  00
07756:  MOVWF  FF8
07758:  CALL   4534
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
0775C:  MOVLB  C
0775E:  CLRF   x3A
07760:  MOVF   x3A,W
07762:  SUBLW  0A
07764:  BNC   7788
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
07766:  CLRF   03
07768:  MOVF   x3A,W
0776A:  ADDLW  0C
0776C:  MOVWF  FE9
0776E:  MOVLW  01
07770:  ADDWFC 03,W
07772:  MOVWF  FEA
07774:  MOVFF  FEF,CBF
07778:  MOVLW  37
0777A:  MOVWF  xC0
0777C:  MOVLB  0
0777E:  CALL   5A92
07782:  MOVLB  C
07784:  INCF   x3A,F
07786:  BRA    7760
....................     } 
....................     fprintf(PC, "\r\n"); 
07788:  MOVLW  0D
0778A:  MOVLB  D
0778C:  MOVWF  x6A
0778E:  MOVLB  0
07790:  CALL   44EE
07794:  MOVLW  0A
07796:  MOVLB  D
07798:  MOVWF  x6A
0779A:  MOVLB  0
0779C:  CALL   44EE
077A0:  RETURN 0
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
*
052E8:  MOVLB  5
052EA:  MOVF   x5C,F
052EC:  BZ    52F8
....................         return mux_cpld_position; // Do not change if locked 
052EE:  MOVLB  7
052F0:  MOVFF  74F,01
052F4:  BRA    53D2
052F6:  MOVLB  5
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
052F8:  MOVLB  C
052FA:  RRCF   xBE,W
052FC:  MOVWF  00
052FE:  RRCF   00,F
05300:  MOVLW  3F
05302:  ANDWF  00,F
05304:  MOVF   00,W
05306:  ANDLW  01
05308:  BNZ   530E
0530A:  BCF    F8C.7
0530C:  BRA    5310
0530E:  BSF    F8C.7
05310:  BCF    F95.7
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
05312:  BCF    FD8.0
05314:  RRCF   xBE,W
05316:  ANDLW  01
05318:  BNZ   531E
0531A:  BCF    F8C.5
0531C:  BRA    5320
0531E:  BSF    F8C.5
05320:  BCF    F95.5
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
05322:  MOVF   xBE,W
05324:  ANDLW  01
05326:  BNZ   532C
05328:  BCF    F8E.6
0532A:  BRA    532E
0532C:  BSF    F8E.6
0532E:  BCF    F97.6
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
05330:  MOVF   xBE,W
05332:  SUBLW  07
05334:  BZ    533A
05336:  MOVF   xBE,F
05338:  BNZ   5352
....................         set_uart_speed(9600, MSN); 
0533A:  BSF    F67.3
0533C:  MOVLW  A0
0533E:  MOVWF  FAF
05340:  MOVLW  01
05342:  MOVLB  F
05344:  MOVWF  x30
05346:  MOVLW  A6
05348:  MOVWF  FAC
0534A:  MOVLW  90
0534C:  MOVWF  FAB
....................     } else { 
0534E:  BRA    5366
05350:  MOVLB  C
....................         set_uart_speed(115200, MSN); 
05352:  BSF    F67.3
05354:  MOVLW  22
05356:  MOVWF  FAF
05358:  MOVLW  00
0535A:  MOVLB  F
0535C:  MOVWF  x30
0535E:  MOVLW  A6
05360:  MOVWF  FAC
05362:  MOVLW  90
05364:  MOVWF  FAB
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
05366:  MOVFF  CBE,74F
....................  
....................     delay_ms(10); 
0536A:  MOVLW  0A
0536C:  MOVLB  D
0536E:  MOVWF  x52
05370:  MOVLB  0
05372:  RCALL  5266
....................  
....................     if (verbose) 
05374:  MOVLB  5
05376:  MOVF   x5A,F
05378:  BZ    53CC
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
0537A:  CLRF   03
0537C:  MOVLB  7
0537E:  MOVFF  74F,02
05382:  BCF    FD8.0
05384:  RLCF   02,F
05386:  RLCF   03,F
05388:  MOVF   02,W
0538A:  ADDLW  1F
0538C:  MOVWF  FE9
0538E:  MOVLW  07
05390:  ADDWFC 03,W
05392:  MOVWF  FEA
05394:  MOVFF  FEC,CC0
05398:  MOVF   FED,F
0539A:  MOVFF  FEF,CBF
0539E:  MOVLW  2A
053A0:  MOVWF  FF6
053A2:  MOVLW  05
053A4:  MOVWF  FF7
053A6:  MOVLW  00
053A8:  MOVWF  FF8
053AA:  MOVLW  10
053AC:  MOVLB  C
053AE:  MOVWF  xC1
053B0:  MOVLB  0
053B2:  RCALL  5290
053B4:  MOVFF  CC0,FEA
053B8:  MOVFF  CBF,FE9
053BC:  RCALL  52C2
053BE:  MOVLW  7C
053C0:  MOVLB  D
053C2:  MOVWF  x6A
053C4:  MOVLB  0
053C6:  CALL   44EE
053CA:  MOVLB  5
....................  
....................     return mux_cpld_position; 
053CC:  MOVLB  7
053CE:  MOVFF  74F,01
053D2:  MOVLB  0
053D4:  RETURN 0
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "libuart.h" 
.................... #ifndef LIBUART_H 
.................... #define LIBUART_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... typedef struct message_config { 
....................     char identifier; // Message identifier 
....................     char length;     // Message length 
....................     int standard;    // Message follows standard structure (true/false) 
.................... } message_config; 
....................  
.................... message_config mconfig[] = { 
....................     { MSG_COMM, MSG_LENGTH_COMM, MSG_CHECKSUM_COMM }, 
....................     { MSG_PCIB, MSG_LENGTH_PCIB, MSG_CHECKSUM_PCIB }, 
....................     { MSG_MCPIC, MSG_LENGTH_MCPIC, MSG_CHECKSUM_MCPIC }, 
....................     { MSG_RST, MSG_LENGTH_RST, MSG_CHECKSUM_RST }, 
....................     { MSG_FAB, MSG_LENGTH_FAB, MSG_CHECKSUM_FAB }, 
....................     { MSG_ADCS, MSG_LENGTH_ADCS, MSG_CHECKSUM_ADCS }, 
....................     { MSG_TMCR1, MSG_LENGTH_TMCR1, MSG_CHECKSUM_TMCR1 }, 
....................     { MSG_TMCR2, MSG_LENGTH_TMCR2, MSG_CHECKSUM_TMCR2 } 
.................... }; 
....................  
.................... message_config* message_COMM = &mconfig[0]; 
.................... message_config* message_PCIB = &mconfig[1]; 
.................... message_config* message_MCPIC = &mconfig[2]; 
.................... message_config* message_RST = &mconfig[3]; 
.................... message_config* message_FAB = &mconfig[4]; 
.................... message_config* message_ADCS = &mconfig[5]; 
.................... message_config* message_TMCR1 = &mconfig[6]; 
.................... message_config* message_TMCR2 = &mconfig[7]; 
....................  
.................... typedef uint8_t (*bytes_available_fn)(); 
.................... typedef uint8_t (*get_char_fn)(); 
.................... typedef void (*put_char_fn)(uint8_t data); 
....................  
.................... typedef struct uart_fn { 
....................     bytes_available_fn* bytes_available; 
....................     get_char_fn* get_char; 
....................     put_char_fn* put_char; 
.................... } uart_fn; 
....................  
.................... #define uart_declare_fn(uart_stream)                   \ 
....................     inline uint8_t bytes_available_##uart_stream()     \ 
....................     {                                                  \ 
....................         return kbhit(uart_stream);                     \ 
....................     }                                                  \ 
....................     inline uint8_t get_character_##uart_stream()       \ 
....................     {                                                  \ 
....................         return fgetc(uart_stream);                     \ 
....................     }                                                  \ 
....................     inline void put_character_##uart_stream(uint8_t c) \ 
....................     {                                                  \ 
....................         fputc(c, uart_stream);                         \ 
....................     }                                                  \ 
....................     uart_fn uart_port_##uart_stream = { bytes_available_##uart_stream, &get_character_##uart_stream, &put_character_##uart_stream } 
....................  
.................... #define uart_use(uart_stream) \ 
....................     uart uart_##uart_stream;  \ 
....................     char buffer_##uart_stream[MSG_LENGTH_##uart_stream] 
....................  
.................... #define uart_init(uart_stream)                          \ 
....................     uart_##uart_stream.data = &buffer_##uart_stream;    \ 
....................     uart_##uart_stream.size = MSG_LENGTH_##uart_stream; \ 
....................     uart_reset(&uart_##uart_stream) 
.................... #define uart_update(uart_stream, message_config) \ 
....................     uart_process(&uart_##uart_stream, message_config, fgetc(uart_stream)); 
.................... #define uart_update_all(uart_stream) \ 
....................     uart_process_all(&uart_##uart_stream, fgetc(uart_stream)); 
....................  
.................... #define uart_ready(uart_stream) uart_##uart_stream.state == ready 
.................... #define uart_message(uart_stream) uart_##uart_stream.data 
.................... #define uart_clean(uart_stream) uart_reset(&uart_##uart_stream) 
....................  
.................... enum state_en { 
....................     waiting, 
....................     receiving, 
....................     ready 
.................... }; 
....................  
.................... typedef struct uart { 
....................     char* data; 
....................     int size; 
....................     char* position; 
....................     char* end; 
....................     state_en state; 
....................     int standard; 
.................... } uart; 
....................  
.................... inline void uart_reset(uart* buffer) 
.................... { 
....................     buffer->position = buffer->data; 
*
024C6:  MOVLW  03
024C8:  ADDWF  x84,W
024CA:  MOVWF  01
024CC:  MOVLW  00
024CE:  ADDWFC x85,W
024D0:  MOVFF  D84,FE9
024D4:  MOVFF  D85,FEA
024D8:  MOVFF  FEC,03
024DC:  MOVF   FED,F
024DE:  MOVFF  FEF,D88
024E2:  MOVWF  FEA
024E4:  MOVFF  01,FE9
024E8:  MOVFF  03,FEC
024EC:  MOVF   FED,F
024EE:  MOVFF  D88,FEF
*
02878:  MOVLW  03
0287A:  ADDWF  x84,W
0287C:  MOVWF  01
0287E:  MOVLW  00
02880:  ADDWFC x85,W
02882:  MOVFF  D84,FE9
02886:  MOVFF  D85,FEA
0288A:  MOVFF  FEC,03
0288E:  MOVF   FED,F
02890:  MOVFF  FEF,D88
02894:  MOVWF  FEA
02896:  MOVFF  01,FE9
0289A:  MOVFF  03,FEC
0289E:  MOVF   FED,F
028A0:  MOVFF  D88,FEF
*
02C2A:  MOVLW  03
02C2C:  ADDWF  x84,W
02C2E:  MOVWF  01
02C30:  MOVLW  00
02C32:  ADDWFC x85,W
02C34:  MOVFF  D84,FE9
02C38:  MOVFF  D85,FEA
02C3C:  MOVFF  FEC,03
02C40:  MOVF   FED,F
02C42:  MOVFF  FEF,D88
02C46:  MOVWF  FEA
02C48:  MOVFF  01,FE9
02C4C:  MOVFF  03,FEC
02C50:  MOVF   FED,F
02C52:  MOVFF  D88,FEF
*
02FDE:  MOVLW  03
02FE0:  ADDWF  x84,W
02FE2:  MOVWF  01
02FE4:  MOVLW  00
02FE6:  ADDWFC x85,W
02FE8:  MOVFF  D84,FE9
02FEC:  MOVFF  D85,FEA
02FF0:  MOVFF  FEC,03
02FF4:  MOVF   FED,F
02FF6:  MOVFF  FEF,D88
02FFA:  MOVWF  FEA
02FFC:  MOVFF  01,FE9
03000:  MOVFF  03,FEC
03004:  MOVF   FED,F
03006:  MOVFF  D88,FEF
*
03392:  MOVLW  03
03394:  ADDWF  x84,W
03396:  MOVWF  01
03398:  MOVLW  00
0339A:  ADDWFC x85,W
0339C:  MOVFF  D84,FE9
033A0:  MOVFF  D85,FEA
033A4:  MOVFF  FEC,03
033A8:  MOVF   FED,F
033AA:  MOVFF  FEF,D88
033AE:  MOVWF  FEA
033B0:  MOVFF  01,FE9
033B4:  MOVFF  03,FEC
033B8:  MOVF   FED,F
033BA:  MOVFF  D88,FEF
*
03746:  MOVLW  03
03748:  ADDWF  x84,W
0374A:  MOVWF  01
0374C:  MOVLW  00
0374E:  ADDWFC x85,W
03750:  MOVFF  D84,FE9
03754:  MOVFF  D85,FEA
03758:  MOVFF  FEC,03
0375C:  MOVF   FED,F
0375E:  MOVFF  FEF,D88
03762:  MOVWF  FEA
03764:  MOVFF  01,FE9
03768:  MOVFF  03,FEC
0376C:  MOVF   FED,F
0376E:  MOVFF  D88,FEF
*
03B16:  MOVLW  03
03B18:  ADDWF  x84,W
03B1A:  MOVWF  01
03B1C:  MOVLW  00
03B1E:  ADDWFC x85,W
03B20:  MOVFF  D84,FE9
03B24:  MOVFF  D85,FEA
03B28:  MOVFF  FEC,03
03B2C:  MOVF   FED,F
03B2E:  MOVFF  FEF,D88
03B32:  MOVWF  FEA
03B34:  MOVFF  01,FE9
03B38:  MOVFF  03,FEC
03B3C:  MOVF   FED,F
03B3E:  MOVFF  D88,FEF
*
03EF4:  MOVLW  03
03EF6:  ADDWF  x84,W
03EF8:  MOVWF  01
03EFA:  MOVLW  00
03EFC:  ADDWFC x85,W
03EFE:  MOVFF  D84,FE9
03F02:  MOVFF  D85,FEA
03F06:  MOVFF  FEC,03
03F0A:  MOVF   FED,F
03F0C:  MOVFF  FEF,D88
03F10:  MOVWF  FEA
03F12:  MOVFF  01,FE9
03F16:  MOVFF  03,FEC
03F1A:  MOVF   FED,F
03F1C:  MOVFF  D88,FEF
*
042C4:  MOVLW  03
042C6:  ADDWF  x84,W
042C8:  MOVWF  01
042CA:  MOVLW  00
042CC:  ADDWFC x85,W
042CE:  MOVFF  D84,FE9
042D2:  MOVFF  D85,FEA
042D6:  MOVFF  FEC,03
042DA:  MOVF   FED,F
042DC:  MOVFF  FEF,D88
042E0:  MOVWF  FEA
042E2:  MOVFF  01,FE9
042E6:  MOVFF  03,FEC
042EA:  MOVF   FED,F
042EC:  MOVFF  D88,FEF
*
0DA08:  MOVLW  03
0DA0A:  ADDWF  x84,W
0DA0C:  MOVWF  01
0DA0E:  MOVLW  00
0DA10:  ADDWFC x85,W
0DA12:  MOVFF  D84,FE9
0DA16:  MOVFF  D85,FEA
0DA1A:  MOVFF  FEC,03
0DA1E:  MOVF   FED,F
0DA20:  MOVFF  FEF,D88
0DA24:  MOVWF  FEA
0DA26:  MOVFF  01,FE9
0DA2A:  MOVFF  03,FEC
0DA2E:  MOVF   FED,F
0DA30:  MOVFF  D88,FEF
*
0DAA0:  MOVLW  03
0DAA2:  ADDWF  x84,W
0DAA4:  MOVWF  01
0DAA6:  MOVLW  00
0DAA8:  ADDWFC x85,W
0DAAA:  MOVFF  D84,FE9
0DAAE:  MOVFF  D85,FEA
0DAB2:  MOVFF  FEC,03
0DAB6:  MOVF   FED,F
0DAB8:  MOVFF  FEF,D88
0DABC:  MOVWF  FEA
0DABE:  MOVFF  01,FE9
0DAC2:  MOVFF  03,FEC
0DAC6:  MOVF   FED,F
0DAC8:  MOVFF  D88,FEF
*
0DB74:  MOVLW  03
0DB76:  ADDWF  x84,W
0DB78:  MOVWF  01
0DB7A:  MOVLW  00
0DB7C:  ADDWFC x85,W
0DB7E:  MOVFF  D84,FE9
0DB82:  MOVFF  D85,FEA
0DB86:  MOVFF  FEC,03
0DB8A:  MOVF   FED,F
0DB8C:  MOVFF  FEF,D88
0DB90:  MOVWF  FEA
0DB92:  MOVFF  01,FE9
0DB96:  MOVFF  03,FEC
0DB9A:  MOVF   FED,F
0DB9C:  MOVFF  D88,FEF
*
0DC38:  MOVLW  03
0DC3A:  ADDWF  x84,W
0DC3C:  MOVWF  01
0DC3E:  MOVLW  00
0DC40:  ADDWFC x85,W
0DC42:  MOVFF  D84,FE9
0DC46:  MOVFF  D85,FEA
0DC4A:  MOVFF  FEC,03
0DC4E:  MOVF   FED,F
0DC50:  MOVFF  FEF,D88
0DC54:  MOVWF  FEA
0DC56:  MOVFF  01,FE9
0DC5A:  MOVFF  03,FEC
0DC5E:  MOVF   FED,F
0DC60:  MOVFF  D88,FEF
*
0DDA0:  MOVLW  03
0DDA2:  ADDWF  x84,W
0DDA4:  MOVWF  01
0DDA6:  MOVLW  00
0DDA8:  ADDWFC x85,W
0DDAA:  MOVFF  D84,FE9
0DDAE:  MOVFF  D85,FEA
0DDB2:  MOVFF  FEC,03
0DDB6:  MOVF   FED,F
0DDB8:  MOVFF  FEF,D88
0DDBC:  MOVWF  FEA
0DDBE:  MOVFF  01,FE9
0DDC2:  MOVFF  03,FEC
0DDC6:  MOVF   FED,F
0DDC8:  MOVFF  D88,FEF
*
0DEC8:  MOVLW  03
0DECA:  ADDWF  x84,W
0DECC:  MOVWF  01
0DECE:  MOVLW  00
0DED0:  ADDWFC x85,W
0DED2:  MOVFF  D84,FE9
0DED6:  MOVFF  D85,FEA
0DEDA:  MOVFF  FEC,03
0DEDE:  MOVF   FED,F
0DEE0:  MOVFF  FEF,D88
0DEE4:  MOVWF  FEA
0DEE6:  MOVFF  01,FE9
0DEEA:  MOVFF  03,FEC
0DEEE:  MOVF   FED,F
0DEF0:  MOVFF  D88,FEF
*
0DFF0:  MOVLW  03
0DFF2:  ADDWF  x84,W
0DFF4:  MOVWF  01
0DFF6:  MOVLW  00
0DFF8:  ADDWFC x85,W
0DFFA:  MOVFF  D84,FE9
0DFFE:  MOVFF  D85,FEA
0E002:  MOVFF  FEC,03
0E006:  MOVF   FED,F
0E008:  MOVFF  FEF,D88
0E00C:  MOVWF  FEA
0E00E:  MOVFF  01,FE9
0E012:  MOVFF  03,FEC
0E016:  MOVF   FED,F
0E018:  MOVFF  D88,FEF
*
1916C:  MOVLW  03
1916E:  ADDWF  x84,W
19170:  MOVWF  01
19172:  MOVLW  00
19174:  ADDWFC x85,W
19176:  MOVFF  D84,FE9
1917A:  MOVFF  D85,FEA
1917E:  MOVFF  FEC,03
19182:  MOVF   FED,F
19184:  MOVFF  FEF,D88
19188:  MOVWF  FEA
1918A:  MOVFF  01,FE9
1918E:  MOVFF  03,FEC
19192:  MOVF   FED,F
19194:  MOVFF  D88,FEF
*
19218:  MOVLW  03
1921A:  ADDWF  x84,W
1921C:  MOVWF  01
1921E:  MOVLW  00
19220:  ADDWFC x85,W
19222:  MOVFF  D84,FE9
19226:  MOVFF  D85,FEA
1922A:  MOVFF  FEC,03
1922E:  MOVF   FED,F
19230:  MOVFF  FEF,D88
19234:  MOVWF  FEA
19236:  MOVFF  01,FE9
1923A:  MOVFF  03,FEC
1923E:  MOVF   FED,F
19240:  MOVFF  D88,FEF
*
192C4:  MOVLW  03
192C6:  ADDWF  x84,W
192C8:  MOVWF  01
192CA:  MOVLW  00
192CC:  ADDWFC x85,W
192CE:  MOVFF  D84,FE9
192D2:  MOVFF  D85,FEA
192D6:  MOVFF  FEC,03
192DA:  MOVF   FED,F
192DC:  MOVFF  FEF,D88
192E0:  MOVWF  FEA
192E2:  MOVFF  01,FE9
192E6:  MOVFF  03,FEC
192EA:  MOVF   FED,F
192EC:  MOVFF  D88,FEF
*
19370:  MOVLW  03
19372:  ADDWF  x84,W
19374:  MOVWF  01
19376:  MOVLW  00
19378:  ADDWFC x85,W
1937A:  MOVFF  D84,FE9
1937E:  MOVFF  D85,FEA
19382:  MOVFF  FEC,03
19386:  MOVF   FED,F
19388:  MOVFF  FEF,D88
1938C:  MOVWF  FEA
1938E:  MOVFF  01,FE9
19392:  MOVFF  03,FEC
19396:  MOVF   FED,F
19398:  MOVFF  D88,FEF
*
1941E:  MOVLW  03
19420:  ADDWF  x84,W
19422:  MOVWF  01
19424:  MOVLW  00
19426:  ADDWFC x85,W
19428:  MOVFF  D84,FE9
1942C:  MOVFF  D85,FEA
19430:  MOVFF  FEC,03
19434:  MOVF   FED,F
19436:  MOVFF  FEF,D88
1943A:  MOVWF  FEA
1943C:  MOVFF  01,FE9
19440:  MOVFF  03,FEC
19444:  MOVF   FED,F
19446:  MOVFF  D88,FEF
*
194CA:  MOVLW  03
194CC:  ADDWF  x84,W
194CE:  MOVWF  01
194D0:  MOVLW  00
194D2:  ADDWFC x85,W
194D4:  MOVFF  D84,FE9
194D8:  MOVFF  D85,FEA
194DC:  MOVFF  FEC,03
194E0:  MOVF   FED,F
194E2:  MOVFF  FEF,D88
194E6:  MOVWF  FEA
194E8:  MOVFF  01,FE9
194EC:  MOVFF  03,FEC
194F0:  MOVF   FED,F
194F2:  MOVFF  D88,FEF
*
19578:  MOVLW  03
1957A:  ADDWF  x84,W
1957C:  MOVWF  01
1957E:  MOVLW  00
19580:  ADDWFC x85,W
19582:  MOVFF  D84,FE9
19586:  MOVFF  D85,FEA
1958A:  MOVFF  FEC,03
1958E:  MOVF   FED,F
19590:  MOVFF  FEF,D88
19594:  MOVWF  FEA
19596:  MOVFF  01,FE9
1959A:  MOVFF  03,FEC
1959E:  MOVF   FED,F
195A0:  MOVFF  D88,FEF
*
19624:  MOVLW  03
19626:  ADDWF  x84,W
19628:  MOVWF  01
1962A:  MOVLW  00
1962C:  ADDWFC x85,W
1962E:  MOVFF  D84,FE9
19632:  MOVFF  D85,FEA
19636:  MOVFF  FEC,03
1963A:  MOVF   FED,F
1963C:  MOVFF  FEF,D88
19640:  MOVWF  FEA
19642:  MOVFF  01,FE9
19646:  MOVFF  03,FEC
1964A:  MOVF   FED,F
1964C:  MOVFF  D88,FEF
*
196D0:  MOVLW  03
196D2:  ADDWF  x84,W
196D4:  MOVWF  01
196D6:  MOVLW  00
196D8:  ADDWFC x85,W
196DA:  MOVFF  D84,FE9
196DE:  MOVFF  D85,FEA
196E2:  MOVFF  FEC,03
196E6:  MOVF   FED,F
196E8:  MOVFF  FEF,D88
196EC:  MOVWF  FEA
196EE:  MOVFF  01,FE9
196F2:  MOVFF  03,FEC
196F6:  MOVF   FED,F
196F8:  MOVFF  D88,FEF
*
1ADC2:  MOVLW  03
1ADC4:  ADDWF  x84,W
1ADC6:  MOVWF  01
1ADC8:  MOVLW  00
1ADCA:  ADDWFC x85,W
1ADCC:  MOVFF  D84,FE9
1ADD0:  MOVFF  D85,FEA
1ADD4:  MOVFF  FEC,03
1ADD8:  MOVF   FED,F
1ADDA:  MOVFF  FEF,D88
1ADDE:  MOVWF  FEA
1ADE0:  MOVFF  01,FE9
1ADE4:  MOVFF  03,FEC
1ADE8:  MOVF   FED,F
1ADEA:  MOVFF  D88,FEF
*
1AE30:  MOVLW  03
1AE32:  ADDWF  x84,W
1AE34:  MOVWF  01
1AE36:  MOVLW  00
1AE38:  ADDWFC x85,W
1AE3A:  MOVFF  D84,FE9
1AE3E:  MOVFF  D85,FEA
1AE42:  MOVFF  FEC,03
1AE46:  MOVF   FED,F
1AE48:  MOVFF  FEF,D88
1AE4C:  MOVWF  FEA
1AE4E:  MOVFF  01,FE9
1AE52:  MOVFF  03,FEC
1AE56:  MOVF   FED,F
1AE58:  MOVFF  D88,FEF
*
1AE9E:  MOVLW  03
1AEA0:  ADDWF  x84,W
1AEA2:  MOVWF  01
1AEA4:  MOVLW  00
1AEA6:  ADDWFC x85,W
1AEA8:  MOVFF  D84,FE9
1AEAC:  MOVFF  D85,FEA
1AEB0:  MOVFF  FEC,03
1AEB4:  MOVF   FED,F
1AEB6:  MOVFF  FEF,D88
1AEBA:  MOVWF  FEA
1AEBC:  MOVFF  01,FE9
1AEC0:  MOVFF  03,FEC
1AEC4:  MOVF   FED,F
1AEC6:  MOVFF  D88,FEF
*
1AF0C:  MOVLW  03
1AF0E:  ADDWF  x84,W
1AF10:  MOVWF  01
1AF12:  MOVLW  00
1AF14:  ADDWFC x85,W
1AF16:  MOVFF  D84,FE9
1AF1A:  MOVFF  D85,FEA
1AF1E:  MOVFF  FEC,03
1AF22:  MOVF   FED,F
1AF24:  MOVFF  FEF,D88
1AF28:  MOVWF  FEA
1AF2A:  MOVFF  01,FE9
1AF2E:  MOVFF  03,FEC
1AF32:  MOVF   FED,F
1AF34:  MOVFF  D88,FEF
*
1AF7A:  MOVLW  03
1AF7C:  ADDWF  x84,W
1AF7E:  MOVWF  01
1AF80:  MOVLW  00
1AF82:  ADDWFC x85,W
1AF84:  MOVFF  D84,FE9
1AF88:  MOVFF  D85,FEA
1AF8C:  MOVFF  FEC,03
1AF90:  MOVF   FED,F
1AF92:  MOVFF  FEF,D88
1AF96:  MOVWF  FEA
1AF98:  MOVFF  01,FE9
1AF9C:  MOVFF  03,FEC
1AFA0:  MOVF   FED,F
1AFA2:  MOVFF  D88,FEF
*
1AFE8:  MOVLW  03
1AFEA:  ADDWF  x84,W
1AFEC:  MOVWF  01
1AFEE:  MOVLW  00
1AFF0:  ADDWFC x85,W
1AFF2:  MOVFF  D84,FE9
1AFF6:  MOVFF  D85,FEA
1AFFA:  MOVFF  FEC,03
1AFFE:  MOVF   FED,F
1B000:  MOVFF  FEF,D88
1B004:  MOVWF  FEA
1B006:  MOVFF  01,FE9
1B00A:  MOVFF  03,FEC
1B00E:  MOVF   FED,F
1B010:  MOVFF  D88,FEF
*
1B056:  MOVLW  03
1B058:  ADDWF  x84,W
1B05A:  MOVWF  01
1B05C:  MOVLW  00
1B05E:  ADDWFC x85,W
1B060:  MOVFF  D84,FE9
1B064:  MOVFF  D85,FEA
1B068:  MOVFF  FEC,03
1B06C:  MOVF   FED,F
1B06E:  MOVFF  FEF,D88
1B072:  MOVWF  FEA
1B074:  MOVFF  01,FE9
1B078:  MOVFF  03,FEC
1B07C:  MOVF   FED,F
1B07E:  MOVFF  D88,FEF
*
1B0C4:  MOVLW  03
1B0C6:  ADDWF  x84,W
1B0C8:  MOVWF  01
1B0CA:  MOVLW  00
1B0CC:  ADDWFC x85,W
1B0CE:  MOVFF  D84,FE9
1B0D2:  MOVFF  D85,FEA
1B0D6:  MOVFF  FEC,03
1B0DA:  MOVF   FED,F
1B0DC:  MOVFF  FEF,D88
1B0E0:  MOVWF  FEA
1B0E2:  MOVFF  01,FE9
1B0E6:  MOVFF  03,FEC
1B0EA:  MOVF   FED,F
1B0EC:  MOVFF  D88,FEF
*
1B132:  MOVLW  03
1B134:  ADDWF  x84,W
1B136:  MOVWF  01
1B138:  MOVLW  00
1B13A:  ADDWFC x85,W
1B13C:  MOVFF  D84,FE9
1B140:  MOVFF  D85,FEA
1B144:  MOVFF  FEC,03
1B148:  MOVF   FED,F
1B14A:  MOVFF  FEF,D88
1B14E:  MOVWF  FEA
1B150:  MOVFF  01,FE9
1B154:  MOVFF  03,FEC
1B158:  MOVF   FED,F
1B15A:  MOVFF  D88,FEF
*
1B556:  MOVLW  03
1B558:  ADDWF  x84,W
1B55A:  MOVWF  01
1B55C:  MOVLW  00
1B55E:  ADDWFC x85,W
1B560:  MOVFF  D84,FE9
1B564:  MOVFF  D85,FEA
1B568:  MOVFF  FEC,03
1B56C:  MOVF   FED,F
1B56E:  MOVFF  FEF,D88
1B572:  MOVWF  FEA
1B574:  MOVFF  01,FE9
1B578:  MOVFF  03,FEC
1B57C:  MOVF   FED,F
1B57E:  MOVFF  D88,FEF
*
1B5D4:  MOVLW  03
1B5D6:  ADDWF  x84,W
1B5D8:  MOVWF  01
1B5DA:  MOVLW  00
1B5DC:  ADDWFC x85,W
1B5DE:  MOVFF  D84,FE9
1B5E2:  MOVFF  D85,FEA
1B5E6:  MOVFF  FEC,03
1B5EA:  MOVF   FED,F
1B5EC:  MOVFF  FEF,D88
1B5F0:  MOVWF  FEA
1B5F2:  MOVFF  01,FE9
1B5F6:  MOVFF  03,FEC
1B5FA:  MOVF   FED,F
1B5FC:  MOVFF  D88,FEF
*
1B652:  MOVLW  03
1B654:  ADDWF  x84,W
1B656:  MOVWF  01
1B658:  MOVLW  00
1B65A:  ADDWFC x85,W
1B65C:  MOVFF  D84,FE9
1B660:  MOVFF  D85,FEA
1B664:  MOVFF  FEC,03
1B668:  MOVF   FED,F
1B66A:  MOVFF  FEF,D88
1B66E:  MOVWF  FEA
1B670:  MOVFF  01,FE9
1B674:  MOVFF  03,FEC
1B678:  MOVF   FED,F
1B67A:  MOVFF  D88,FEF
*
1B6D0:  MOVLW  03
1B6D2:  ADDWF  x84,W
1B6D4:  MOVWF  01
1B6D6:  MOVLW  00
1B6D8:  ADDWFC x85,W
1B6DA:  MOVFF  D84,FE9
1B6DE:  MOVFF  D85,FEA
1B6E2:  MOVFF  FEC,03
1B6E6:  MOVF   FED,F
1B6E8:  MOVFF  FEF,D88
1B6EC:  MOVWF  FEA
1B6EE:  MOVFF  01,FE9
1B6F2:  MOVFF  03,FEC
1B6F6:  MOVF   FED,F
1B6F8:  MOVFF  D88,FEF
*
1B74E:  MOVLW  03
1B750:  ADDWF  x84,W
1B752:  MOVWF  01
1B754:  MOVLW  00
1B756:  ADDWFC x85,W
1B758:  MOVFF  D84,FE9
1B75C:  MOVFF  D85,FEA
1B760:  MOVFF  FEC,03
1B764:  MOVF   FED,F
1B766:  MOVFF  FEF,D88
1B76A:  MOVWF  FEA
1B76C:  MOVFF  01,FE9
1B770:  MOVFF  03,FEC
1B774:  MOVF   FED,F
1B776:  MOVFF  D88,FEF
*
1B7CC:  MOVLW  03
1B7CE:  ADDWF  x84,W
1B7D0:  MOVWF  01
1B7D2:  MOVLW  00
1B7D4:  ADDWFC x85,W
1B7D6:  MOVFF  D84,FE9
1B7DA:  MOVFF  D85,FEA
1B7DE:  MOVFF  FEC,03
1B7E2:  MOVF   FED,F
1B7E4:  MOVFF  FEF,D88
1B7E8:  MOVWF  FEA
1B7EA:  MOVFF  01,FE9
1B7EE:  MOVFF  03,FEC
1B7F2:  MOVF   FED,F
1B7F4:  MOVFF  D88,FEF
*
1B84A:  MOVLW  03
1B84C:  ADDWF  x84,W
1B84E:  MOVWF  01
1B850:  MOVLW  00
1B852:  ADDWFC x85,W
1B854:  MOVFF  D84,FE9
1B858:  MOVFF  D85,FEA
1B85C:  MOVFF  FEC,03
1B860:  MOVF   FED,F
1B862:  MOVFF  FEF,D88
1B866:  MOVWF  FEA
1B868:  MOVFF  01,FE9
1B86C:  MOVFF  03,FEC
1B870:  MOVF   FED,F
1B872:  MOVFF  D88,FEF
*
1B8C8:  MOVLW  03
1B8CA:  ADDWF  x84,W
1B8CC:  MOVWF  01
1B8CE:  MOVLW  00
1B8D0:  ADDWFC x85,W
1B8D2:  MOVFF  D84,FE9
1B8D6:  MOVFF  D85,FEA
1B8DA:  MOVFF  FEC,03
1B8DE:  MOVF   FED,F
1B8E0:  MOVFF  FEF,D88
1B8E4:  MOVWF  FEA
1B8E6:  MOVFF  01,FE9
1B8EA:  MOVFF  03,FEC
1B8EE:  MOVF   FED,F
1B8F0:  MOVFF  D88,FEF
*
1B946:  MOVLW  03
1B948:  ADDWF  x84,W
1B94A:  MOVWF  01
1B94C:  MOVLW  00
1B94E:  ADDWFC x85,W
1B950:  MOVFF  D84,FE9
1B954:  MOVFF  D85,FEA
1B958:  MOVFF  FEC,03
1B95C:  MOVF   FED,F
1B95E:  MOVFF  FEF,D88
1B962:  MOVWF  FEA
1B964:  MOVFF  01,FE9
1B968:  MOVFF  03,FEC
1B96C:  MOVF   FED,F
1B96E:  MOVFF  D88,FEF
*
1BE9C:  MOVLW  03
1BE9E:  ADDWF  x84,W
1BEA0:  MOVWF  01
1BEA2:  MOVLW  00
1BEA4:  ADDWFC x85,W
1BEA6:  MOVFF  D84,FE9
1BEAA:  MOVFF  D85,FEA
1BEAE:  MOVFF  FEC,03
1BEB2:  MOVF   FED,F
1BEB4:  MOVFF  FEF,D88
1BEB8:  MOVWF  FEA
1BEBA:  MOVFF  01,FE9
1BEBE:  MOVFF  03,FEC
1BEC2:  MOVF   FED,F
1BEC4:  MOVFF  D88,FEF
....................     buffer->end = buffer->data; 
*
024F2:  MOVLW  05
024F4:  ADDWF  x84,W
024F6:  MOVWF  01
024F8:  MOVLW  00
024FA:  ADDWFC x85,W
024FC:  MOVFF  D84,FE9
02500:  MOVFF  D85,FEA
02504:  MOVFF  FEC,03
02508:  MOVF   FED,F
0250A:  MOVFF  FEF,D88
0250E:  MOVWF  FEA
02510:  MOVFF  01,FE9
02514:  MOVFF  03,FEC
02518:  MOVF   FED,F
0251A:  MOVFF  D88,FEF
*
028A4:  MOVLW  05
028A6:  ADDWF  x84,W
028A8:  MOVWF  01
028AA:  MOVLW  00
028AC:  ADDWFC x85,W
028AE:  MOVFF  D84,FE9
028B2:  MOVFF  D85,FEA
028B6:  MOVFF  FEC,03
028BA:  MOVF   FED,F
028BC:  MOVFF  FEF,D88
028C0:  MOVWF  FEA
028C2:  MOVFF  01,FE9
028C6:  MOVFF  03,FEC
028CA:  MOVF   FED,F
028CC:  MOVFF  D88,FEF
*
02C56:  MOVLW  05
02C58:  ADDWF  x84,W
02C5A:  MOVWF  01
02C5C:  MOVLW  00
02C5E:  ADDWFC x85,W
02C60:  MOVFF  D84,FE9
02C64:  MOVFF  D85,FEA
02C68:  MOVFF  FEC,03
02C6C:  MOVF   FED,F
02C6E:  MOVFF  FEF,D88
02C72:  MOVWF  FEA
02C74:  MOVFF  01,FE9
02C78:  MOVFF  03,FEC
02C7C:  MOVF   FED,F
02C7E:  MOVFF  D88,FEF
*
0300A:  MOVLW  05
0300C:  ADDWF  x84,W
0300E:  MOVWF  01
03010:  MOVLW  00
03012:  ADDWFC x85,W
03014:  MOVFF  D84,FE9
03018:  MOVFF  D85,FEA
0301C:  MOVFF  FEC,03
03020:  MOVF   FED,F
03022:  MOVFF  FEF,D88
03026:  MOVWF  FEA
03028:  MOVFF  01,FE9
0302C:  MOVFF  03,FEC
03030:  MOVF   FED,F
03032:  MOVFF  D88,FEF
*
033BE:  MOVLW  05
033C0:  ADDWF  x84,W
033C2:  MOVWF  01
033C4:  MOVLW  00
033C6:  ADDWFC x85,W
033C8:  MOVFF  D84,FE9
033CC:  MOVFF  D85,FEA
033D0:  MOVFF  FEC,03
033D4:  MOVF   FED,F
033D6:  MOVFF  FEF,D88
033DA:  MOVWF  FEA
033DC:  MOVFF  01,FE9
033E0:  MOVFF  03,FEC
033E4:  MOVF   FED,F
033E6:  MOVFF  D88,FEF
*
03772:  MOVLW  05
03774:  ADDWF  x84,W
03776:  MOVWF  01
03778:  MOVLW  00
0377A:  ADDWFC x85,W
0377C:  MOVFF  D84,FE9
03780:  MOVFF  D85,FEA
03784:  MOVFF  FEC,03
03788:  MOVF   FED,F
0378A:  MOVFF  FEF,D88
0378E:  MOVWF  FEA
03790:  MOVFF  01,FE9
03794:  MOVFF  03,FEC
03798:  MOVF   FED,F
0379A:  MOVFF  D88,FEF
*
03B42:  MOVLW  05
03B44:  ADDWF  x84,W
03B46:  MOVWF  01
03B48:  MOVLW  00
03B4A:  ADDWFC x85,W
03B4C:  MOVFF  D84,FE9
03B50:  MOVFF  D85,FEA
03B54:  MOVFF  FEC,03
03B58:  MOVF   FED,F
03B5A:  MOVFF  FEF,D88
03B5E:  MOVWF  FEA
03B60:  MOVFF  01,FE9
03B64:  MOVFF  03,FEC
03B68:  MOVF   FED,F
03B6A:  MOVFF  D88,FEF
*
03F20:  MOVLW  05
03F22:  ADDWF  x84,W
03F24:  MOVWF  01
03F26:  MOVLW  00
03F28:  ADDWFC x85,W
03F2A:  MOVFF  D84,FE9
03F2E:  MOVFF  D85,FEA
03F32:  MOVFF  FEC,03
03F36:  MOVF   FED,F
03F38:  MOVFF  FEF,D88
03F3C:  MOVWF  FEA
03F3E:  MOVFF  01,FE9
03F42:  MOVFF  03,FEC
03F46:  MOVF   FED,F
03F48:  MOVFF  D88,FEF
*
042F0:  MOVLW  05
042F2:  ADDWF  x84,W
042F4:  MOVWF  01
042F6:  MOVLW  00
042F8:  ADDWFC x85,W
042FA:  MOVFF  D84,FE9
042FE:  MOVFF  D85,FEA
04302:  MOVFF  FEC,03
04306:  MOVF   FED,F
04308:  MOVFF  FEF,D88
0430C:  MOVWF  FEA
0430E:  MOVFF  01,FE9
04312:  MOVFF  03,FEC
04316:  MOVF   FED,F
04318:  MOVFF  D88,FEF
*
0DA34:  MOVLW  05
0DA36:  ADDWF  x84,W
0DA38:  MOVWF  01
0DA3A:  MOVLW  00
0DA3C:  ADDWFC x85,W
0DA3E:  MOVFF  D84,FE9
0DA42:  MOVFF  D85,FEA
0DA46:  MOVFF  FEC,03
0DA4A:  MOVF   FED,F
0DA4C:  MOVFF  FEF,D88
0DA50:  MOVWF  FEA
0DA52:  MOVFF  01,FE9
0DA56:  MOVFF  03,FEC
0DA5A:  MOVF   FED,F
0DA5C:  MOVFF  D88,FEF
*
0DACC:  MOVLW  05
0DACE:  ADDWF  x84,W
0DAD0:  MOVWF  01
0DAD2:  MOVLW  00
0DAD4:  ADDWFC x85,W
0DAD6:  MOVFF  D84,FE9
0DADA:  MOVFF  D85,FEA
0DADE:  MOVFF  FEC,03
0DAE2:  MOVF   FED,F
0DAE4:  MOVFF  FEF,D88
0DAE8:  MOVWF  FEA
0DAEA:  MOVFF  01,FE9
0DAEE:  MOVFF  03,FEC
0DAF2:  MOVF   FED,F
0DAF4:  MOVFF  D88,FEF
*
0DBA0:  MOVLW  05
0DBA2:  ADDWF  x84,W
0DBA4:  MOVWF  01
0DBA6:  MOVLW  00
0DBA8:  ADDWFC x85,W
0DBAA:  MOVFF  D84,FE9
0DBAE:  MOVFF  D85,FEA
0DBB2:  MOVFF  FEC,03
0DBB6:  MOVF   FED,F
0DBB8:  MOVFF  FEF,D88
0DBBC:  MOVWF  FEA
0DBBE:  MOVFF  01,FE9
0DBC2:  MOVFF  03,FEC
0DBC6:  MOVF   FED,F
0DBC8:  MOVFF  D88,FEF
*
0DC64:  MOVLW  05
0DC66:  ADDWF  x84,W
0DC68:  MOVWF  01
0DC6A:  MOVLW  00
0DC6C:  ADDWFC x85,W
0DC6E:  MOVFF  D84,FE9
0DC72:  MOVFF  D85,FEA
0DC76:  MOVFF  FEC,03
0DC7A:  MOVF   FED,F
0DC7C:  MOVFF  FEF,D88
0DC80:  MOVWF  FEA
0DC82:  MOVFF  01,FE9
0DC86:  MOVFF  03,FEC
0DC8A:  MOVF   FED,F
0DC8C:  MOVFF  D88,FEF
*
0DDCC:  MOVLW  05
0DDCE:  ADDWF  x84,W
0DDD0:  MOVWF  01
0DDD2:  MOVLW  00
0DDD4:  ADDWFC x85,W
0DDD6:  MOVFF  D84,FE9
0DDDA:  MOVFF  D85,FEA
0DDDE:  MOVFF  FEC,03
0DDE2:  MOVF   FED,F
0DDE4:  MOVFF  FEF,D88
0DDE8:  MOVWF  FEA
0DDEA:  MOVFF  01,FE9
0DDEE:  MOVFF  03,FEC
0DDF2:  MOVF   FED,F
0DDF4:  MOVFF  D88,FEF
*
0DEF4:  MOVLW  05
0DEF6:  ADDWF  x84,W
0DEF8:  MOVWF  01
0DEFA:  MOVLW  00
0DEFC:  ADDWFC x85,W
0DEFE:  MOVFF  D84,FE9
0DF02:  MOVFF  D85,FEA
0DF06:  MOVFF  FEC,03
0DF0A:  MOVF   FED,F
0DF0C:  MOVFF  FEF,D88
0DF10:  MOVWF  FEA
0DF12:  MOVFF  01,FE9
0DF16:  MOVFF  03,FEC
0DF1A:  MOVF   FED,F
0DF1C:  MOVFF  D88,FEF
*
0E01C:  MOVLW  05
0E01E:  ADDWF  x84,W
0E020:  MOVWF  01
0E022:  MOVLW  00
0E024:  ADDWFC x85,W
0E026:  MOVFF  D84,FE9
0E02A:  MOVFF  D85,FEA
0E02E:  MOVFF  FEC,03
0E032:  MOVF   FED,F
0E034:  MOVFF  FEF,D88
0E038:  MOVWF  FEA
0E03A:  MOVFF  01,FE9
0E03E:  MOVFF  03,FEC
0E042:  MOVF   FED,F
0E044:  MOVFF  D88,FEF
*
19198:  MOVLW  05
1919A:  ADDWF  x84,W
1919C:  MOVWF  01
1919E:  MOVLW  00
191A0:  ADDWFC x85,W
191A2:  MOVFF  D84,FE9
191A6:  MOVFF  D85,FEA
191AA:  MOVFF  FEC,03
191AE:  MOVF   FED,F
191B0:  MOVFF  FEF,D88
191B4:  MOVWF  FEA
191B6:  MOVFF  01,FE9
191BA:  MOVFF  03,FEC
191BE:  MOVF   FED,F
191C0:  MOVFF  D88,FEF
*
19244:  MOVLW  05
19246:  ADDWF  x84,W
19248:  MOVWF  01
1924A:  MOVLW  00
1924C:  ADDWFC x85,W
1924E:  MOVFF  D84,FE9
19252:  MOVFF  D85,FEA
19256:  MOVFF  FEC,03
1925A:  MOVF   FED,F
1925C:  MOVFF  FEF,D88
19260:  MOVWF  FEA
19262:  MOVFF  01,FE9
19266:  MOVFF  03,FEC
1926A:  MOVF   FED,F
1926C:  MOVFF  D88,FEF
*
192F0:  MOVLW  05
192F2:  ADDWF  x84,W
192F4:  MOVWF  01
192F6:  MOVLW  00
192F8:  ADDWFC x85,W
192FA:  MOVFF  D84,FE9
192FE:  MOVFF  D85,FEA
19302:  MOVFF  FEC,03
19306:  MOVF   FED,F
19308:  MOVFF  FEF,D88
1930C:  MOVWF  FEA
1930E:  MOVFF  01,FE9
19312:  MOVFF  03,FEC
19316:  MOVF   FED,F
19318:  MOVFF  D88,FEF
*
1939C:  MOVLW  05
1939E:  ADDWF  x84,W
193A0:  MOVWF  01
193A2:  MOVLW  00
193A4:  ADDWFC x85,W
193A6:  MOVFF  D84,FE9
193AA:  MOVFF  D85,FEA
193AE:  MOVFF  FEC,03
193B2:  MOVF   FED,F
193B4:  MOVFF  FEF,D88
193B8:  MOVWF  FEA
193BA:  MOVFF  01,FE9
193BE:  MOVFF  03,FEC
193C2:  MOVF   FED,F
193C4:  MOVFF  D88,FEF
*
1944A:  MOVLW  05
1944C:  ADDWF  x84,W
1944E:  MOVWF  01
19450:  MOVLW  00
19452:  ADDWFC x85,W
19454:  MOVFF  D84,FE9
19458:  MOVFF  D85,FEA
1945C:  MOVFF  FEC,03
19460:  MOVF   FED,F
19462:  MOVFF  FEF,D88
19466:  MOVWF  FEA
19468:  MOVFF  01,FE9
1946C:  MOVFF  03,FEC
19470:  MOVF   FED,F
19472:  MOVFF  D88,FEF
*
194F6:  MOVLW  05
194F8:  ADDWF  x84,W
194FA:  MOVWF  01
194FC:  MOVLW  00
194FE:  ADDWFC x85,W
19500:  MOVFF  D84,FE9
19504:  MOVFF  D85,FEA
19508:  MOVFF  FEC,03
1950C:  MOVF   FED,F
1950E:  MOVFF  FEF,D88
19512:  MOVWF  FEA
19514:  MOVFF  01,FE9
19518:  MOVFF  03,FEC
1951C:  MOVF   FED,F
1951E:  MOVFF  D88,FEF
*
195A4:  MOVLW  05
195A6:  ADDWF  x84,W
195A8:  MOVWF  01
195AA:  MOVLW  00
195AC:  ADDWFC x85,W
195AE:  MOVFF  D84,FE9
195B2:  MOVFF  D85,FEA
195B6:  MOVFF  FEC,03
195BA:  MOVF   FED,F
195BC:  MOVFF  FEF,D88
195C0:  MOVWF  FEA
195C2:  MOVFF  01,FE9
195C6:  MOVFF  03,FEC
195CA:  MOVF   FED,F
195CC:  MOVFF  D88,FEF
*
19650:  MOVLW  05
19652:  ADDWF  x84,W
19654:  MOVWF  01
19656:  MOVLW  00
19658:  ADDWFC x85,W
1965A:  MOVFF  D84,FE9
1965E:  MOVFF  D85,FEA
19662:  MOVFF  FEC,03
19666:  MOVF   FED,F
19668:  MOVFF  FEF,D88
1966C:  MOVWF  FEA
1966E:  MOVFF  01,FE9
19672:  MOVFF  03,FEC
19676:  MOVF   FED,F
19678:  MOVFF  D88,FEF
*
196FC:  MOVLW  05
196FE:  ADDWF  x84,W
19700:  MOVWF  01
19702:  MOVLW  00
19704:  ADDWFC x85,W
19706:  MOVFF  D84,FE9
1970A:  MOVFF  D85,FEA
1970E:  MOVFF  FEC,03
19712:  MOVF   FED,F
19714:  MOVFF  FEF,D88
19718:  MOVWF  FEA
1971A:  MOVFF  01,FE9
1971E:  MOVFF  03,FEC
19722:  MOVF   FED,F
19724:  MOVFF  D88,FEF
*
1ADEE:  MOVLW  05
1ADF0:  ADDWF  x84,W
1ADF2:  MOVWF  01
1ADF4:  MOVLW  00
1ADF6:  ADDWFC x85,W
1ADF8:  MOVFF  D84,FE9
1ADFC:  MOVFF  D85,FEA
1AE00:  MOVFF  FEC,03
1AE04:  MOVF   FED,F
1AE06:  MOVFF  FEF,D88
1AE0A:  MOVWF  FEA
1AE0C:  MOVFF  01,FE9
1AE10:  MOVFF  03,FEC
1AE14:  MOVF   FED,F
1AE16:  MOVFF  D88,FEF
*
1AE5C:  MOVLW  05
1AE5E:  ADDWF  x84,W
1AE60:  MOVWF  01
1AE62:  MOVLW  00
1AE64:  ADDWFC x85,W
1AE66:  MOVFF  D84,FE9
1AE6A:  MOVFF  D85,FEA
1AE6E:  MOVFF  FEC,03
1AE72:  MOVF   FED,F
1AE74:  MOVFF  FEF,D88
1AE78:  MOVWF  FEA
1AE7A:  MOVFF  01,FE9
1AE7E:  MOVFF  03,FEC
1AE82:  MOVF   FED,F
1AE84:  MOVFF  D88,FEF
*
1AECA:  MOVLW  05
1AECC:  ADDWF  x84,W
1AECE:  MOVWF  01
1AED0:  MOVLW  00
1AED2:  ADDWFC x85,W
1AED4:  MOVFF  D84,FE9
1AED8:  MOVFF  D85,FEA
1AEDC:  MOVFF  FEC,03
1AEE0:  MOVF   FED,F
1AEE2:  MOVFF  FEF,D88
1AEE6:  MOVWF  FEA
1AEE8:  MOVFF  01,FE9
1AEEC:  MOVFF  03,FEC
1AEF0:  MOVF   FED,F
1AEF2:  MOVFF  D88,FEF
*
1AF38:  MOVLW  05
1AF3A:  ADDWF  x84,W
1AF3C:  MOVWF  01
1AF3E:  MOVLW  00
1AF40:  ADDWFC x85,W
1AF42:  MOVFF  D84,FE9
1AF46:  MOVFF  D85,FEA
1AF4A:  MOVFF  FEC,03
1AF4E:  MOVF   FED,F
1AF50:  MOVFF  FEF,D88
1AF54:  MOVWF  FEA
1AF56:  MOVFF  01,FE9
1AF5A:  MOVFF  03,FEC
1AF5E:  MOVF   FED,F
1AF60:  MOVFF  D88,FEF
*
1AFA6:  MOVLW  05
1AFA8:  ADDWF  x84,W
1AFAA:  MOVWF  01
1AFAC:  MOVLW  00
1AFAE:  ADDWFC x85,W
1AFB0:  MOVFF  D84,FE9
1AFB4:  MOVFF  D85,FEA
1AFB8:  MOVFF  FEC,03
1AFBC:  MOVF   FED,F
1AFBE:  MOVFF  FEF,D88
1AFC2:  MOVWF  FEA
1AFC4:  MOVFF  01,FE9
1AFC8:  MOVFF  03,FEC
1AFCC:  MOVF   FED,F
1AFCE:  MOVFF  D88,FEF
*
1B014:  MOVLW  05
1B016:  ADDWF  x84,W
1B018:  MOVWF  01
1B01A:  MOVLW  00
1B01C:  ADDWFC x85,W
1B01E:  MOVFF  D84,FE9
1B022:  MOVFF  D85,FEA
1B026:  MOVFF  FEC,03
1B02A:  MOVF   FED,F
1B02C:  MOVFF  FEF,D88
1B030:  MOVWF  FEA
1B032:  MOVFF  01,FE9
1B036:  MOVFF  03,FEC
1B03A:  MOVF   FED,F
1B03C:  MOVFF  D88,FEF
*
1B082:  MOVLW  05
1B084:  ADDWF  x84,W
1B086:  MOVWF  01
1B088:  MOVLW  00
1B08A:  ADDWFC x85,W
1B08C:  MOVFF  D84,FE9
1B090:  MOVFF  D85,FEA
1B094:  MOVFF  FEC,03
1B098:  MOVF   FED,F
1B09A:  MOVFF  FEF,D88
1B09E:  MOVWF  FEA
1B0A0:  MOVFF  01,FE9
1B0A4:  MOVFF  03,FEC
1B0A8:  MOVF   FED,F
1B0AA:  MOVFF  D88,FEF
*
1B0F0:  MOVLW  05
1B0F2:  ADDWF  x84,W
1B0F4:  MOVWF  01
1B0F6:  MOVLW  00
1B0F8:  ADDWFC x85,W
1B0FA:  MOVFF  D84,FE9
1B0FE:  MOVFF  D85,FEA
1B102:  MOVFF  FEC,03
1B106:  MOVF   FED,F
1B108:  MOVFF  FEF,D88
1B10C:  MOVWF  FEA
1B10E:  MOVFF  01,FE9
1B112:  MOVFF  03,FEC
1B116:  MOVF   FED,F
1B118:  MOVFF  D88,FEF
*
1B15E:  MOVLW  05
1B160:  ADDWF  x84,W
1B162:  MOVWF  01
1B164:  MOVLW  00
1B166:  ADDWFC x85,W
1B168:  MOVFF  D84,FE9
1B16C:  MOVFF  D85,FEA
1B170:  MOVFF  FEC,03
1B174:  MOVF   FED,F
1B176:  MOVFF  FEF,D88
1B17A:  MOVWF  FEA
1B17C:  MOVFF  01,FE9
1B180:  MOVFF  03,FEC
1B184:  MOVF   FED,F
1B186:  MOVFF  D88,FEF
*
1B582:  MOVLW  05
1B584:  ADDWF  x84,W
1B586:  MOVWF  01
1B588:  MOVLW  00
1B58A:  ADDWFC x85,W
1B58C:  MOVFF  D84,FE9
1B590:  MOVFF  D85,FEA
1B594:  MOVFF  FEC,03
1B598:  MOVF   FED,F
1B59A:  MOVFF  FEF,D88
1B59E:  MOVWF  FEA
1B5A0:  MOVFF  01,FE9
1B5A4:  MOVFF  03,FEC
1B5A8:  MOVF   FED,F
1B5AA:  MOVFF  D88,FEF
*
1B600:  MOVLW  05
1B602:  ADDWF  x84,W
1B604:  MOVWF  01
1B606:  MOVLW  00
1B608:  ADDWFC x85,W
1B60A:  MOVFF  D84,FE9
1B60E:  MOVFF  D85,FEA
1B612:  MOVFF  FEC,03
1B616:  MOVF   FED,F
1B618:  MOVFF  FEF,D88
1B61C:  MOVWF  FEA
1B61E:  MOVFF  01,FE9
1B622:  MOVFF  03,FEC
1B626:  MOVF   FED,F
1B628:  MOVFF  D88,FEF
*
1B67E:  MOVLW  05
1B680:  ADDWF  x84,W
1B682:  MOVWF  01
1B684:  MOVLW  00
1B686:  ADDWFC x85,W
1B688:  MOVFF  D84,FE9
1B68C:  MOVFF  D85,FEA
1B690:  MOVFF  FEC,03
1B694:  MOVF   FED,F
1B696:  MOVFF  FEF,D88
1B69A:  MOVWF  FEA
1B69C:  MOVFF  01,FE9
1B6A0:  MOVFF  03,FEC
1B6A4:  MOVF   FED,F
1B6A6:  MOVFF  D88,FEF
*
1B6FC:  MOVLW  05
1B6FE:  ADDWF  x84,W
1B700:  MOVWF  01
1B702:  MOVLW  00
1B704:  ADDWFC x85,W
1B706:  MOVFF  D84,FE9
1B70A:  MOVFF  D85,FEA
1B70E:  MOVFF  FEC,03
1B712:  MOVF   FED,F
1B714:  MOVFF  FEF,D88
1B718:  MOVWF  FEA
1B71A:  MOVFF  01,FE9
1B71E:  MOVFF  03,FEC
1B722:  MOVF   FED,F
1B724:  MOVFF  D88,FEF
*
1B77A:  MOVLW  05
1B77C:  ADDWF  x84,W
1B77E:  MOVWF  01
1B780:  MOVLW  00
1B782:  ADDWFC x85,W
1B784:  MOVFF  D84,FE9
1B788:  MOVFF  D85,FEA
1B78C:  MOVFF  FEC,03
1B790:  MOVF   FED,F
1B792:  MOVFF  FEF,D88
1B796:  MOVWF  FEA
1B798:  MOVFF  01,FE9
1B79C:  MOVFF  03,FEC
1B7A0:  MOVF   FED,F
1B7A2:  MOVFF  D88,FEF
*
1B7F8:  MOVLW  05
1B7FA:  ADDWF  x84,W
1B7FC:  MOVWF  01
1B7FE:  MOVLW  00
1B800:  ADDWFC x85,W
1B802:  MOVFF  D84,FE9
1B806:  MOVFF  D85,FEA
1B80A:  MOVFF  FEC,03
1B80E:  MOVF   FED,F
1B810:  MOVFF  FEF,D88
1B814:  MOVWF  FEA
1B816:  MOVFF  01,FE9
1B81A:  MOVFF  03,FEC
1B81E:  MOVF   FED,F
1B820:  MOVFF  D88,FEF
*
1B876:  MOVLW  05
1B878:  ADDWF  x84,W
1B87A:  MOVWF  01
1B87C:  MOVLW  00
1B87E:  ADDWFC x85,W
1B880:  MOVFF  D84,FE9
1B884:  MOVFF  D85,FEA
1B888:  MOVFF  FEC,03
1B88C:  MOVF   FED,F
1B88E:  MOVFF  FEF,D88
1B892:  MOVWF  FEA
1B894:  MOVFF  01,FE9
1B898:  MOVFF  03,FEC
1B89C:  MOVF   FED,F
1B89E:  MOVFF  D88,FEF
*
1B8F4:  MOVLW  05
1B8F6:  ADDWF  x84,W
1B8F8:  MOVWF  01
1B8FA:  MOVLW  00
1B8FC:  ADDWFC x85,W
1B8FE:  MOVFF  D84,FE9
1B902:  MOVFF  D85,FEA
1B906:  MOVFF  FEC,03
1B90A:  MOVF   FED,F
1B90C:  MOVFF  FEF,D88
1B910:  MOVWF  FEA
1B912:  MOVFF  01,FE9
1B916:  MOVFF  03,FEC
1B91A:  MOVF   FED,F
1B91C:  MOVFF  D88,FEF
*
1B972:  MOVLW  05
1B974:  ADDWF  x84,W
1B976:  MOVWF  01
1B978:  MOVLW  00
1B97A:  ADDWFC x85,W
1B97C:  MOVFF  D84,FE9
1B980:  MOVFF  D85,FEA
1B984:  MOVFF  FEC,03
1B988:  MOVF   FED,F
1B98A:  MOVFF  FEF,D88
1B98E:  MOVWF  FEA
1B990:  MOVFF  01,FE9
1B994:  MOVFF  03,FEC
1B998:  MOVF   FED,F
1B99A:  MOVFF  D88,FEF
*
1BEC8:  MOVLW  05
1BECA:  ADDWF  x84,W
1BECC:  MOVWF  01
1BECE:  MOVLW  00
1BED0:  ADDWFC x85,W
1BED2:  MOVFF  D84,FE9
1BED6:  MOVFF  D85,FEA
1BEDA:  MOVFF  FEC,03
1BEDE:  MOVF   FED,F
1BEE0:  MOVFF  FEF,D88
1BEE4:  MOVWF  FEA
1BEE6:  MOVFF  01,FE9
1BEEA:  MOVFF  03,FEC
1BEEE:  MOVF   FED,F
1BEF0:  MOVFF  D88,FEF
....................     buffer->state = waiting; 
*
0251E:  MOVLW  07
02520:  ADDWF  x84,W
02522:  MOVWF  FE9
02524:  MOVLW  00
02526:  ADDWFC x85,W
02528:  MOVWF  FEA
0252A:  CLRF   FEF
*
028D0:  MOVLW  07
028D2:  ADDWF  x84,W
028D4:  MOVWF  FE9
028D6:  MOVLW  00
028D8:  ADDWFC x85,W
028DA:  MOVWF  FEA
028DC:  CLRF   FEF
*
02C82:  MOVLW  07
02C84:  ADDWF  x84,W
02C86:  MOVWF  FE9
02C88:  MOVLW  00
02C8A:  ADDWFC x85,W
02C8C:  MOVWF  FEA
02C8E:  CLRF   FEF
*
03036:  MOVLW  07
03038:  ADDWF  x84,W
0303A:  MOVWF  FE9
0303C:  MOVLW  00
0303E:  ADDWFC x85,W
03040:  MOVWF  FEA
03042:  CLRF   FEF
*
033EA:  MOVLW  07
033EC:  ADDWF  x84,W
033EE:  MOVWF  FE9
033F0:  MOVLW  00
033F2:  ADDWFC x85,W
033F4:  MOVWF  FEA
033F6:  CLRF   FEF
*
0379E:  MOVLW  07
037A0:  ADDWF  x84,W
037A2:  MOVWF  FE9
037A4:  MOVLW  00
037A6:  ADDWFC x85,W
037A8:  MOVWF  FEA
037AA:  CLRF   FEF
*
03B6E:  MOVLW  07
03B70:  ADDWF  x84,W
03B72:  MOVWF  FE9
03B74:  MOVLW  00
03B76:  ADDWFC x85,W
03B78:  MOVWF  FEA
03B7A:  CLRF   FEF
*
03F4C:  MOVLW  07
03F4E:  ADDWF  x84,W
03F50:  MOVWF  FE9
03F52:  MOVLW  00
03F54:  ADDWFC x85,W
03F56:  MOVWF  FEA
03F58:  CLRF   FEF
*
0431C:  MOVLW  07
0431E:  ADDWF  x84,W
04320:  MOVWF  FE9
04322:  MOVLW  00
04324:  ADDWFC x85,W
04326:  MOVWF  FEA
04328:  CLRF   FEF
*
0DA60:  MOVLW  07
0DA62:  ADDWF  x84,W
0DA64:  MOVWF  FE9
0DA66:  MOVLW  00
0DA68:  ADDWFC x85,W
0DA6A:  MOVWF  FEA
0DA6C:  CLRF   FEF
*
0DAF8:  MOVLW  07
0DAFA:  ADDWF  x84,W
0DAFC:  MOVWF  FE9
0DAFE:  MOVLW  00
0DB00:  ADDWFC x85,W
0DB02:  MOVWF  FEA
0DB04:  CLRF   FEF
*
0DBCC:  MOVLW  07
0DBCE:  ADDWF  x84,W
0DBD0:  MOVWF  FE9
0DBD2:  MOVLW  00
0DBD4:  ADDWFC x85,W
0DBD6:  MOVWF  FEA
0DBD8:  CLRF   FEF
*
0DC90:  MOVLW  07
0DC92:  ADDWF  x84,W
0DC94:  MOVWF  FE9
0DC96:  MOVLW  00
0DC98:  ADDWFC x85,W
0DC9A:  MOVWF  FEA
0DC9C:  CLRF   FEF
*
0DDF8:  MOVLW  07
0DDFA:  ADDWF  x84,W
0DDFC:  MOVWF  FE9
0DDFE:  MOVLW  00
0DE00:  ADDWFC x85,W
0DE02:  MOVWF  FEA
0DE04:  CLRF   FEF
*
0DF20:  MOVLW  07
0DF22:  ADDWF  x84,W
0DF24:  MOVWF  FE9
0DF26:  MOVLW  00
0DF28:  ADDWFC x85,W
0DF2A:  MOVWF  FEA
0DF2C:  CLRF   FEF
*
0E048:  MOVLW  07
0E04A:  ADDWF  x84,W
0E04C:  MOVWF  FE9
0E04E:  MOVLW  00
0E050:  ADDWFC x85,W
0E052:  MOVWF  FEA
0E054:  CLRF   FEF
*
191C4:  MOVLW  07
191C6:  ADDWF  x84,W
191C8:  MOVWF  FE9
191CA:  MOVLW  00
191CC:  ADDWFC x85,W
191CE:  MOVWF  FEA
191D0:  CLRF   FEF
191D2:  MOVLB  9
*
19270:  MOVLW  07
19272:  ADDWF  x84,W
19274:  MOVWF  FE9
19276:  MOVLW  00
19278:  ADDWFC x85,W
1927A:  MOVWF  FEA
1927C:  CLRF   FEF
1927E:  MOVLB  9
*
1931C:  MOVLW  07
1931E:  ADDWF  x84,W
19320:  MOVWF  FE9
19322:  MOVLW  00
19324:  ADDWFC x85,W
19326:  MOVWF  FEA
19328:  CLRF   FEF
1932A:  MOVLB  9
*
193C8:  MOVLW  07
193CA:  ADDWF  x84,W
193CC:  MOVWF  FE9
193CE:  MOVLW  00
193D0:  ADDWFC x85,W
193D2:  MOVWF  FEA
193D4:  CLRF   FEF
193D6:  MOVLB  9
*
19476:  MOVLW  07
19478:  ADDWF  x84,W
1947A:  MOVWF  FE9
1947C:  MOVLW  00
1947E:  ADDWFC x85,W
19480:  MOVWF  FEA
19482:  CLRF   FEF
19484:  MOVLB  A
*
19522:  MOVLW  07
19524:  ADDWF  x84,W
19526:  MOVWF  FE9
19528:  MOVLW  00
1952A:  ADDWFC x85,W
1952C:  MOVWF  FEA
1952E:  CLRF   FEF
19530:  MOVLB  A
*
195D0:  MOVLW  07
195D2:  ADDWF  x84,W
195D4:  MOVWF  FE9
195D6:  MOVLW  00
195D8:  ADDWFC x85,W
195DA:  MOVWF  FEA
195DC:  CLRF   FEF
195DE:  MOVLB  9
*
1967C:  MOVLW  07
1967E:  ADDWF  x84,W
19680:  MOVWF  FE9
19682:  MOVLW  00
19684:  ADDWFC x85,W
19686:  MOVWF  FEA
19688:  CLRF   FEF
1968A:  MOVLB  9
*
19728:  MOVLW  07
1972A:  ADDWF  x84,W
1972C:  MOVWF  FE9
1972E:  MOVLW  00
19730:  ADDWFC x85,W
19732:  MOVWF  FEA
19734:  CLRF   FEF
19736:  MOVLB  8
*
1AE1A:  MOVLW  07
1AE1C:  ADDWF  x84,W
1AE1E:  MOVWF  FE9
1AE20:  MOVLW  00
1AE22:  ADDWFC x85,W
1AE24:  MOVWF  FEA
1AE26:  CLRF   FEF
*
1AE88:  MOVLW  07
1AE8A:  ADDWF  x84,W
1AE8C:  MOVWF  FE9
1AE8E:  MOVLW  00
1AE90:  ADDWFC x85,W
1AE92:  MOVWF  FEA
1AE94:  CLRF   FEF
*
1AEF6:  MOVLW  07
1AEF8:  ADDWF  x84,W
1AEFA:  MOVWF  FE9
1AEFC:  MOVLW  00
1AEFE:  ADDWFC x85,W
1AF00:  MOVWF  FEA
1AF02:  CLRF   FEF
*
1AF64:  MOVLW  07
1AF66:  ADDWF  x84,W
1AF68:  MOVWF  FE9
1AF6A:  MOVLW  00
1AF6C:  ADDWFC x85,W
1AF6E:  MOVWF  FEA
1AF70:  CLRF   FEF
*
1AFD2:  MOVLW  07
1AFD4:  ADDWF  x84,W
1AFD6:  MOVWF  FE9
1AFD8:  MOVLW  00
1AFDA:  ADDWFC x85,W
1AFDC:  MOVWF  FEA
1AFDE:  CLRF   FEF
*
1B040:  MOVLW  07
1B042:  ADDWF  x84,W
1B044:  MOVWF  FE9
1B046:  MOVLW  00
1B048:  ADDWFC x85,W
1B04A:  MOVWF  FEA
1B04C:  CLRF   FEF
*
1B0AE:  MOVLW  07
1B0B0:  ADDWF  x84,W
1B0B2:  MOVWF  FE9
1B0B4:  MOVLW  00
1B0B6:  ADDWFC x85,W
1B0B8:  MOVWF  FEA
1B0BA:  CLRF   FEF
*
1B11C:  MOVLW  07
1B11E:  ADDWF  x84,W
1B120:  MOVWF  FE9
1B122:  MOVLW  00
1B124:  ADDWFC x85,W
1B126:  MOVWF  FEA
1B128:  CLRF   FEF
*
1B18A:  MOVLW  07
1B18C:  ADDWF  x84,W
1B18E:  MOVWF  FE9
1B190:  MOVLW  00
1B192:  ADDWFC x85,W
1B194:  MOVWF  FEA
1B196:  CLRF   FEF
*
1B5AE:  MOVLW  07
1B5B0:  ADDWF  x84,W
1B5B2:  MOVWF  FE9
1B5B4:  MOVLW  00
1B5B6:  ADDWFC x85,W
1B5B8:  MOVWF  FEA
1B5BA:  CLRF   FEF
*
1B62C:  MOVLW  07
1B62E:  ADDWF  x84,W
1B630:  MOVWF  FE9
1B632:  MOVLW  00
1B634:  ADDWFC x85,W
1B636:  MOVWF  FEA
1B638:  CLRF   FEF
*
1B6AA:  MOVLW  07
1B6AC:  ADDWF  x84,W
1B6AE:  MOVWF  FE9
1B6B0:  MOVLW  00
1B6B2:  ADDWFC x85,W
1B6B4:  MOVWF  FEA
1B6B6:  CLRF   FEF
*
1B728:  MOVLW  07
1B72A:  ADDWF  x84,W
1B72C:  MOVWF  FE9
1B72E:  MOVLW  00
1B730:  ADDWFC x85,W
1B732:  MOVWF  FEA
1B734:  CLRF   FEF
*
1B7A6:  MOVLW  07
1B7A8:  ADDWF  x84,W
1B7AA:  MOVWF  FE9
1B7AC:  MOVLW  00
1B7AE:  ADDWFC x85,W
1B7B0:  MOVWF  FEA
1B7B2:  CLRF   FEF
*
1B824:  MOVLW  07
1B826:  ADDWF  x84,W
1B828:  MOVWF  FE9
1B82A:  MOVLW  00
1B82C:  ADDWFC x85,W
1B82E:  MOVWF  FEA
1B830:  CLRF   FEF
*
1B8A2:  MOVLW  07
1B8A4:  ADDWF  x84,W
1B8A6:  MOVWF  FE9
1B8A8:  MOVLW  00
1B8AA:  ADDWFC x85,W
1B8AC:  MOVWF  FEA
1B8AE:  CLRF   FEF
*
1B920:  MOVLW  07
1B922:  ADDWF  x84,W
1B924:  MOVWF  FE9
1B926:  MOVLW  00
1B928:  ADDWFC x85,W
1B92A:  MOVWF  FEA
1B92C:  CLRF   FEF
*
1B99E:  MOVLW  07
1B9A0:  ADDWF  x84,W
1B9A2:  MOVWF  FE9
1B9A4:  MOVLW  00
1B9A6:  ADDWFC x85,W
1B9A8:  MOVWF  FEA
1B9AA:  CLRF   FEF
*
1BEF4:  MOVLW  07
1BEF6:  ADDWF  x84,W
1BEF8:  MOVWF  FE9
1BEFA:  MOVLW  00
1BEFC:  ADDWFC x85,W
1BEFE:  MOVWF  FEA
1BF00:  CLRF   FEF
1BF02:  MOVLB  0
.................... } 
....................  
.................... inline void check_string(uart* buffer) 
*
022E4:  CLRF   x86
*
02696:  CLRF   x86
*
02A48:  CLRF   x86
*
02DFC:  CLRF   x86
*
031B0:  CLRF   x86
*
03564:  CLRF   x86
*
03934:  CLRF   x86
*
03D12:  CLRF   x86
*
040E2:  CLRF   x86
*
1BCBA:  CLRF   x86
.................... { 
....................     unsigned int checksum = 0; 
....................     if (!buffer->standard) { 
*
022E6:  MOVLW  08
022E8:  ADDWF  x84,W
022EA:  MOVWF  FE9
022EC:  MOVLW  00
022EE:  ADDWFC x85,W
022F0:  MOVWF  FEA
022F2:  MOVF   FEF,F
022F4:  BNZ   2308
*
02698:  MOVLW  08
0269A:  ADDWF  x84,W
0269C:  MOVWF  FE9
0269E:  MOVLW  00
026A0:  ADDWFC x85,W
026A2:  MOVWF  FEA
026A4:  MOVF   FEF,F
026A6:  BNZ   26BA
*
02A4A:  MOVLW  08
02A4C:  ADDWF  x84,W
02A4E:  MOVWF  FE9
02A50:  MOVLW  00
02A52:  ADDWFC x85,W
02A54:  MOVWF  FEA
02A56:  MOVF   FEF,F
02A58:  BNZ   2A6C
*
02DFE:  MOVLW  08
02E00:  ADDWF  x84,W
02E02:  MOVWF  FE9
02E04:  MOVLW  00
02E06:  ADDWFC x85,W
02E08:  MOVWF  FEA
02E0A:  MOVF   FEF,F
02E0C:  BNZ   2E20
*
031B2:  MOVLW  08
031B4:  ADDWF  x84,W
031B6:  MOVWF  FE9
031B8:  MOVLW  00
031BA:  ADDWFC x85,W
031BC:  MOVWF  FEA
031BE:  MOVF   FEF,F
031C0:  BNZ   31D4
*
03566:  MOVLW  08
03568:  ADDWF  x84,W
0356A:  MOVWF  FE9
0356C:  MOVLW  00
0356E:  ADDWFC x85,W
03570:  MOVWF  FEA
03572:  MOVF   FEF,F
03574:  BNZ   3588
*
03936:  MOVLW  08
03938:  ADDWF  x84,W
0393A:  MOVWF  FE9
0393C:  MOVLW  00
0393E:  ADDWFC x85,W
03940:  MOVWF  FEA
03942:  MOVF   FEF,F
03944:  BNZ   3958
*
03D14:  MOVLW  08
03D16:  ADDWF  x84,W
03D18:  MOVWF  FE9
03D1A:  MOVLW  00
03D1C:  ADDWFC x85,W
03D1E:  MOVWF  FEA
03D20:  MOVF   FEF,F
03D22:  BNZ   3D36
*
040E4:  MOVLW  08
040E6:  ADDWF  x84,W
040E8:  MOVWF  FE9
040EA:  MOVLW  00
040EC:  ADDWFC x85,W
040EE:  MOVWF  FEA
040F0:  MOVF   FEF,F
040F2:  BNZ   4106
*
1BCBC:  MOVLW  08
1BCBE:  ADDWF  x84,W
1BCC0:  MOVWF  FE9
1BCC2:  MOVLW  00
1BCC4:  ADDWFC x85,W
1BCC6:  MOVWF  FEA
1BCC8:  MOVF   FEF,F
1BCCA:  BNZ   1BCDE
....................         buffer->state = ready; 
*
022F6:  MOVLW  07
022F8:  ADDWF  x84,W
022FA:  MOVWF  FE9
022FC:  MOVLW  00
022FE:  ADDWFC x85,W
02300:  MOVWF  FEA
02302:  MOVLW  02
02304:  MOVWF  FEF
*
026A8:  MOVLW  07
026AA:  ADDWF  x84,W
026AC:  MOVWF  FE9
026AE:  MOVLW  00
026B0:  ADDWFC x85,W
026B2:  MOVWF  FEA
026B4:  MOVLW  02
026B6:  MOVWF  FEF
*
02A5A:  MOVLW  07
02A5C:  ADDWF  x84,W
02A5E:  MOVWF  FE9
02A60:  MOVLW  00
02A62:  ADDWFC x85,W
02A64:  MOVWF  FEA
02A66:  MOVLW  02
02A68:  MOVWF  FEF
*
02E0E:  MOVLW  07
02E10:  ADDWF  x84,W
02E12:  MOVWF  FE9
02E14:  MOVLW  00
02E16:  ADDWFC x85,W
02E18:  MOVWF  FEA
02E1A:  MOVLW  02
02E1C:  MOVWF  FEF
*
031C2:  MOVLW  07
031C4:  ADDWF  x84,W
031C6:  MOVWF  FE9
031C8:  MOVLW  00
031CA:  ADDWFC x85,W
031CC:  MOVWF  FEA
031CE:  MOVLW  02
031D0:  MOVWF  FEF
*
03576:  MOVLW  07
03578:  ADDWF  x84,W
0357A:  MOVWF  FE9
0357C:  MOVLW  00
0357E:  ADDWFC x85,W
03580:  MOVWF  FEA
03582:  MOVLW  02
03584:  MOVWF  FEF
*
03946:  MOVLW  07
03948:  ADDWF  x84,W
0394A:  MOVWF  FE9
0394C:  MOVLW  00
0394E:  ADDWFC x85,W
03950:  MOVWF  FEA
03952:  MOVLW  02
03954:  MOVWF  FEF
*
03D24:  MOVLW  07
03D26:  ADDWF  x84,W
03D28:  MOVWF  FE9
03D2A:  MOVLW  00
03D2C:  ADDWFC x85,W
03D2E:  MOVWF  FEA
03D30:  MOVLW  02
03D32:  MOVWF  FEF
*
040F4:  MOVLW  07
040F6:  ADDWF  x84,W
040F8:  MOVWF  FE9
040FA:  MOVLW  00
040FC:  ADDWFC x85,W
040FE:  MOVWF  FEA
04100:  MOVLW  02
04102:  MOVWF  FEF
*
1BCCC:  MOVLW  07
1BCCE:  ADDWF  x84,W
1BCD0:  MOVWF  FE9
1BCD2:  MOVLW  00
1BCD4:  ADDWFC x85,W
1BCD6:  MOVWF  FEA
1BCD8:  MOVLW  02
1BCDA:  MOVWF  FEF
....................     } else { 
*
02306:  BRA    23FC
*
026B8:  BRA    27AE
*
02A6A:  BRA    2B60
*
02E1E:  BRA    2F14
*
031D2:  BRA    32C8
*
03586:  BRA    367C
*
03956:  BRA    3A4C
*
03D34:  BRA    3E2A
*
04104:  BRA    41FA
*
1BCDC:  BRA    1BDD2
....................         for (unsigned int* ptr = (buffer->data + 1); ptr < (buffer->end - 1); ptr++) { 
*
02308:  MOVFF  D84,FE9
0230C:  MOVFF  D85,FEA
02310:  MOVFF  FEC,D8A
02314:  MOVF   FED,F
02316:  MOVFF  FEF,D89
0231A:  MOVLW  01
0231C:  ADDWF  x89,W
0231E:  MOVWF  x87
02320:  MOVLW  00
02322:  ADDWFC x8A,W
02324:  MOVWF  x88
02326:  MOVLW  05
02328:  ADDWF  x84,W
0232A:  MOVWF  FE9
0232C:  MOVLW  00
0232E:  ADDWFC x85,W
02330:  MOVWF  FEA
02332:  MOVFF  FEC,D8A
02336:  MOVF   FED,F
02338:  MOVFF  FEF,D89
0233C:  MOVLW  01
0233E:  SUBWF  x89,W
02340:  MOVWF  00
02342:  MOVLW  00
02344:  SUBWFB x8A,W
02346:  MOVWF  03
02348:  MOVFF  00,01
0234C:  MOVF   x88,W
0234E:  SUBWF  03,W
02350:  BNC   236E
02352:  BNZ   235A
02354:  MOVF   01,W
02356:  SUBWF  x87,W
02358:  BC    236E
*
026BA:  MOVFF  D84,FE9
026BE:  MOVFF  D85,FEA
026C2:  MOVFF  FEC,D8A
026C6:  MOVF   FED,F
026C8:  MOVFF  FEF,D89
026CC:  MOVLW  01
026CE:  ADDWF  x89,W
026D0:  MOVWF  x87
026D2:  MOVLW  00
026D4:  ADDWFC x8A,W
026D6:  MOVWF  x88
026D8:  MOVLW  05
026DA:  ADDWF  x84,W
026DC:  MOVWF  FE9
026DE:  MOVLW  00
026E0:  ADDWFC x85,W
026E2:  MOVWF  FEA
026E4:  MOVFF  FEC,D8A
026E8:  MOVF   FED,F
026EA:  MOVFF  FEF,D89
026EE:  MOVLW  01
026F0:  SUBWF  x89,W
026F2:  MOVWF  00
026F4:  MOVLW  00
026F6:  SUBWFB x8A,W
026F8:  MOVWF  03
026FA:  MOVFF  00,01
026FE:  MOVF   x88,W
02700:  SUBWF  03,W
02702:  BNC   2720
02704:  BNZ   270C
02706:  MOVF   01,W
02708:  SUBWF  x87,W
0270A:  BC    2720
*
02A6C:  MOVFF  D84,FE9
02A70:  MOVFF  D85,FEA
02A74:  MOVFF  FEC,D8A
02A78:  MOVF   FED,F
02A7A:  MOVFF  FEF,D89
02A7E:  MOVLW  01
02A80:  ADDWF  x89,W
02A82:  MOVWF  x87
02A84:  MOVLW  00
02A86:  ADDWFC x8A,W
02A88:  MOVWF  x88
02A8A:  MOVLW  05
02A8C:  ADDWF  x84,W
02A8E:  MOVWF  FE9
02A90:  MOVLW  00
02A92:  ADDWFC x85,W
02A94:  MOVWF  FEA
02A96:  MOVFF  FEC,D8A
02A9A:  MOVF   FED,F
02A9C:  MOVFF  FEF,D89
02AA0:  MOVLW  01
02AA2:  SUBWF  x89,W
02AA4:  MOVWF  00
02AA6:  MOVLW  00
02AA8:  SUBWFB x8A,W
02AAA:  MOVWF  03
02AAC:  MOVFF  00,01
02AB0:  MOVF   x88,W
02AB2:  SUBWF  03,W
02AB4:  BNC   2AD2
02AB6:  BNZ   2ABE
02AB8:  MOVF   01,W
02ABA:  SUBWF  x87,W
02ABC:  BC    2AD2
*
02E20:  MOVFF  D84,FE9
02E24:  MOVFF  D85,FEA
02E28:  MOVFF  FEC,D8A
02E2C:  MOVF   FED,F
02E2E:  MOVFF  FEF,D89
02E32:  MOVLW  01
02E34:  ADDWF  x89,W
02E36:  MOVWF  x87
02E38:  MOVLW  00
02E3A:  ADDWFC x8A,W
02E3C:  MOVWF  x88
02E3E:  MOVLW  05
02E40:  ADDWF  x84,W
02E42:  MOVWF  FE9
02E44:  MOVLW  00
02E46:  ADDWFC x85,W
02E48:  MOVWF  FEA
02E4A:  MOVFF  FEC,D8A
02E4E:  MOVF   FED,F
02E50:  MOVFF  FEF,D89
02E54:  MOVLW  01
02E56:  SUBWF  x89,W
02E58:  MOVWF  00
02E5A:  MOVLW  00
02E5C:  SUBWFB x8A,W
02E5E:  MOVWF  03
02E60:  MOVFF  00,01
02E64:  MOVF   x88,W
02E66:  SUBWF  03,W
02E68:  BNC   2E86
02E6A:  BNZ   2E72
02E6C:  MOVF   01,W
02E6E:  SUBWF  x87,W
02E70:  BC    2E86
*
031D4:  MOVFF  D84,FE9
031D8:  MOVFF  D85,FEA
031DC:  MOVFF  FEC,D8A
031E0:  MOVF   FED,F
031E2:  MOVFF  FEF,D89
031E6:  MOVLW  01
031E8:  ADDWF  x89,W
031EA:  MOVWF  x87
031EC:  MOVLW  00
031EE:  ADDWFC x8A,W
031F0:  MOVWF  x88
031F2:  MOVLW  05
031F4:  ADDWF  x84,W
031F6:  MOVWF  FE9
031F8:  MOVLW  00
031FA:  ADDWFC x85,W
031FC:  MOVWF  FEA
031FE:  MOVFF  FEC,D8A
03202:  MOVF   FED,F
03204:  MOVFF  FEF,D89
03208:  MOVLW  01
0320A:  SUBWF  x89,W
0320C:  MOVWF  00
0320E:  MOVLW  00
03210:  SUBWFB x8A,W
03212:  MOVWF  03
03214:  MOVFF  00,01
03218:  MOVF   x88,W
0321A:  SUBWF  03,W
0321C:  BNC   323A
0321E:  BNZ   3226
03220:  MOVF   01,W
03222:  SUBWF  x87,W
03224:  BC    323A
*
03588:  MOVFF  D84,FE9
0358C:  MOVFF  D85,FEA
03590:  MOVFF  FEC,D8A
03594:  MOVF   FED,F
03596:  MOVFF  FEF,D89
0359A:  MOVLW  01
0359C:  ADDWF  x89,W
0359E:  MOVWF  x87
035A0:  MOVLW  00
035A2:  ADDWFC x8A,W
035A4:  MOVWF  x88
035A6:  MOVLW  05
035A8:  ADDWF  x84,W
035AA:  MOVWF  FE9
035AC:  MOVLW  00
035AE:  ADDWFC x85,W
035B0:  MOVWF  FEA
035B2:  MOVFF  FEC,D8A
035B6:  MOVF   FED,F
035B8:  MOVFF  FEF,D89
035BC:  MOVLW  01
035BE:  SUBWF  x89,W
035C0:  MOVWF  00
035C2:  MOVLW  00
035C4:  SUBWFB x8A,W
035C6:  MOVWF  03
035C8:  MOVFF  00,01
035CC:  MOVF   x88,W
035CE:  SUBWF  03,W
035D0:  BNC   35EE
035D2:  BNZ   35DA
035D4:  MOVF   01,W
035D6:  SUBWF  x87,W
035D8:  BC    35EE
*
03958:  MOVFF  D84,FE9
0395C:  MOVFF  D85,FEA
03960:  MOVFF  FEC,D8A
03964:  MOVF   FED,F
03966:  MOVFF  FEF,D89
0396A:  MOVLW  01
0396C:  ADDWF  x89,W
0396E:  MOVWF  x87
03970:  MOVLW  00
03972:  ADDWFC x8A,W
03974:  MOVWF  x88
03976:  MOVLW  05
03978:  ADDWF  x84,W
0397A:  MOVWF  FE9
0397C:  MOVLW  00
0397E:  ADDWFC x85,W
03980:  MOVWF  FEA
03982:  MOVFF  FEC,D8A
03986:  MOVF   FED,F
03988:  MOVFF  FEF,D89
0398C:  MOVLW  01
0398E:  SUBWF  x89,W
03990:  MOVWF  00
03992:  MOVLW  00
03994:  SUBWFB x8A,W
03996:  MOVWF  03
03998:  MOVFF  00,01
0399C:  MOVF   x88,W
0399E:  SUBWF  03,W
039A0:  BNC   39BE
039A2:  BNZ   39AA
039A4:  MOVF   01,W
039A6:  SUBWF  x87,W
039A8:  BC    39BE
*
03D36:  MOVFF  D84,FE9
03D3A:  MOVFF  D85,FEA
03D3E:  MOVFF  FEC,D8A
03D42:  MOVF   FED,F
03D44:  MOVFF  FEF,D89
03D48:  MOVLW  01
03D4A:  ADDWF  x89,W
03D4C:  MOVWF  x87
03D4E:  MOVLW  00
03D50:  ADDWFC x8A,W
03D52:  MOVWF  x88
03D54:  MOVLW  05
03D56:  ADDWF  x84,W
03D58:  MOVWF  FE9
03D5A:  MOVLW  00
03D5C:  ADDWFC x85,W
03D5E:  MOVWF  FEA
03D60:  MOVFF  FEC,D8A
03D64:  MOVF   FED,F
03D66:  MOVFF  FEF,D89
03D6A:  MOVLW  01
03D6C:  SUBWF  x89,W
03D6E:  MOVWF  00
03D70:  MOVLW  00
03D72:  SUBWFB x8A,W
03D74:  MOVWF  03
03D76:  MOVFF  00,01
03D7A:  MOVF   x88,W
03D7C:  SUBWF  03,W
03D7E:  BNC   3D9C
03D80:  BNZ   3D88
03D82:  MOVF   01,W
03D84:  SUBWF  x87,W
03D86:  BC    3D9C
*
04106:  MOVFF  D84,FE9
0410A:  MOVFF  D85,FEA
0410E:  MOVFF  FEC,D8A
04112:  MOVF   FED,F
04114:  MOVFF  FEF,D89
04118:  MOVLW  01
0411A:  ADDWF  x89,W
0411C:  MOVWF  x87
0411E:  MOVLW  00
04120:  ADDWFC x8A,W
04122:  MOVWF  x88
04124:  MOVLW  05
04126:  ADDWF  x84,W
04128:  MOVWF  FE9
0412A:  MOVLW  00
0412C:  ADDWFC x85,W
0412E:  MOVWF  FEA
04130:  MOVFF  FEC,D8A
04134:  MOVF   FED,F
04136:  MOVFF  FEF,D89
0413A:  MOVLW  01
0413C:  SUBWF  x89,W
0413E:  MOVWF  00
04140:  MOVLW  00
04142:  SUBWFB x8A,W
04144:  MOVWF  03
04146:  MOVFF  00,01
0414A:  MOVF   x88,W
0414C:  SUBWF  03,W
0414E:  BNC   416C
04150:  BNZ   4158
04152:  MOVF   01,W
04154:  SUBWF  x87,W
04156:  BC    416C
*
1BCDE:  MOVFF  D84,FE9
1BCE2:  MOVFF  D85,FEA
1BCE6:  MOVFF  FEC,D8A
1BCEA:  MOVF   FED,F
1BCEC:  MOVFF  FEF,D89
1BCF0:  MOVLW  01
1BCF2:  ADDWF  x89,W
1BCF4:  MOVWF  x87
1BCF6:  MOVLW  00
1BCF8:  ADDWFC x8A,W
1BCFA:  MOVWF  x88
1BCFC:  MOVLW  05
1BCFE:  ADDWF  x84,W
1BD00:  MOVWF  FE9
1BD02:  MOVLW  00
1BD04:  ADDWFC x85,W
1BD06:  MOVWF  FEA
1BD08:  MOVFF  FEC,D8A
1BD0C:  MOVF   FED,F
1BD0E:  MOVFF  FEF,D89
1BD12:  MOVLW  01
1BD14:  SUBWF  x89,W
1BD16:  MOVWF  00
1BD18:  MOVLW  00
1BD1A:  SUBWFB x8A,W
1BD1C:  MOVWF  03
1BD1E:  MOVFF  00,01
1BD22:  MOVF   x88,W
1BD24:  SUBWF  03,W
1BD26:  BNC   1BD44
1BD28:  BNZ   1BD30
1BD2A:  MOVF   01,W
1BD2C:  SUBWF  x87,W
1BD2E:  BC    1BD44
....................             checksum ^= *ptr; 
*
0235A:  MOVFF  D87,FE9
0235E:  MOVFF  D88,FEA
02362:  MOVF   FEF,W
02364:  XORWF  x86,F
02366:  INCF   x87,F
02368:  BTFSC  FD8.2
0236A:  INCF   x88,F
0236C:  BRA    2326
*
0270C:  MOVFF  D87,FE9
02710:  MOVFF  D88,FEA
02714:  MOVF   FEF,W
02716:  XORWF  x86,F
02718:  INCF   x87,F
0271A:  BTFSC  FD8.2
0271C:  INCF   x88,F
0271E:  BRA    26D8
*
02ABE:  MOVFF  D87,FE9
02AC2:  MOVFF  D88,FEA
02AC6:  MOVF   FEF,W
02AC8:  XORWF  x86,F
02ACA:  INCF   x87,F
02ACC:  BTFSC  FD8.2
02ACE:  INCF   x88,F
02AD0:  BRA    2A8A
*
02E72:  MOVFF  D87,FE9
02E76:  MOVFF  D88,FEA
02E7A:  MOVF   FEF,W
02E7C:  XORWF  x86,F
02E7E:  INCF   x87,F
02E80:  BTFSC  FD8.2
02E82:  INCF   x88,F
02E84:  BRA    2E3E
*
03226:  MOVFF  D87,FE9
0322A:  MOVFF  D88,FEA
0322E:  MOVF   FEF,W
03230:  XORWF  x86,F
03232:  INCF   x87,F
03234:  BTFSC  FD8.2
03236:  INCF   x88,F
03238:  BRA    31F2
*
035DA:  MOVFF  D87,FE9
035DE:  MOVFF  D88,FEA
035E2:  MOVF   FEF,W
035E4:  XORWF  x86,F
035E6:  INCF   x87,F
035E8:  BTFSC  FD8.2
035EA:  INCF   x88,F
035EC:  BRA    35A6
*
039AA:  MOVFF  D87,FE9
039AE:  MOVFF  D88,FEA
039B2:  MOVF   FEF,W
039B4:  XORWF  x86,F
039B6:  INCF   x87,F
039B8:  BTFSC  FD8.2
039BA:  INCF   x88,F
039BC:  BRA    3976
*
03D88:  MOVFF  D87,FE9
03D8C:  MOVFF  D88,FEA
03D90:  MOVF   FEF,W
03D92:  XORWF  x86,F
03D94:  INCF   x87,F
03D96:  BTFSC  FD8.2
03D98:  INCF   x88,F
03D9A:  BRA    3D54
*
04158:  MOVFF  D87,FE9
0415C:  MOVFF  D88,FEA
04160:  MOVF   FEF,W
04162:  XORWF  x86,F
04164:  INCF   x87,F
04166:  BTFSC  FD8.2
04168:  INCF   x88,F
0416A:  BRA    4124
*
1BD30:  MOVFF  D87,FE9
1BD34:  MOVFF  D88,FEA
1BD38:  MOVF   FEF,W
1BD3A:  XORWF  x86,F
1BD3C:  INCF   x87,F
1BD3E:  BTFSC  FD8.2
1BD40:  INCF   x88,F
1BD42:  BRA    1BCFC
....................         } 
....................         if ((*(buffer->position - 1) == checksum) && (*buffer->position == buffer->data[0] + 1)) { 
*
0236E:  MOVLW  03
02370:  ADDWF  x84,W
02372:  MOVWF  FE9
02374:  MOVLW  00
02376:  ADDWFC x85,W
02378:  MOVWF  FEA
0237A:  MOVFF  FEC,D8A
0237E:  MOVF   FED,F
02380:  MOVFF  FEF,D89
02384:  MOVLW  01
02386:  SUBWF  x89,W
02388:  MOVWF  00
0238A:  MOVLW  00
0238C:  SUBWFB x8A,W
0238E:  MOVWF  03
02390:  MOVFF  00,FE9
02394:  MOVWF  FEA
02396:  MOVF   x86,W
02398:  SUBWF  FEF,W
0239A:  BNZ   23EE
0239C:  MOVLW  03
0239E:  ADDWF  x84,W
023A0:  MOVWF  FE9
023A2:  MOVLW  00
023A4:  ADDWFC x85,W
023A6:  MOVWF  FEA
023A8:  MOVFF  FEC,03
023AC:  MOVF   FED,F
023AE:  MOVFF  FEF,FE9
023B2:  MOVFF  03,FEA
023B6:  MOVFF  FEF,D89
023BA:  MOVFF  D84,FE9
023BE:  MOVFF  D85,FEA
023C2:  MOVFF  FEC,D8B
023C6:  MOVF   FED,F
023C8:  MOVFF  FEF,D8A
023CC:  MOVFF  D8A,FE9
023D0:  MOVFF  D8B,FEA
023D4:  MOVLW  01
023D6:  ADDWF  FEF,W
023D8:  SUBWF  x89,W
023DA:  BNZ   23EE
*
02720:  MOVLW  03
02722:  ADDWF  x84,W
02724:  MOVWF  FE9
02726:  MOVLW  00
02728:  ADDWFC x85,W
0272A:  MOVWF  FEA
0272C:  MOVFF  FEC,D8A
02730:  MOVF   FED,F
02732:  MOVFF  FEF,D89
02736:  MOVLW  01
02738:  SUBWF  x89,W
0273A:  MOVWF  00
0273C:  MOVLW  00
0273E:  SUBWFB x8A,W
02740:  MOVWF  03
02742:  MOVFF  00,FE9
02746:  MOVWF  FEA
02748:  MOVF   x86,W
0274A:  SUBWF  FEF,W
0274C:  BNZ   27A0
0274E:  MOVLW  03
02750:  ADDWF  x84,W
02752:  MOVWF  FE9
02754:  MOVLW  00
02756:  ADDWFC x85,W
02758:  MOVWF  FEA
0275A:  MOVFF  FEC,03
0275E:  MOVF   FED,F
02760:  MOVFF  FEF,FE9
02764:  MOVFF  03,FEA
02768:  MOVFF  FEF,D89
0276C:  MOVFF  D84,FE9
02770:  MOVFF  D85,FEA
02774:  MOVFF  FEC,D8B
02778:  MOVF   FED,F
0277A:  MOVFF  FEF,D8A
0277E:  MOVFF  D8A,FE9
02782:  MOVFF  D8B,FEA
02786:  MOVLW  01
02788:  ADDWF  FEF,W
0278A:  SUBWF  x89,W
0278C:  BNZ   27A0
*
02AD2:  MOVLW  03
02AD4:  ADDWF  x84,W
02AD6:  MOVWF  FE9
02AD8:  MOVLW  00
02ADA:  ADDWFC x85,W
02ADC:  MOVWF  FEA
02ADE:  MOVFF  FEC,D8A
02AE2:  MOVF   FED,F
02AE4:  MOVFF  FEF,D89
02AE8:  MOVLW  01
02AEA:  SUBWF  x89,W
02AEC:  MOVWF  00
02AEE:  MOVLW  00
02AF0:  SUBWFB x8A,W
02AF2:  MOVWF  03
02AF4:  MOVFF  00,FE9
02AF8:  MOVWF  FEA
02AFA:  MOVF   x86,W
02AFC:  SUBWF  FEF,W
02AFE:  BNZ   2B52
02B00:  MOVLW  03
02B02:  ADDWF  x84,W
02B04:  MOVWF  FE9
02B06:  MOVLW  00
02B08:  ADDWFC x85,W
02B0A:  MOVWF  FEA
02B0C:  MOVFF  FEC,03
02B10:  MOVF   FED,F
02B12:  MOVFF  FEF,FE9
02B16:  MOVFF  03,FEA
02B1A:  MOVFF  FEF,D89
02B1E:  MOVFF  D84,FE9
02B22:  MOVFF  D85,FEA
02B26:  MOVFF  FEC,D8B
02B2A:  MOVF   FED,F
02B2C:  MOVFF  FEF,D8A
02B30:  MOVFF  D8A,FE9
02B34:  MOVFF  D8B,FEA
02B38:  MOVLW  01
02B3A:  ADDWF  FEF,W
02B3C:  SUBWF  x89,W
02B3E:  BNZ   2B52
*
02E86:  MOVLW  03
02E88:  ADDWF  x84,W
02E8A:  MOVWF  FE9
02E8C:  MOVLW  00
02E8E:  ADDWFC x85,W
02E90:  MOVWF  FEA
02E92:  MOVFF  FEC,D8A
02E96:  MOVF   FED,F
02E98:  MOVFF  FEF,D89
02E9C:  MOVLW  01
02E9E:  SUBWF  x89,W
02EA0:  MOVWF  00
02EA2:  MOVLW  00
02EA4:  SUBWFB x8A,W
02EA6:  MOVWF  03
02EA8:  MOVFF  00,FE9
02EAC:  MOVWF  FEA
02EAE:  MOVF   x86,W
02EB0:  SUBWF  FEF,W
02EB2:  BNZ   2F06
02EB4:  MOVLW  03
02EB6:  ADDWF  x84,W
02EB8:  MOVWF  FE9
02EBA:  MOVLW  00
02EBC:  ADDWFC x85,W
02EBE:  MOVWF  FEA
02EC0:  MOVFF  FEC,03
02EC4:  MOVF   FED,F
02EC6:  MOVFF  FEF,FE9
02ECA:  MOVFF  03,FEA
02ECE:  MOVFF  FEF,D89
02ED2:  MOVFF  D84,FE9
02ED6:  MOVFF  D85,FEA
02EDA:  MOVFF  FEC,D8B
02EDE:  MOVF   FED,F
02EE0:  MOVFF  FEF,D8A
02EE4:  MOVFF  D8A,FE9
02EE8:  MOVFF  D8B,FEA
02EEC:  MOVLW  01
02EEE:  ADDWF  FEF,W
02EF0:  SUBWF  x89,W
02EF2:  BNZ   2F06
*
0323A:  MOVLW  03
0323C:  ADDWF  x84,W
0323E:  MOVWF  FE9
03240:  MOVLW  00
03242:  ADDWFC x85,W
03244:  MOVWF  FEA
03246:  MOVFF  FEC,D8A
0324A:  MOVF   FED,F
0324C:  MOVFF  FEF,D89
03250:  MOVLW  01
03252:  SUBWF  x89,W
03254:  MOVWF  00
03256:  MOVLW  00
03258:  SUBWFB x8A,W
0325A:  MOVWF  03
0325C:  MOVFF  00,FE9
03260:  MOVWF  FEA
03262:  MOVF   x86,W
03264:  SUBWF  FEF,W
03266:  BNZ   32BA
03268:  MOVLW  03
0326A:  ADDWF  x84,W
0326C:  MOVWF  FE9
0326E:  MOVLW  00
03270:  ADDWFC x85,W
03272:  MOVWF  FEA
03274:  MOVFF  FEC,03
03278:  MOVF   FED,F
0327A:  MOVFF  FEF,FE9
0327E:  MOVFF  03,FEA
03282:  MOVFF  FEF,D89
03286:  MOVFF  D84,FE9
0328A:  MOVFF  D85,FEA
0328E:  MOVFF  FEC,D8B
03292:  MOVF   FED,F
03294:  MOVFF  FEF,D8A
03298:  MOVFF  D8A,FE9
0329C:  MOVFF  D8B,FEA
032A0:  MOVLW  01
032A2:  ADDWF  FEF,W
032A4:  SUBWF  x89,W
032A6:  BNZ   32BA
*
035EE:  MOVLW  03
035F0:  ADDWF  x84,W
035F2:  MOVWF  FE9
035F4:  MOVLW  00
035F6:  ADDWFC x85,W
035F8:  MOVWF  FEA
035FA:  MOVFF  FEC,D8A
035FE:  MOVF   FED,F
03600:  MOVFF  FEF,D89
03604:  MOVLW  01
03606:  SUBWF  x89,W
03608:  MOVWF  00
0360A:  MOVLW  00
0360C:  SUBWFB x8A,W
0360E:  MOVWF  03
03610:  MOVFF  00,FE9
03614:  MOVWF  FEA
03616:  MOVF   x86,W
03618:  SUBWF  FEF,W
0361A:  BNZ   366E
0361C:  MOVLW  03
0361E:  ADDWF  x84,W
03620:  MOVWF  FE9
03622:  MOVLW  00
03624:  ADDWFC x85,W
03626:  MOVWF  FEA
03628:  MOVFF  FEC,03
0362C:  MOVF   FED,F
0362E:  MOVFF  FEF,FE9
03632:  MOVFF  03,FEA
03636:  MOVFF  FEF,D89
0363A:  MOVFF  D84,FE9
0363E:  MOVFF  D85,FEA
03642:  MOVFF  FEC,D8B
03646:  MOVF   FED,F
03648:  MOVFF  FEF,D8A
0364C:  MOVFF  D8A,FE9
03650:  MOVFF  D8B,FEA
03654:  MOVLW  01
03656:  ADDWF  FEF,W
03658:  SUBWF  x89,W
0365A:  BNZ   366E
*
039BE:  MOVLW  03
039C0:  ADDWF  x84,W
039C2:  MOVWF  FE9
039C4:  MOVLW  00
039C6:  ADDWFC x85,W
039C8:  MOVWF  FEA
039CA:  MOVFF  FEC,D8A
039CE:  MOVF   FED,F
039D0:  MOVFF  FEF,D89
039D4:  MOVLW  01
039D6:  SUBWF  x89,W
039D8:  MOVWF  00
039DA:  MOVLW  00
039DC:  SUBWFB x8A,W
039DE:  MOVWF  03
039E0:  MOVFF  00,FE9
039E4:  MOVWF  FEA
039E6:  MOVF   x86,W
039E8:  SUBWF  FEF,W
039EA:  BNZ   3A3E
039EC:  MOVLW  03
039EE:  ADDWF  x84,W
039F0:  MOVWF  FE9
039F2:  MOVLW  00
039F4:  ADDWFC x85,W
039F6:  MOVWF  FEA
039F8:  MOVFF  FEC,03
039FC:  MOVF   FED,F
039FE:  MOVFF  FEF,FE9
03A02:  MOVFF  03,FEA
03A06:  MOVFF  FEF,D89
03A0A:  MOVFF  D84,FE9
03A0E:  MOVFF  D85,FEA
03A12:  MOVFF  FEC,D8B
03A16:  MOVF   FED,F
03A18:  MOVFF  FEF,D8A
03A1C:  MOVFF  D8A,FE9
03A20:  MOVFF  D8B,FEA
03A24:  MOVLW  01
03A26:  ADDWF  FEF,W
03A28:  SUBWF  x89,W
03A2A:  BNZ   3A3E
*
03D9C:  MOVLW  03
03D9E:  ADDWF  x84,W
03DA0:  MOVWF  FE9
03DA2:  MOVLW  00
03DA4:  ADDWFC x85,W
03DA6:  MOVWF  FEA
03DA8:  MOVFF  FEC,D8A
03DAC:  MOVF   FED,F
03DAE:  MOVFF  FEF,D89
03DB2:  MOVLW  01
03DB4:  SUBWF  x89,W
03DB6:  MOVWF  00
03DB8:  MOVLW  00
03DBA:  SUBWFB x8A,W
03DBC:  MOVWF  03
03DBE:  MOVFF  00,FE9
03DC2:  MOVWF  FEA
03DC4:  MOVF   x86,W
03DC6:  SUBWF  FEF,W
03DC8:  BNZ   3E1C
03DCA:  MOVLW  03
03DCC:  ADDWF  x84,W
03DCE:  MOVWF  FE9
03DD0:  MOVLW  00
03DD2:  ADDWFC x85,W
03DD4:  MOVWF  FEA
03DD6:  MOVFF  FEC,03
03DDA:  MOVF   FED,F
03DDC:  MOVFF  FEF,FE9
03DE0:  MOVFF  03,FEA
03DE4:  MOVFF  FEF,D89
03DE8:  MOVFF  D84,FE9
03DEC:  MOVFF  D85,FEA
03DF0:  MOVFF  FEC,D8B
03DF4:  MOVF   FED,F
03DF6:  MOVFF  FEF,D8A
03DFA:  MOVFF  D8A,FE9
03DFE:  MOVFF  D8B,FEA
03E02:  MOVLW  01
03E04:  ADDWF  FEF,W
03E06:  SUBWF  x89,W
03E08:  BNZ   3E1C
*
0416C:  MOVLW  03
0416E:  ADDWF  x84,W
04170:  MOVWF  FE9
04172:  MOVLW  00
04174:  ADDWFC x85,W
04176:  MOVWF  FEA
04178:  MOVFF  FEC,D8A
0417C:  MOVF   FED,F
0417E:  MOVFF  FEF,D89
04182:  MOVLW  01
04184:  SUBWF  x89,W
04186:  MOVWF  00
04188:  MOVLW  00
0418A:  SUBWFB x8A,W
0418C:  MOVWF  03
0418E:  MOVFF  00,FE9
04192:  MOVWF  FEA
04194:  MOVF   x86,W
04196:  SUBWF  FEF,W
04198:  BNZ   41EC
0419A:  MOVLW  03
0419C:  ADDWF  x84,W
0419E:  MOVWF  FE9
041A0:  MOVLW  00
041A2:  ADDWFC x85,W
041A4:  MOVWF  FEA
041A6:  MOVFF  FEC,03
041AA:  MOVF   FED,F
041AC:  MOVFF  FEF,FE9
041B0:  MOVFF  03,FEA
041B4:  MOVFF  FEF,D89
041B8:  MOVFF  D84,FE9
041BC:  MOVFF  D85,FEA
041C0:  MOVFF  FEC,D8B
041C4:  MOVF   FED,F
041C6:  MOVFF  FEF,D8A
041CA:  MOVFF  D8A,FE9
041CE:  MOVFF  D8B,FEA
041D2:  MOVLW  01
041D4:  ADDWF  FEF,W
041D6:  SUBWF  x89,W
041D8:  BNZ   41EC
*
1BD44:  MOVLW  03
1BD46:  ADDWF  x84,W
1BD48:  MOVWF  FE9
1BD4A:  MOVLW  00
1BD4C:  ADDWFC x85,W
1BD4E:  MOVWF  FEA
1BD50:  MOVFF  FEC,D8A
1BD54:  MOVF   FED,F
1BD56:  MOVFF  FEF,D89
1BD5A:  MOVLW  01
1BD5C:  SUBWF  x89,W
1BD5E:  MOVWF  00
1BD60:  MOVLW  00
1BD62:  SUBWFB x8A,W
1BD64:  MOVWF  03
1BD66:  MOVFF  00,FE9
1BD6A:  MOVWF  FEA
1BD6C:  MOVF   x86,W
1BD6E:  SUBWF  FEF,W
1BD70:  BNZ   1BDC4
1BD72:  MOVLW  03
1BD74:  ADDWF  x84,W
1BD76:  MOVWF  FE9
1BD78:  MOVLW  00
1BD7A:  ADDWFC x85,W
1BD7C:  MOVWF  FEA
1BD7E:  MOVFF  FEC,03
1BD82:  MOVF   FED,F
1BD84:  MOVFF  FEF,FE9
1BD88:  MOVFF  03,FEA
1BD8C:  MOVFF  FEF,D89
1BD90:  MOVFF  D84,FE9
1BD94:  MOVFF  D85,FEA
1BD98:  MOVFF  FEC,D8B
1BD9C:  MOVF   FED,F
1BD9E:  MOVFF  FEF,D8A
1BDA2:  MOVFF  D8A,FE9
1BDA6:  MOVFF  D8B,FEA
1BDAA:  MOVLW  01
1BDAC:  ADDWF  FEF,W
1BDAE:  SUBWF  x89,W
1BDB0:  BNZ   1BDC4
....................             buffer->state = ready; 
*
023DC:  MOVLW  07
023DE:  ADDWF  x84,W
023E0:  MOVWF  FE9
023E2:  MOVLW  00
023E4:  ADDWFC x85,W
023E6:  MOVWF  FEA
023E8:  MOVLW  02
023EA:  MOVWF  FEF
*
0278E:  MOVLW  07
02790:  ADDWF  x84,W
02792:  MOVWF  FE9
02794:  MOVLW  00
02796:  ADDWFC x85,W
02798:  MOVWF  FEA
0279A:  MOVLW  02
0279C:  MOVWF  FEF
*
02B40:  MOVLW  07
02B42:  ADDWF  x84,W
02B44:  MOVWF  FE9
02B46:  MOVLW  00
02B48:  ADDWFC x85,W
02B4A:  MOVWF  FEA
02B4C:  MOVLW  02
02B4E:  MOVWF  FEF
*
02EF4:  MOVLW  07
02EF6:  ADDWF  x84,W
02EF8:  MOVWF  FE9
02EFA:  MOVLW  00
02EFC:  ADDWFC x85,W
02EFE:  MOVWF  FEA
02F00:  MOVLW  02
02F02:  MOVWF  FEF
*
032A8:  MOVLW  07
032AA:  ADDWF  x84,W
032AC:  MOVWF  FE9
032AE:  MOVLW  00
032B0:  ADDWFC x85,W
032B2:  MOVWF  FEA
032B4:  MOVLW  02
032B6:  MOVWF  FEF
*
0365C:  MOVLW  07
0365E:  ADDWF  x84,W
03660:  MOVWF  FE9
03662:  MOVLW  00
03664:  ADDWFC x85,W
03666:  MOVWF  FEA
03668:  MOVLW  02
0366A:  MOVWF  FEF
*
03A2C:  MOVLW  07
03A2E:  ADDWF  x84,W
03A30:  MOVWF  FE9
03A32:  MOVLW  00
03A34:  ADDWFC x85,W
03A36:  MOVWF  FEA
03A38:  MOVLW  02
03A3A:  MOVWF  FEF
*
03E0A:  MOVLW  07
03E0C:  ADDWF  x84,W
03E0E:  MOVWF  FE9
03E10:  MOVLW  00
03E12:  ADDWFC x85,W
03E14:  MOVWF  FEA
03E16:  MOVLW  02
03E18:  MOVWF  FEF
*
041DA:  MOVLW  07
041DC:  ADDWF  x84,W
041DE:  MOVWF  FE9
041E0:  MOVLW  00
041E2:  ADDWFC x85,W
041E4:  MOVWF  FEA
041E6:  MOVLW  02
041E8:  MOVWF  FEF
*
1BDB2:  MOVLW  07
1BDB4:  ADDWF  x84,W
1BDB6:  MOVWF  FE9
1BDB8:  MOVLW  00
1BDBA:  ADDWFC x85,W
1BDBC:  MOVWF  FEA
1BDBE:  MOVLW  02
1BDC0:  MOVWF  FEF
....................         } else { 
*
023EC:  BRA    23FC
*
0279E:  BRA    27AE
*
02B50:  BRA    2B60
*
02F04:  BRA    2F14
*
032B8:  BRA    32C8
*
0366C:  BRA    367C
*
03A3C:  BRA    3A4C
*
03E1A:  BRA    3E2A
*
041EA:  BRA    41FA
*
1BDC2:  BRA    1BDD2
....................             buffer->state = waiting; 
*
023EE:  MOVLW  07
023F0:  ADDWF  x84,W
023F2:  MOVWF  FE9
023F4:  MOVLW  00
023F6:  ADDWFC x85,W
023F8:  MOVWF  FEA
023FA:  CLRF   FEF
*
027A0:  MOVLW  07
027A2:  ADDWF  x84,W
027A4:  MOVWF  FE9
027A6:  MOVLW  00
027A8:  ADDWFC x85,W
027AA:  MOVWF  FEA
027AC:  CLRF   FEF
*
02B52:  MOVLW  07
02B54:  ADDWF  x84,W
02B56:  MOVWF  FE9
02B58:  MOVLW  00
02B5A:  ADDWFC x85,W
02B5C:  MOVWF  FEA
02B5E:  CLRF   FEF
*
02F06:  MOVLW  07
02F08:  ADDWF  x84,W
02F0A:  MOVWF  FE9
02F0C:  MOVLW  00
02F0E:  ADDWFC x85,W
02F10:  MOVWF  FEA
02F12:  CLRF   FEF
*
032BA:  MOVLW  07
032BC:  ADDWF  x84,W
032BE:  MOVWF  FE9
032C0:  MOVLW  00
032C2:  ADDWFC x85,W
032C4:  MOVWF  FEA
032C6:  CLRF   FEF
*
0366E:  MOVLW  07
03670:  ADDWF  x84,W
03672:  MOVWF  FE9
03674:  MOVLW  00
03676:  ADDWFC x85,W
03678:  MOVWF  FEA
0367A:  CLRF   FEF
*
03A3E:  MOVLW  07
03A40:  ADDWF  x84,W
03A42:  MOVWF  FE9
03A44:  MOVLW  00
03A46:  ADDWFC x85,W
03A48:  MOVWF  FEA
03A4A:  CLRF   FEF
*
03E1C:  MOVLW  07
03E1E:  ADDWF  x84,W
03E20:  MOVWF  FE9
03E22:  MOVLW  00
03E24:  ADDWFC x85,W
03E26:  MOVWF  FEA
03E28:  CLRF   FEF
*
041EC:  MOVLW  07
041EE:  ADDWF  x84,W
041F0:  MOVWF  FE9
041F2:  MOVLW  00
041F4:  ADDWFC x85,W
041F6:  MOVWF  FEA
041F8:  CLRF   FEF
*
1BDC4:  MOVLW  07
1BDC6:  ADDWF  x84,W
1BDC8:  MOVWF  FE9
1BDCA:  MOVLW  00
1BDCC:  ADDWFC x85,W
1BDCE:  MOVWF  FEA
1BDD0:  CLRF   FEF
....................         } 
....................     } 
....................     buffer->position = buffer->data; 
*
023FC:  MOVLW  03
023FE:  ADDWF  x84,W
02400:  MOVWF  01
02402:  MOVLW  00
02404:  ADDWFC x85,W
02406:  MOVFF  D84,FE9
0240A:  MOVFF  D85,FEA
0240E:  MOVFF  FEC,03
02412:  MOVF   FED,F
02414:  MOVFF  FEF,D8B
02418:  MOVWF  FEA
0241A:  MOVFF  01,FE9
0241E:  MOVFF  03,FEC
02422:  MOVF   FED,F
02424:  MOVFF  D8B,FEF
*
027AE:  MOVLW  03
027B0:  ADDWF  x84,W
027B2:  MOVWF  01
027B4:  MOVLW  00
027B6:  ADDWFC x85,W
027B8:  MOVFF  D84,FE9
027BC:  MOVFF  D85,FEA
027C0:  MOVFF  FEC,03
027C4:  MOVF   FED,F
027C6:  MOVFF  FEF,D8B
027CA:  MOVWF  FEA
027CC:  MOVFF  01,FE9
027D0:  MOVFF  03,FEC
027D4:  MOVF   FED,F
027D6:  MOVFF  D8B,FEF
*
02B60:  MOVLW  03
02B62:  ADDWF  x84,W
02B64:  MOVWF  01
02B66:  MOVLW  00
02B68:  ADDWFC x85,W
02B6A:  MOVFF  D84,FE9
02B6E:  MOVFF  D85,FEA
02B72:  MOVFF  FEC,03
02B76:  MOVF   FED,F
02B78:  MOVFF  FEF,D8B
02B7C:  MOVWF  FEA
02B7E:  MOVFF  01,FE9
02B82:  MOVFF  03,FEC
02B86:  MOVF   FED,F
02B88:  MOVFF  D8B,FEF
*
02F14:  MOVLW  03
02F16:  ADDWF  x84,W
02F18:  MOVWF  01
02F1A:  MOVLW  00
02F1C:  ADDWFC x85,W
02F1E:  MOVFF  D84,FE9
02F22:  MOVFF  D85,FEA
02F26:  MOVFF  FEC,03
02F2A:  MOVF   FED,F
02F2C:  MOVFF  FEF,D8B
02F30:  MOVWF  FEA
02F32:  MOVFF  01,FE9
02F36:  MOVFF  03,FEC
02F3A:  MOVF   FED,F
02F3C:  MOVFF  D8B,FEF
*
032C8:  MOVLW  03
032CA:  ADDWF  x84,W
032CC:  MOVWF  01
032CE:  MOVLW  00
032D0:  ADDWFC x85,W
032D2:  MOVFF  D84,FE9
032D6:  MOVFF  D85,FEA
032DA:  MOVFF  FEC,03
032DE:  MOVF   FED,F
032E0:  MOVFF  FEF,D8B
032E4:  MOVWF  FEA
032E6:  MOVFF  01,FE9
032EA:  MOVFF  03,FEC
032EE:  MOVF   FED,F
032F0:  MOVFF  D8B,FEF
*
0367C:  MOVLW  03
0367E:  ADDWF  x84,W
03680:  MOVWF  01
03682:  MOVLW  00
03684:  ADDWFC x85,W
03686:  MOVFF  D84,FE9
0368A:  MOVFF  D85,FEA
0368E:  MOVFF  FEC,03
03692:  MOVF   FED,F
03694:  MOVFF  FEF,D8B
03698:  MOVWF  FEA
0369A:  MOVFF  01,FE9
0369E:  MOVFF  03,FEC
036A2:  MOVF   FED,F
036A4:  MOVFF  D8B,FEF
*
03A4C:  MOVLW  03
03A4E:  ADDWF  x84,W
03A50:  MOVWF  01
03A52:  MOVLW  00
03A54:  ADDWFC x85,W
03A56:  MOVFF  D84,FE9
03A5A:  MOVFF  D85,FEA
03A5E:  MOVFF  FEC,03
03A62:  MOVF   FED,F
03A64:  MOVFF  FEF,D8B
03A68:  MOVWF  FEA
03A6A:  MOVFF  01,FE9
03A6E:  MOVFF  03,FEC
03A72:  MOVF   FED,F
03A74:  MOVFF  D8B,FEF
*
03E2A:  MOVLW  03
03E2C:  ADDWF  x84,W
03E2E:  MOVWF  01
03E30:  MOVLW  00
03E32:  ADDWFC x85,W
03E34:  MOVFF  D84,FE9
03E38:  MOVFF  D85,FEA
03E3C:  MOVFF  FEC,03
03E40:  MOVF   FED,F
03E42:  MOVFF  FEF,D8B
03E46:  MOVWF  FEA
03E48:  MOVFF  01,FE9
03E4C:  MOVFF  03,FEC
03E50:  MOVF   FED,F
03E52:  MOVFF  D8B,FEF
*
041FA:  MOVLW  03
041FC:  ADDWF  x84,W
041FE:  MOVWF  01
04200:  MOVLW  00
04202:  ADDWFC x85,W
04204:  MOVFF  D84,FE9
04208:  MOVFF  D85,FEA
0420C:  MOVFF  FEC,03
04210:  MOVF   FED,F
04212:  MOVFF  FEF,D8B
04216:  MOVWF  FEA
04218:  MOVFF  01,FE9
0421C:  MOVFF  03,FEC
04220:  MOVF   FED,F
04222:  MOVFF  D8B,FEF
*
1BDD2:  MOVLW  03
1BDD4:  ADDWF  x84,W
1BDD6:  MOVWF  01
1BDD8:  MOVLW  00
1BDDA:  ADDWFC x85,W
1BDDC:  MOVFF  D84,FE9
1BDE0:  MOVFF  D85,FEA
1BDE4:  MOVFF  FEC,03
1BDE8:  MOVF   FED,F
1BDEA:  MOVFF  FEF,D8B
1BDEE:  MOVWF  FEA
1BDF0:  MOVFF  01,FE9
1BDF4:  MOVFF  03,FEC
1BDF8:  MOVF   FED,F
1BDFA:  MOVFF  D8B,FEF
....................     buffer->end = buffer->data; 
*
02428:  MOVLW  05
0242A:  ADDWF  x84,W
0242C:  MOVWF  01
0242E:  MOVLW  00
02430:  ADDWFC x85,W
02432:  MOVFF  D84,FE9
02436:  MOVFF  D85,FEA
0243A:  MOVFF  FEC,03
0243E:  MOVF   FED,F
02440:  MOVFF  FEF,D8B
02444:  MOVWF  FEA
02446:  MOVFF  01,FE9
0244A:  MOVFF  03,FEC
0244E:  MOVF   FED,F
02450:  MOVFF  D8B,FEF
*
027DA:  MOVLW  05
027DC:  ADDWF  x84,W
027DE:  MOVWF  01
027E0:  MOVLW  00
027E2:  ADDWFC x85,W
027E4:  MOVFF  D84,FE9
027E8:  MOVFF  D85,FEA
027EC:  MOVFF  FEC,03
027F0:  MOVF   FED,F
027F2:  MOVFF  FEF,D8B
027F6:  MOVWF  FEA
027F8:  MOVFF  01,FE9
027FC:  MOVFF  03,FEC
02800:  MOVF   FED,F
02802:  MOVFF  D8B,FEF
*
02B8C:  MOVLW  05
02B8E:  ADDWF  x84,W
02B90:  MOVWF  01
02B92:  MOVLW  00
02B94:  ADDWFC x85,W
02B96:  MOVFF  D84,FE9
02B9A:  MOVFF  D85,FEA
02B9E:  MOVFF  FEC,03
02BA2:  MOVF   FED,F
02BA4:  MOVFF  FEF,D8B
02BA8:  MOVWF  FEA
02BAA:  MOVFF  01,FE9
02BAE:  MOVFF  03,FEC
02BB2:  MOVF   FED,F
02BB4:  MOVFF  D8B,FEF
*
02F40:  MOVLW  05
02F42:  ADDWF  x84,W
02F44:  MOVWF  01
02F46:  MOVLW  00
02F48:  ADDWFC x85,W
02F4A:  MOVFF  D84,FE9
02F4E:  MOVFF  D85,FEA
02F52:  MOVFF  FEC,03
02F56:  MOVF   FED,F
02F58:  MOVFF  FEF,D8B
02F5C:  MOVWF  FEA
02F5E:  MOVFF  01,FE9
02F62:  MOVFF  03,FEC
02F66:  MOVF   FED,F
02F68:  MOVFF  D8B,FEF
*
032F4:  MOVLW  05
032F6:  ADDWF  x84,W
032F8:  MOVWF  01
032FA:  MOVLW  00
032FC:  ADDWFC x85,W
032FE:  MOVFF  D84,FE9
03302:  MOVFF  D85,FEA
03306:  MOVFF  FEC,03
0330A:  MOVF   FED,F
0330C:  MOVFF  FEF,D8B
03310:  MOVWF  FEA
03312:  MOVFF  01,FE9
03316:  MOVFF  03,FEC
0331A:  MOVF   FED,F
0331C:  MOVFF  D8B,FEF
*
036A8:  MOVLW  05
036AA:  ADDWF  x84,W
036AC:  MOVWF  01
036AE:  MOVLW  00
036B0:  ADDWFC x85,W
036B2:  MOVFF  D84,FE9
036B6:  MOVFF  D85,FEA
036BA:  MOVFF  FEC,03
036BE:  MOVF   FED,F
036C0:  MOVFF  FEF,D8B
036C4:  MOVWF  FEA
036C6:  MOVFF  01,FE9
036CA:  MOVFF  03,FEC
036CE:  MOVF   FED,F
036D0:  MOVFF  D8B,FEF
*
03A78:  MOVLW  05
03A7A:  ADDWF  x84,W
03A7C:  MOVWF  01
03A7E:  MOVLW  00
03A80:  ADDWFC x85,W
03A82:  MOVFF  D84,FE9
03A86:  MOVFF  D85,FEA
03A8A:  MOVFF  FEC,03
03A8E:  MOVF   FED,F
03A90:  MOVFF  FEF,D8B
03A94:  MOVWF  FEA
03A96:  MOVFF  01,FE9
03A9A:  MOVFF  03,FEC
03A9E:  MOVF   FED,F
03AA0:  MOVFF  D8B,FEF
*
03E56:  MOVLW  05
03E58:  ADDWF  x84,W
03E5A:  MOVWF  01
03E5C:  MOVLW  00
03E5E:  ADDWFC x85,W
03E60:  MOVFF  D84,FE9
03E64:  MOVFF  D85,FEA
03E68:  MOVFF  FEC,03
03E6C:  MOVF   FED,F
03E6E:  MOVFF  FEF,D8B
03E72:  MOVWF  FEA
03E74:  MOVFF  01,FE9
03E78:  MOVFF  03,FEC
03E7C:  MOVF   FED,F
03E7E:  MOVFF  D8B,FEF
*
04226:  MOVLW  05
04228:  ADDWF  x84,W
0422A:  MOVWF  01
0422C:  MOVLW  00
0422E:  ADDWFC x85,W
04230:  MOVFF  D84,FE9
04234:  MOVFF  D85,FEA
04238:  MOVFF  FEC,03
0423C:  MOVF   FED,F
0423E:  MOVFF  FEF,D8B
04242:  MOVWF  FEA
04244:  MOVFF  01,FE9
04248:  MOVFF  03,FEC
0424C:  MOVF   FED,F
0424E:  MOVFF  D8B,FEF
*
1BDFE:  MOVLW  05
1BE00:  ADDWF  x84,W
1BE02:  MOVWF  01
1BE04:  MOVLW  00
1BE06:  ADDWFC x85,W
1BE08:  MOVFF  D84,FE9
1BE0C:  MOVFF  D85,FEA
1BE10:  MOVFF  FEC,03
1BE14:  MOVF   FED,F
1BE16:  MOVFF  FEF,D8B
1BE1A:  MOVWF  FEA
1BE1C:  MOVFF  01,FE9
1BE20:  MOVFF  03,FEC
1BE24:  MOVF   FED,F
1BE26:  MOVFF  D8B,FEF
.................... } 
....................  
.................... inline void uart_process_all(uart* buffer, char rx) 
.................... { 
....................     switch (buffer->state) { 
....................     case ready: 
....................     case waiting: 
....................         for (int i = 0; i < sizeof(mconfig) / sizeof(message_config); i++) { 
....................             if (mconfig[i].identifier == rx) { // Found a message unique identifier 
....................                 buffer->end += (mconfig[i].length - 1); 
....................                 buffer->standard = mconfig[i].standard; 
....................                 *(buffer->position) = rx; 
....................                 buffer->position++; 
....................                 buffer->state = receiving; 
....................                 break; 
....................             } 
....................         } 
....................         break; 
....................     case receiving: 
....................         *(buffer->position) = rx; 
....................         if (buffer->position >= buffer->end) { 
....................             check_string(buffer); 
....................             break; 
....................         } 
....................         buffer->position++; 
....................         break; 
....................     default: 
....................         break; 
....................     } 
....................     if (buffer->position >= buffer->data + buffer->size) { 
....................         uart_reset(buffer); 
....................     } 
.................... } 
....................  
.................... inline void uart_process(uart* buffer, message_config* cfg, char rx) 
.................... { 
....................     switch (buffer->state) { 
*
0219A:  MOVLW  07
0219C:  ADDWF  x7F,W
0219E:  MOVWF  FE9
021A0:  MOVLW  00
021A2:  ADDWFC x80,W
021A4:  MOVWF  FEA
021A6:  MOVF   FEF,W
021A8:  XORLW  02
021AA:  MOVLB  0
021AC:  BZ    21B8
021AE:  XORLW  02
021B0:  BZ    21B8
021B2:  XORLW  01
021B4:  BZ    227E
021B6:  BRA    246E
*
0254C:  MOVLW  07
0254E:  ADDWF  x7F,W
02550:  MOVWF  FE9
02552:  MOVLW  00
02554:  ADDWFC x80,W
02556:  MOVWF  FEA
02558:  MOVF   FEF,W
0255A:  XORLW  02
0255C:  MOVLB  0
0255E:  BZ    256A
02560:  XORLW  02
02562:  BZ    256A
02564:  XORLW  01
02566:  BZ    2630
02568:  BRA    2820
*
028FE:  MOVLW  07
02900:  ADDWF  x7F,W
02902:  MOVWF  FE9
02904:  MOVLW  00
02906:  ADDWFC x80,W
02908:  MOVWF  FEA
0290A:  MOVF   FEF,W
0290C:  XORLW  02
0290E:  MOVLB  0
02910:  BZ    291C
02912:  XORLW  02
02914:  BZ    291C
02916:  XORLW  01
02918:  BZ    29E2
0291A:  BRA    2BD2
*
02CB2:  MOVLW  07
02CB4:  ADDWF  x7F,W
02CB6:  MOVWF  FE9
02CB8:  MOVLW  00
02CBA:  ADDWFC x80,W
02CBC:  MOVWF  FEA
02CBE:  MOVF   FEF,W
02CC0:  XORLW  02
02CC2:  MOVLB  0
02CC4:  BZ    2CD0
02CC6:  XORLW  02
02CC8:  BZ    2CD0
02CCA:  XORLW  01
02CCC:  BZ    2D96
02CCE:  BRA    2F86
*
03066:  MOVLW  07
03068:  ADDWF  x7F,W
0306A:  MOVWF  FE9
0306C:  MOVLW  00
0306E:  ADDWFC x80,W
03070:  MOVWF  FEA
03072:  MOVF   FEF,W
03074:  XORLW  02
03076:  MOVLB  0
03078:  BZ    3084
0307A:  XORLW  02
0307C:  BZ    3084
0307E:  XORLW  01
03080:  BZ    314A
03082:  BRA    333A
*
0341A:  MOVLW  07
0341C:  ADDWF  x7F,W
0341E:  MOVWF  FE9
03420:  MOVLW  00
03422:  ADDWFC x80,W
03424:  MOVWF  FEA
03426:  MOVF   FEF,W
03428:  XORLW  02
0342A:  MOVLB  0
0342C:  BZ    3438
0342E:  XORLW  02
03430:  BZ    3438
03432:  XORLW  01
03434:  BZ    34FE
03436:  BRA    36EE
*
037EA:  MOVLW  07
037EC:  ADDWF  x7F,W
037EE:  MOVWF  FE9
037F0:  MOVLW  00
037F2:  ADDWFC x80,W
037F4:  MOVWF  FEA
037F6:  MOVF   FEF,W
037F8:  XORLW  02
037FA:  MOVLB  0
037FC:  BZ    3808
037FE:  XORLW  02
03800:  BZ    3808
03802:  XORLW  01
03804:  BZ    38CE
03806:  BRA    3ABE
*
03BC8:  MOVLW  07
03BCA:  ADDWF  x7F,W
03BCC:  MOVWF  FE9
03BCE:  MOVLW  00
03BD0:  ADDWFC x80,W
03BD2:  MOVWF  FEA
03BD4:  MOVF   FEF,W
03BD6:  XORLW  02
03BD8:  MOVLB  0
03BDA:  BZ    3BE6
03BDC:  XORLW  02
03BDE:  BZ    3BE6
03BE0:  XORLW  01
03BE2:  BZ    3CAC
03BE4:  BRA    3E9C
*
03F98:  MOVLW  07
03F9A:  ADDWF  x7F,W
03F9C:  MOVWF  FE9
03F9E:  MOVLW  00
03FA0:  ADDWFC x80,W
03FA2:  MOVWF  FEA
03FA4:  MOVF   FEF,W
03FA6:  XORLW  02
03FA8:  MOVLB  0
03FAA:  BZ    3FB6
03FAC:  XORLW  02
03FAE:  BZ    3FB6
03FB0:  XORLW  01
03FB2:  BZ    407C
03FB4:  BRA    426C
*
1BB70:  MOVLW  07
1BB72:  ADDWF  x7F,W
1BB74:  MOVWF  FE9
1BB76:  MOVLW  00
1BB78:  ADDWFC x80,W
1BB7A:  MOVWF  FEA
1BB7C:  MOVF   FEF,W
1BB7E:  XORLW  02
1BB80:  MOVLB  0
1BB82:  BZ    1BB8E
1BB84:  XORLW  02
1BB86:  BZ    1BB8E
1BB88:  XORLW  01
1BB8A:  BZ    1BC54
1BB8C:  BRA    1BE44
....................     case ready: 
....................     case waiting: 
....................         if (cfg->identifier == rx) { // Found a message unique identifier 
*
021B8:  MOVLB  D
021BA:  MOVFF  D81,FE9
021BE:  MOVFF  D82,FEA
021C2:  MOVF   x83,W
021C4:  SUBWF  FEF,W
021C6:  BNZ   227C
*
0256A:  MOVLB  D
0256C:  MOVFF  D81,FE9
02570:  MOVFF  D82,FEA
02574:  MOVF   x83,W
02576:  SUBWF  FEF,W
02578:  BNZ   262E
*
0291C:  MOVLB  D
0291E:  MOVFF  D81,FE9
02922:  MOVFF  D82,FEA
02926:  MOVF   x83,W
02928:  SUBWF  FEF,W
0292A:  BNZ   29E0
*
02CD0:  MOVLB  D
02CD2:  MOVFF  D81,FE9
02CD6:  MOVFF  D82,FEA
02CDA:  MOVF   x83,W
02CDC:  SUBWF  FEF,W
02CDE:  BNZ   2D94
*
03084:  MOVLB  D
03086:  MOVFF  D81,FE9
0308A:  MOVFF  D82,FEA
0308E:  MOVF   x83,W
03090:  SUBWF  FEF,W
03092:  BNZ   3148
*
03438:  MOVLB  D
0343A:  MOVFF  D81,FE9
0343E:  MOVFF  D82,FEA
03442:  MOVF   x83,W
03444:  SUBWF  FEF,W
03446:  BNZ   34FC
*
03808:  MOVLB  D
0380A:  MOVFF  D81,FE9
0380E:  MOVFF  D82,FEA
03812:  MOVF   x83,W
03814:  SUBWF  FEF,W
03816:  BNZ   38CC
*
03BE6:  MOVLB  D
03BE8:  MOVFF  D81,FE9
03BEC:  MOVFF  D82,FEA
03BF0:  MOVF   x83,W
03BF2:  SUBWF  FEF,W
03BF4:  BNZ   3CAA
*
03FB6:  MOVLB  D
03FB8:  MOVFF  D81,FE9
03FBC:  MOVFF  D82,FEA
03FC0:  MOVF   x83,W
03FC2:  SUBWF  FEF,W
03FC4:  BNZ   407A
*
1BB8E:  MOVLB  D
1BB90:  MOVFF  D81,FE9
1BB94:  MOVFF  D82,FEA
1BB98:  MOVF   x83,W
1BB9A:  SUBWF  FEF,W
1BB9C:  BNZ   1BC52
....................             buffer->end += (cfg->length - 1); 
*
021C8:  MOVLW  05
021CA:  ADDWF  x7F,W
021CC:  MOVWF  01
021CE:  MOVLW  00
021D0:  ADDWFC x80,W
021D2:  MOVFF  01,D84
021D6:  MOVWF  x85
021D8:  MOVWF  FEA
021DA:  MOVFF  01,FE9
021DE:  MOVFF  FEC,D87
021E2:  MOVF   FED,F
021E4:  MOVFF  FEF,D86
021E8:  MOVLW  01
021EA:  ADDWF  x81,W
021EC:  MOVWF  FE9
021EE:  MOVLW  00
021F0:  ADDWFC x82,W
021F2:  MOVWF  FEA
021F4:  MOVLW  01
021F6:  SUBWF  FEF,W
021F8:  ADDWF  x86,W
021FA:  MOVWF  01
021FC:  MOVLW  00
021FE:  ADDWFC x87,W
02200:  MOVFF  D85,FEA
02204:  MOVFF  D84,FE9
02208:  MOVWF  FEC
0220A:  MOVF   FED,F
0220C:  MOVFF  01,FEF
*
0257A:  MOVLW  05
0257C:  ADDWF  x7F,W
0257E:  MOVWF  01
02580:  MOVLW  00
02582:  ADDWFC x80,W
02584:  MOVFF  01,D84
02588:  MOVWF  x85
0258A:  MOVWF  FEA
0258C:  MOVFF  01,FE9
02590:  MOVFF  FEC,D87
02594:  MOVF   FED,F
02596:  MOVFF  FEF,D86
0259A:  MOVLW  01
0259C:  ADDWF  x81,W
0259E:  MOVWF  FE9
025A0:  MOVLW  00
025A2:  ADDWFC x82,W
025A4:  MOVWF  FEA
025A6:  MOVLW  01
025A8:  SUBWF  FEF,W
025AA:  ADDWF  x86,W
025AC:  MOVWF  01
025AE:  MOVLW  00
025B0:  ADDWFC x87,W
025B2:  MOVFF  D85,FEA
025B6:  MOVFF  D84,FE9
025BA:  MOVWF  FEC
025BC:  MOVF   FED,F
025BE:  MOVFF  01,FEF
*
0292C:  MOVLW  05
0292E:  ADDWF  x7F,W
02930:  MOVWF  01
02932:  MOVLW  00
02934:  ADDWFC x80,W
02936:  MOVFF  01,D84
0293A:  MOVWF  x85
0293C:  MOVWF  FEA
0293E:  MOVFF  01,FE9
02942:  MOVFF  FEC,D87
02946:  MOVF   FED,F
02948:  MOVFF  FEF,D86
0294C:  MOVLW  01
0294E:  ADDWF  x81,W
02950:  MOVWF  FE9
02952:  MOVLW  00
02954:  ADDWFC x82,W
02956:  MOVWF  FEA
02958:  MOVLW  01
0295A:  SUBWF  FEF,W
0295C:  ADDWF  x86,W
0295E:  MOVWF  01
02960:  MOVLW  00
02962:  ADDWFC x87,W
02964:  MOVFF  D85,FEA
02968:  MOVFF  D84,FE9
0296C:  MOVWF  FEC
0296E:  MOVF   FED,F
02970:  MOVFF  01,FEF
*
02CE0:  MOVLW  05
02CE2:  ADDWF  x7F,W
02CE4:  MOVWF  01
02CE6:  MOVLW  00
02CE8:  ADDWFC x80,W
02CEA:  MOVFF  01,D84
02CEE:  MOVWF  x85
02CF0:  MOVWF  FEA
02CF2:  MOVFF  01,FE9
02CF6:  MOVFF  FEC,D87
02CFA:  MOVF   FED,F
02CFC:  MOVFF  FEF,D86
02D00:  MOVLW  01
02D02:  ADDWF  x81,W
02D04:  MOVWF  FE9
02D06:  MOVLW  00
02D08:  ADDWFC x82,W
02D0A:  MOVWF  FEA
02D0C:  MOVLW  01
02D0E:  SUBWF  FEF,W
02D10:  ADDWF  x86,W
02D12:  MOVWF  01
02D14:  MOVLW  00
02D16:  ADDWFC x87,W
02D18:  MOVFF  D85,FEA
02D1C:  MOVFF  D84,FE9
02D20:  MOVWF  FEC
02D22:  MOVF   FED,F
02D24:  MOVFF  01,FEF
*
03094:  MOVLW  05
03096:  ADDWF  x7F,W
03098:  MOVWF  01
0309A:  MOVLW  00
0309C:  ADDWFC x80,W
0309E:  MOVFF  01,D84
030A2:  MOVWF  x85
030A4:  MOVWF  FEA
030A6:  MOVFF  01,FE9
030AA:  MOVFF  FEC,D87
030AE:  MOVF   FED,F
030B0:  MOVFF  FEF,D86
030B4:  MOVLW  01
030B6:  ADDWF  x81,W
030B8:  MOVWF  FE9
030BA:  MOVLW  00
030BC:  ADDWFC x82,W
030BE:  MOVWF  FEA
030C0:  MOVLW  01
030C2:  SUBWF  FEF,W
030C4:  ADDWF  x86,W
030C6:  MOVWF  01
030C8:  MOVLW  00
030CA:  ADDWFC x87,W
030CC:  MOVFF  D85,FEA
030D0:  MOVFF  D84,FE9
030D4:  MOVWF  FEC
030D6:  MOVF   FED,F
030D8:  MOVFF  01,FEF
*
03448:  MOVLW  05
0344A:  ADDWF  x7F,W
0344C:  MOVWF  01
0344E:  MOVLW  00
03450:  ADDWFC x80,W
03452:  MOVFF  01,D84
03456:  MOVWF  x85
03458:  MOVWF  FEA
0345A:  MOVFF  01,FE9
0345E:  MOVFF  FEC,D87
03462:  MOVF   FED,F
03464:  MOVFF  FEF,D86
03468:  MOVLW  01
0346A:  ADDWF  x81,W
0346C:  MOVWF  FE9
0346E:  MOVLW  00
03470:  ADDWFC x82,W
03472:  MOVWF  FEA
03474:  MOVLW  01
03476:  SUBWF  FEF,W
03478:  ADDWF  x86,W
0347A:  MOVWF  01
0347C:  MOVLW  00
0347E:  ADDWFC x87,W
03480:  MOVFF  D85,FEA
03484:  MOVFF  D84,FE9
03488:  MOVWF  FEC
0348A:  MOVF   FED,F
0348C:  MOVFF  01,FEF
*
03818:  MOVLW  05
0381A:  ADDWF  x7F,W
0381C:  MOVWF  01
0381E:  MOVLW  00
03820:  ADDWFC x80,W
03822:  MOVFF  01,D84
03826:  MOVWF  x85
03828:  MOVWF  FEA
0382A:  MOVFF  01,FE9
0382E:  MOVFF  FEC,D87
03832:  MOVF   FED,F
03834:  MOVFF  FEF,D86
03838:  MOVLW  01
0383A:  ADDWF  x81,W
0383C:  MOVWF  FE9
0383E:  MOVLW  00
03840:  ADDWFC x82,W
03842:  MOVWF  FEA
03844:  MOVLW  01
03846:  SUBWF  FEF,W
03848:  ADDWF  x86,W
0384A:  MOVWF  01
0384C:  MOVLW  00
0384E:  ADDWFC x87,W
03850:  MOVFF  D85,FEA
03854:  MOVFF  D84,FE9
03858:  MOVWF  FEC
0385A:  MOVF   FED,F
0385C:  MOVFF  01,FEF
*
03BF6:  MOVLW  05
03BF8:  ADDWF  x7F,W
03BFA:  MOVWF  01
03BFC:  MOVLW  00
03BFE:  ADDWFC x80,W
03C00:  MOVFF  01,D84
03C04:  MOVWF  x85
03C06:  MOVWF  FEA
03C08:  MOVFF  01,FE9
03C0C:  MOVFF  FEC,D87
03C10:  MOVF   FED,F
03C12:  MOVFF  FEF,D86
03C16:  MOVLW  01
03C18:  ADDWF  x81,W
03C1A:  MOVWF  FE9
03C1C:  MOVLW  00
03C1E:  ADDWFC x82,W
03C20:  MOVWF  FEA
03C22:  MOVLW  01
03C24:  SUBWF  FEF,W
03C26:  ADDWF  x86,W
03C28:  MOVWF  01
03C2A:  MOVLW  00
03C2C:  ADDWFC x87,W
03C2E:  MOVFF  D85,FEA
03C32:  MOVFF  D84,FE9
03C36:  MOVWF  FEC
03C38:  MOVF   FED,F
03C3A:  MOVFF  01,FEF
*
03FC6:  MOVLW  05
03FC8:  ADDWF  x7F,W
03FCA:  MOVWF  01
03FCC:  MOVLW  00
03FCE:  ADDWFC x80,W
03FD0:  MOVFF  01,D84
03FD4:  MOVWF  x85
03FD6:  MOVWF  FEA
03FD8:  MOVFF  01,FE9
03FDC:  MOVFF  FEC,D87
03FE0:  MOVF   FED,F
03FE2:  MOVFF  FEF,D86
03FE6:  MOVLW  01
03FE8:  ADDWF  x81,W
03FEA:  MOVWF  FE9
03FEC:  MOVLW  00
03FEE:  ADDWFC x82,W
03FF0:  MOVWF  FEA
03FF2:  MOVLW  01
03FF4:  SUBWF  FEF,W
03FF6:  ADDWF  x86,W
03FF8:  MOVWF  01
03FFA:  MOVLW  00
03FFC:  ADDWFC x87,W
03FFE:  MOVFF  D85,FEA
04002:  MOVFF  D84,FE9
04006:  MOVWF  FEC
04008:  MOVF   FED,F
0400A:  MOVFF  01,FEF
*
1BB9E:  MOVLW  05
1BBA0:  ADDWF  x7F,W
1BBA2:  MOVWF  01
1BBA4:  MOVLW  00
1BBA6:  ADDWFC x80,W
1BBA8:  MOVFF  01,D84
1BBAC:  MOVWF  x85
1BBAE:  MOVWF  FEA
1BBB0:  MOVFF  01,FE9
1BBB4:  MOVFF  FEC,D87
1BBB8:  MOVF   FED,F
1BBBA:  MOVFF  FEF,D86
1BBBE:  MOVLW  01
1BBC0:  ADDWF  x81,W
1BBC2:  MOVWF  FE9
1BBC4:  MOVLW  00
1BBC6:  ADDWFC x82,W
1BBC8:  MOVWF  FEA
1BBCA:  MOVLW  01
1BBCC:  SUBWF  FEF,W
1BBCE:  ADDWF  x86,W
1BBD0:  MOVWF  01
1BBD2:  MOVLW  00
1BBD4:  ADDWFC x87,W
1BBD6:  MOVFF  D85,FEA
1BBDA:  MOVFF  D84,FE9
1BBDE:  MOVWF  FEC
1BBE0:  MOVF   FED,F
1BBE2:  MOVFF  01,FEF
....................             buffer->standard = cfg->standard; 
*
02210:  MOVLW  08
02212:  ADDWF  x7F,W
02214:  MOVWF  01
02216:  MOVLW  00
02218:  ADDWFC x80,W
0221A:  MOVWF  03
0221C:  MOVLW  02
0221E:  ADDWF  x81,W
02220:  MOVWF  FE9
02222:  MOVLW  00
02224:  ADDWFC x82,W
02226:  MOVWF  FEA
02228:  MOVFF  FEF,D86
0222C:  MOVFF  03,FEA
02230:  MOVFF  01,FE9
02234:  MOVFF  D86,FEF
*
025C2:  MOVLW  08
025C4:  ADDWF  x7F,W
025C6:  MOVWF  01
025C8:  MOVLW  00
025CA:  ADDWFC x80,W
025CC:  MOVWF  03
025CE:  MOVLW  02
025D0:  ADDWF  x81,W
025D2:  MOVWF  FE9
025D4:  MOVLW  00
025D6:  ADDWFC x82,W
025D8:  MOVWF  FEA
025DA:  MOVFF  FEF,D86
025DE:  MOVFF  03,FEA
025E2:  MOVFF  01,FE9
025E6:  MOVFF  D86,FEF
*
02974:  MOVLW  08
02976:  ADDWF  x7F,W
02978:  MOVWF  01
0297A:  MOVLW  00
0297C:  ADDWFC x80,W
0297E:  MOVWF  03
02980:  MOVLW  02
02982:  ADDWF  x81,W
02984:  MOVWF  FE9
02986:  MOVLW  00
02988:  ADDWFC x82,W
0298A:  MOVWF  FEA
0298C:  MOVFF  FEF,D86
02990:  MOVFF  03,FEA
02994:  MOVFF  01,FE9
02998:  MOVFF  D86,FEF
*
02D28:  MOVLW  08
02D2A:  ADDWF  x7F,W
02D2C:  MOVWF  01
02D2E:  MOVLW  00
02D30:  ADDWFC x80,W
02D32:  MOVWF  03
02D34:  MOVLW  02
02D36:  ADDWF  x81,W
02D38:  MOVWF  FE9
02D3A:  MOVLW  00
02D3C:  ADDWFC x82,W
02D3E:  MOVWF  FEA
02D40:  MOVFF  FEF,D86
02D44:  MOVFF  03,FEA
02D48:  MOVFF  01,FE9
02D4C:  MOVFF  D86,FEF
*
030DC:  MOVLW  08
030DE:  ADDWF  x7F,W
030E0:  MOVWF  01
030E2:  MOVLW  00
030E4:  ADDWFC x80,W
030E6:  MOVWF  03
030E8:  MOVLW  02
030EA:  ADDWF  x81,W
030EC:  MOVWF  FE9
030EE:  MOVLW  00
030F0:  ADDWFC x82,W
030F2:  MOVWF  FEA
030F4:  MOVFF  FEF,D86
030F8:  MOVFF  03,FEA
030FC:  MOVFF  01,FE9
03100:  MOVFF  D86,FEF
*
03490:  MOVLW  08
03492:  ADDWF  x7F,W
03494:  MOVWF  01
03496:  MOVLW  00
03498:  ADDWFC x80,W
0349A:  MOVWF  03
0349C:  MOVLW  02
0349E:  ADDWF  x81,W
034A0:  MOVWF  FE9
034A2:  MOVLW  00
034A4:  ADDWFC x82,W
034A6:  MOVWF  FEA
034A8:  MOVFF  FEF,D86
034AC:  MOVFF  03,FEA
034B0:  MOVFF  01,FE9
034B4:  MOVFF  D86,FEF
*
03860:  MOVLW  08
03862:  ADDWF  x7F,W
03864:  MOVWF  01
03866:  MOVLW  00
03868:  ADDWFC x80,W
0386A:  MOVWF  03
0386C:  MOVLW  02
0386E:  ADDWF  x81,W
03870:  MOVWF  FE9
03872:  MOVLW  00
03874:  ADDWFC x82,W
03876:  MOVWF  FEA
03878:  MOVFF  FEF,D86
0387C:  MOVFF  03,FEA
03880:  MOVFF  01,FE9
03884:  MOVFF  D86,FEF
*
03C3E:  MOVLW  08
03C40:  ADDWF  x7F,W
03C42:  MOVWF  01
03C44:  MOVLW  00
03C46:  ADDWFC x80,W
03C48:  MOVWF  03
03C4A:  MOVLW  02
03C4C:  ADDWF  x81,W
03C4E:  MOVWF  FE9
03C50:  MOVLW  00
03C52:  ADDWFC x82,W
03C54:  MOVWF  FEA
03C56:  MOVFF  FEF,D86
03C5A:  MOVFF  03,FEA
03C5E:  MOVFF  01,FE9
03C62:  MOVFF  D86,FEF
*
0400E:  MOVLW  08
04010:  ADDWF  x7F,W
04012:  MOVWF  01
04014:  MOVLW  00
04016:  ADDWFC x80,W
04018:  MOVWF  03
0401A:  MOVLW  02
0401C:  ADDWF  x81,W
0401E:  MOVWF  FE9
04020:  MOVLW  00
04022:  ADDWFC x82,W
04024:  MOVWF  FEA
04026:  MOVFF  FEF,D86
0402A:  MOVFF  03,FEA
0402E:  MOVFF  01,FE9
04032:  MOVFF  D86,FEF
*
1BBE6:  MOVLW  08
1BBE8:  ADDWF  x7F,W
1BBEA:  MOVWF  01
1BBEC:  MOVLW  00
1BBEE:  ADDWFC x80,W
1BBF0:  MOVWF  03
1BBF2:  MOVLW  02
1BBF4:  ADDWF  x81,W
1BBF6:  MOVWF  FE9
1BBF8:  MOVLW  00
1BBFA:  ADDWFC x82,W
1BBFC:  MOVWF  FEA
1BBFE:  MOVFF  FEF,D86
1BC02:  MOVFF  03,FEA
1BC06:  MOVFF  01,FE9
1BC0A:  MOVFF  D86,FEF
....................             *(buffer->position) = rx; 
*
02238:  MOVLW  03
0223A:  ADDWF  x7F,W
0223C:  MOVWF  FE9
0223E:  MOVLW  00
02240:  ADDWFC x80,W
02242:  MOVWF  FEA
02244:  MOVFF  FEC,03
02248:  MOVF   FED,F
0224A:  MOVFF  FEF,FE9
0224E:  MOVFF  03,FEA
02252:  MOVFF  D83,FEF
*
025EA:  MOVLW  03
025EC:  ADDWF  x7F,W
025EE:  MOVWF  FE9
025F0:  MOVLW  00
025F2:  ADDWFC x80,W
025F4:  MOVWF  FEA
025F6:  MOVFF  FEC,03
025FA:  MOVF   FED,F
025FC:  MOVFF  FEF,FE9
02600:  MOVFF  03,FEA
02604:  MOVFF  D83,FEF
*
0299C:  MOVLW  03
0299E:  ADDWF  x7F,W
029A0:  MOVWF  FE9
029A2:  MOVLW  00
029A4:  ADDWFC x80,W
029A6:  MOVWF  FEA
029A8:  MOVFF  FEC,03
029AC:  MOVF   FED,F
029AE:  MOVFF  FEF,FE9
029B2:  MOVFF  03,FEA
029B6:  MOVFF  D83,FEF
*
02D50:  MOVLW  03
02D52:  ADDWF  x7F,W
02D54:  MOVWF  FE9
02D56:  MOVLW  00
02D58:  ADDWFC x80,W
02D5A:  MOVWF  FEA
02D5C:  MOVFF  FEC,03
02D60:  MOVF   FED,F
02D62:  MOVFF  FEF,FE9
02D66:  MOVFF  03,FEA
02D6A:  MOVFF  D83,FEF
*
03104:  MOVLW  03
03106:  ADDWF  x7F,W
03108:  MOVWF  FE9
0310A:  MOVLW  00
0310C:  ADDWFC x80,W
0310E:  MOVWF  FEA
03110:  MOVFF  FEC,03
03114:  MOVF   FED,F
03116:  MOVFF  FEF,FE9
0311A:  MOVFF  03,FEA
0311E:  MOVFF  D83,FEF
*
034B8:  MOVLW  03
034BA:  ADDWF  x7F,W
034BC:  MOVWF  FE9
034BE:  MOVLW  00
034C0:  ADDWFC x80,W
034C2:  MOVWF  FEA
034C4:  MOVFF  FEC,03
034C8:  MOVF   FED,F
034CA:  MOVFF  FEF,FE9
034CE:  MOVFF  03,FEA
034D2:  MOVFF  D83,FEF
*
03888:  MOVLW  03
0388A:  ADDWF  x7F,W
0388C:  MOVWF  FE9
0388E:  MOVLW  00
03890:  ADDWFC x80,W
03892:  MOVWF  FEA
03894:  MOVFF  FEC,03
03898:  MOVF   FED,F
0389A:  MOVFF  FEF,FE9
0389E:  MOVFF  03,FEA
038A2:  MOVFF  D83,FEF
*
03C66:  MOVLW  03
03C68:  ADDWF  x7F,W
03C6A:  MOVWF  FE9
03C6C:  MOVLW  00
03C6E:  ADDWFC x80,W
03C70:  MOVWF  FEA
03C72:  MOVFF  FEC,03
03C76:  MOVF   FED,F
03C78:  MOVFF  FEF,FE9
03C7C:  MOVFF  03,FEA
03C80:  MOVFF  D83,FEF
*
04036:  MOVLW  03
04038:  ADDWF  x7F,W
0403A:  MOVWF  FE9
0403C:  MOVLW  00
0403E:  ADDWFC x80,W
04040:  MOVWF  FEA
04042:  MOVFF  FEC,03
04046:  MOVF   FED,F
04048:  MOVFF  FEF,FE9
0404C:  MOVFF  03,FEA
04050:  MOVFF  D83,FEF
*
1BC0E:  MOVLW  03
1BC10:  ADDWF  x7F,W
1BC12:  MOVWF  FE9
1BC14:  MOVLW  00
1BC16:  ADDWFC x80,W
1BC18:  MOVWF  FEA
1BC1A:  MOVFF  FEC,03
1BC1E:  MOVF   FED,F
1BC20:  MOVFF  FEF,FE9
1BC24:  MOVFF  03,FEA
1BC28:  MOVFF  D83,FEF
....................             buffer->position++; 
*
02256:  MOVLW  03
02258:  ADDWF  x7F,W
0225A:  MOVWF  FE9
0225C:  MOVLW  00
0225E:  ADDWFC x80,W
02260:  MOVWF  FEA
02262:  MOVLW  01
02264:  ADDWF  FEE,F
02266:  BNC   226A
02268:  INCF   FEF,F
*
02608:  MOVLW  03
0260A:  ADDWF  x7F,W
0260C:  MOVWF  FE9
0260E:  MOVLW  00
02610:  ADDWFC x80,W
02612:  MOVWF  FEA
02614:  MOVLW  01
02616:  ADDWF  FEE,F
02618:  BNC   261C
0261A:  INCF   FEF,F
*
029BA:  MOVLW  03
029BC:  ADDWF  x7F,W
029BE:  MOVWF  FE9
029C0:  MOVLW  00
029C2:  ADDWFC x80,W
029C4:  MOVWF  FEA
029C6:  MOVLW  01
029C8:  ADDWF  FEE,F
029CA:  BNC   29CE
029CC:  INCF   FEF,F
*
02D6E:  MOVLW  03
02D70:  ADDWF  x7F,W
02D72:  MOVWF  FE9
02D74:  MOVLW  00
02D76:  ADDWFC x80,W
02D78:  MOVWF  FEA
02D7A:  MOVLW  01
02D7C:  ADDWF  FEE,F
02D7E:  BNC   2D82
02D80:  INCF   FEF,F
*
03122:  MOVLW  03
03124:  ADDWF  x7F,W
03126:  MOVWF  FE9
03128:  MOVLW  00
0312A:  ADDWFC x80,W
0312C:  MOVWF  FEA
0312E:  MOVLW  01
03130:  ADDWF  FEE,F
03132:  BNC   3136
03134:  INCF   FEF,F
*
034D6:  MOVLW  03
034D8:  ADDWF  x7F,W
034DA:  MOVWF  FE9
034DC:  MOVLW  00
034DE:  ADDWFC x80,W
034E0:  MOVWF  FEA
034E2:  MOVLW  01
034E4:  ADDWF  FEE,F
034E6:  BNC   34EA
034E8:  INCF   FEF,F
*
038A6:  MOVLW  03
038A8:  ADDWF  x7F,W
038AA:  MOVWF  FE9
038AC:  MOVLW  00
038AE:  ADDWFC x80,W
038B0:  MOVWF  FEA
038B2:  MOVLW  01
038B4:  ADDWF  FEE,F
038B6:  BNC   38BA
038B8:  INCF   FEF,F
*
03C84:  MOVLW  03
03C86:  ADDWF  x7F,W
03C88:  MOVWF  FE9
03C8A:  MOVLW  00
03C8C:  ADDWFC x80,W
03C8E:  MOVWF  FEA
03C90:  MOVLW  01
03C92:  ADDWF  FEE,F
03C94:  BNC   3C98
03C96:  INCF   FEF,F
*
04054:  MOVLW  03
04056:  ADDWF  x7F,W
04058:  MOVWF  FE9
0405A:  MOVLW  00
0405C:  ADDWFC x80,W
0405E:  MOVWF  FEA
04060:  MOVLW  01
04062:  ADDWF  FEE,F
04064:  BNC   4068
04066:  INCF   FEF,F
*
1BC2C:  MOVLW  03
1BC2E:  ADDWF  x7F,W
1BC30:  MOVWF  FE9
1BC32:  MOVLW  00
1BC34:  ADDWFC x80,W
1BC36:  MOVWF  FEA
1BC38:  MOVLW  01
1BC3A:  ADDWF  FEE,F
1BC3C:  BNC   1BC40
1BC3E:  INCF   FEF,F
....................             buffer->state = receiving; 
*
0226A:  MOVLW  07
0226C:  ADDWF  x7F,W
0226E:  MOVWF  FE9
02270:  MOVLW  00
02272:  ADDWFC x80,W
02274:  MOVWF  FEA
02276:  MOVLW  01
02278:  MOVWF  FEF
*
0261C:  MOVLW  07
0261E:  ADDWF  x7F,W
02620:  MOVWF  FE9
02622:  MOVLW  00
02624:  ADDWFC x80,W
02626:  MOVWF  FEA
02628:  MOVLW  01
0262A:  MOVWF  FEF
*
029CE:  MOVLW  07
029D0:  ADDWF  x7F,W
029D2:  MOVWF  FE9
029D4:  MOVLW  00
029D6:  ADDWFC x80,W
029D8:  MOVWF  FEA
029DA:  MOVLW  01
029DC:  MOVWF  FEF
*
02D82:  MOVLW  07
02D84:  ADDWF  x7F,W
02D86:  MOVWF  FE9
02D88:  MOVLW  00
02D8A:  ADDWFC x80,W
02D8C:  MOVWF  FEA
02D8E:  MOVLW  01
02D90:  MOVWF  FEF
*
03136:  MOVLW  07
03138:  ADDWF  x7F,W
0313A:  MOVWF  FE9
0313C:  MOVLW  00
0313E:  ADDWFC x80,W
03140:  MOVWF  FEA
03142:  MOVLW  01
03144:  MOVWF  FEF
*
034EA:  MOVLW  07
034EC:  ADDWF  x7F,W
034EE:  MOVWF  FE9
034F0:  MOVLW  00
034F2:  ADDWFC x80,W
034F4:  MOVWF  FEA
034F6:  MOVLW  01
034F8:  MOVWF  FEF
*
038BA:  MOVLW  07
038BC:  ADDWF  x7F,W
038BE:  MOVWF  FE9
038C0:  MOVLW  00
038C2:  ADDWFC x80,W
038C4:  MOVWF  FEA
038C6:  MOVLW  01
038C8:  MOVWF  FEF
*
03C98:  MOVLW  07
03C9A:  ADDWF  x7F,W
03C9C:  MOVWF  FE9
03C9E:  MOVLW  00
03CA0:  ADDWFC x80,W
03CA2:  MOVWF  FEA
03CA4:  MOVLW  01
03CA6:  MOVWF  FEF
*
04068:  MOVLW  07
0406A:  ADDWF  x7F,W
0406C:  MOVWF  FE9
0406E:  MOVLW  00
04070:  ADDWFC x80,W
04072:  MOVWF  FEA
04074:  MOVLW  01
04076:  MOVWF  FEF
*
1BC40:  MOVLW  07
1BC42:  ADDWF  x7F,W
1BC44:  MOVWF  FE9
1BC46:  MOVLW  00
1BC48:  ADDWFC x80,W
1BC4A:  MOVWF  FEA
1BC4C:  MOVLW  01
1BC4E:  MOVWF  FEF
....................             break; 
*
0227A:  BRA    2470
*
0262C:  BRA    2822
*
029DE:  BRA    2BD4
*
02D92:  BRA    2F88
*
03146:  BRA    333C
*
034FA:  BRA    36F0
*
038CA:  BRA    3AC0
*
03CA8:  BRA    3E9E
*
04078:  BRA    426E
*
1BC50:  BRA    1BE46
....................         } 
....................         break; 
*
0227C:  BRA    2470
*
0262E:  BRA    2822
*
029E0:  BRA    2BD4
*
02D94:  BRA    2F88
*
03148:  BRA    333C
*
034FC:  BRA    36F0
*
038CC:  BRA    3AC0
*
03CAA:  BRA    3E9E
*
0407A:  BRA    426E
*
1BC52:  BRA    1BE46
....................     case receiving: 
....................         *(buffer->position) = rx; 
*
0227E:  MOVLW  03
02280:  MOVLB  D
02282:  ADDWF  x7F,W
02284:  MOVWF  FE9
02286:  MOVLW  00
02288:  ADDWFC x80,W
0228A:  MOVWF  FEA
0228C:  MOVFF  FEC,03
02290:  MOVF   FED,F
02292:  MOVFF  FEF,FE9
02296:  MOVFF  03,FEA
0229A:  MOVFF  D83,FEF
*
02630:  MOVLW  03
02632:  MOVLB  D
02634:  ADDWF  x7F,W
02636:  MOVWF  FE9
02638:  MOVLW  00
0263A:  ADDWFC x80,W
0263C:  MOVWF  FEA
0263E:  MOVFF  FEC,03
02642:  MOVF   FED,F
02644:  MOVFF  FEF,FE9
02648:  MOVFF  03,FEA
0264C:  MOVFF  D83,FEF
*
029E2:  MOVLW  03
029E4:  MOVLB  D
029E6:  ADDWF  x7F,W
029E8:  MOVWF  FE9
029EA:  MOVLW  00
029EC:  ADDWFC x80,W
029EE:  MOVWF  FEA
029F0:  MOVFF  FEC,03
029F4:  MOVF   FED,F
029F6:  MOVFF  FEF,FE9
029FA:  MOVFF  03,FEA
029FE:  MOVFF  D83,FEF
*
02D96:  MOVLW  03
02D98:  MOVLB  D
02D9A:  ADDWF  x7F,W
02D9C:  MOVWF  FE9
02D9E:  MOVLW  00
02DA0:  ADDWFC x80,W
02DA2:  MOVWF  FEA
02DA4:  MOVFF  FEC,03
02DA8:  MOVF   FED,F
02DAA:  MOVFF  FEF,FE9
02DAE:  MOVFF  03,FEA
02DB2:  MOVFF  D83,FEF
*
0314A:  MOVLW  03
0314C:  MOVLB  D
0314E:  ADDWF  x7F,W
03150:  MOVWF  FE9
03152:  MOVLW  00
03154:  ADDWFC x80,W
03156:  MOVWF  FEA
03158:  MOVFF  FEC,03
0315C:  MOVF   FED,F
0315E:  MOVFF  FEF,FE9
03162:  MOVFF  03,FEA
03166:  MOVFF  D83,FEF
*
034FE:  MOVLW  03
03500:  MOVLB  D
03502:  ADDWF  x7F,W
03504:  MOVWF  FE9
03506:  MOVLW  00
03508:  ADDWFC x80,W
0350A:  MOVWF  FEA
0350C:  MOVFF  FEC,03
03510:  MOVF   FED,F
03512:  MOVFF  FEF,FE9
03516:  MOVFF  03,FEA
0351A:  MOVFF  D83,FEF
*
038CE:  MOVLW  03
038D0:  MOVLB  D
038D2:  ADDWF  x7F,W
038D4:  MOVWF  FE9
038D6:  MOVLW  00
038D8:  ADDWFC x80,W
038DA:  MOVWF  FEA
038DC:  MOVFF  FEC,03
038E0:  MOVF   FED,F
038E2:  MOVFF  FEF,FE9
038E6:  MOVFF  03,FEA
038EA:  MOVFF  D83,FEF
*
03CAC:  MOVLW  03
03CAE:  MOVLB  D
03CB0:  ADDWF  x7F,W
03CB2:  MOVWF  FE9
03CB4:  MOVLW  00
03CB6:  ADDWFC x80,W
03CB8:  MOVWF  FEA
03CBA:  MOVFF  FEC,03
03CBE:  MOVF   FED,F
03CC0:  MOVFF  FEF,FE9
03CC4:  MOVFF  03,FEA
03CC8:  MOVFF  D83,FEF
*
0407C:  MOVLW  03
0407E:  MOVLB  D
04080:  ADDWF  x7F,W
04082:  MOVWF  FE9
04084:  MOVLW  00
04086:  ADDWFC x80,W
04088:  MOVWF  FEA
0408A:  MOVFF  FEC,03
0408E:  MOVF   FED,F
04090:  MOVFF  FEF,FE9
04094:  MOVFF  03,FEA
04098:  MOVFF  D83,FEF
*
1BC54:  MOVLW  03
1BC56:  MOVLB  D
1BC58:  ADDWF  x7F,W
1BC5A:  MOVWF  FE9
1BC5C:  MOVLW  00
1BC5E:  ADDWFC x80,W
1BC60:  MOVWF  FEA
1BC62:  MOVFF  FEC,03
1BC66:  MOVF   FED,F
1BC68:  MOVFF  FEF,FE9
1BC6C:  MOVFF  03,FEA
1BC70:  MOVFF  D83,FEF
....................         if (buffer->position >= buffer->end) { 
*
0229E:  MOVLW  03
022A0:  ADDWF  x7F,W
022A2:  MOVWF  FE9
022A4:  MOVLW  00
022A6:  ADDWFC x80,W
022A8:  MOVWF  FEA
022AA:  MOVFF  FEC,D85
022AE:  MOVF   FED,F
022B0:  MOVFF  FEF,D84
022B4:  MOVLW  05
022B6:  ADDWF  x7F,W
022B8:  MOVWF  FE9
022BA:  MOVLW  00
022BC:  ADDWFC x80,W
022BE:  MOVWF  FEA
022C0:  MOVFF  FEC,03
022C4:  MOVF   FED,F
022C6:  MOVFF  FEF,01
022CA:  MOVF   03,W
022CC:  SUBWF  x85,W
022CE:  BTFSS  FD8.0
022D0:  BRA    2456
022D2:  BNZ   22DC
022D4:  MOVF   01,W
022D6:  SUBWF  x84,W
022D8:  BTFSS  FD8.0
022DA:  BRA    2456
*
02650:  MOVLW  03
02652:  ADDWF  x7F,W
02654:  MOVWF  FE9
02656:  MOVLW  00
02658:  ADDWFC x80,W
0265A:  MOVWF  FEA
0265C:  MOVFF  FEC,D85
02660:  MOVF   FED,F
02662:  MOVFF  FEF,D84
02666:  MOVLW  05
02668:  ADDWF  x7F,W
0266A:  MOVWF  FE9
0266C:  MOVLW  00
0266E:  ADDWFC x80,W
02670:  MOVWF  FEA
02672:  MOVFF  FEC,03
02676:  MOVF   FED,F
02678:  MOVFF  FEF,01
0267C:  MOVF   03,W
0267E:  SUBWF  x85,W
02680:  BTFSS  FD8.0
02682:  BRA    2808
02684:  BNZ   268E
02686:  MOVF   01,W
02688:  SUBWF  x84,W
0268A:  BTFSS  FD8.0
0268C:  BRA    2808
*
02A02:  MOVLW  03
02A04:  ADDWF  x7F,W
02A06:  MOVWF  FE9
02A08:  MOVLW  00
02A0A:  ADDWFC x80,W
02A0C:  MOVWF  FEA
02A0E:  MOVFF  FEC,D85
02A12:  MOVF   FED,F
02A14:  MOVFF  FEF,D84
02A18:  MOVLW  05
02A1A:  ADDWF  x7F,W
02A1C:  MOVWF  FE9
02A1E:  MOVLW  00
02A20:  ADDWFC x80,W
02A22:  MOVWF  FEA
02A24:  MOVFF  FEC,03
02A28:  MOVF   FED,F
02A2A:  MOVFF  FEF,01
02A2E:  MOVF   03,W
02A30:  SUBWF  x85,W
02A32:  BTFSS  FD8.0
02A34:  BRA    2BBA
02A36:  BNZ   2A40
02A38:  MOVF   01,W
02A3A:  SUBWF  x84,W
02A3C:  BTFSS  FD8.0
02A3E:  BRA    2BBA
*
02DB6:  MOVLW  03
02DB8:  ADDWF  x7F,W
02DBA:  MOVWF  FE9
02DBC:  MOVLW  00
02DBE:  ADDWFC x80,W
02DC0:  MOVWF  FEA
02DC2:  MOVFF  FEC,D85
02DC6:  MOVF   FED,F
02DC8:  MOVFF  FEF,D84
02DCC:  MOVLW  05
02DCE:  ADDWF  x7F,W
02DD0:  MOVWF  FE9
02DD2:  MOVLW  00
02DD4:  ADDWFC x80,W
02DD6:  MOVWF  FEA
02DD8:  MOVFF  FEC,03
02DDC:  MOVF   FED,F
02DDE:  MOVFF  FEF,01
02DE2:  MOVF   03,W
02DE4:  SUBWF  x85,W
02DE6:  BTFSS  FD8.0
02DE8:  BRA    2F6E
02DEA:  BNZ   2DF4
02DEC:  MOVF   01,W
02DEE:  SUBWF  x84,W
02DF0:  BTFSS  FD8.0
02DF2:  BRA    2F6E
*
0316A:  MOVLW  03
0316C:  ADDWF  x7F,W
0316E:  MOVWF  FE9
03170:  MOVLW  00
03172:  ADDWFC x80,W
03174:  MOVWF  FEA
03176:  MOVFF  FEC,D85
0317A:  MOVF   FED,F
0317C:  MOVFF  FEF,D84
03180:  MOVLW  05
03182:  ADDWF  x7F,W
03184:  MOVWF  FE9
03186:  MOVLW  00
03188:  ADDWFC x80,W
0318A:  MOVWF  FEA
0318C:  MOVFF  FEC,03
03190:  MOVF   FED,F
03192:  MOVFF  FEF,01
03196:  MOVF   03,W
03198:  SUBWF  x85,W
0319A:  BTFSS  FD8.0
0319C:  BRA    3322
0319E:  BNZ   31A8
031A0:  MOVF   01,W
031A2:  SUBWF  x84,W
031A4:  BTFSS  FD8.0
031A6:  BRA    3322
*
0351E:  MOVLW  03
03520:  ADDWF  x7F,W
03522:  MOVWF  FE9
03524:  MOVLW  00
03526:  ADDWFC x80,W
03528:  MOVWF  FEA
0352A:  MOVFF  FEC,D85
0352E:  MOVF   FED,F
03530:  MOVFF  FEF,D84
03534:  MOVLW  05
03536:  ADDWF  x7F,W
03538:  MOVWF  FE9
0353A:  MOVLW  00
0353C:  ADDWFC x80,W
0353E:  MOVWF  FEA
03540:  MOVFF  FEC,03
03544:  MOVF   FED,F
03546:  MOVFF  FEF,01
0354A:  MOVF   03,W
0354C:  SUBWF  x85,W
0354E:  BTFSS  FD8.0
03550:  BRA    36D6
03552:  BNZ   355C
03554:  MOVF   01,W
03556:  SUBWF  x84,W
03558:  BTFSS  FD8.0
0355A:  BRA    36D6
*
038EE:  MOVLW  03
038F0:  ADDWF  x7F,W
038F2:  MOVWF  FE9
038F4:  MOVLW  00
038F6:  ADDWFC x80,W
038F8:  MOVWF  FEA
038FA:  MOVFF  FEC,D85
038FE:  MOVF   FED,F
03900:  MOVFF  FEF,D84
03904:  MOVLW  05
03906:  ADDWF  x7F,W
03908:  MOVWF  FE9
0390A:  MOVLW  00
0390C:  ADDWFC x80,W
0390E:  MOVWF  FEA
03910:  MOVFF  FEC,03
03914:  MOVF   FED,F
03916:  MOVFF  FEF,01
0391A:  MOVF   03,W
0391C:  SUBWF  x85,W
0391E:  BTFSS  FD8.0
03920:  BRA    3AA6
03922:  BNZ   392C
03924:  MOVF   01,W
03926:  SUBWF  x84,W
03928:  BTFSS  FD8.0
0392A:  BRA    3AA6
*
03CCC:  MOVLW  03
03CCE:  ADDWF  x7F,W
03CD0:  MOVWF  FE9
03CD2:  MOVLW  00
03CD4:  ADDWFC x80,W
03CD6:  MOVWF  FEA
03CD8:  MOVFF  FEC,D85
03CDC:  MOVF   FED,F
03CDE:  MOVFF  FEF,D84
03CE2:  MOVLW  05
03CE4:  ADDWF  x7F,W
03CE6:  MOVWF  FE9
03CE8:  MOVLW  00
03CEA:  ADDWFC x80,W
03CEC:  MOVWF  FEA
03CEE:  MOVFF  FEC,03
03CF2:  MOVF   FED,F
03CF4:  MOVFF  FEF,01
03CF8:  MOVF   03,W
03CFA:  SUBWF  x85,W
03CFC:  BTFSS  FD8.0
03CFE:  BRA    3E84
03D00:  BNZ   3D0A
03D02:  MOVF   01,W
03D04:  SUBWF  x84,W
03D06:  BTFSS  FD8.0
03D08:  BRA    3E84
*
0409C:  MOVLW  03
0409E:  ADDWF  x7F,W
040A0:  MOVWF  FE9
040A2:  MOVLW  00
040A4:  ADDWFC x80,W
040A6:  MOVWF  FEA
040A8:  MOVFF  FEC,D85
040AC:  MOVF   FED,F
040AE:  MOVFF  FEF,D84
040B2:  MOVLW  05
040B4:  ADDWF  x7F,W
040B6:  MOVWF  FE9
040B8:  MOVLW  00
040BA:  ADDWFC x80,W
040BC:  MOVWF  FEA
040BE:  MOVFF  FEC,03
040C2:  MOVF   FED,F
040C4:  MOVFF  FEF,01
040C8:  MOVF   03,W
040CA:  SUBWF  x85,W
040CC:  BTFSS  FD8.0
040CE:  BRA    4254
040D0:  BNZ   40DA
040D2:  MOVF   01,W
040D4:  SUBWF  x84,W
040D6:  BTFSS  FD8.0
040D8:  BRA    4254
*
1BC74:  MOVLW  03
1BC76:  ADDWF  x7F,W
1BC78:  MOVWF  FE9
1BC7A:  MOVLW  00
1BC7C:  ADDWFC x80,W
1BC7E:  MOVWF  FEA
1BC80:  MOVFF  FEC,D85
1BC84:  MOVF   FED,F
1BC86:  MOVFF  FEF,D84
1BC8A:  MOVLW  05
1BC8C:  ADDWF  x7F,W
1BC8E:  MOVWF  FE9
1BC90:  MOVLW  00
1BC92:  ADDWFC x80,W
1BC94:  MOVWF  FEA
1BC96:  MOVFF  FEC,03
1BC9A:  MOVF   FED,F
1BC9C:  MOVFF  FEF,01
1BCA0:  MOVF   03,W
1BCA2:  SUBWF  x85,W
1BCA4:  BTFSS  FD8.0
1BCA6:  BRA    1BE2C
1BCA8:  BNZ   1BCB2
1BCAA:  MOVF   01,W
1BCAC:  SUBWF  x84,W
1BCAE:  BTFSS  FD8.0
1BCB0:  BRA    1BE2C
....................             check_string(buffer); 
*
022DC:  MOVFF  D80,D85
022E0:  MOVFF  D7F,D84
*
0268E:  MOVFF  D80,D85
02692:  MOVFF  D7F,D84
*
02A40:  MOVFF  D80,D85
02A44:  MOVFF  D7F,D84
*
02DF4:  MOVFF  D80,D85
02DF8:  MOVFF  D7F,D84
*
031A8:  MOVFF  D80,D85
031AC:  MOVFF  D7F,D84
*
0355C:  MOVFF  D80,D85
03560:  MOVFF  D7F,D84
*
0392C:  MOVFF  D80,D85
03930:  MOVFF  D7F,D84
*
03D0A:  MOVFF  D80,D85
03D0E:  MOVFF  D7F,D84
*
040DA:  MOVFF  D80,D85
040DE:  MOVFF  D7F,D84
*
1BCB2:  MOVFF  D80,D85
1BCB6:  MOVFF  D7F,D84
....................             break; 
*
02454:  BRA    2470
*
02806:  BRA    2822
*
02BB8:  BRA    2BD4
*
02F6C:  BRA    2F88
*
03320:  BRA    333C
*
036D4:  BRA    36F0
*
03AA4:  BRA    3AC0
*
03E82:  BRA    3E9E
*
04252:  BRA    426E
*
1BE2A:  BRA    1BE46
....................         } 
....................         buffer->position++; 
*
02456:  MOVLW  03
02458:  ADDWF  x7F,W
0245A:  MOVWF  FE9
0245C:  MOVLW  00
0245E:  ADDWFC x80,W
02460:  MOVWF  FEA
02462:  MOVLW  01
02464:  ADDWF  FEE,F
02466:  BNC   246A
02468:  INCF   FEF,F
*
02808:  MOVLW  03
0280A:  ADDWF  x7F,W
0280C:  MOVWF  FE9
0280E:  MOVLW  00
02810:  ADDWFC x80,W
02812:  MOVWF  FEA
02814:  MOVLW  01
02816:  ADDWF  FEE,F
02818:  BNC   281C
0281A:  INCF   FEF,F
*
02BBA:  MOVLW  03
02BBC:  ADDWF  x7F,W
02BBE:  MOVWF  FE9
02BC0:  MOVLW  00
02BC2:  ADDWFC x80,W
02BC4:  MOVWF  FEA
02BC6:  MOVLW  01
02BC8:  ADDWF  FEE,F
02BCA:  BNC   2BCE
02BCC:  INCF   FEF,F
*
02F6E:  MOVLW  03
02F70:  ADDWF  x7F,W
02F72:  MOVWF  FE9
02F74:  MOVLW  00
02F76:  ADDWFC x80,W
02F78:  MOVWF  FEA
02F7A:  MOVLW  01
02F7C:  ADDWF  FEE,F
02F7E:  BNC   2F82
02F80:  INCF   FEF,F
*
03322:  MOVLW  03
03324:  ADDWF  x7F,W
03326:  MOVWF  FE9
03328:  MOVLW  00
0332A:  ADDWFC x80,W
0332C:  MOVWF  FEA
0332E:  MOVLW  01
03330:  ADDWF  FEE,F
03332:  BNC   3336
03334:  INCF   FEF,F
*
036D6:  MOVLW  03
036D8:  ADDWF  x7F,W
036DA:  MOVWF  FE9
036DC:  MOVLW  00
036DE:  ADDWFC x80,W
036E0:  MOVWF  FEA
036E2:  MOVLW  01
036E4:  ADDWF  FEE,F
036E6:  BNC   36EA
036E8:  INCF   FEF,F
*
03AA6:  MOVLW  03
03AA8:  ADDWF  x7F,W
03AAA:  MOVWF  FE9
03AAC:  MOVLW  00
03AAE:  ADDWFC x80,W
03AB0:  MOVWF  FEA
03AB2:  MOVLW  01
03AB4:  ADDWF  FEE,F
03AB6:  BNC   3ABA
03AB8:  INCF   FEF,F
*
03E84:  MOVLW  03
03E86:  ADDWF  x7F,W
03E88:  MOVWF  FE9
03E8A:  MOVLW  00
03E8C:  ADDWFC x80,W
03E8E:  MOVWF  FEA
03E90:  MOVLW  01
03E92:  ADDWF  FEE,F
03E94:  BNC   3E98
03E96:  INCF   FEF,F
*
04254:  MOVLW  03
04256:  ADDWF  x7F,W
04258:  MOVWF  FE9
0425A:  MOVLW  00
0425C:  ADDWFC x80,W
0425E:  MOVWF  FEA
04260:  MOVLW  01
04262:  ADDWF  FEE,F
04264:  BNC   4268
04266:  INCF   FEF,F
*
1BE2C:  MOVLW  03
1BE2E:  ADDWF  x7F,W
1BE30:  MOVWF  FE9
1BE32:  MOVLW  00
1BE34:  ADDWFC x80,W
1BE36:  MOVWF  FEA
1BE38:  MOVLW  01
1BE3A:  ADDWF  FEE,F
1BE3C:  BNC   1BE40
1BE3E:  INCF   FEF,F
....................         break; 
*
0246A:  BRA    2470
0246C:  MOVLB  0
*
0281C:  BRA    2822
0281E:  MOVLB  0
*
02BCE:  BRA    2BD4
02BD0:  MOVLB  0
*
02F82:  BRA    2F88
02F84:  MOVLB  0
*
03336:  BRA    333C
03338:  MOVLB  0
*
036EA:  BRA    36F0
036EC:  MOVLB  0
*
03ABA:  BRA    3AC0
03ABC:  MOVLB  0
*
03E98:  BRA    3E9E
03E9A:  MOVLB  0
*
04268:  BRA    426E
0426A:  MOVLB  0
*
1BE40:  BRA    1BE46
1BE42:  MOVLB  0
....................     default: 
....................         break; 
*
0246E:  MOVLB  D
*
02820:  MOVLB  D
*
02BD2:  MOVLB  D
*
02F86:  MOVLB  D
*
0333A:  MOVLB  D
*
036EE:  MOVLB  D
*
03ABE:  MOVLB  D
*
03E9C:  MOVLB  D
*
0426C:  MOVLB  D
*
1BE44:  MOVLB  D
....................     } 
....................     if (buffer->position >= buffer->data + buffer->size) { 
*
02470:  MOVLW  03
02472:  ADDWF  x7F,W
02474:  MOVWF  FE9
02476:  MOVLW  00
02478:  ADDWFC x80,W
0247A:  MOVWF  FEA
0247C:  MOVFF  FEC,D85
02480:  MOVF   FED,F
02482:  MOVFF  FEF,D84
02486:  MOVFF  D7F,FE9
0248A:  MOVFF  D80,FEA
0248E:  MOVFF  FEC,D87
02492:  MOVF   FED,F
02494:  MOVFF  FEF,D86
02498:  MOVLW  02
0249A:  ADDWF  x7F,W
0249C:  MOVWF  FE9
0249E:  MOVLW  00
024A0:  ADDWFC x80,W
024A2:  MOVWF  FEA
024A4:  MOVF   FEF,W
024A6:  ADDWF  x86,W
024A8:  MOVWF  01
024AA:  MOVLW  00
024AC:  ADDWFC x87,W
024AE:  MOVWF  03
024B0:  MOVF   03,W
024B2:  SUBWF  x85,W
024B4:  BNC   252C
024B6:  BNZ   24BE
024B8:  MOVF   01,W
024BA:  SUBWF  x84,W
024BC:  BNC   252C
*
02822:  MOVLW  03
02824:  ADDWF  x7F,W
02826:  MOVWF  FE9
02828:  MOVLW  00
0282A:  ADDWFC x80,W
0282C:  MOVWF  FEA
0282E:  MOVFF  FEC,D85
02832:  MOVF   FED,F
02834:  MOVFF  FEF,D84
02838:  MOVFF  D7F,FE9
0283C:  MOVFF  D80,FEA
02840:  MOVFF  FEC,D87
02844:  MOVF   FED,F
02846:  MOVFF  FEF,D86
0284A:  MOVLW  02
0284C:  ADDWF  x7F,W
0284E:  MOVWF  FE9
02850:  MOVLW  00
02852:  ADDWFC x80,W
02854:  MOVWF  FEA
02856:  MOVF   FEF,W
02858:  ADDWF  x86,W
0285A:  MOVWF  01
0285C:  MOVLW  00
0285E:  ADDWFC x87,W
02860:  MOVWF  03
02862:  MOVF   03,W
02864:  SUBWF  x85,W
02866:  BNC   28DE
02868:  BNZ   2870
0286A:  MOVF   01,W
0286C:  SUBWF  x84,W
0286E:  BNC   28DE
*
02BD4:  MOVLW  03
02BD6:  ADDWF  x7F,W
02BD8:  MOVWF  FE9
02BDA:  MOVLW  00
02BDC:  ADDWFC x80,W
02BDE:  MOVWF  FEA
02BE0:  MOVFF  FEC,D85
02BE4:  MOVF   FED,F
02BE6:  MOVFF  FEF,D84
02BEA:  MOVFF  D7F,FE9
02BEE:  MOVFF  D80,FEA
02BF2:  MOVFF  FEC,D87
02BF6:  MOVF   FED,F
02BF8:  MOVFF  FEF,D86
02BFC:  MOVLW  02
02BFE:  ADDWF  x7F,W
02C00:  MOVWF  FE9
02C02:  MOVLW  00
02C04:  ADDWFC x80,W
02C06:  MOVWF  FEA
02C08:  MOVF   FEF,W
02C0A:  ADDWF  x86,W
02C0C:  MOVWF  01
02C0E:  MOVLW  00
02C10:  ADDWFC x87,W
02C12:  MOVWF  03
02C14:  MOVF   03,W
02C16:  SUBWF  x85,W
02C18:  BNC   2C90
02C1A:  BNZ   2C22
02C1C:  MOVF   01,W
02C1E:  SUBWF  x84,W
02C20:  BNC   2C90
*
02F88:  MOVLW  03
02F8A:  ADDWF  x7F,W
02F8C:  MOVWF  FE9
02F8E:  MOVLW  00
02F90:  ADDWFC x80,W
02F92:  MOVWF  FEA
02F94:  MOVFF  FEC,D85
02F98:  MOVF   FED,F
02F9A:  MOVFF  FEF,D84
02F9E:  MOVFF  D7F,FE9
02FA2:  MOVFF  D80,FEA
02FA6:  MOVFF  FEC,D87
02FAA:  MOVF   FED,F
02FAC:  MOVFF  FEF,D86
02FB0:  MOVLW  02
02FB2:  ADDWF  x7F,W
02FB4:  MOVWF  FE9
02FB6:  MOVLW  00
02FB8:  ADDWFC x80,W
02FBA:  MOVWF  FEA
02FBC:  MOVF   FEF,W
02FBE:  ADDWF  x86,W
02FC0:  MOVWF  01
02FC2:  MOVLW  00
02FC4:  ADDWFC x87,W
02FC6:  MOVWF  03
02FC8:  MOVF   03,W
02FCA:  SUBWF  x85,W
02FCC:  BNC   3044
02FCE:  BNZ   2FD6
02FD0:  MOVF   01,W
02FD2:  SUBWF  x84,W
02FD4:  BNC   3044
*
0333C:  MOVLW  03
0333E:  ADDWF  x7F,W
03340:  MOVWF  FE9
03342:  MOVLW  00
03344:  ADDWFC x80,W
03346:  MOVWF  FEA
03348:  MOVFF  FEC,D85
0334C:  MOVF   FED,F
0334E:  MOVFF  FEF,D84
03352:  MOVFF  D7F,FE9
03356:  MOVFF  D80,FEA
0335A:  MOVFF  FEC,D87
0335E:  MOVF   FED,F
03360:  MOVFF  FEF,D86
03364:  MOVLW  02
03366:  ADDWF  x7F,W
03368:  MOVWF  FE9
0336A:  MOVLW  00
0336C:  ADDWFC x80,W
0336E:  MOVWF  FEA
03370:  MOVF   FEF,W
03372:  ADDWF  x86,W
03374:  MOVWF  01
03376:  MOVLW  00
03378:  ADDWFC x87,W
0337A:  MOVWF  03
0337C:  MOVF   03,W
0337E:  SUBWF  x85,W
03380:  BNC   33F8
03382:  BNZ   338A
03384:  MOVF   01,W
03386:  SUBWF  x84,W
03388:  BNC   33F8
*
036F0:  MOVLW  03
036F2:  ADDWF  x7F,W
036F4:  MOVWF  FE9
036F6:  MOVLW  00
036F8:  ADDWFC x80,W
036FA:  MOVWF  FEA
036FC:  MOVFF  FEC,D85
03700:  MOVF   FED,F
03702:  MOVFF  FEF,D84
03706:  MOVFF  D7F,FE9
0370A:  MOVFF  D80,FEA
0370E:  MOVFF  FEC,D87
03712:  MOVF   FED,F
03714:  MOVFF  FEF,D86
03718:  MOVLW  02
0371A:  ADDWF  x7F,W
0371C:  MOVWF  FE9
0371E:  MOVLW  00
03720:  ADDWFC x80,W
03722:  MOVWF  FEA
03724:  MOVF   FEF,W
03726:  ADDWF  x86,W
03728:  MOVWF  01
0372A:  MOVLW  00
0372C:  ADDWFC x87,W
0372E:  MOVWF  03
03730:  MOVF   03,W
03732:  SUBWF  x85,W
03734:  BNC   37AC
03736:  BNZ   373E
03738:  MOVF   01,W
0373A:  SUBWF  x84,W
0373C:  BNC   37AC
*
03AC0:  MOVLW  03
03AC2:  ADDWF  x7F,W
03AC4:  MOVWF  FE9
03AC6:  MOVLW  00
03AC8:  ADDWFC x80,W
03ACA:  MOVWF  FEA
03ACC:  MOVFF  FEC,D85
03AD0:  MOVF   FED,F
03AD2:  MOVFF  FEF,D84
03AD6:  MOVFF  D7F,FE9
03ADA:  MOVFF  D80,FEA
03ADE:  MOVFF  FEC,D87
03AE2:  MOVF   FED,F
03AE4:  MOVFF  FEF,D86
03AE8:  MOVLW  02
03AEA:  ADDWF  x7F,W
03AEC:  MOVWF  FE9
03AEE:  MOVLW  00
03AF0:  ADDWFC x80,W
03AF2:  MOVWF  FEA
03AF4:  MOVF   FEF,W
03AF6:  ADDWF  x86,W
03AF8:  MOVWF  01
03AFA:  MOVLW  00
03AFC:  ADDWFC x87,W
03AFE:  MOVWF  03
03B00:  MOVF   03,W
03B02:  SUBWF  x85,W
03B04:  BNC   3B7C
03B06:  BNZ   3B0E
03B08:  MOVF   01,W
03B0A:  SUBWF  x84,W
03B0C:  BNC   3B7C
*
03E9E:  MOVLW  03
03EA0:  ADDWF  x7F,W
03EA2:  MOVWF  FE9
03EA4:  MOVLW  00
03EA6:  ADDWFC x80,W
03EA8:  MOVWF  FEA
03EAA:  MOVFF  FEC,D85
03EAE:  MOVF   FED,F
03EB0:  MOVFF  FEF,D84
03EB4:  MOVFF  D7F,FE9
03EB8:  MOVFF  D80,FEA
03EBC:  MOVFF  FEC,D87
03EC0:  MOVF   FED,F
03EC2:  MOVFF  FEF,D86
03EC6:  MOVLW  02
03EC8:  ADDWF  x7F,W
03ECA:  MOVWF  FE9
03ECC:  MOVLW  00
03ECE:  ADDWFC x80,W
03ED0:  MOVWF  FEA
03ED2:  MOVF   FEF,W
03ED4:  ADDWF  x86,W
03ED6:  MOVWF  01
03ED8:  MOVLW  00
03EDA:  ADDWFC x87,W
03EDC:  MOVWF  03
03EDE:  MOVF   03,W
03EE0:  SUBWF  x85,W
03EE2:  BNC   3F5A
03EE4:  BNZ   3EEC
03EE6:  MOVF   01,W
03EE8:  SUBWF  x84,W
03EEA:  BNC   3F5A
*
0426E:  MOVLW  03
04270:  ADDWF  x7F,W
04272:  MOVWF  FE9
04274:  MOVLW  00
04276:  ADDWFC x80,W
04278:  MOVWF  FEA
0427A:  MOVFF  FEC,D85
0427E:  MOVF   FED,F
04280:  MOVFF  FEF,D84
04284:  MOVFF  D7F,FE9
04288:  MOVFF  D80,FEA
0428C:  MOVFF  FEC,D87
04290:  MOVF   FED,F
04292:  MOVFF  FEF,D86
04296:  MOVLW  02
04298:  ADDWF  x7F,W
0429A:  MOVWF  FE9
0429C:  MOVLW  00
0429E:  ADDWFC x80,W
042A0:  MOVWF  FEA
042A2:  MOVF   FEF,W
042A4:  ADDWF  x86,W
042A6:  MOVWF  01
042A8:  MOVLW  00
042AA:  ADDWFC x87,W
042AC:  MOVWF  03
042AE:  MOVF   03,W
042B0:  SUBWF  x85,W
042B2:  BNC   432A
042B4:  BNZ   42BC
042B6:  MOVF   01,W
042B8:  SUBWF  x84,W
042BA:  BNC   432A
*
1BE46:  MOVLW  03
1BE48:  ADDWF  x7F,W
1BE4A:  MOVWF  FE9
1BE4C:  MOVLW  00
1BE4E:  ADDWFC x80,W
1BE50:  MOVWF  FEA
1BE52:  MOVFF  FEC,D85
1BE56:  MOVF   FED,F
1BE58:  MOVFF  FEF,D84
1BE5C:  MOVFF  D7F,FE9
1BE60:  MOVFF  D80,FEA
1BE64:  MOVFF  FEC,D87
1BE68:  MOVF   FED,F
1BE6A:  MOVFF  FEF,D86
1BE6E:  MOVLW  02
1BE70:  ADDWF  x7F,W
1BE72:  MOVWF  FE9
1BE74:  MOVLW  00
1BE76:  ADDWFC x80,W
1BE78:  MOVWF  FEA
1BE7A:  MOVF   FEF,W
1BE7C:  ADDWF  x86,W
1BE7E:  MOVWF  01
1BE80:  MOVLW  00
1BE82:  ADDWFC x87,W
1BE84:  MOVWF  03
1BE86:  MOVF   03,W
1BE88:  SUBWF  x85,W
1BE8A:  BNC   1BF02
1BE8C:  BNZ   1BE94
1BE8E:  MOVF   01,W
1BE90:  SUBWF  x84,W
1BE92:  BNC   1BF02
....................         uart_reset(buffer); 
*
024BE:  MOVFF  D80,D85
024C2:  MOVFF  D7F,D84
*
02870:  MOVFF  D80,D85
02874:  MOVFF  D7F,D84
*
02C22:  MOVFF  D80,D85
02C26:  MOVFF  D7F,D84
*
02FD6:  MOVFF  D80,D85
02FDA:  MOVFF  D7F,D84
*
0338A:  MOVFF  D80,D85
0338E:  MOVFF  D7F,D84
*
0373E:  MOVFF  D80,D85
03742:  MOVFF  D7F,D84
*
03B0E:  MOVFF  D80,D85
03B12:  MOVFF  D7F,D84
*
03EEC:  MOVFF  D80,D85
03EF0:  MOVFF  D7F,D84
*
042BC:  MOVFF  D80,D85
042C0:  MOVFF  D7F,D84
*
1BE94:  MOVFF  D80,D85
1BE98:  MOVFF  D7F,D84
....................     } 
.................... } 
....................  
.................... #endif // !LIBUART_H 
....................  
.................... #include "libuart_fn.h" 
.................... #ifndef LIBUART_FN_H 
.................... #define LIBUART_FN_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... void uart_print_pc_hex(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size - 1; i++) { 
*
07A5C:  MOVLB  C
07A5E:  CLRF   x92
07A60:  MOVLW  01
07A62:  SUBWF  x91,W
07A64:  SUBWF  x92,W
07A66:  BC    7A94
....................         fprintf(PC, "%02X ", data[i]); 
07A68:  MOVF   x92,W
07A6A:  ADDWF  x8F,W
07A6C:  MOVWF  FE9
07A6E:  MOVLW  00
07A70:  ADDWFC x90,W
07A72:  MOVWF  FEA
07A74:  MOVFF  FEF,CBF
07A78:  MOVLW  37
07A7A:  MOVWF  xC0
07A7C:  MOVLB  0
07A7E:  CALL   5A92
07A82:  MOVLW  20
07A84:  MOVLB  D
07A86:  MOVWF  x6A
07A88:  MOVLB  0
07A8A:  CALL   44EE
07A8E:  MOVLB  C
07A90:  INCF   x92,F
07A92:  BRA    7A60
....................     } 
....................     fprintf(PC, "%02X", data[size - 1]); 
07A94:  MOVLW  01
07A96:  SUBWF  x91,W
07A98:  ADDWF  x8F,W
07A9A:  MOVWF  FE9
07A9C:  MOVLW  00
07A9E:  ADDWFC x90,W
07AA0:  MOVWF  FEA
07AA2:  MOVFF  FEF,CBF
07AA6:  MOVLW  37
07AA8:  MOVWF  xC0
07AAA:  MOVLB  0
07AAC:  CALL   5A92
07AB0:  RETURN 0
.................... } 
....................  
.................... void uart_print_pc_hex_short(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size; i++) { 
*
15402:  MOVLB  C
15404:  CLRF   x5D
15406:  MOVF   x5C,W
15408:  SUBWF  x5D,W
1540A:  BC    15430
....................         fprintf(PC, "%02X", data[i]); 
1540C:  MOVF   x5D,W
1540E:  ADDWF  x5A,W
15410:  MOVWF  FE9
15412:  MOVLW  00
15414:  ADDWFC x5B,W
15416:  MOVWF  FEA
15418:  MOVFF  FEF,C5E
1541C:  MOVFF  C5E,CBF
15420:  MOVLW  37
15422:  MOVWF  xC0
15424:  MOVLB  0
15426:  CALL   5A92
1542A:  MOVLB  C
1542C:  INCF   x5D,F
1542E:  BRA    15406
....................     } 
15430:  MOVLB  0
15432:  RETURN 0
.................... } 
....................  
.................... void uart_download_packet(uart_fn* port, uint8_t* buffer, uint32_t size, uint32_t timeout) 
*
097CE:  MOVLB  D
097D0:  CLRF   x50
.................... { 
....................     uint8_t n = 0; 
....................     for (uint32_t i = 0; i < timeout; i++) { 
097D2:  CLRF   x54
097D4:  CLRF   x53
097D6:  CLRF   x52
097D8:  CLRF   x51
097DA:  MOVF   x54,W
097DC:  SUBWF  x4F,W
097DE:  BNC   9886
097E0:  BNZ   97F8
097E2:  MOVF   x53,W
097E4:  SUBWF  x4E,W
097E6:  BNC   9886
097E8:  BNZ   97F8
097EA:  MOVF   x52,W
097EC:  SUBWF  x4D,W
097EE:  BNC   9886
097F0:  BNZ   97F8
097F2:  MOVF   x4C,W
097F4:  SUBWF  x51,W
097F6:  BC    9886
....................         if (port->bytes_available()) { 
097F8:  MOVFF  D44,01
097FC:  MOVFF  D45,03
09800:  MOVFF  D44,D55
09804:  MOVFF  D45,D56
09808:  MOVFF  D45,FEA
0980C:  MOVFF  D44,FE9
09810:  MOVLB  0
09812:  CALL   03FC
09816:  MOVF   01,F
09818:  BZ    9872
....................             buffer[n++] = port->get_char(); 
0981A:  MOVLB  D
0981C:  MOVF   x50,W
0981E:  INCF   x50,F
09820:  ADDWF  x46,W
09822:  MOVWF  01
09824:  MOVLW  00
09826:  ADDWFC x47,W
09828:  MOVWF  03
0982A:  MOVFF  01,D55
0982E:  MOVWF  x56
09830:  MOVLW  04
09832:  ADDWF  x44,W
09834:  MOVWF  01
09836:  MOVLW  00
09838:  ADDWFC x45,W
0983A:  MOVWF  03
0983C:  MOVFF  01,D57
09840:  MOVWF  x58
09842:  MOVWF  FEA
09844:  MOVFF  01,FE9
09848:  MOVLB  0
0984A:  CALL   03FC
0984E:  MOVFF  D56,FEA
09852:  MOVFF  D55,FE9
09856:  MOVFF  01,FEF
....................             if (n >= size) 
0985A:  MOVLB  D
0985C:  MOVF   x4B,F
0985E:  BNZ   9870
09860:  MOVF   x4A,F
09862:  BNZ   9870
09864:  MOVF   x49,F
09866:  BNZ   9870
09868:  MOVF   x48,W
0986A:  SUBWF  x50,W
0986C:  BNC   9870
....................                 break; 
0986E:  BRA    9886
09870:  MOVLB  0
....................         } 
09872:  MOVLW  01
09874:  MOVLB  D
09876:  ADDWF  x51,F
09878:  BTFSC  FD8.0
0987A:  INCF   x52,F
0987C:  BTFSC  FD8.2
0987E:  INCF   x53,F
09880:  BTFSC  FD8.2
09882:  INCF   x54,F
09884:  BRA    97DA
....................     } 
09886:  MOVLB  0
09888:  RETURN 0
.................... } 
....................  
.................... // Send packet macro; buffer is of type uint8_t*; 
.................... void uart_send_packet(uart_fn* port, uint8_t* buffer, uint32_t size) 
.................... { 
....................     for (uint8_t* i = buffer; i < size + buffer; i++) { 
*
08EDE:  MOVFF  D3E,D44
08EE2:  MOVFF  D3D,D43
08EE6:  MOVLB  D
08EE8:  MOVF   x3D,W
08EEA:  ADDWF  x3F,W
08EEC:  MOVWF  01
08EEE:  MOVF   x3E,W
08EF0:  ADDWFC x40,W
08EF2:  MOVWF  03
08EF4:  MOVF   x44,W
08EF6:  SUBWF  03,W
08EF8:  BNC   8F38
08EFA:  BNZ   8F02
08EFC:  MOVF   01,W
08EFE:  SUBWF  x43,W
08F00:  BC    8F38
....................         port->put_char(*i); 
08F02:  MOVLW  08
08F04:  ADDWF  x3B,W
08F06:  MOVWF  01
08F08:  MOVLW  00
08F0A:  ADDWFC x3C,W
08F0C:  MOVFF  01,D45
08F10:  MOVWF  x46
08F12:  MOVFF  D44,03
08F16:  MOVFF  D43,FE9
08F1A:  MOVFF  D44,FEA
08F1E:  MOVFF  FEF,D69
08F22:  MOVWF  FEA
08F24:  MOVFF  01,FE9
08F28:  MOVLB  0
08F2A:  CALL   03FC
08F2E:  MOVLB  D
08F30:  INCF   x43,F
08F32:  BTFSC  FD8.2
08F34:  INCF   x44,F
08F36:  BRA    8EE8
....................     } 
08F38:  MOVLB  0
08F3A:  RETURN 0
.................... } 
....................  
.................... void uart_send_packet_repeat(uart_fn* port, uint8_t* buffer, uint32_t size, uint8_t repetitions, uint32_t delay) 
.................... { 
....................     for(uint8_t i=0; i<repetitions; i++){ 
08F3C:  MOVLB  C
08F3E:  CLRF   xBB
08F40:  MOVF   xB6,W
08F42:  SUBWF  xBB,W
08F44:  BC    8F96
....................         uart_send_packet(port, buffer, size); 
08F46:  MOVFF  CAF,D3C
08F4A:  MOVFF  CAE,D3B
08F4E:  MOVFF  CB1,D3E
08F52:  MOVFF  CB0,D3D
08F56:  MOVFF  CB5,D42
08F5A:  MOVFF  CB4,D41
08F5E:  MOVFF  CB3,D40
08F62:  MOVFF  CB2,D3F
08F66:  MOVLB  0
08F68:  RCALL  8EDE
....................         delay_ms(delay); 
08F6A:  MOVFF  CB8,CBC
08F6E:  MOVLB  C
08F70:  INCF   xBC,F
08F72:  DECF   xBC,F
08F74:  BTFSC  FD8.2
08F76:  BRA    8F86
08F78:  MOVLB  D
08F7A:  SETF   x52
08F7C:  MOVLB  0
08F7E:  CALL   5266
08F82:  MOVLB  C
08F84:  BRA    8F72
08F86:  MOVFF  CB7,D52
08F8A:  MOVLB  0
08F8C:  CALL   5266
08F90:  MOVLB  C
08F92:  INCF   xBB,F
08F94:  BRA    8F40
....................     } 
08F96:  MOVLB  0
08F98:  RETURN 0
.................... } 
....................  
.................... #endif // !LIBUART_FN_H 
....................  
....................  
.................... #include "rtcperipheral.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          rtcperipheral.c                          //// 
.................... ////                                                                   //// 
.................... //// Using the built-in RTC provided on some devices, provides a time  //// 
.................... //// base and the functions needed for a time.h compatable driver.     //// 
.................... //// See time.h for documentation of the time.h library.               //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __RTCPERIPHERAL_C__ 
.................... #define __RTCPERIPHERAL_C__ 
....................  
.................... #include <time.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              time.c                                 /// 
.................... ///                                                                     /// 
.................... /// Contains common time routines that can be used by several           /// 
.................... /// timebases, and the runtime code needed for time.h.                  /// 
.................... ///                                                                     /// 
.................... /// See time.h for documentation.                                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_C__ 
.................... #define __TIME_C__ 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... static unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
.................... { 
....................    switch(month) 
*
046C4:  MOVLB  C
046C6:  MOVF   x8B,W
046C8:  XORLW  00
046CA:  MOVLB  0
046CC:  BZ    46FC
046CE:  XORLW  02
046D0:  BZ    46FC
046D2:  XORLW  06
046D4:  BZ    46FC
046D6:  XORLW  02
046D8:  BZ    46FC
046DA:  XORLW  01
046DC:  BZ    46FC
046DE:  XORLW  0E
046E0:  BZ    46FC
046E2:  XORLW  02
046E4:  BZ    46FC
046E6:  XORLW  0A
046E8:  BZ    4702
046EA:  XORLW  02
046EC:  BZ    471A
046EE:  XORLW  06
046F0:  BZ    471A
046F2:  XORLW  0D
046F4:  BZ    471A
046F6:  XORLW  02
046F8:  BZ    471A
046FA:  BRA    4720
....................    { 
....................       case JANUARY: 
....................       case MARCH: 
....................       case MAY: 
....................       case JULY: 
....................       case AUGUST: 
....................       case OCTOBER: 
....................       case DECEMBER: 
....................          return 31; 
046FC:  MOVLW  1F
046FE:  MOVWF  01
04700:  BRA    4724
....................  
....................       case FEBRUARY: 
....................          if(IsLeapYear) 
04702:  MOVLB  C
04704:  MOVF   x8C,F
04706:  BZ    4712
....................             return 29;             
04708:  MOVLW  1D
0470A:  MOVWF  01
0470C:  MOVLB  0
0470E:  BRA    4724
04710:  MOVLB  C
....................          return 28; 
04712:  MOVLW  1C
04714:  MOVWF  01
04716:  MOVLB  0
04718:  BRA    4724
....................  
....................       case APRIL: 
....................       case JUNE: 
....................       case SEPTEMBER: 
....................       case NOVEMBER: 
....................          return 30; 
0471A:  MOVLW  1E
0471C:  MOVWF  01
0471E:  BRA    4724
....................        
....................       // error 
....................       default: 
....................          return 0; 
04720:  MOVLW  00
04722:  MOVWF  01
....................    } 
04724:  RETURN 0
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... static void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... static void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... static int1 LeapYear(unsigned int16 year) 
.................... { 
....................    if( ((year + 1900) % 400 == 0) ||  
....................        (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
04610:  MOVLW  6C
04612:  MOVLB  C
04614:  ADDWF  x8A,W
04616:  MOVWF  x8C
04618:  MOVLW  07
0461A:  ADDWFC x8B,W
0461C:  MOVWF  x8D
0461E:  MOVWF  x8F
04620:  MOVFF  C8C,C8E
04624:  MOVLW  01
04626:  MOVWF  x91
04628:  MOVLW  90
0462A:  MOVWF  x90
0462C:  MOVLB  0
0462E:  RCALL  45CA
04630:  MOVFF  00,C8C
04634:  MOVLB  C
04636:  MOVFF  03,C8D
0463A:  MOVF   x8C,F
0463C:  BNZ   4642
0463E:  MOVF   x8D,F
04640:  BZ    468A
04642:  MOVLW  6C
04644:  ADDWF  x8A,W
04646:  MOVWF  x8C
04648:  MOVLW  07
0464A:  ADDWFC x8B,W
0464C:  MOVWF  x8D
0464E:  MOVLW  03
04650:  ANDWF  x8C,F
04652:  CLRF   x8D
04654:  MOVF   x8C,F
04656:  BNZ   4690
04658:  MOVF   x8D,F
0465A:  BNZ   4690
0465C:  MOVLW  6C
0465E:  ADDWF  x8A,W
04660:  MOVWF  x8C
04662:  MOVLW  07
04664:  ADDWFC x8B,W
04666:  MOVWF  x8D
04668:  MOVWF  x8F
0466A:  MOVFF  C8C,C8E
0466E:  CLRF   x91
04670:  MOVLW  64
04672:  MOVWF  x90
04674:  MOVLB  0
04676:  RCALL  45CA
04678:  MOVFF  00,C8C
0467C:  MOVLB  C
0467E:  MOVFF  03,C8D
04682:  MOVF   x8C,F
04684:  BNZ   468A
04686:  MOVF   x8D,F
04688:  BZ    4690
....................       return TRUE; 
0468A:  MOVLW  01
0468C:  MOVWF  01
0468E:  BRA    4694
....................       
....................    return FALSE; 
04690:  MOVLW  00
04692:  MOVWF  01
04694:  MOVLB  0
04696:  RETURN 0
.................... } 
....................  
.................... // see time.h for documentation 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... // see time.h for documentation 
.................... time_t mktime(struct_tm * timeT) 
*
04810:  MOVLB  C
04812:  CLRF   x69
04814:  CLRF   x68
04816:  CLRF   x67
04818:  CLRF   x66
0481A:  BCF    x6A.0
0481C:  CLRF   x6C
0481E:  CLRF   x6B
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
04820:  MOVF   x64,F
04822:  BNZ   482A
04824:  MOVF   x65,F
04826:  BTFSC  FD8.2
04828:  BRA    4C4C
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
0482A:  MOVFF  C64,FE9
0482E:  MOVFF  C65,FEA
04832:  MOVF   FEF,W
04834:  ADDWF  x66,F
04836:  MOVLW  00
04838:  ADDWFC x67,F
0483A:  ADDWFC x68,F
0483C:  ADDWFC x69,F
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
0483E:  MOVLW  01
04840:  ADDWF  x64,W
04842:  MOVWF  FE9
04844:  MOVLW  00
04846:  ADDWFC x65,W
04848:  MOVWF  FEA
0484A:  MOVF   FEF,W
0484C:  CLRF   x70
0484E:  CLRF   x6F
04850:  CLRF   x6E
04852:  MOVWF  x6D
04854:  MOVFF  FEA,C72
04858:  MOVFF  FE9,C71
0485C:  MOVFF  C70,CB4
04860:  MOVFF  C6F,CB3
04864:  MOVFF  C6E,CB2
04868:  MOVWF  xB1
0486A:  CLRF   xB8
0486C:  CLRF   xB7
0486E:  CLRF   xB6
04870:  MOVLW  3C
04872:  MOVWF  xB5
04874:  MOVLB  0
04876:  RCALL  456E
04878:  MOVFF  C72,FEA
0487C:  MOVFF  C71,FE9
04880:  MOVF   00,W
04882:  MOVLB  C
04884:  ADDWF  x66,F
04886:  MOVF   01,W
04888:  ADDWFC x67,F
0488A:  MOVF   02,W
0488C:  ADDWFC x68,F
0488E:  MOVF   03,W
04890:  ADDWFC x69,F
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
04892:  MOVLW  02
04894:  ADDWF  x64,W
04896:  MOVWF  FE9
04898:  MOVLW  00
0489A:  ADDWFC x65,W
0489C:  MOVWF  FEA
0489E:  MOVF   FEF,W
048A0:  CLRF   x70
048A2:  CLRF   x6F
048A4:  CLRF   x6E
048A6:  MOVWF  x6D
048A8:  MOVFF  FEA,C72
048AC:  MOVFF  FE9,C71
048B0:  MOVFF  C70,CB4
048B4:  MOVFF  C6F,CB3
048B8:  MOVFF  C6E,CB2
048BC:  MOVWF  xB1
048BE:  CLRF   xB8
048C0:  CLRF   xB7
048C2:  MOVLW  0E
048C4:  MOVWF  xB6
048C6:  MOVLW  10
048C8:  MOVWF  xB5
048CA:  MOVLB  0
048CC:  RCALL  456E
048CE:  MOVFF  C72,FEA
048D2:  MOVFF  C71,FE9
048D6:  MOVF   00,W
048D8:  MOVLB  C
048DA:  ADDWF  x66,F
048DC:  MOVF   01,W
048DE:  ADDWFC x67,F
048E0:  MOVF   02,W
048E2:  ADDWFC x68,F
048E4:  MOVF   03,W
048E6:  ADDWFC x69,F
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
048E8:  MOVLW  05
048EA:  ADDWF  x64,W
048EC:  MOVWF  FE9
048EE:  MOVLW  00
048F0:  ADDWFC x65,W
048F2:  MOVWF  FEA
048F4:  MOVFF  FEC,C8B
048F8:  MOVF   FED,F
048FA:  MOVFF  FEF,C8A
048FE:  MOVLB  0
04900:  RCALL  4610
04902:  MOVLB  C
04904:  BCF    x6A.0
04906:  BTFSC  01.0
04908:  BSF    x6A.0
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
0490A:  MOVLW  04
0490C:  ADDWF  x64,W
0490E:  MOVWF  FE9
04910:  MOVLW  00
04912:  ADDWFC x65,W
04914:  MOVWF  FEA
04916:  MOVFF  FEF,CC4
0491A:  MOVLW  0C
0491C:  MOVWF  xC5
0491E:  MOVLB  0
04920:  RCALL  4698
04922:  MOVFF  00,FEF
....................       for(i = 1;i <= timeT->tm_mon;i++) 
04926:  MOVLB  C
04928:  CLRF   x6C
0492A:  MOVLW  01
0492C:  MOVWF  x6B
0492E:  MOVLW  04
04930:  ADDWF  x64,W
04932:  MOVWF  FE9
04934:  MOVLW  00
04936:  ADDWFC x65,W
04938:  MOVWF  FEA
0493A:  MOVF   FEF,W
0493C:  MOVF   x6C,F
0493E:  BNZ   49AC
04940:  SUBWF  x6B,W
04942:  BZ    4946
04944:  BC    49AC
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
04946:  MOVLW  01
04948:  SUBWF  x6B,W
0494A:  MOVWF  x6D
0494C:  MOVLW  00
0494E:  SUBWFB x6C,W
04950:  MOVWF  x6E
04952:  MOVLW  00
04954:  BTFSC  x6A.0
04956:  MOVLW  01
04958:  MOVWF  x6F
0495A:  MOVFF  C6D,C8B
0495E:  MOVWF  x8C
04960:  MOVLB  0
04962:  RCALL  46C4
04964:  MOVFF  FEA,C6F
04968:  MOVFF  FE9,C6E
0496C:  MOVLB  C
0496E:  CLRF   xB4
04970:  CLRF   xB3
04972:  CLRF   xB2
04974:  MOVFF  01,CB1
04978:  CLRF   xB8
0497A:  MOVLW  01
0497C:  MOVWF  xB7
0497E:  MOVLW  51
04980:  MOVWF  xB6
04982:  MOVLW  80
04984:  MOVWF  xB5
04986:  MOVLB  0
04988:  RCALL  456E
0498A:  MOVFF  C6F,FEA
0498E:  MOVFF  C6E,FE9
04992:  MOVF   00,W
04994:  MOVLB  C
04996:  ADDWF  x66,F
04998:  MOVF   01,W
0499A:  ADDWFC x67,F
0499C:  MOVF   02,W
0499E:  ADDWFC x68,F
049A0:  MOVF   03,W
049A2:  ADDWFC x69,F
049A4:  INCF   x6B,F
049A6:  BTFSC  FD8.2
049A8:  INCF   x6C,F
049AA:  BRA    492E
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       //timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
....................       unixTime += (timeT->tm_mday - 1) * 86400; 
049AC:  MOVLW  03
049AE:  ADDWF  x64,W
049B0:  MOVWF  FE9
049B2:  MOVLW  00
049B4:  ADDWFC x65,W
049B6:  MOVWF  FEA
049B8:  MOVLW  01
049BA:  SUBWF  FEF,W
049BC:  MOVWF  x6E
049BE:  MOVFF  FEA,C70
049C2:  MOVFF  FE9,C6F
049C6:  CLRF   xB4
049C8:  CLRF   xB3
049CA:  CLRF   xB2
049CC:  MOVWF  xB1
049CE:  CLRF   xB8
049D0:  MOVLW  01
049D2:  MOVWF  xB7
049D4:  MOVLW  51
049D6:  MOVWF  xB6
049D8:  MOVLW  80
049DA:  MOVWF  xB5
049DC:  MOVLB  0
049DE:  RCALL  456E
049E0:  MOVFF  C70,FEA
049E4:  MOVFF  C6F,FE9
049E8:  MOVF   00,W
049EA:  MOVLB  C
049EC:  ADDWF  x66,F
049EE:  MOVF   01,W
049F0:  ADDWFC x67,F
049F2:  MOVF   02,W
049F4:  ADDWFC x68,F
049F6:  MOVF   03,W
049F8:  ADDWFC x69,F
....................        
....................       if(isLeapYear) 
049FA:  BTFSS  x6A.0
049FC:  BRA    4A96
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
049FE:  MOVLW  08
04A00:  ADDWF  x64,W
04A02:  MOVWF  01
04A04:  MOVLW  00
04A06:  ADDWFC x65,W
04A08:  MOVWF  03
04A0A:  MOVFF  01,C6D
04A0E:  MOVWF  x6E
04A10:  MOVFF  FEA,C70
04A14:  MOVFF  FE9,C6F
04A18:  BCF    FD8.1
04A1A:  MOVFF  C69,C95
04A1E:  MOVFF  C68,C94
04A22:  MOVFF  C67,C93
04A26:  MOVFF  C66,C92
04A2A:  CLRF   x99
04A2C:  MOVLW  01
04A2E:  MOVWF  x98
04A30:  MOVLW  51
04A32:  MOVWF  x97
04A34:  MOVLW  80
04A36:  MOVWF  x96
04A38:  MOVLB  0
04A3A:  RCALL  4726
04A3C:  MOVFF  C70,FEA
04A40:  MOVFF  C6F,FE9
04A44:  MOVFF  03,C74
04A48:  MOVFF  02,C73
04A4C:  MOVFF  01,C72
04A50:  MOVFF  00,C71
04A54:  BSF    FD8.1
04A56:  MOVLW  0C
04A58:  MOVWF  FEA
04A5A:  MOVLW  77
04A5C:  MOVWF  FE9
04A5E:  MOVFF  03,C95
04A62:  MOVFF  02,C94
04A66:  MOVFF  01,C93
04A6A:  MOVFF  00,C92
04A6E:  MOVLB  C
04A70:  CLRF   x99
04A72:  CLRF   x98
04A74:  MOVLW  01
04A76:  MOVWF  x97
04A78:  MOVLW  6E
04A7A:  MOVWF  x96
04A7C:  MOVLB  0
04A7E:  RCALL  4726
04A80:  MOVFF  C6E,FEA
04A84:  MOVFF  C6D,FE9
04A88:  MOVFF  C78,FEC
04A8C:  MOVF   FED,F
04A8E:  MOVFF  C77,FEF
....................       } 
04A92:  BRA    4B2A
04A94:  MOVLB  C
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
04A96:  MOVLW  08
04A98:  ADDWF  x64,W
04A9A:  MOVWF  01
04A9C:  MOVLW  00
04A9E:  ADDWFC x65,W
04AA0:  MOVWF  03
04AA2:  MOVFF  01,C6D
04AA6:  MOVWF  x6E
04AA8:  MOVFF  FEA,C70
04AAC:  MOVFF  FE9,C6F
04AB0:  BCF    FD8.1
04AB2:  MOVFF  C69,C95
04AB6:  MOVFF  C68,C94
04ABA:  MOVFF  C67,C93
04ABE:  MOVFF  C66,C92
04AC2:  CLRF   x99
04AC4:  MOVLW  01
04AC6:  MOVWF  x98
04AC8:  MOVLW  51
04ACA:  MOVWF  x97
04ACC:  MOVLW  80
04ACE:  MOVWF  x96
04AD0:  MOVLB  0
04AD2:  RCALL  4726
04AD4:  MOVFF  C70,FEA
04AD8:  MOVFF  C6F,FE9
04ADC:  MOVFF  03,C74
04AE0:  MOVFF  02,C73
04AE4:  MOVFF  01,C72
04AE8:  MOVFF  00,C71
04AEC:  BSF    FD8.1
04AEE:  MOVLW  0C
04AF0:  MOVWF  FEA
04AF2:  MOVLW  77
04AF4:  MOVWF  FE9
04AF6:  MOVFF  03,C95
04AFA:  MOVFF  02,C94
04AFE:  MOVFF  01,C93
04B02:  MOVFF  00,C92
04B06:  MOVLB  C
04B08:  CLRF   x99
04B0A:  CLRF   x98
04B0C:  MOVLW  01
04B0E:  MOVWF  x97
04B10:  MOVLW  6D
04B12:  MOVWF  x96
04B14:  MOVLB  0
04B16:  RCALL  4726
04B18:  MOVFF  C6E,FEA
04B1C:  MOVFF  C6D,FE9
04B20:  MOVFF  C78,FEC
04B24:  MOVF   FED,F
04B26:  MOVFF  C77,FEF
....................       } 
....................        
....................      #if defined(TIME_T_USES_2010) 
....................       i = 110; 
....................       if(timeT->tm_year - 110 >= 0) 
....................      #else 
....................       i = 70; 
04B2A:  MOVLB  C
04B2C:  CLRF   x6C
04B2E:  MOVLW  46
04B30:  MOVWF  x6B
....................       if(timeT->tm_year - 70 >= 0) 
04B32:  MOVLW  05
04B34:  ADDWF  x64,W
04B36:  MOVWF  FE9
04B38:  MOVLW  00
04B3A:  ADDWFC x65,W
04B3C:  MOVWF  FEA
04B3E:  MOVFF  FEC,C6E
04B42:  MOVF   FED,F
04B44:  MOVFF  FEF,C6D
04B48:  MOVLW  46
04B4A:  SUBWF  x6D,F
04B4C:  MOVLW  00
04B4E:  SUBWFB x6E,F
....................      #endif 
....................       { 
....................          while(i < (timeT->tm_year)) 
04B50:  MOVLW  05
04B52:  ADDWF  x64,W
04B54:  MOVWF  FE9
04B56:  MOVLW  00
04B58:  ADDWFC x65,W
04B5A:  MOVWF  FEA
04B5C:  MOVFF  FEC,03
04B60:  MOVF   FED,F
04B62:  MOVFF  FEF,01
04B66:  MOVF   x6C,W
04B68:  SUBWF  03,W
04B6A:  BNC   4BB2
04B6C:  BNZ   4B74
04B6E:  MOVF   01,W
04B70:  SUBWF  x6B,W
04B72:  BC    4BB2
....................          { 
....................             isLeapYear = LeapYear(i); 
04B74:  MOVFF  C6C,C8B
04B78:  MOVFF  C6B,C8A
04B7C:  MOVLB  0
04B7E:  RCALL  4610
04B80:  MOVLB  C
04B82:  BCF    x6A.0
04B84:  BTFSC  01.0
04B86:  BSF    x6A.0
....................             if(isLeapYear) 
04B88:  BTFSS  x6A.0
04B8A:  BRA    4B9A
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
04B8C:  MOVLW  85
04B8E:  ADDWF  x67,F
04B90:  MOVLW  E2
04B92:  ADDWFC x68,F
04B94:  MOVLW  01
04B96:  ADDWFC x69,F
....................             } 
04B98:  BRA    4BAA
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
04B9A:  MOVLW  80
04B9C:  ADDWF  x66,F
04B9E:  MOVLW  33
04BA0:  ADDWFC x67,F
04BA2:  MOVLW  E1
04BA4:  ADDWFC x68,F
04BA6:  MOVLW  01
04BA8:  ADDWFC x69,F
....................             } 
....................             i++; 
04BAA:  INCF   x6B,F
04BAC:  BTFSC  FD8.2
04BAE:  INCF   x6C,F
04BB0:  BRA    4B50
....................          } 
....................       } 
....................        
....................      #if defined(TIME_T_USES_2010) 
....................       timeT->tm_wday = ((unixTime / 86400) + 5) % 7; 
....................      #else 
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
04BB2:  MOVLW  07
04BB4:  ADDWF  x64,W
04BB6:  MOVWF  01
04BB8:  MOVLW  00
04BBA:  ADDWFC x65,W
04BBC:  MOVWF  03
04BBE:  MOVFF  01,C6D
04BC2:  MOVWF  x6E
04BC4:  MOVFF  FEA,C70
04BC8:  MOVFF  FE9,C6F
04BCC:  BCF    FD8.1
04BCE:  MOVFF  C69,C95
04BD2:  MOVFF  C68,C94
04BD6:  MOVFF  C67,C93
04BDA:  MOVFF  C66,C92
04BDE:  CLRF   x99
04BE0:  MOVLW  01
04BE2:  MOVWF  x98
04BE4:  MOVLW  51
04BE6:  MOVWF  x97
04BE8:  MOVLW  80
04BEA:  MOVWF  x96
04BEC:  MOVLB  0
04BEE:  RCALL  4726
04BF0:  MOVFF  C70,FEA
04BF4:  MOVFF  C6F,FE9
04BF8:  MOVFF  03,C74
04BFC:  MOVFF  02,C73
04C00:  MOVFF  01,C72
04C04:  MOVFF  00,C71
04C08:  MOVLW  04
04C0A:  MOVLB  C
04C0C:  ADDWF  x71,F
04C0E:  MOVLW  00
04C10:  ADDWFC x72,F
04C12:  ADDWFC x73,F
04C14:  ADDWFC x74,F
04C16:  BSF    FD8.1
04C18:  MOVLW  0C
04C1A:  MOVWF  FEA
04C1C:  MOVLW  77
04C1E:  MOVWF  FE9
04C20:  MOVFF  C74,C95
04C24:  MOVFF  C73,C94
04C28:  MOVFF  C72,C93
04C2C:  MOVFF  C71,C92
04C30:  CLRF   x99
04C32:  CLRF   x98
04C34:  CLRF   x97
04C36:  MOVLW  07
04C38:  MOVWF  x96
04C3A:  MOVLB  0
04C3C:  RCALL  4726
04C3E:  MOVFF  C6E,FEA
04C42:  MOVFF  C6D,FE9
04C46:  MOVFF  C77,FEF
04C4A:  MOVLB  C
....................      #endif 
....................    } 
....................  
....................    return unixTime; 
04C4C:  MOVFF  C66,00
04C50:  MOVFF  C67,01
04C54:  MOVFF  C68,02
04C58:  MOVFF  C69,03
04C5C:  MOVLB  0
04C5E:  RETURN 0
.................... } 
....................  
.................... // see time.h for documentation 
.................... char * asctime ( struct_tm * timeptr, char * szTime = 0) 
.................... { 
....................    char result[25]; 
....................  
....................    WeekdayAbbreviations(timeptr->tm_wday, &result[0]); 
....................    result[3] = ' '; 
....................    MonthAbbreviations(timeptr->tm_mon, &result[4]); 
....................  
....................    sprintf(&result[7]," %u %02u:%02u:%02u %04lu", 
....................       timeptr->tm_mday, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + (unsigned int16)1900)); 
....................  
....................    if (szTime) 
....................    { 
....................       strcpy(szTime, result); 
....................       return szTime; 
....................    } 
....................     
....................    return result; 
.................... } 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // stop in 's1' on a space. 
.................... // return FALSE on match, TRUE on error 
.................... static int1 _time_stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)||(*s1==' ')); 
....................     s1++, s2++) 
....................     if ((*s1 == '\0') || (*s1 == ' ')) 
....................        return(FALSE);   //match 
....................  return(TRUE); //not match 
.................... } 
....................  
.................... // see time.h for documentation 
.................... int1 timeasc(struct_tm *pTm, char *szTime) 
.................... { 
....................    struct_tm tm; 
....................    char str[9]; 
....................     
....................    if (strlen(szTime) > 20) 
....................    { 
....................       if (szTime[3] != ' ')   return(FALSE); 
....................       for (tm.tm_wday=0; tm.tm_wday<7; tm.tm_wday++) 
....................       { 
....................          WeekdayAbbreviations(tm.tm_wday, str); 
....................          if (!_time_stricmp(szTime, str)) 
....................             break; 
....................       } 
....................     
....................       if (tm.tm_wday >= 7) 
....................          return(FALSE); 
....................       szTime += 4; 
....................    } 
....................    else 
....................    { 
....................       tm.tm_wday = 0; 
....................    } 
....................     
....................    if (szTime[3] != ' ')   return(FALSE); 
....................    for (tm.tm_mon=0; tm.tm_mon<12; tm.tm_mon++) 
....................    { 
....................       MonthAbbreviations(tm.tm_mon, str); 
....................       if (!_time_stricmp(szTime, str)) 
....................          break; 
....................    } 
....................    if (tm.tm_mon >= 12) 
....................       return(FALSE); 
....................    szTime += 4; 
....................  
....................    tm.tm_mday = atoi(szTime); 
....................    szTime += 2; 
....................    if (*szTime == ' ') 
....................       szTime += 1; 
....................  
....................    if (szTime[2] != ':')   return(FALSE); 
....................    tm.tm_hour = atoi(szTime); 
....................    szTime += 3; 
....................  
....................    if (szTime[2] != ':')   return(FALSE); 
....................    tm.tm_min = atoi(szTime);    
....................    szTime += 3; 
....................  
....................    if (szTime[2] != ' ')   return(FALSE); 
....................    tm.tm_sec = atoi(szTime); 
....................    szTime += 3; 
....................  
....................    tm.tm_year = atol(szTime) - 1900; 
....................    szTime += 4; 
....................  
....................    if (pTm != NULL) 
....................    { 
....................       memcpy(pTm, &tm, sizeof(tm)); 
....................    } 
....................     
....................    return(*szTime == '\0'); 
.................... } 
....................  
.................... // see time.h for documentation 
.................... char * ctime ( time_t * timer, char *szTime = 0 ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... // see time.h for documenation 
.................... struct_tm * localtime(time_t * timer) 
*
04D28:  MOVLB  C
04D2A:  BCF    x89.0
04D2C:  BCF    x89.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;   //1970 or 2010 is not a leap year 
....................  
....................    if(timer != NULL) 
04D2E:  MOVF   x83,F
04D30:  BNZ   4D38
04D32:  MOVF   x84,F
04D34:  BTFSC  FD8.2
04D36:  BRA    5110
....................    { 
....................       timeCounter = *timer; 
04D38:  MOVFF  C83,FE9
04D3C:  MOVFF  C84,FEA
04D40:  MOVFF  FEF,C85
04D44:  MOVFF  FEC,C86
04D48:  MOVFF  FEC,C87
04D4C:  MOVFF  FEC,C88
....................      #if defined(TIME_T_USES_2010) 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 5) % 7;//fill in the weekday 
....................       g_lTime.tm_year = 110; 
....................      #else 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
04D50:  BCF    FD8.1
04D52:  MOVFF  C88,C95
04D56:  MOVFF  C87,C94
04D5A:  MOVFF  C86,C93
04D5E:  MOVFF  C85,C92
04D62:  CLRF   x99
04D64:  MOVLW  01
04D66:  MOVWF  x98
04D68:  MOVLW  51
04D6A:  MOVWF  x97
04D6C:  MOVLW  80
04D6E:  MOVWF  x96
04D70:  MOVLB  0
04D72:  RCALL  4726
04D74:  MOVFF  03,C8D
04D78:  MOVFF  02,C8C
04D7C:  MOVFF  01,C8B
04D80:  MOVFF  00,C8A
04D84:  MOVLW  04
04D86:  MOVLB  C
04D88:  ADDWF  x8A,F
04D8A:  MOVLW  00
04D8C:  ADDWFC x8B,F
04D8E:  ADDWFC x8C,F
04D90:  ADDWFC x8D,F
04D92:  BSF    FD8.1
04D94:  MOVLW  0C
04D96:  MOVWF  FEA
04D98:  MOVLW  8E
04D9A:  MOVWF  FE9
04D9C:  MOVFF  C8D,C95
04DA0:  MOVFF  C8C,C94
04DA4:  MOVFF  C8B,C93
04DA8:  MOVFF  C8A,C92
04DAC:  CLRF   x99
04DAE:  CLRF   x98
04DB0:  CLRF   x97
04DB2:  MOVLW  07
04DB4:  MOVWF  x96
04DB6:  MOVLB  0
04DB8:  RCALL  4726
04DBA:  MOVFF  C8E,8DB
....................       g_lTime.tm_year = 70;//we are starting in 1970 
04DBE:  MOVLB  8
04DC0:  CLRF   xDA
04DC2:  MOVLW  46
04DC4:  MOVWF  xD9
....................      #endif 
....................        
....................       while(!done) 
04DC6:  MOVLB  C
04DC8:  BTFSC  x89.0
04DCA:  BRA    4EB4
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
04DCC:  BTFSC  x88.7
04DCE:  BRA    4DE6
04DD0:  MOVF   x88,W
04DD2:  SUBLW  01
04DD4:  BNC   4E1C
04DD6:  BNZ   4DE6
04DD8:  MOVF   x87,W
04DDA:  SUBLW  E2
04DDC:  BNC   4E1C
04DDE:  BNZ   4DE6
04DE0:  MOVF   x86,W
04DE2:  SUBLW  84
04DE4:  BNC   4E1C
04DE6:  BTFSS  x89.1
04DE8:  BRA    4E1C
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
04DEA:  BCF    FD8.1
04DEC:  MOVFF  C88,C95
04DF0:  MOVFF  C87,C94
04DF4:  MOVFF  C86,C93
04DF8:  MOVFF  C85,C92
04DFC:  CLRF   x99
04DFE:  MOVLW  01
04E00:  MOVWF  x98
04E02:  MOVLW  51
04E04:  MOVWF  x97
04E06:  MOVLW  80
04E08:  MOVWF  x96
04E0A:  MOVLB  0
04E0C:  RCALL  4726
04E0E:  MOVFF  01,8DD
04E12:  MOVFF  00,8DC
....................             break; 
04E16:  MOVLB  C
04E18:  BRA    4EB4
....................          } 
04E1A:  BRA    4E6E
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
04E1C:  BTFSC  x88.7
04E1E:  BRA    4E3E
04E20:  MOVF   x88,W
04E22:  SUBLW  01
04E24:  BNC   4E6E
04E26:  BNZ   4E3E
04E28:  MOVF   x87,W
04E2A:  SUBLW  E1
04E2C:  BNC   4E6E
04E2E:  BNZ   4E3E
04E30:  MOVF   x86,W
04E32:  SUBLW  33
04E34:  BNC   4E6E
04E36:  BNZ   4E3E
04E38:  MOVF   x85,W
04E3A:  SUBLW  7F
04E3C:  BNC   4E6E
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
04E3E:  BCF    FD8.1
04E40:  MOVFF  C88,C95
04E44:  MOVFF  C87,C94
04E48:  MOVFF  C86,C93
04E4C:  MOVFF  C85,C92
04E50:  CLRF   x99
04E52:  MOVLW  01
04E54:  MOVWF  x98
04E56:  MOVLW  51
04E58:  MOVWF  x97
04E5A:  MOVLW  80
04E5C:  MOVWF  x96
04E5E:  MOVLB  0
04E60:  RCALL  4726
04E62:  MOVFF  01,8DD
04E66:  MOVFF  00,8DC
....................             break; 
04E6A:  MOVLB  C
04E6C:  BRA    4EB4
....................          } 
....................           
....................          if(isLeapYear) 
04E6E:  BTFSS  x89.1
04E70:  BRA    4E84
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
04E72:  MOVLW  00
04E74:  SUBWF  x85,F
04E76:  MOVLW  85
04E78:  SUBWFB x86,F
04E7A:  MOVLW  E2
04E7C:  SUBWFB x87,F
04E7E:  MOVLW  01
04E80:  SUBWFB x88,F
....................          } 
04E82:  BRA    4E94
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
04E84:  MOVLW  80
04E86:  SUBWF  x85,F
04E88:  MOVLW  33
04E8A:  SUBWFB x86,F
04E8C:  MOVLW  E1
04E8E:  SUBWFB x87,F
04E90:  MOVLW  01
04E92:  SUBWFB x88,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
04E94:  MOVLB  8
04E96:  INCF   xD9,F
04E98:  BTFSC  FD8.2
04E9A:  INCF   xDA,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
04E9C:  MOVFF  8DA,C8B
04EA0:  MOVFF  8D9,C8A
04EA4:  MOVLB  0
04EA6:  CALL   4610
04EAA:  MOVLB  C
04EAC:  BCF    x89.1
04EAE:  BTFSC  01.0
04EB0:  BSF    x89.1
04EB2:  BRA    4DC8
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
04EB4:  MOVLB  8
04EB6:  CLRF   xD8
....................       while(!done) 
04EB8:  MOVLB  C
04EBA:  BTFSC  x89.0
04EBC:  BRA    4FF0
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
04EBE:  MOVLW  00
04EC0:  BTFSC  x89.1
04EC2:  MOVLW  01
04EC4:  MOVWF  x8A
04EC6:  MOVFF  8D8,C8B
04ECA:  MOVWF  x8C
04ECC:  MOVLB  0
04ECE:  CALL   46C4
04ED2:  MOVFF  FEA,C8C
04ED6:  MOVFF  FE9,C8B
04EDA:  MOVLB  C
04EDC:  CLRF   xB4
04EDE:  CLRF   xB3
04EE0:  CLRF   xB2
04EE2:  MOVFF  01,CB1
04EE6:  CLRF   xB8
04EE8:  MOVLW  01
04EEA:  MOVWF  xB7
04EEC:  MOVLW  51
04EEE:  MOVWF  xB6
04EF0:  MOVLW  80
04EF2:  MOVWF  xB5
04EF4:  MOVLB  0
04EF6:  CALL   456E
04EFA:  MOVFF  C8C,FEA
04EFE:  MOVFF  C8B,FE9
04F02:  MOVLB  C
04F04:  BTFSC  x88.7
04F06:  BRA    4F26
04F08:  MOVF   x88,W
04F0A:  SUBWF  03,W
04F0C:  BNC   4F2A
04F0E:  BNZ   4F26
04F10:  MOVF   x87,W
04F12:  SUBWF  02,W
04F14:  BNC   4F2A
04F16:  BNZ   4F26
04F18:  MOVF   x86,W
04F1A:  SUBWF  01,W
04F1C:  BNC   4F2A
04F1E:  BNZ   4F26
04F20:  MOVF   00,W
04F22:  SUBWF  x85,W
04F24:  BC    4F2A
....................          { 
....................             break; 
04F26:  BRA    4FF0
....................          } 
04F28:  BRA    4FEE
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
04F2A:  MOVLW  00
04F2C:  BTFSC  x89.1
04F2E:  MOVLW  01
04F30:  MOVWF  x8A
04F32:  MOVFF  8D8,C8B
04F36:  MOVWF  x8C
04F38:  MOVLB  0
04F3A:  CALL   46C4
04F3E:  MOVFF  FEA,C8C
04F42:  MOVFF  FE9,C8B
04F46:  MOVLB  C
04F48:  CLRF   xB4
04F4A:  CLRF   xB3
04F4C:  CLRF   xB2
04F4E:  MOVFF  01,CB1
04F52:  CLRF   xB8
04F54:  MOVLW  01
04F56:  MOVWF  xB7
04F58:  MOVLW  51
04F5A:  MOVWF  xB6
04F5C:  MOVLW  80
04F5E:  MOVWF  xB5
04F60:  MOVLB  0
04F62:  CALL   456E
04F66:  MOVFF  C8C,FEA
04F6A:  MOVFF  C8B,FE9
04F6E:  MOVLB  C
04F70:  BTFSC  x88.7
04F72:  BRA    4FEE
04F74:  MOVF   03,W
04F76:  SUBWF  x88,W
04F78:  BNC   4FEE
04F7A:  BNZ   4F92
04F7C:  MOVF   02,W
04F7E:  SUBWF  x87,W
04F80:  BNC   4FEE
04F82:  BNZ   4F92
04F84:  MOVF   01,W
04F86:  SUBWF  x86,W
04F88:  BNC   4FEE
04F8A:  BNZ   4F92
04F8C:  MOVF   00,W
04F8E:  SUBWF  x85,W
04F90:  BNC   4FEE
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
04F92:  MOVLW  00
04F94:  BTFSC  x89.1
04F96:  MOVLW  01
04F98:  MOVWF  x8A
04F9A:  MOVFF  8D8,C8B
04F9E:  MOVWF  x8C
04FA0:  MOVLB  0
04FA2:  CALL   46C4
04FA6:  MOVFF  FEA,C8C
04FAA:  MOVFF  FE9,C8B
04FAE:  MOVLB  C
04FB0:  CLRF   xB4
04FB2:  CLRF   xB3
04FB4:  CLRF   xB2
04FB6:  MOVFF  01,CB1
04FBA:  CLRF   xB8
04FBC:  MOVLW  01
04FBE:  MOVWF  xB7
04FC0:  MOVLW  51
04FC2:  MOVWF  xB6
04FC4:  MOVLW  80
04FC6:  MOVWF  xB5
04FC8:  MOVLB  0
04FCA:  CALL   456E
04FCE:  MOVFF  C8C,FEA
04FD2:  MOVFF  C8B,FE9
04FD6:  MOVF   00,W
04FD8:  MOVLB  C
04FDA:  SUBWF  x85,F
04FDC:  MOVF   01,W
04FDE:  SUBWFB x86,F
04FE0:  MOVF   02,W
04FE2:  SUBWFB x87,F
04FE4:  MOVF   03,W
04FE6:  SUBWFB x88,F
....................             g_lTime.tm_mon++; 
04FE8:  MOVLB  8
04FEA:  INCF   xD8,F
04FEC:  MOVLB  C
....................          } 
04FEE:  BRA    4EBA
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
04FF0:  BCF    FD8.1
04FF2:  MOVFF  C88,C95
04FF6:  MOVFF  C87,C94
04FFA:  MOVFF  C86,C93
04FFE:  MOVFF  C85,C92
05002:  CLRF   x99
05004:  MOVLW  01
05006:  MOVWF  x98
05008:  MOVLW  51
0500A:  MOVWF  x97
0500C:  MOVLW  80
0500E:  MOVWF  x96
05010:  MOVLB  0
05012:  CALL   4726
05016:  MOVFF  00,8D7
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
0501A:  MOVLB  C
0501C:  CLRF   xB4
0501E:  CLRF   xB3
05020:  CLRF   xB2
05022:  MOVFF  8D7,CB1
05026:  CLRF   xB8
05028:  MOVLW  01
0502A:  MOVWF  xB7
0502C:  MOVLW  51
0502E:  MOVWF  xB6
05030:  MOVLW  80
05032:  MOVWF  xB5
05034:  MOVLB  0
05036:  CALL   456E
0503A:  MOVF   00,W
0503C:  MOVLB  C
0503E:  SUBWF  x85,F
05040:  MOVF   01,W
05042:  SUBWFB x86,F
05044:  MOVF   02,W
05046:  SUBWFB x87,F
05048:  MOVF   03,W
0504A:  SUBWFB x88,F
....................       g_lTime.tm_mday += 1; 
0504C:  MOVLW  01
0504E:  MOVLB  8
05050:  ADDWF  xD7,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
05052:  BCF    FD8.1
05054:  MOVFF  C88,C95
05058:  MOVFF  C87,C94
0505C:  MOVFF  C86,C93
05060:  MOVFF  C85,C92
05064:  MOVLB  C
05066:  CLRF   x99
05068:  CLRF   x98
0506A:  MOVLW  0E
0506C:  MOVWF  x97
0506E:  MOVLW  10
05070:  MOVWF  x96
05072:  MOVLB  0
05074:  CALL   4726
05078:  MOVFF  00,8D6
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
0507C:  MOVLB  C
0507E:  CLRF   x8D
05080:  CLRF   x8C
05082:  CLRF   x8B
05084:  MOVFF  8D6,C8A
05088:  MOVFF  C8D,CB4
0508C:  MOVFF  C8C,CB3
05090:  MOVFF  C8B,CB2
05094:  MOVFF  8D6,CB1
05098:  CLRF   xB8
0509A:  CLRF   xB7
0509C:  MOVLW  0E
0509E:  MOVWF  xB6
050A0:  MOVLW  10
050A2:  MOVWF  xB5
050A4:  MOVLB  0
050A6:  CALL   456E
050AA:  MOVF   00,W
050AC:  MOVLB  C
050AE:  SUBWF  x85,F
050B0:  MOVF   01,W
050B2:  SUBWFB x86,F
050B4:  MOVF   02,W
050B6:  SUBWFB x87,F
050B8:  MOVF   03,W
050BA:  SUBWFB x88,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
050BC:  BCF    FD8.1
050BE:  MOVFF  C88,C95
050C2:  MOVFF  C87,C94
050C6:  MOVFF  C86,C93
050CA:  MOVFF  C85,C92
050CE:  CLRF   x99
050D0:  CLRF   x98
050D2:  CLRF   x97
050D4:  MOVLW  3C
050D6:  MOVWF  x96
050D8:  MOVLB  0
050DA:  CALL   4726
050DE:  MOVFF  00,8D5
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
050E2:  MOVLB  C
050E4:  CLRF   x8B
050E6:  MOVFF  8D5,C8A
050EA:  MOVFF  C8B,CC4
050EE:  MOVFF  8D5,CC3
050F2:  CLRF   xC6
050F4:  MOVLW  3C
050F6:  MOVWF  xC5
050F8:  MOVLB  0
050FA:  RCALL  4D06
050FC:  MOVF   01,W
050FE:  MOVLB  C
05100:  SUBWF  x85,F
05102:  MOVF   02,W
05104:  SUBWFB x86,F
05106:  MOVLW  00
05108:  SUBWFB x87,F
0510A:  SUBWFB x88,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
0510C:  MOVFF  C85,8D4
....................    } 
....................     
....................    return &g_lTime; 
05110:  MOVLW  D4
05112:  MOVWF  01
05114:  MOVLW  08
05116:  MOVWF  02
05118:  MOVLB  0
0511A:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define CLOCKS_PER_SECOND -1 
....................  
.................... /* Globals & Resources */ 
.................... static time_t calendar_time; //seconds since Jan 1, 1970 00:00:00 
....................  
.................... /* Returns processor time used by program (clock ticks)  
....................  * The built-in RTC does not use ticks, so return 0 
....................  */ 
.................... clock_t clock() 
.................... { 
....................     return 0; 
.................... } 
....................  
.................... /* Returns the current calendar time. 
....................  * First gets the time from the built-in RTC, converts it to seconds, 
....................  * and sets this as the calendar time. 
....................  * If a timer is specified, it will be set to the current calendar time. 
....................  * It is assumed that SetTime has already been called and the 
....................  * built-in RTCC is initialized. 
....................  */ 
.................... time_t time(time_t* timer) 
.................... { 
....................     struct_tm nTime; 
....................     rtc_time_t datetime; 
....................     rtc_read(&datetime); 
*
04C60:  MOVLB  F
04C62:  BSF    x5F.0
04C64:  BSF    x5F.1
04C66:  MOVLW  0C
04C68:  MOVWF  FEA
04C6A:  MOVLW  5B
04C6C:  MOVWF  FE9
04C6E:  MOVLW  04
04C70:  MOVWF  01
04C72:  MOVF   x5C,W
04C74:  MOVLB  0
04C76:  RCALL  455C
04C78:  MOVWF  FEE
04C7A:  MOVLB  F
04C7C:  MOVF   x5D,W
04C7E:  MOVLB  0
04C80:  RCALL  455C
04C82:  MOVWF  FEE
04C84:  DECFSZ 01,F
04C86:  BRA    4C8A
04C88:  BRA    4C8E
04C8A:  MOVLB  F
04C8C:  BRA    4C72
....................  
....................     // adjust date to be time.h compatible 
....................     nTime.tm_year = datetime.tm_year + 100; // starting at 1900 
04C8E:  MOVLW  64
04C90:  MOVLB  C
04C92:  ADDWF  x5B,W
04C94:  MOVWF  x56
04C96:  CLRF   x57
04C98:  BTFSC  FD8.0
04C9A:  INCF   x56,F
....................     nTime.tm_mon = datetime.tm_mon - 1;     // 0-11 
04C9C:  MOVLW  01
04C9E:  SUBWF  x5E,W
04CA0:  MOVWF  x55
....................     nTime.tm_mday = datetime.tm_mday - 1;   // 0-30 
04CA2:  MOVLW  01
04CA4:  SUBWF  x5D,W
04CA6:  MOVWF  x54
....................  
....................     nTime.tm_hour = datetime.tm_hour; 
04CA8:  MOVFF  C5F,C53
....................     nTime.tm_sec = datetime.tm_sec; 
04CAC:  MOVFF  C61,C51
....................     nTime.tm_min = datetime.tm_min; 
04CB0:  MOVFF  C62,C52
....................  
....................     // mktime() calculates the yday and wday 
....................  
....................     calendar_time = mktime(&nTime); 
04CB4:  MOVLW  0C
04CB6:  MOVWF  x65
04CB8:  MOVLW  51
04CBA:  MOVWF  x64
04CBC:  MOVLB  0
04CBE:  RCALL  4810
04CC0:  MOVFF  03,8E1
04CC4:  MOVFF  02,8E0
04CC8:  MOVFF  01,8DF
04CCC:  MOVFF  00,8DE
....................  
....................     if (timer != NULL) { 
04CD0:  MOVLB  C
04CD2:  MOVF   x4F,F
04CD4:  BNZ   4CDA
04CD6:  MOVF   x50,F
04CD8:  BZ    4CF2
....................         *timer = calendar_time; 
04CDA:  MOVFF  C4F,FE9
04CDE:  MOVFF  C50,FEA
04CE2:  MOVFF  8DE,FEF
04CE6:  MOVFF  8DF,FEC
04CEA:  MOVFF  8E0,FEC
04CEE:  MOVFF  8E1,FEC
....................     } 
....................  
....................     return calendar_time; 
04CF2:  MOVFF  8DE,00
04CF6:  MOVFF  8DF,01
04CFA:  MOVFF  8E0,02
04CFE:  MOVFF  8E1,03
04D02:  MOVLB  0
04D04:  RETURN 0
.................... } 
....................  
.................... /* Sets the current calendar time (in seconds) from the given time, 
....................  * and sets the time on and enables the built-in RTC 
....................  */ 
.................... void SetTime(struct_tm* nTime) 
.................... { 
....................     rtc_time_t datetime; 
....................     calendar_time = mktime(nTime); // will also set the yday and wday 
*
08594:  MOVFF  C50,C65
08598:  MOVFF  C4F,C64
0859C:  CALL   4810
085A0:  MOVFF  03,8E1
085A4:  MOVFF  02,8E0
085A8:  MOVFF  01,8DF
085AC:  MOVFF  00,8DE
....................  
....................     // adjust date to be built-in RTC compatible 
....................     datetime.tm_year = nTime->tm_year - 100; // 20(00-99) 
085B0:  MOVLW  05
085B2:  MOVLB  C
085B4:  ADDWF  x4F,W
085B6:  MOVWF  FE9
085B8:  MOVLW  00
085BA:  ADDWFC x50,W
085BC:  MOVWF  FEA
085BE:  MOVFF  FEC,C5B
085C2:  MOVF   FED,F
085C4:  MOVFF  FEF,C5A
085C8:  MOVLW  64
085CA:  SUBWF  x5A,W
085CC:  MOVWF  x51
....................     datetime.tm_mon = nTime->tm_mon + 1;     // 1-12 
085CE:  MOVLW  04
085D0:  ADDWF  x4F,W
085D2:  MOVWF  FE9
085D4:  MOVLW  00
085D6:  ADDWFC x50,W
085D8:  MOVWF  FEA
085DA:  MOVLW  01
085DC:  ADDWF  FEF,W
085DE:  MOVWF  x54
....................     datetime.tm_mday = nTime->tm_mday + 1;   // 1-31 
085E0:  MOVLW  03
085E2:  ADDWF  x4F,W
085E4:  MOVWF  FE9
085E6:  MOVLW  00
085E8:  ADDWFC x50,W
085EA:  MOVWF  FEA
085EC:  MOVLW  01
085EE:  ADDWF  FEF,W
085F0:  MOVWF  x53
....................     // datetime.tm_yday = 0; // Commented to avoid compiling error. 
....................  
....................     datetime.tm_hour = nTime->tm_hour; 
085F2:  MOVLW  02
085F4:  ADDWF  x4F,W
085F6:  MOVWF  FE9
085F8:  MOVLW  00
085FA:  ADDWFC x50,W
085FC:  MOVWF  FEA
085FE:  MOVFF  FEF,C55
....................     datetime.tm_wday = nTime->tm_wday + 1; //1-7 
08602:  MOVLW  07
08604:  ADDWF  x4F,W
08606:  MOVWF  FE9
08608:  MOVLW  00
0860A:  ADDWFC x50,W
0860C:  MOVWF  FEA
0860E:  MOVLW  01
08610:  ADDWF  FEF,W
08612:  MOVWF  x56
....................     datetime.tm_sec = nTime->tm_sec; 
08614:  MOVFF  C4F,FE9
08618:  MOVFF  C50,FEA
0861C:  MOVFF  FEF,C57
....................     datetime.tm_min = nTime->tm_min; 
08620:  MOVLW  01
08622:  ADDWF  x4F,W
08624:  MOVWF  FE9
08626:  MOVLW  00
08628:  ADDWFC x50,W
0862A:  MOVWF  FEA
0862C:  MOVFF  FEF,C58
08630:  MOVLB  F
....................  
....................     rtc_write(&datetime); 
08632:  MOVLB  F
08634:  MOVLW  55
08636:  MOVWF  F7E
08638:  MOVLW  AA
0863A:  MOVWF  F7E
0863C:  BSF    x5F.5
0863E:  BSF    x5F.0
08640:  BSF    x5F.1
08642:  MOVLW  0C
08644:  MOVWF  FEA
08646:  MOVLW  51
08648:  MOVWF  FE9
0864A:  MOVLW  04
0864C:  MOVWF  01
0864E:  MOVF   FEE,W
08650:  MOVLB  0
08652:  CALL   511C
08656:  MOVLB  F
08658:  MOVWF  x5C
0865A:  MOVF   FEE,W
0865C:  MOVLB  0
0865E:  CALL   511C
08662:  MOVLB  F
08664:  MOVWF  x5D
08666:  DECFSZ 01,F
08668:  BRA    864E
0866A:  BCF    x5F.5
0866C:  MOVLB  0
0866E:  GOTO   886E (RETURN)
.................... } 
....................  
.................... /* Sets the current time on the built-in RTC given a time in seconds and 
....................  * sets the calendar time to this time. 
....................  */ 
.................... void SetTimeSec(time_t sTime) 
.................... { 
....................     struct_tm* nTime; 
....................     nTime = localtime(&sTime); 
*
05140:  MOVLW  0C
05142:  MOVLB  C
05144:  MOVWF  x84
05146:  MOVLW  4F
05148:  MOVWF  x83
0514A:  MOVLB  0
0514C:  RCALL  4D28
0514E:  MOVFF  02,C54
05152:  MOVFF  01,C53
....................     calendar_time = sTime; 
05156:  MOVFF  C52,8E1
0515A:  MOVFF  C51,8E0
0515E:  MOVFF  C50,8DF
05162:  MOVFF  C4F,8DE
....................  
....................     rtc_time_t datetime; 
....................  
....................     // adjust date to be built-in RTC compatible 
....................     datetime.tm_year = nTime->tm_year - 100; // 20(00-99) 
05166:  MOVLW  05
05168:  MOVLB  C
0516A:  ADDWF  x53,W
0516C:  MOVWF  FE9
0516E:  MOVLW  00
05170:  ADDWFC x54,W
05172:  MOVWF  FEA
05174:  MOVFF  FEC,C5F
05178:  MOVF   FED,F
0517A:  MOVFF  FEF,C5E
0517E:  MOVLW  64
05180:  SUBWF  x5E,W
05182:  MOVWF  x55
....................     datetime.tm_mon = nTime->tm_mon + 1;     // 1-12 
05184:  MOVLW  04
05186:  ADDWF  x53,W
05188:  MOVWF  FE9
0518A:  MOVLW  00
0518C:  ADDWFC x54,W
0518E:  MOVWF  FEA
05190:  MOVLW  01
05192:  ADDWF  FEF,W
05194:  MOVWF  x58
....................     datetime.tm_mday = nTime->tm_mday + 1;   // 1-31 
05196:  MOVLW  03
05198:  ADDWF  x53,W
0519A:  MOVWF  FE9
0519C:  MOVLW  00
0519E:  ADDWFC x54,W
051A0:  MOVWF  FEA
051A2:  MOVLW  01
051A4:  ADDWF  FEF,W
051A6:  MOVWF  x57
....................     datetime.tm_wday = nTime->tm_wday + 1;   // 1-7 
051A8:  MOVLW  07
051AA:  ADDWF  x53,W
051AC:  MOVWF  FE9
051AE:  MOVLW  00
051B0:  ADDWFC x54,W
051B2:  MOVWF  FEA
051B4:  MOVLW  01
051B6:  ADDWF  FEF,W
051B8:  MOVWF  x5A
....................  
....................     datetime.tm_hour = nTime->tm_hour; 
051BA:  MOVLW  02
051BC:  ADDWF  x53,W
051BE:  MOVWF  FE9
051C0:  MOVLW  00
051C2:  ADDWFC x54,W
051C4:  MOVWF  FEA
051C6:  MOVFF  FEF,C59
....................     datetime.tm_sec = nTime->tm_sec; 
051CA:  MOVFF  C53,FE9
051CE:  MOVFF  C54,FEA
051D2:  MOVFF  FEF,C5B
....................     datetime.tm_min = nTime->tm_min; 
051D6:  MOVLW  01
051D8:  ADDWF  x53,W
051DA:  MOVWF  FE9
051DC:  MOVLW  00
051DE:  ADDWFC x54,W
051E0:  MOVWF  FEA
051E2:  MOVFF  FEF,C5C
051E6:  MOVLB  F
....................  
....................     rtc_write(&datetime); 
051E8:  MOVLB  F
051EA:  MOVLW  55
051EC:  MOVWF  F7E
051EE:  MOVLW  AA
051F0:  MOVWF  F7E
051F2:  BSF    x5F.5
051F4:  BSF    x5F.0
051F6:  BSF    x5F.1
051F8:  MOVLW  0C
051FA:  MOVWF  FEA
051FC:  MOVLW  55
051FE:  MOVWF  FE9
05200:  MOVLW  04
05202:  MOVWF  01
05204:  MOVF   FEE,W
05206:  MOVLB  0
05208:  RCALL  511C
0520A:  MOVLB  F
0520C:  MOVWF  x5C
0520E:  MOVF   FEE,W
05210:  MOVLB  0
05212:  RCALL  511C
05214:  MOVLB  F
05216:  MOVWF  x5D
05218:  DECFSZ 01,F
0521A:  BRA    5204
0521C:  BCF    x5F.5
0521E:  MOVLB  0
05220:  RETURN 0
.................... } 
....................  
.................... /* Returns the current time from the built-in RTC as a time struct 
....................  */ 
.................... void GetTime(struct_tm* pRetTm) 
.................... { 
....................     struct_tm cTime; 
....................     rtc_time_t datetime; 
....................     rtc_read(&datetime); 
....................  
....................     // adjust date to be time.h compatible 
....................     cTime.tm_year = datetime.tm_year + 100; // starting at 1900 
....................     cTime.tm_mon = datetime.tm_mon - 1;     // 0-11 
....................     cTime.tm_mday = datetime.tm_mday - 1;   // 0-30 
....................     cTime.tm_wday = datetime.tm_wday - 1;   // 0-6 
....................  
....................     cTime.tm_hour = datetime.tm_hour; 
....................     cTime.tm_sec = datetime.tm_sec; 
....................     cTime.tm_min = datetime.tm_min; 
....................  
....................     memcpy(pRetTm, &cTime, sizeof(struct_tm)); 
.................... } 
....................  
.................... /* Initializes The Built-In RTC 
....................  */ 
.................... void TimeInit(void) 
.................... { 
....................     setup_rtc(RTC_ENABLE | RTC_OUTPUT_SECONDS, 0); 
.................... } 
....................  
.................... #endif //__RTCPERIPHERAL_C__ 
....................  
....................  
.................... // Create buffers (real and pseudo UARTs) 
.................... uart_use(PC); 
.................... uart_use(COMM); 
.................... uart_use(FAB); 
.................... uart_use(RST); 
.................... uart_use(ADCS); 
.................... uart_use(MCPIC); 
.................... uart_use(PCIB); 
.................... uart_use(TMCR1); 
.................... uart_use(TMCR2); 
....................  
.................... // Create supporting functions (real UARTs only) 
.................... uart_declare_fn(PC); 
*
05418:  MOVFF  D69,D6A
0541C:  CALL   44EE
05420:  RETURN 0
*
0555A:  MOVLW  00
0555C:  BTFSS  F82.7
0555E:  MOVLW  01
05560:  MOVWF  01
05562:  RETURN 0
*
055AE:  RCALL  5564
055B0:  MOVF   01,W
055B2:  RETURN 0
.................... uart_declare_fn(COMM); 
*
0542E:  MOVLB  D
05430:  MOVF   x69,W
05432:  MOVLB  0
05434:  RCALL  5422
05436:  RETURN 0
*
055B4:  MOVLW  00
055B6:  BTFSC  FA4.5
055B8:  MOVLW  01
055BA:  MOVWF  01
055BC:  RETURN 0
055BE:  CALL   37B4
055C2:  MOVF   01,W
055C4:  RETURN 0
.................... uart_declare_fn(FAB); 
*
05444:  MOVLB  D
05446:  MOVF   x69,W
05448:  MOVLB  0
0544A:  RCALL  5438
0544C:  RETURN 0
*
055C6:  MOVLW  00
055C8:  BTFSC  FA6.5
055CA:  MOVLW  01
055CC:  MOVWF  01
055CE:  RETURN 0
055D0:  CALL   3B92
055D4:  MOVF   01,W
055D6:  RETURN 0
.................... uart_declare_fn(RST); 
*
0545A:  MOVLB  D
0545C:  MOVF   x69,W
0545E:  MOVLB  0
05460:  RCALL  544E
05462:  RETURN 0
*
055D8:  MOVLW  00
055DA:  BTFSC  FA6.7
055DC:  MOVLW  01
055DE:  MOVWF  01
055E0:  RETURN 0
055E2:  CALL   3F62
055E6:  MOVF   01,W
055E8:  RETURN 0
.................... uart_declare_fn(MSN); 
*
0546C:  MOVLB  D
0546E:  MOVF   x69,W
05470:  MOVLB  0
05472:  RCALL  5464
05474:  RETURN 0
*
055EA:  MOVLW  00
055EC:  BTFSC  F9E.5
055EE:  MOVLW  01
055F0:  MOVWF  01
055F2:  RETURN 0
055F4:  CALL   213C
055F8:  MOVF   01,W
055FA:  RETURN 0
....................  
.................... #include "memory_setup.h" 
.................... #ifndef MEMORY_SETUP_H 
.................... #define MEMORY_SETUP_H 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include <flash_memory.h> 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
*
054B2:  MOVFF  D69,D6A
054B6:  MOVLW  08
054B8:  MOVLB  D
054BA:  MOVWF  x6B
054BC:  MOVLB  0
054BE:  RCALL  5476
054C0:  RETURN 0
*
055FC:  MOVLW  02
055FE:  MOVLB  D
05600:  MOVWF  x6A
05602:  MOVLW  08
05604:  MOVWF  x6B
05606:  MOVLB  0
05608:  RCALL  5476
0560A:  MOVF   01,W
0560C:  RETURN 0
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
*
054FE:  MOVFF  D69,D6A
05502:  MOVLW  08
05504:  MOVLB  D
05506:  MOVWF  x6B
05508:  MOVLB  0
0550A:  RCALL  54C2
0550C:  RETURN 0
*
0560E:  MOVLW  01
05610:  MOVLB  D
05612:  MOVWF  x6A
05614:  MOVLW  08
05616:  MOVWF  x6B
05618:  MOVLB  0
0561A:  RCALL  54C2
0561C:  MOVF   01,W
0561E:  RETURN 0
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
*
0554A:  MOVFF  D69,D6A
0554E:  MOVLW  08
05550:  MOVLB  D
05552:  MOVWF  x6B
05554:  MOVLB  0
05556:  RCALL  550E
05558:  RETURN 0
*
05620:  MOVLW  03
05622:  MOVLB  D
05624:  MOVWF  x6A
05626:  MOVLW  08
05628:  MOVWF  x6B
0562A:  MOVLB  0
0562C:  RCALL  550E
0562E:  MOVF   01,W
05630:  RETURN 0
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
*
062F6:  MOVLW  0D
062F8:  MOVLB  D
062FA:  MOVWF  x61
062FC:  MOVLW  59
062FE:  MOVFF  D61,D5F
06302:  MOVWF  x5E
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
06304:  MOVLW  08
06306:  ADDWF  x57,W
06308:  MOVWF  FE9
0630A:  MOVLW  00
0630C:  ADDWFC x58,W
0630E:  MOVWF  FEA
06310:  MOVFF  FEC,D61
06314:  MOVF   FED,F
06316:  MOVFF  FEF,D60
0631A:  MOVFF  D60,D68
0631E:  CLRF   x69
06320:  MOVLW  0F
06322:  MOVWF  x6B
06324:  MOVLW  89
06326:  MOVWF  x6A
06328:  MOVLB  0
0632A:  CALL   53D6
0632E:  MOVFF  D60,D68
06332:  MOVLB  D
06334:  CLRF   x69
06336:  MOVLW  0F
06338:  MOVWF  x6B
0633A:  MOVLW  92
0633C:  MOVWF  x6A
0633E:  MOVLB  0
06340:  CALL   53D6
....................     spi_functions->spi_send(ENABLE_WRITE); 
06344:  MOVLB  D
06346:  MOVFF  D57,01
0634A:  MOVFF  D58,03
0634E:  MOVFF  D57,D60
06352:  MOVFF  D58,D61
06356:  MOVFF  D58,FEA
0635A:  MOVFF  D57,FE9
0635E:  MOVLW  06
06360:  MOVWF  x69
06362:  MOVLB  0
06364:  CALL   03FC
....................     output_high(spi_functions->cs_pin); 
06368:  MOVLW  08
0636A:  MOVLB  D
0636C:  ADDWF  x57,W
0636E:  MOVWF  FE9
06370:  MOVLW  00
06372:  ADDWFC x58,W
06374:  MOVWF  FEA
06376:  MOVFF  FEC,D61
0637A:  MOVF   FED,F
0637C:  MOVFF  FEF,D60
06380:  MOVFF  D60,D68
06384:  MOVLW  01
06386:  MOVWF  x69
06388:  MOVLW  0F
0638A:  MOVWF  x6B
0638C:  MOVLW  89
0638E:  MOVWF  x6A
06390:  MOVLB  0
06392:  CALL   53D6
06396:  MOVFF  D60,D68
0639A:  MOVLB  D
0639C:  CLRF   x69
0639E:  MOVLW  0F
063A0:  MOVWF  x6B
063A2:  MOVLW  92
063A4:  MOVWF  x6A
063A6:  MOVLB  0
063A8:  CALL   53D6
....................     output_low(spi_functions->cs_pin); 
063AC:  MOVLW  08
063AE:  MOVLB  D
063B0:  ADDWF  x57,W
063B2:  MOVWF  FE9
063B4:  MOVLW  00
063B6:  ADDWFC x58,W
063B8:  MOVWF  FEA
063BA:  MOVFF  FEC,D61
063BE:  MOVF   FED,F
063C0:  MOVFF  FEF,D60
063C4:  MOVFF  D60,D68
063C8:  CLRF   x69
063CA:  MOVLW  0F
063CC:  MOVWF  x6B
063CE:  MOVLW  89
063D0:  MOVWF  x6A
063D2:  MOVLB  0
063D4:  CALL   53D6
063D8:  MOVFF  D60,D68
063DC:  MOVLB  D
063DE:  CLRF   x69
063E0:  MOVLW  0F
063E2:  MOVWF  x6B
063E4:  MOVLW  92
063E6:  MOVWF  x6A
063E8:  MOVLB  0
063EA:  CALL   53D6
....................     spi_functions->spi_send(WRITE_PAGE); 
063EE:  MOVLB  D
063F0:  MOVFF  D57,01
063F4:  MOVFF  D58,03
063F8:  MOVFF  D57,D60
063FC:  MOVFF  D58,D61
06400:  MOVFF  D58,FEA
06404:  MOVFF  D57,FE9
06408:  MOVLW  12
0640A:  MOVWF  x69
0640C:  MOVLB  0
0640E:  CALL   03FC
....................     spi_functions->spi_send(address[3]); 
06412:  MOVLB  D
06414:  MOVFF  D57,01
06418:  MOVFF  D58,03
0641C:  MOVFF  D57,D60
06420:  MOVFF  D58,D61
06424:  MOVLW  03
06426:  ADDWF  x5E,W
06428:  MOVWF  FE9
0642A:  MOVLW  00
0642C:  ADDWFC x5F,W
0642E:  MOVWF  FEA
06430:  MOVFF  FEF,D69
06434:  MOVFF  D58,FEA
06438:  MOVFF  D57,FE9
0643C:  MOVLB  0
0643E:  CALL   03FC
....................     spi_functions->spi_send(address[2]); 
06442:  MOVLB  D
06444:  MOVFF  D57,01
06448:  MOVFF  D58,03
0644C:  MOVFF  D57,D60
06450:  MOVFF  D58,D61
06454:  MOVLW  02
06456:  ADDWF  x5E,W
06458:  MOVWF  FE9
0645A:  MOVLW  00
0645C:  ADDWFC x5F,W
0645E:  MOVWF  FEA
06460:  MOVFF  FEF,D69
06464:  MOVFF  D58,FEA
06468:  MOVFF  D57,FE9
0646C:  MOVLB  0
0646E:  CALL   03FC
....................     spi_functions->spi_send(address[1]); 
06472:  MOVLB  D
06474:  MOVFF  D57,01
06478:  MOVFF  D58,03
0647C:  MOVFF  D57,D60
06480:  MOVFF  D58,D61
06484:  MOVLW  01
06486:  ADDWF  x5E,W
06488:  MOVWF  FE9
0648A:  MOVLW  00
0648C:  ADDWFC x5F,W
0648E:  MOVWF  FEA
06490:  MOVFF  FEF,D69
06494:  MOVFF  D58,FEA
06498:  MOVFF  D57,FE9
0649C:  MOVLB  0
0649E:  CALL   03FC
....................     spi_functions->spi_send(address[0]); 
064A2:  MOVFF  D57,01
064A6:  MOVFF  D58,03
064AA:  MOVFF  D57,D60
064AE:  MOVFF  D58,D61
064B2:  MOVFF  D5E,FE9
064B6:  MOVFF  D5F,FEA
064BA:  MOVFF  FEF,D69
064BE:  MOVFF  D58,FEA
064C2:  MOVFF  D57,FE9
064C6:  MOVLB  0
064C8:  CALL   03FC
....................     spi_functions->spi_send(data); 
064CC:  MOVFF  D57,01
064D0:  MOVFF  D58,03
064D4:  MOVFF  D57,D60
064D8:  MOVFF  D58,D61
064DC:  MOVFF  D58,FEA
064E0:  MOVFF  D57,FE9
064E4:  MOVFF  D5D,D69
064E8:  MOVLB  0
064EA:  CALL   03FC
....................     output_high(spi_functions->cs_pin); 
064EE:  MOVLW  08
064F0:  MOVLB  D
064F2:  ADDWF  x57,W
064F4:  MOVWF  FE9
064F6:  MOVLW  00
064F8:  ADDWFC x58,W
064FA:  MOVWF  FEA
064FC:  MOVFF  FEC,D61
06500:  MOVF   FED,F
06502:  MOVFF  FEF,D60
06506:  MOVFF  D60,D68
0650A:  MOVLW  01
0650C:  MOVWF  x69
0650E:  MOVLW  0F
06510:  MOVWF  x6B
06512:  MOVLW  89
06514:  MOVWF  x6A
06516:  MOVLB  0
06518:  CALL   53D6
0651C:  MOVFF  D60,D68
06520:  MOVLB  D
06522:  CLRF   x69
06524:  MOVLW  0F
06526:  MOVWF  x6B
06528:  MOVLW  92
0652A:  MOVWF  x6A
0652C:  MOVLB  0
0652E:  CALL   53D6
....................     delay_us(20); 
06532:  MOVLW  1A
06534:  MOVWF  00
06536:  DECFSZ 00,F
06538:  BRA    6536
0653A:  NOP   
0653C:  RETURN 0
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
*
05632:  MOVLW  0D
05634:  MOVLB  D
05636:  MOVWF  x67
05638:  MOVLW  5F
0563A:  MOVFF  D67,D64
0563E:  MOVWF  x63
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
05640:  MOVLW  08
05642:  ADDWF  x5D,W
05644:  MOVWF  FE9
05646:  MOVLW  00
05648:  ADDWFC x5E,W
0564A:  MOVWF  FEA
0564C:  MOVFF  FEC,D67
05650:  MOVF   FED,F
05652:  MOVFF  FEF,D66
05656:  MOVFF  D66,D68
0565A:  CLRF   x69
0565C:  MOVLW  0F
0565E:  MOVWF  x6B
05660:  MOVLW  89
05662:  MOVWF  x6A
05664:  MOVLB  0
05666:  RCALL  53D6
05668:  MOVFF  D66,D68
0566C:  MOVLB  D
0566E:  CLRF   x69
05670:  MOVLW  0F
05672:  MOVWF  x6B
05674:  MOVLW  92
05676:  MOVWF  x6A
05678:  MOVLB  0
0567A:  RCALL  53D6
....................     spi_functions->spi_send(READ_DATA_BYTES); 
0567C:  MOVLB  D
0567E:  MOVFF  D5D,01
05682:  MOVFF  D5E,03
05686:  MOVFF  D5D,D66
0568A:  MOVFF  D5E,D67
0568E:  MOVFF  D5E,FEA
05692:  MOVFF  D5D,FE9
05696:  MOVLW  13
05698:  MOVWF  x69
0569A:  MOVLB  0
0569C:  CALL   03FC
....................     spi_functions->spi_send(address[3]); 
056A0:  MOVLB  D
056A2:  MOVFF  D5D,01
056A6:  MOVFF  D5E,03
056AA:  MOVFF  D5D,D66
056AE:  MOVFF  D5E,D67
056B2:  MOVLW  03
056B4:  ADDWF  x63,W
056B6:  MOVWF  FE9
056B8:  MOVLW  00
056BA:  ADDWFC x64,W
056BC:  MOVWF  FEA
056BE:  MOVFF  FEF,D69
056C2:  MOVFF  D5E,FEA
056C6:  MOVFF  D5D,FE9
056CA:  MOVLB  0
056CC:  CALL   03FC
....................     spi_functions->spi_send(address[2]); 
056D0:  MOVLB  D
056D2:  MOVFF  D5D,01
056D6:  MOVFF  D5E,03
056DA:  MOVFF  D5D,D66
056DE:  MOVFF  D5E,D67
056E2:  MOVLW  02
056E4:  ADDWF  x63,W
056E6:  MOVWF  FE9
056E8:  MOVLW  00
056EA:  ADDWFC x64,W
056EC:  MOVWF  FEA
056EE:  MOVFF  FEF,D69
056F2:  MOVFF  D5E,FEA
056F6:  MOVFF  D5D,FE9
056FA:  MOVLB  0
056FC:  CALL   03FC
....................     spi_functions->spi_send(address[1]); 
05700:  MOVLB  D
05702:  MOVFF  D5D,01
05706:  MOVFF  D5E,03
0570A:  MOVFF  D5D,D66
0570E:  MOVFF  D5E,D67
05712:  MOVLW  01
05714:  ADDWF  x63,W
05716:  MOVWF  FE9
05718:  MOVLW  00
0571A:  ADDWFC x64,W
0571C:  MOVWF  FEA
0571E:  MOVFF  FEF,D69
05722:  MOVFF  D5E,FEA
05726:  MOVFF  D5D,FE9
0572A:  MOVLB  0
0572C:  CALL   03FC
....................     spi_functions->spi_send(address[0]); 
05730:  MOVFF  D5D,01
05734:  MOVFF  D5E,03
05738:  MOVFF  D5D,D66
0573C:  MOVFF  D5E,D67
05740:  MOVFF  D63,FE9
05744:  MOVFF  D64,FEA
05748:  MOVFF  FEF,D69
0574C:  MOVFF  D5E,FEA
05750:  MOVFF  D5D,FE9
05754:  MOVLB  0
05756:  CALL   03FC
....................     uint8_t data = spi_functions->spi_receive(); 
0575A:  MOVLW  04
0575C:  MOVLB  D
0575E:  ADDWF  x5D,W
05760:  MOVWF  01
05762:  MOVLW  00
05764:  ADDWFC x5E,W
05766:  MOVWF  03
05768:  MOVFF  01,D66
0576C:  MOVWF  x67
0576E:  MOVWF  FEA
05770:  MOVFF  01,FE9
05774:  MOVLB  0
05776:  CALL   03FC
0577A:  MOVFF  01,D65
....................     output_high(spi_functions->cs_pin); 
0577E:  MOVLW  08
05780:  MOVLB  D
05782:  ADDWF  x5D,W
05784:  MOVWF  FE9
05786:  MOVLW  00
05788:  ADDWFC x5E,W
0578A:  MOVWF  FEA
0578C:  MOVFF  FEC,D67
05790:  MOVF   FED,F
05792:  MOVFF  FEF,D66
05796:  MOVFF  D66,D68
0579A:  MOVLW  01
0579C:  MOVWF  x69
0579E:  MOVLW  0F
057A0:  MOVWF  x6B
057A2:  MOVLW  89
057A4:  MOVWF  x6A
057A6:  MOVLB  0
057A8:  RCALL  53D6
057AA:  MOVFF  D66,D68
057AE:  MOVLB  D
057B0:  CLRF   x69
057B2:  MOVLW  0F
057B4:  MOVWF  x6B
057B6:  MOVLW  92
057B8:  MOVWF  x6A
057BA:  MOVLB  0
057BC:  RCALL  53D6
....................     return data; 
057BE:  MOVLB  D
057C0:  MOVFF  D65,01
057C4:  MOVLB  0
057C6:  RETURN 0
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
*
0604C:  MOVLW  0D
0604E:  MOVLB  D
06050:  MOVWF  x52
06052:  MOVLW  4A
06054:  MOVFF  D52,D50
06058:  MOVWF  x4F
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
0605A:  MOVLW  08
0605C:  ADDWF  x48,W
0605E:  MOVWF  FE9
06060:  MOVLW  00
06062:  ADDWFC x49,W
06064:  MOVWF  FEA
06066:  MOVFF  FEC,D52
0606A:  MOVF   FED,F
0606C:  MOVFF  FEF,D51
06070:  MOVFF  D51,D68
06074:  CLRF   x69
06076:  MOVLW  0F
06078:  MOVWF  x6B
0607A:  MOVLW  89
0607C:  MOVWF  x6A
0607E:  MOVLB  0
06080:  CALL   53D6
06084:  MOVFF  D51,D68
06088:  MOVLB  D
0608A:  CLRF   x69
0608C:  MOVLW  0F
0608E:  MOVWF  x6B
06090:  MOVLW  92
06092:  MOVWF  x6A
06094:  MOVLB  0
06096:  CALL   53D6
....................     spi_functions->spi_send(ENABLE_WRITE); 
0609A:  MOVLB  D
0609C:  MOVFF  D48,01
060A0:  MOVFF  D49,03
060A4:  MOVFF  D48,D51
060A8:  MOVFF  D49,D52
060AC:  MOVFF  D49,FEA
060B0:  MOVFF  D48,FE9
060B4:  MOVLW  06
060B6:  MOVWF  x69
060B8:  MOVLB  0
060BA:  CALL   03FC
....................     output_high(spi_functions->cs_pin); 
060BE:  MOVLW  08
060C0:  MOVLB  D
060C2:  ADDWF  x48,W
060C4:  MOVWF  FE9
060C6:  MOVLW  00
060C8:  ADDWFC x49,W
060CA:  MOVWF  FEA
060CC:  MOVFF  FEC,D52
060D0:  MOVF   FED,F
060D2:  MOVFF  FEF,D51
060D6:  MOVFF  D51,D68
060DA:  MOVLW  01
060DC:  MOVWF  x69
060DE:  MOVLW  0F
060E0:  MOVWF  x6B
060E2:  MOVLW  89
060E4:  MOVWF  x6A
060E6:  MOVLB  0
060E8:  CALL   53D6
060EC:  MOVFF  D51,D68
060F0:  MOVLB  D
060F2:  CLRF   x69
060F4:  MOVLW  0F
060F6:  MOVWF  x6B
060F8:  MOVLW  92
060FA:  MOVWF  x6A
060FC:  MOVLB  0
060FE:  CALL   53D6
....................     output_low(spi_functions->cs_pin); 
06102:  MOVLW  08
06104:  MOVLB  D
06106:  ADDWF  x48,W
06108:  MOVWF  FE9
0610A:  MOVLW  00
0610C:  ADDWFC x49,W
0610E:  MOVWF  FEA
06110:  MOVFF  FEC,D52
06114:  MOVF   FED,F
06116:  MOVFF  FEF,D51
0611A:  MOVFF  D51,D68
0611E:  CLRF   x69
06120:  MOVLW  0F
06122:  MOVWF  x6B
06124:  MOVLW  89
06126:  MOVWF  x6A
06128:  MOVLB  0
0612A:  CALL   53D6
0612E:  MOVFF  D51,D68
06132:  MOVLB  D
06134:  CLRF   x69
06136:  MOVLW  0F
06138:  MOVWF  x6B
0613A:  MOVLW  92
0613C:  MOVWF  x6A
0613E:  MOVLB  0
06140:  CALL   53D6
....................     delay_us(2); 
06144:  MOVLW  02
06146:  MOVWF  00
06148:  DECFSZ 00,F
0614A:  BRA    6148
0614C:  NOP   
....................     spi_functions->spi_send(erase_command); 
0614E:  MOVFF  D48,01
06152:  MOVFF  D49,03
06156:  MOVFF  D48,D51
0615A:  MOVFF  D49,D52
0615E:  MOVFF  D49,FEA
06162:  MOVFF  D48,FE9
06166:  MOVFF  D4E,D69
0616A:  MOVLB  0
0616C:  CALL   03FC
....................     spi_functions->spi_send(address[3]); 
06170:  MOVLB  D
06172:  MOVFF  D48,01
06176:  MOVFF  D49,03
0617A:  MOVFF  D48,D51
0617E:  MOVFF  D49,D52
06182:  MOVLW  03
06184:  ADDWF  x4F,W
06186:  MOVWF  FE9
06188:  MOVLW  00
0618A:  ADDWFC x50,W
0618C:  MOVWF  FEA
0618E:  MOVFF  FEF,D69
06192:  MOVFF  D49,FEA
06196:  MOVFF  D48,FE9
0619A:  MOVLB  0
0619C:  CALL   03FC
....................     spi_functions->spi_send(address[2]); 
061A0:  MOVLB  D
061A2:  MOVFF  D48,01
061A6:  MOVFF  D49,03
061AA:  MOVFF  D48,D51
061AE:  MOVFF  D49,D52
061B2:  MOVLW  02
061B4:  ADDWF  x4F,W
061B6:  MOVWF  FE9
061B8:  MOVLW  00
061BA:  ADDWFC x50,W
061BC:  MOVWF  FEA
061BE:  MOVFF  FEF,D69
061C2:  MOVFF  D49,FEA
061C6:  MOVFF  D48,FE9
061CA:  MOVLB  0
061CC:  CALL   03FC
....................     spi_functions->spi_send(address[1]); 
061D0:  MOVLB  D
061D2:  MOVFF  D48,01
061D6:  MOVFF  D49,03
061DA:  MOVFF  D48,D51
061DE:  MOVFF  D49,D52
061E2:  MOVLW  01
061E4:  ADDWF  x4F,W
061E6:  MOVWF  FE9
061E8:  MOVLW  00
061EA:  ADDWFC x50,W
061EC:  MOVWF  FEA
061EE:  MOVFF  FEF,D69
061F2:  MOVFF  D49,FEA
061F6:  MOVFF  D48,FE9
061FA:  MOVLB  0
061FC:  CALL   03FC
....................     spi_functions->spi_send(address[0]); 
06200:  MOVFF  D48,01
06204:  MOVFF  D49,03
06208:  MOVFF  D48,D51
0620C:  MOVFF  D49,D52
06210:  MOVFF  D4F,FE9
06214:  MOVFF  D50,FEA
06218:  MOVFF  FEF,D69
0621C:  MOVFF  D49,FEA
06220:  MOVFF  D48,FE9
06224:  MOVLB  0
06226:  CALL   03FC
....................     delay_us(2); 
0622A:  MOVLW  02
0622C:  MOVWF  00
0622E:  DECFSZ 00,F
06230:  BRA    622E
06232:  NOP   
....................     output_high(spi_functions->cs_pin); 
06234:  MOVLW  08
06236:  MOVLB  D
06238:  ADDWF  x48,W
0623A:  MOVWF  FE9
0623C:  MOVLW  00
0623E:  ADDWFC x49,W
06240:  MOVWF  FEA
06242:  MOVFF  FEC,D52
06246:  MOVF   FED,F
06248:  MOVFF  FEF,D51
0624C:  MOVFF  D51,D68
06250:  MOVLW  01
06252:  MOVWF  x69
06254:  MOVLW  0F
06256:  MOVWF  x6B
06258:  MOVLW  89
0625A:  MOVWF  x6A
0625C:  MOVLB  0
0625E:  CALL   53D6
06262:  MOVFF  D51,D68
06266:  MOVLB  D
06268:  CLRF   x69
0626A:  MOVLW  0F
0626C:  MOVWF  x6B
0626E:  MOVLW  92
06270:  MOVWF  x6A
06272:  MOVLB  0
06274:  CALL   53D6
....................     delay_ms(750); 
06278:  MOVLW  03
0627A:  MOVLB  D
0627C:  MOVWF  x51
0627E:  MOVLW  FA
06280:  MOVWF  x52
06282:  MOVLB  0
06284:  CALL   5266
06288:  MOVLB  D
0628A:  DECFSZ x51,F
0628C:  BRA    627E
0628E:  MOVLB  0
06290:  RETURN 0
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include <boot_command.h> 
.................... #ifndef BOOT_COMMAND_H 
.................... #define BOOT_COMMAND_H 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include <flash_memory.h> 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include <flash_memory_fn.h> 
.................... #ifndef FLASH_MEMORY_FN_H 
.................... #define FLASH_MEMORY_FN_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
....................  
.................... // Erase all sectors from a given flash memory (spi_port). 
.................... void flash_erase_all_sectors(spi_fn* spi_functions) 
.................... { 
....................     uint32_t address = 0; 
....................     for (uint16_t i = 0; i < MEMORY_N_SECTORS; i++) { 
....................         flash_erase(spi_functions, address, ERASE_SECTOR); 
....................         address = address + MEMORY_SECTOR_SIZE; 
....................     } 
.................... } 
....................  
.................... // Transfer data from the flash memory (spi_port) to an uart device (uart_port), starting from a given 
.................... // address (page_address) and with a given total lenth (nbytes). 
.................... void flash_transfer_data_to_uart(spi_fn* from_spi_functions, uart_fn* to_uart_port, uint32_t page_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data = flash_read(from_spi_functions, page_address); 
....................         to_uart_port->put_char(data); 
....................         page_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data from one flash memory (from_spi_port) to another (to_spi_port), with different to and from page 
.................... // addresses and configurable length (nbytes). The same flash memory can be used as source and destination. 
.................... void flash_transfer_data_to_flash(spi_fn* from_spi_functions, uint32_t from_address, spi_fn* to_spi_functions, uint32_t to_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
*
0AAAE:  MOVLB  C
0AAB0:  CLRF   xC5
0AAB2:  CLRF   xC4
0AAB4:  CLRF   xC3
0AAB6:  CLRF   xC2
0AAB8:  MOVF   xC5,W
0AABA:  SUBWF  xC0,W
0AABC:  BNC   AB4C
0AABE:  BNZ   AAD6
0AAC0:  MOVF   xC4,W
0AAC2:  SUBWF  xBF,W
0AAC4:  BNC   AB4C
0AAC6:  BNZ   AAD6
0AAC8:  MOVF   xC3,W
0AACA:  SUBWF  xBE,W
0AACC:  BNC   AB4C
0AACE:  BNZ   AAD6
0AAD0:  MOVF   xBD,W
0AAD2:  SUBWF  xC2,W
0AAD4:  BC    AB4C
....................         data = flash_read(from_spi_functions, from_address); 
0AAD6:  MOVFF  CB2,D5E
0AADA:  MOVFF  CB1,D5D
0AADE:  MOVFF  CB6,D62
0AAE2:  MOVFF  CB5,D61
0AAE6:  MOVFF  CB4,D60
0AAEA:  MOVFF  CB3,D5F
0AAEE:  MOVLB  0
0AAF0:  CALL   5632
0AAF4:  MOVFF  01,CC1
....................         flash_write(to_spi_functions, to_address, data); 
0AAF8:  MOVFF  CB8,D58
0AAFC:  MOVFF  CB7,D57
0AB00:  MOVFF  CBC,D5C
0AB04:  MOVFF  CBB,D5B
0AB08:  MOVFF  CBA,D5A
0AB0C:  MOVFF  CB9,D59
0AB10:  MOVFF  CC1,D5D
0AB14:  CALL   62F6
....................         from_address++; 
0AB18:  MOVLW  01
0AB1A:  MOVLB  C
0AB1C:  ADDWF  xB3,F
0AB1E:  BTFSC  FD8.0
0AB20:  INCF   xB4,F
0AB22:  BTFSC  FD8.2
0AB24:  INCF   xB5,F
0AB26:  BTFSC  FD8.2
0AB28:  INCF   xB6,F
....................         to_address++; 
0AB2A:  MOVLW  01
0AB2C:  ADDWF  xB9,F
0AB2E:  BTFSC  FD8.0
0AB30:  INCF   xBA,F
0AB32:  BTFSC  FD8.2
0AB34:  INCF   xBB,F
0AB36:  BTFSC  FD8.2
0AB38:  INCF   xBC,F
0AB3A:  MOVLW  01
0AB3C:  ADDWF  xC2,F
0AB3E:  BTFSC  FD8.0
0AB40:  INCF   xC3,F
0AB42:  BTFSC  FD8.2
0AB44:  INCF   xC4,F
0AB46:  BTFSC  FD8.2
0AB48:  INCF   xC5,F
0AB4A:  BRA    AAB8
....................     } 
0AB4C:  MOVLB  0
0AB4E:  RETURN 0
.................... } 
....................  
.................... // Transfer data from ram to flash memory (to_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_from_ram(spi_fn* to_spi_functions, uint32_t to_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
*
0653E:  MOVLB  D
06540:  CLRF   x55
06542:  CLRF   x54
06544:  CLRF   x53
06546:  CLRF   x52
06548:  MOVF   x55,W
0654A:  SUBWF  x51,W
0654C:  BNC   65B6
0654E:  BNZ   6566
06550:  MOVF   x54,W
06552:  SUBWF  x50,W
06554:  BNC   65B6
06556:  BNZ   6566
06558:  MOVF   x53,W
0655A:  SUBWF  x4F,W
0655C:  BNC   65B6
0655E:  BNZ   6566
06560:  MOVF   x4E,W
06562:  SUBWF  x52,W
06564:  BC    65B6
....................         flash_write(to_spi_functions, to_address, data[i]); 
06566:  MOVF   x4C,W
06568:  ADDWF  x52,W
0656A:  MOVWF  FE9
0656C:  MOVF   x4D,W
0656E:  ADDWFC x53,W
06570:  MOVWF  FEA
06572:  MOVFF  FEF,D5D
06576:  MOVFF  D47,D58
0657A:  MOVFF  D46,D57
0657E:  MOVFF  D4B,D5C
06582:  MOVFF  D4A,D5B
06586:  MOVFF  D49,D5A
0658A:  MOVFF  D48,D59
0658E:  MOVLB  0
06590:  RCALL  62F6
....................         to_address++; 
06592:  MOVLW  01
06594:  MOVLB  D
06596:  ADDWF  x48,F
06598:  BTFSC  FD8.0
0659A:  INCF   x49,F
0659C:  BTFSC  FD8.2
0659E:  INCF   x4A,F
065A0:  BTFSC  FD8.2
065A2:  INCF   x4B,F
065A4:  MOVLW  01
065A6:  ADDWF  x52,F
065A8:  BTFSC  FD8.0
065AA:  INCF   x53,F
065AC:  BTFSC  FD8.2
065AE:  INCF   x54,F
065B0:  BTFSC  FD8.2
065B2:  INCF   x55,F
065B4:  BRA    6548
....................     } 
065B6:  MOVLB  0
065B8:  RETURN 0
.................... } 
....................  
.................... // Transfer data to ram from flash memory (from_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_to_ram(spi_fn* to_spi_functions, uint32_t from_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
*
057C8:  MOVLB  D
057CA:  CLRF   x5A
057CC:  CLRF   x59
057CE:  CLRF   x58
057D0:  CLRF   x57
057D2:  MOVF   x5A,W
057D4:  SUBWF  x56,W
057D6:  BNC   584E
057D8:  BNZ   57F0
057DA:  MOVF   x59,W
057DC:  SUBWF  x55,W
057DE:  BNC   584E
057E0:  BNZ   57F0
057E2:  MOVF   x58,W
057E4:  SUBWF  x54,W
057E6:  BNC   584E
057E8:  BNZ   57F0
057EA:  MOVF   x53,W
057EC:  SUBWF  x57,W
057EE:  BC    584E
....................         data[i] = flash_read(to_spi_functions, from_address); 
057F0:  MOVF   x51,W
057F2:  ADDWF  x57,W
057F4:  MOVWF  01
057F6:  MOVF   x52,W
057F8:  ADDWFC x58,W
057FA:  MOVWF  03
057FC:  MOVFF  01,D5B
05800:  MOVWF  x5C
05802:  MOVFF  D4C,D5E
05806:  MOVFF  D4B,D5D
0580A:  MOVFF  D50,D62
0580E:  MOVFF  D4F,D61
05812:  MOVFF  D4E,D60
05816:  MOVFF  D4D,D5F
0581A:  MOVLB  0
0581C:  RCALL  5632
0581E:  MOVFF  D5C,FEA
05822:  MOVFF  D5B,FE9
05826:  MOVFF  01,FEF
....................         from_address++; 
0582A:  MOVLW  01
0582C:  MOVLB  D
0582E:  ADDWF  x4D,F
05830:  BTFSC  FD8.0
05832:  INCF   x4E,F
05834:  BTFSC  FD8.2
05836:  INCF   x4F,F
05838:  BTFSC  FD8.2
0583A:  INCF   x50,F
0583C:  MOVLW  01
0583E:  ADDWF  x57,F
05840:  BTFSC  FD8.0
05842:  INCF   x58,F
05844:  BTFSC  FD8.2
05846:  INCF   x59,F
05848:  BTFSC  FD8.2
0584A:  INCF   x5A,F
0584C:  BRA    57D2
....................     } 
0584E:  MOVLB  0
05850:  RETURN 0
.................... } 
....................  
.................... // Erase memory pages around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to page allignment. 
....................  
.................... void flash_erase_pages(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_PAGE_SIZE) { 
*
06292:  MOVFF  C6B,C73
06296:  MOVFF  C6A,C72
0629A:  MOVFF  C69,C71
0629E:  MOVFF  C68,C70
062A2:  MOVLB  C
062A4:  MOVF   x73,W
062A6:  SUBWF  x6F,W
062A8:  BNC   62F2
062AA:  BNZ   62C2
062AC:  MOVF   x72,W
062AE:  SUBWF  x6E,W
062B0:  BNC   62F2
062B2:  BNZ   62C2
062B4:  MOVF   x71,W
062B6:  SUBWF  x6D,W
062B8:  BNC   62F2
062BA:  BNZ   62C2
062BC:  MOVF   x6C,W
062BE:  SUBWF  x70,W
062C0:  BC    62F2
....................         flash_erase(to_spi_functions, i, ERASE_PAGE); 
062C2:  MOVFF  C67,D49
062C6:  MOVFF  C66,D48
062CA:  MOVFF  C73,D4D
062CE:  MOVFF  C72,D4C
062D2:  MOVFF  C71,D4B
062D6:  MOVFF  C70,D4A
062DA:  MOVLW  21
062DC:  MOVLB  D
062DE:  MOVWF  x4E
062E0:  MOVLB  0
062E2:  RCALL  604C
062E4:  MOVLW  10
062E6:  MOVLB  C
062E8:  ADDWF  x71,F
062EA:  MOVLW  00
062EC:  ADDWFC x72,F
062EE:  ADDWFC x73,F
062F0:  BRA    62A4
....................     } 
062F2:  MOVLB  0
062F4:  RETURN 0
.................... } 
....................  
.................... // Erase memory sectors around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to sector allignment. 
.................... void flash_erase_sectors(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_SECTOR_SIZE) { 
....................         flash_erase(to_spi_functions, i, ERASE_SECTOR); 
....................     } 
.................... } 
....................  
.................... void flash_dump(spi_fn* spi_functions, uint32_t start, uint32_t end) 
*
12760:  MOVLB  C
12762:  CLRF   x50
12764:  CLRF   x4F
.................... { 
....................     uint8_t data; 
....................     uint16_t empty_blocks = 0; 
....................     for (uint32_t i = start; i < end; i++) { 
12766:  MOVFF  C49,C54
1276A:  MOVFF  C48,C53
1276E:  MOVFF  C47,C52
12772:  MOVFF  C46,C51
12776:  MOVF   x54,W
12778:  SUBWF  x4D,W
1277A:  BTFSS  FD8.0
1277C:  BRA    12860
1277E:  BNZ   12798
12780:  MOVF   x53,W
12782:  SUBWF  x4C,W
12784:  BTFSS  FD8.0
12786:  BRA    12860
12788:  BNZ   12798
1278A:  MOVF   x52,W
1278C:  SUBWF  x4B,W
1278E:  BNC   12860
12790:  BNZ   12798
12792:  MOVF   x4A,W
12794:  SUBWF  x51,W
12796:  BC    12860
....................         if (i % (TERMINAL_COLS / 2) == 0) 
12798:  BSF    FD8.1
1279A:  MOVLW  0C
1279C:  MOVWF  FEA
1279E:  MOVLW  55
127A0:  MOVWF  FE9
127A2:  MOVFF  C54,CB3
127A6:  MOVFF  C53,CB2
127AA:  MOVFF  C52,CB1
127AE:  MOVFF  C51,CB0
127B2:  CLRF   xB7
127B4:  CLRF   xB6
127B6:  CLRF   xB5
127B8:  MOVLW  28
127BA:  MOVWF  xB4
127BC:  MOVLB  0
127BE:  CALL   5852
127C2:  MOVFF  C58,C5C
127C6:  MOVFF  C57,C5B
127CA:  MOVFF  C56,C5A
127CE:  MOVFF  C55,C59
127D2:  MOVLB  C
127D4:  MOVF   x59,F
127D6:  BNZ   127FE
127D8:  MOVF   x5A,F
127DA:  BNZ   127FE
127DC:  MOVF   x5B,F
127DE:  BNZ   127FE
127E0:  MOVF   x5C,F
127E2:  BNZ   127FE
....................             fprintf(PC, "\r\n"); 
127E4:  MOVLW  0D
127E6:  MOVLB  D
127E8:  MOVWF  x6A
127EA:  MOVLB  0
127EC:  CALL   44EE
127F0:  MOVLW  0A
127F2:  MOVLB  D
127F4:  MOVWF  x6A
127F6:  MOVLB  0
127F8:  CALL   44EE
127FC:  MOVLB  C
....................         data = flash_read(spi_functions, i); 
127FE:  MOVFF  C45,D5E
12802:  MOVFF  C44,D5D
12806:  MOVFF  C54,D62
1280A:  MOVFF  C53,D61
1280E:  MOVFF  C52,D60
12812:  MOVFF  C51,D5F
12816:  MOVLB  0
12818:  CALL   5632
1281C:  MOVFF  01,C4E
....................         fprintf(PC, "%02X", data); 
12820:  MOVFF  C4E,CBF
12824:  MOVLW  37
12826:  MOVLB  C
12828:  MOVWF  xC0
1282A:  MOVLB  0
1282C:  CALL   5A92
....................         if (data == 0xFF) { 
12830:  MOVLB  C
12832:  INCFSZ x4E,W
12834:  BRA    1283E
....................             empty_blocks++; 
12836:  INCF   x4F,F
12838:  BTFSC  FD8.2
1283A:  INCF   x50,F
....................         } else { 
1283C:  BRA    12842
....................             empty_blocks = 0; 
1283E:  CLRF   x50
12840:  CLRF   x4F
....................         } 
....................         if (empty_blocks >= EMPTY_BLOCKS_LIMIT) { 
12842:  MOVF   x50,F
12844:  BNZ   1284C
12846:  MOVF   x4F,W
12848:  SUBLW  3F
1284A:  BC    1284E
....................             break; 
1284C:  BRA    12860
....................         } 
1284E:  MOVLW  01
12850:  ADDWF  x51,F
12852:  BTFSC  FD8.0
12854:  INCF   x52,F
12856:  BTFSC  FD8.2
12858:  INCF   x53,F
1285A:  BTFSC  FD8.2
1285C:  INCF   x54,F
1285E:  BRA    12776
....................     } 
12860:  MOVLB  0
12862:  RETURN 0
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) 
.................... void flash_initialize_flash_ctrl(uint32_t start, 
....................     uint32_t end, 
....................     uint32_t current, 
....................     uint32_t packet_size, 
....................     flash_ctrl* fmem) 
.................... { 
....................     fmem->start = start; 
*
058E6:  MOVLB  C
058E8:  MOVFF  C7C,FE9
058EC:  MOVFF  C7D,FEA
058F0:  MOVFF  C6C,FEF
058F4:  MOVFF  C6D,FEC
058F8:  MOVFF  C6E,FEC
058FC:  MOVFF  C6F,FEC
....................     fmem->end = end - (end - start) % packet_size; 
05900:  MOVLW  04
05902:  ADDWF  x7C,W
05904:  MOVWF  01
05906:  MOVLW  00
05908:  ADDWFC x7D,W
0590A:  MOVWF  03
0590C:  MOVFF  01,C7E
05910:  MOVWF  x7F
05912:  MOVF   x6C,W
05914:  SUBWF  x70,W
05916:  MOVWF  x80
05918:  MOVF   x6D,W
0591A:  SUBWFB x71,W
0591C:  MOVWF  x81
0591E:  MOVF   x6E,W
05920:  SUBWFB x72,W
05922:  MOVWF  x82
05924:  MOVF   x6F,W
05926:  SUBWFB x73,W
05928:  MOVWF  x83
0592A:  MOVFF  FEA,C85
0592E:  MOVFF  FE9,C84
05932:  BSF    FD8.1
05934:  MOVLW  0C
05936:  MOVWF  FEA
05938:  MOVLW  86
0593A:  MOVWF  FE9
0593C:  MOVFF  C83,CB3
05940:  MOVFF  C82,CB2
05944:  MOVFF  C81,CB1
05948:  MOVFF  C80,CB0
0594C:  MOVFF  C7B,CB7
05950:  MOVFF  C7A,CB6
05954:  MOVFF  C79,CB5
05958:  MOVFF  C78,CB4
0595C:  MOVLB  0
0595E:  RCALL  5852
05960:  MOVFF  C86,00
05964:  MOVFF  C85,FEA
05968:  MOVFF  C84,FE9
0596C:  MOVF   00,W
0596E:  MOVLB  C
05970:  SUBWF  x70,W
05972:  MOVWF  00
05974:  MOVF   x87,W
05976:  SUBWFB x71,W
05978:  MOVWF  01
0597A:  MOVF   x88,W
0597C:  SUBWFB x72,W
0597E:  MOVWF  02
05980:  MOVF   x89,W
05982:  SUBWFB x73,W
05984:  MOVFF  C7F,FEA
05988:  MOVFF  C7E,FE9
0598C:  MOVFF  00,FEF
05990:  MOVFF  01,FEC
05994:  MOVFF  02,FEC
05998:  MOVWF  FEC
....................     fmem->current = current; 
0599A:  MOVLW  08
0599C:  ADDWF  x7C,W
0599E:  MOVWF  FE9
059A0:  MOVLW  00
059A2:  ADDWFC x7D,W
059A4:  MOVWF  FEA
059A6:  MOVFF  C74,FEF
059AA:  MOVFF  C75,FEC
059AE:  MOVFF  C76,FEC
059B2:  MOVFF  C77,FEC
....................     fmem->delta = packet_size; 
059B6:  MOVLW  0C
059B8:  ADDWF  x7C,W
059BA:  MOVWF  FE9
059BC:  MOVLW  00
059BE:  ADDWFC x7D,W
059C0:  MOVWF  FEA
059C2:  MOVFF  C78,FEF
059C6:  MOVLB  0
059C8:  RETURN 0
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) based on existing address information from flash 
.................... void flash_initialize_flash_ctrl_from_memory_date_based( 
....................     uint8_t sectors_per_day, 
....................     int8_t deployment_counter, 
....................     uint32_t candidate_address, 
....................     uint32_t first_address, 
....................     uint32_t telemetry_size, 
....................     uint8_t update_date, 
....................     flash_ctrl* fmem) 
.................... { 
....................      
....................     if(deployment_counter < 0) 
*
05B62:  MOVLB  C
05B64:  BTFSS  x50.7
05B66:  BRA    5B6A
....................         deployment_counter = 0; 
05B68:  CLRF   x50
....................  
....................     uint32_t addr_start; 
....................     uint16_t day_of_the_year; 
....................  
....................     if(deployment_counter < 5){ 
05B6A:  BTFSC  x50.7
05B6C:  BRA    5B74
05B6E:  MOVF   x50,W
05B70:  SUBLW  04
05B72:  BNC   5C00
....................         day_of_the_year = deployment_counter; 
05B74:  CLRF   03
05B76:  MOVFF  C50,C64
05B7A:  MOVFF  03,C65
....................         addr_start = first_address + (uint32_t)deployment_counter * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
05B7E:  CLRF   01
05B80:  CLRF   02
05B82:  CLRF   03
05B84:  MOVFF  03,CB4
05B88:  MOVFF  02,CB3
05B8C:  MOVFF  01,CB2
05B90:  MOVFF  C50,C6C
05B94:  MOVFF  C4F,00
05B98:  CLRF   01
05B9A:  CLRF   02
05B9C:  CLRF   03
05B9E:  MOVFF  03,C73
05BA2:  MOVFF  02,C72
05BA6:  MOVFF  01,C71
05BAA:  MOVFF  C4F,C70
05BAE:  MOVFF  C50,CB1
05BB2:  MOVFF  03,CB8
05BB6:  MOVFF  02,CB7
05BBA:  MOVFF  01,CB6
05BBE:  MOVFF  C4F,CB5
05BC2:  MOVLB  0
05BC4:  CALL   456E
05BC8:  MOVFF  03,C6F
05BCC:  MOVFF  02,C6E
05BD0:  MOVFF  01,C6D
05BD4:  MOVFF  00,C6C
05BD8:  MOVFF  01,03
05BDC:  MOVFF  00,02
05BE0:  CLRF   00
05BE2:  CLRF   01
05BE4:  MOVF   00,W
05BE6:  MOVLB  C
05BE8:  ADDWF  x55,W
05BEA:  MOVWF  x60
05BEC:  MOVF   01,W
05BEE:  ADDWFC x56,W
05BF0:  MOVWF  x61
05BF2:  MOVF   02,W
05BF4:  ADDWFC x57,W
05BF6:  MOVWF  x62
05BF8:  MOVF   03,W
05BFA:  ADDWFC x58,W
05BFC:  MOVWF  x63
....................     } 
05BFE:  BRA    5D2C
....................     else{ 
....................         if(update_date){ 
05C00:  MOVF   x5D,F
05C02:  BZ    5C32
....................             struct_tm* local_time = localtime(&current_time); 
05C04:  CLRF   x84
05C06:  MOVLW  3B
05C08:  MOVWF  x83
05C0A:  MOVLB  0
05C0C:  CALL   4D28
05C10:  MOVFF  02,C67
05C14:  MOVFF  01,C66
....................             day_of_the_year = local_time->tm_yday; // struct_tm::tm_yday is the day of the year (from 0-365) 
05C18:  MOVLW  08
05C1A:  MOVLB  C
05C1C:  ADDWF  x66,W
05C1E:  MOVWF  FE9
05C20:  MOVLW  00
05C22:  ADDWFC x67,W
05C24:  MOVWF  FEA
05C26:  MOVFF  FEC,C65
05C2A:  MOVF   FED,F
05C2C:  MOVFF  FEF,C64
....................         } else{ 
05C30:  BRA    5C96
....................             day_of_the_year = (candidate_address - first_address) / ((uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE); 
05C32:  MOVF   x55,W
05C34:  SUBWF  x51,W
05C36:  MOVWF  x6C
05C38:  MOVF   x56,W
05C3A:  SUBWFB x52,W
05C3C:  MOVWF  x6D
05C3E:  MOVF   x57,W
05C40:  SUBWFB x53,W
05C42:  MOVWF  x6E
05C44:  MOVF   x58,W
05C46:  SUBWFB x54,W
05C48:  MOVWF  x6F
05C4A:  CLRF   x73
05C4C:  CLRF   x72
05C4E:  CLRF   x71
05C50:  MOVFF  C71,03
05C54:  MOVFF  C4F,02
05C58:  CLRF   00
05C5A:  CLRF   01
05C5C:  MOVFF  C71,CB7
05C60:  MOVFF  C4F,C72
05C64:  MOVFF  01,C71
05C68:  MOVFF  00,C70
05C6C:  BCF    FD8.1
05C6E:  MOVWF  xB3
05C70:  MOVFF  C6E,CB2
05C74:  MOVFF  C6D,CB1
05C78:  MOVFF  C6C,CB0
05C7C:  MOVFF  C4F,CB6
05C80:  MOVFF  01,CB5
05C84:  MOVFF  00,CB4
05C88:  MOVLB  0
05C8A:  RCALL  5852
05C8C:  MOVFF  01,C65
05C90:  MOVFF  00,C64
05C94:  MOVLB  C
....................         } 
....................         if (day_of_the_year > 366) 
05C96:  MOVF   x65,W
05C98:  SUBLW  00
05C9A:  BC    5CAA
05C9C:  XORLW  FF
05C9E:  BNZ   5CA6
05CA0:  MOVF   x64,W
05CA2:  SUBLW  6E
05CA4:  BC    5CAA
....................             day_of_the_year = 0; 
05CA6:  CLRF   x65
05CA8:  CLRF   x64
....................         addr_start = first_address + (uint32_t)day_of_the_year * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
05CAA:  CLRF   x6F
05CAC:  CLRF   x6E
05CAE:  MOVFF  C65,C6D
05CB2:  MOVFF  C64,C6C
05CB6:  MOVFF  C4F,00
05CBA:  CLRF   01
05CBC:  CLRF   02
05CBE:  CLRF   03
05CC0:  MOVFF  03,C73
05CC4:  MOVFF  02,C72
05CC8:  MOVFF  01,C71
05CCC:  MOVFF  C4F,C70
05CD0:  MOVFF  C6F,CB4
05CD4:  MOVFF  C6E,CB3
05CD8:  MOVFF  C65,CB2
05CDC:  MOVFF  C64,CB1
05CE0:  MOVFF  03,CB8
05CE4:  MOVFF  02,CB7
05CE8:  MOVFF  01,CB6
05CEC:  MOVFF  C4F,CB5
05CF0:  MOVLB  0
05CF2:  CALL   456E
05CF6:  MOVFF  03,C6F
05CFA:  MOVFF  02,C6E
05CFE:  MOVFF  01,C6D
05D02:  MOVFF  00,C6C
05D06:  MOVFF  01,03
05D0A:  MOVFF  00,02
05D0E:  CLRF   00
05D10:  CLRF   01
05D12:  MOVF   00,W
05D14:  MOVLB  C
05D16:  ADDWF  x55,W
05D18:  MOVWF  x60
05D1A:  MOVF   01,W
05D1C:  ADDWFC x56,W
05D1E:  MOVWF  x61
05D20:  MOVF   02,W
05D22:  ADDWFC x57,W
05D24:  MOVWF  x62
05D26:  MOVF   03,W
05D28:  ADDWFC x58,W
05D2A:  MOVWF  x63
....................     } 
....................     uint32_t addr_end = addr_start + (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
05D2C:  CLRF   x6D
05D2E:  CLRF   00
05D30:  CLRF   01
05D32:  MOVF   00,W
05D34:  ADDWF  x60,W
05D36:  MOVWF  x68
05D38:  MOVF   01,W
05D3A:  ADDWFC x61,W
05D3C:  MOVWF  x69
05D3E:  MOVF   x4F,W
05D40:  ADDWFC x62,W
05D42:  MOVWF  x6A
05D44:  MOVF   x6D,W
05D46:  ADDWFC x63,W
05D48:  MOVWF  x6B
....................     if(candidate_address >= addr_start && candidate_address < addr_end){ 
05D4A:  MOVF   x63,W
05D4C:  SUBWF  x54,W
05D4E:  BNC   5DD6
05D50:  BNZ   5D68
05D52:  MOVF   x62,W
05D54:  SUBWF  x53,W
05D56:  BNC   5DD6
05D58:  BNZ   5D68
05D5A:  MOVF   x61,W
05D5C:  SUBWF  x52,W
05D5E:  BNC   5DD6
05D60:  BNZ   5D68
05D62:  MOVF   x60,W
05D64:  SUBWF  x51,W
05D66:  BNC   5DD6
05D68:  MOVF   x54,W
05D6A:  SUBWF  x6B,W
05D6C:  BNC   5DD6
05D6E:  BNZ   5D86
05D70:  MOVF   x53,W
05D72:  SUBWF  x6A,W
05D74:  BNC   5DD6
05D76:  BNZ   5D86
05D78:  MOVF   x52,W
05D7A:  SUBWF  x69,W
05D7C:  BNC   5DD6
05D7E:  BNZ   5D86
05D80:  MOVF   x68,W
05D82:  SUBWF  x51,W
05D84:  BC    5DD6
....................         flash_initialize_flash_ctrl(addr_start, addr_end, candidate_address, telemetry_size, fmem); 
05D86:  MOVFF  C63,C6F
05D8A:  MOVFF  C62,C6E
05D8E:  MOVFF  C61,C6D
05D92:  MOVFF  C60,C6C
05D96:  MOVFF  C6B,C73
05D9A:  MOVFF  C6A,C72
05D9E:  MOVFF  C69,C71
05DA2:  MOVFF  C68,C70
05DA6:  MOVFF  C54,C77
05DAA:  MOVFF  C53,C76
05DAE:  MOVFF  C52,C75
05DB2:  MOVFF  C51,C74
05DB6:  MOVFF  C5C,C7B
05DBA:  MOVFF  C5B,C7A
05DBE:  MOVFF  C5A,C79
05DC2:  MOVFF  C59,C78
05DC6:  MOVFF  C5F,C7D
05DCA:  MOVFF  C5E,C7C
05DCE:  MOVLB  0
05DD0:  RCALL  58E6
....................     } else { 
05DD2:  BRA    5E22
05DD4:  MOVLB  C
....................         flash_initialize_flash_ctrl(addr_start, addr_end, addr_start, telemetry_size, fmem); 
05DD6:  MOVFF  C63,C6F
05DDA:  MOVFF  C62,C6E
05DDE:  MOVFF  C61,C6D
05DE2:  MOVFF  C60,C6C
05DE6:  MOVFF  C6B,C73
05DEA:  MOVFF  C6A,C72
05DEE:  MOVFF  C69,C71
05DF2:  MOVFF  C68,C70
05DF6:  MOVFF  C63,C77
05DFA:  MOVFF  C62,C76
05DFE:  MOVFF  C61,C75
05E02:  MOVFF  C60,C74
05E06:  MOVFF  C5C,C7B
05E0A:  MOVFF  C5B,C7A
05E0E:  MOVFF  C5A,C79
05E12:  MOVFF  C59,C78
05E16:  MOVFF  C5F,C7D
05E1A:  MOVFF  C5E,C7C
05E1E:  MOVLB  0
05E20:  RCALL  58E6
....................     } 
....................     fprintf(PC, "\r\nDay of the year = %lu\r\n", day_of_the_year + 1); 
05E22:  MOVLW  01
05E24:  MOVLB  C
05E26:  ADDWF  x64,W
05E28:  MOVWF  x6C
05E2A:  MOVLW  00
05E2C:  ADDWFC x65,W
05E2E:  MOVWF  x6D
05E30:  MOVLW  3E
05E32:  MOVWF  FF6
05E34:  MOVLW  05
05E36:  MOVWF  FF7
05E38:  MOVLW  00
05E3A:  MOVWF  FF8
05E3C:  MOVLW  14
05E3E:  MOVWF  xC1
05E40:  MOVLB  0
05E42:  CALL   5290
05E46:  MOVLW  10
05E48:  MOVWF  FE9
05E4A:  MOVFF  C6D,C76
05E4E:  MOVFF  C6C,C75
05E52:  RCALL  59CA
05E54:  MOVLW  0D
05E56:  MOVLB  D
05E58:  MOVWF  x6A
05E5A:  MOVLB  0
05E5C:  CALL   44EE
05E60:  MOVLW  0A
05E62:  MOVLB  D
05E64:  MOVWF  x6A
05E66:  MOVLB  0
05E68:  CALL   44EE
....................     fprintf(PC, "Candidate telemetry address = 0x%8lX\r\n", candidate_address); 
05E6C:  MOVLW  58
05E6E:  MOVWF  FF6
05E70:  MOVLW  05
05E72:  MOVWF  FF7
05E74:  MOVLW  00
05E76:  MOVWF  FF8
05E78:  MOVLW  20
05E7A:  MOVLB  C
05E7C:  MOVWF  xC1
05E7E:  MOVLB  0
05E80:  CALL   5290
05E84:  MOVFF  C54,CBF
05E88:  MOVLW  37
05E8A:  MOVLB  C
05E8C:  MOVWF  xC0
05E8E:  MOVLB  0
05E90:  RCALL  5A92
05E92:  MOVFF  C53,CBF
05E96:  MOVLW  37
05E98:  MOVLB  C
05E9A:  MOVWF  xC0
05E9C:  MOVLB  0
05E9E:  RCALL  5A92
05EA0:  MOVFF  C52,CBF
05EA4:  MOVLW  37
05EA6:  MOVLB  C
05EA8:  MOVWF  xC0
05EAA:  MOVLB  0
05EAC:  RCALL  5A92
05EAE:  MOVFF  C51,CBF
05EB2:  MOVLW  37
05EB4:  MOVLB  C
05EB6:  MOVWF  xC0
05EB8:  MOVLB  0
05EBA:  RCALL  5A92
05EBC:  MOVLW  0D
05EBE:  MOVLB  D
05EC0:  MOVWF  x6A
05EC2:  MOVLB  0
05EC4:  CALL   44EE
05EC8:  MOVLW  0A
05ECA:  MOVLB  D
05ECC:  MOVWF  x6A
05ECE:  MOVLB  0
05ED0:  CALL   44EE
....................     fprintf(PC, "Initial telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.start); 
05ED4:  MOVLW  80
05ED6:  MOVWF  FF6
05ED8:  MOVLW  05
05EDA:  MOVWF  FF7
05EDC:  MOVLW  00
05EDE:  MOVWF  FF8
05EE0:  MOVLW  1E
05EE2:  MOVLB  C
05EE4:  MOVWF  xC1
05EE6:  MOVLB  0
05EE8:  CALL   5290
05EEC:  MOVFF  134,CBF
05EF0:  MOVLW  37
05EF2:  MOVLB  C
05EF4:  MOVWF  xC0
05EF6:  MOVLB  0
05EF8:  RCALL  5A92
05EFA:  MOVFF  133,CBF
05EFE:  MOVLW  37
05F00:  MOVLB  C
05F02:  MOVWF  xC0
05F04:  MOVLB  0
05F06:  RCALL  5A92
05F08:  MOVFF  132,CBF
05F0C:  MOVLW  37
05F0E:  MOVLB  C
05F10:  MOVWF  xC0
05F12:  MOVLB  0
05F14:  RCALL  5A92
05F16:  MOVFF  131,CBF
05F1A:  MOVLW  37
05F1C:  MOVLB  C
05F1E:  MOVWF  xC0
05F20:  MOVLB  0
05F22:  RCALL  5A92
05F24:  MOVLW  0D
05F26:  MOVLB  D
05F28:  MOVWF  x6A
05F2A:  MOVLB  0
05F2C:  CALL   44EE
05F30:  MOVLW  0A
05F32:  MOVLB  D
05F34:  MOVWF  x6A
05F36:  MOVLB  0
05F38:  CALL   44EE
....................     fprintf(PC, "Current telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.current); 
05F3C:  MOVLW  A6
05F3E:  MOVWF  FF6
05F40:  MOVLW  05
05F42:  MOVWF  FF7
05F44:  MOVLW  00
05F46:  MOVWF  FF8
05F48:  MOVLW  1E
05F4A:  MOVLB  C
05F4C:  MOVWF  xC1
05F4E:  MOVLB  0
05F50:  CALL   5290
05F54:  MOVFF  13C,CBF
05F58:  MOVLW  37
05F5A:  MOVLB  C
05F5C:  MOVWF  xC0
05F5E:  MOVLB  0
05F60:  RCALL  5A92
05F62:  MOVFF  13B,CBF
05F66:  MOVLW  37
05F68:  MOVLB  C
05F6A:  MOVWF  xC0
05F6C:  MOVLB  0
05F6E:  RCALL  5A92
05F70:  MOVFF  13A,CBF
05F74:  MOVLW  37
05F76:  MOVLB  C
05F78:  MOVWF  xC0
05F7A:  MOVLB  0
05F7C:  RCALL  5A92
05F7E:  MOVFF  139,CBF
05F82:  MOVLW  37
05F84:  MOVLB  C
05F86:  MOVWF  xC0
05F88:  MOVLB  0
05F8A:  RCALL  5A92
05F8C:  MOVLW  0D
05F8E:  MOVLB  D
05F90:  MOVWF  x6A
05F92:  MOVLB  0
05F94:  CALL   44EE
05F98:  MOVLW  0A
05F9A:  MOVLB  D
05F9C:  MOVWF  x6A
05F9E:  MOVLB  0
05FA0:  CALL   44EE
....................     fprintf(PC, "Telemetry size = %u\r\n", addr_flags.flash_telemetry.delta); 
05FA4:  MOVLW  CC
05FA6:  MOVWF  FF6
05FA8:  MOVLW  05
05FAA:  MOVWF  FF7
05FAC:  MOVLW  00
05FAE:  MOVWF  FF8
05FB0:  MOVLW  11
05FB2:  MOVLB  C
05FB4:  MOVWF  xC1
05FB6:  MOVLB  0
05FB8:  CALL   5290
05FBC:  MOVFF  13D,C78
05FC0:  MOVLW  1B
05FC2:  MOVLB  C
05FC4:  MOVWF  x79
05FC6:  MOVLB  0
05FC8:  RCALL  5ADC
05FCA:  MOVLW  0D
05FCC:  MOVLB  D
05FCE:  MOVWF  x6A
05FD0:  MOVLB  0
05FD2:  CALL   44EE
05FD6:  MOVLW  0A
05FD8:  MOVLB  D
05FDA:  MOVWF  x6A
05FDC:  MOVLB  0
05FDE:  CALL   44EE
....................     fprintf(PC, "Last telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.end); 
05FE2:  MOVLW  E2
05FE4:  MOVWF  FF6
05FE6:  MOVLW  05
05FE8:  MOVWF  FF7
05FEA:  MOVLW  00
05FEC:  MOVWF  FF8
05FEE:  MOVLW  1B
05FF0:  MOVLB  C
05FF2:  MOVWF  xC1
05FF4:  MOVLB  0
05FF6:  CALL   5290
05FFA:  MOVFF  138,CBF
05FFE:  MOVLW  37
06000:  MOVLB  C
06002:  MOVWF  xC0
06004:  MOVLB  0
06006:  RCALL  5A92
06008:  MOVFF  137,CBF
0600C:  MOVLW  37
0600E:  MOVLB  C
06010:  MOVWF  xC0
06012:  MOVLB  0
06014:  RCALL  5A92
06016:  MOVFF  136,CBF
0601A:  MOVLW  37
0601C:  MOVLB  C
0601E:  MOVWF  xC0
06020:  MOVLB  0
06022:  RCALL  5A92
06024:  MOVFF  135,CBF
06028:  MOVLW  37
0602A:  MOVLB  C
0602C:  MOVWF  xC0
0602E:  MOVLB  0
06030:  RCALL  5A92
06032:  MOVLW  0D
06034:  MOVLB  D
06036:  MOVWF  x6A
06038:  MOVLB  0
0603A:  CALL   44EE
0603E:  MOVLW  0A
06040:  MOVLB  D
06042:  MOVWF  x6A
06044:  MOVLB  0
06046:  CALL   44EE
0604A:  RETURN 0
.................... } 
....................  
.................... // Writes data according to a flash control structure (fctrl) to a flash memory in spi_port 
.................... void flash_cycle_write(spi_fn* spi_functions, uint8_t* data, flash_ctrl* fctrl) 
.................... { 
....................     if (fctrl->current < fctrl->start || fctrl->current >= fctrl->end) 
*
06658:  MOVLW  08
0665A:  MOVLB  C
0665C:  ADDWF  xC2,W
0665E:  MOVWF  FE9
06660:  MOVLW  00
06662:  ADDWFC xC3,W
06664:  MOVWF  FEA
06666:  MOVFF  FEF,CC9
0666A:  MOVFF  FEC,CCA
0666E:  MOVFF  FEC,CCB
06672:  MOVFF  FEC,CCC
06676:  MOVFF  CC2,FE9
0667A:  MOVFF  CC3,FEA
0667E:  MOVFF  FEF,00
06682:  MOVFF  FEC,01
06686:  MOVFF  FEC,02
0668A:  MOVFF  FEC,03
0668E:  MOVF   xCC,W
06690:  SUBWF  03,W
06692:  BNC   66AC
06694:  BNZ   6702
06696:  MOVF   xCB,W
06698:  SUBWF  02,W
0669A:  BNC   66AC
0669C:  BNZ   6702
0669E:  MOVF   xCA,W
066A0:  SUBWF  01,W
066A2:  BNC   66AC
066A4:  BNZ   6702
066A6:  MOVF   00,W
066A8:  SUBWF  xC9,W
066AA:  BNC   6702
066AC:  MOVLW  08
066AE:  ADDWF  xC2,W
066B0:  MOVWF  FE9
066B2:  MOVLW  00
066B4:  ADDWFC xC3,W
066B6:  MOVWF  FEA
066B8:  MOVFF  FEF,CC9
066BC:  MOVFF  FEC,CCA
066C0:  MOVFF  FEC,CCB
066C4:  MOVFF  FEC,CCC
066C8:  MOVLW  04
066CA:  ADDWF  xC2,W
066CC:  MOVWF  FE9
066CE:  MOVLW  00
066D0:  ADDWFC xC3,W
066D2:  MOVWF  FEA
066D4:  MOVFF  FEF,00
066D8:  MOVFF  FEC,01
066DC:  MOVFF  FEC,02
066E0:  MOVFF  FEC,03
066E4:  MOVF   03,W
066E6:  SUBWF  xCC,W
066E8:  BNC   6744
066EA:  BNZ   6702
066EC:  MOVF   02,W
066EE:  SUBWF  xCB,W
066F0:  BNC   6744
066F2:  BNZ   6702
066F4:  MOVF   01,W
066F6:  SUBWF  xCA,W
066F8:  BNC   6744
066FA:  BNZ   6702
066FC:  MOVF   00,W
066FE:  SUBWF  xC9,W
06700:  BNC   6744
....................         fctrl->current = fctrl->start; 
06702:  MOVLW  08
06704:  ADDWF  xC2,W
06706:  MOVWF  01
06708:  MOVLW  00
0670A:  ADDWFC xC3,W
0670C:  MOVWF  03
0670E:  MOVFF  01,CC9
06712:  MOVWF  xCA
06714:  MOVFF  CC2,FE9
06718:  MOVFF  CC3,FEA
0671C:  MOVFF  FEF,00
06720:  MOVFF  FEC,01
06724:  MOVFF  FEC,02
06728:  MOVFF  FEC,03
0672C:  MOVFF  CCA,FEA
06730:  MOVFF  CC9,FE9
06734:  MOVFF  00,FEF
06738:  MOVFF  01,FEC
0673C:  MOVFF  02,FEC
06740:  MOVFF  03,FEC
....................     uint32_t remaining_addressess = (MEMORY_PAGE_SIZE - (fctrl->current % MEMORY_PAGE_SIZE)) % MEMORY_PAGE_SIZE; 
06744:  MOVLW  08
06746:  ADDWF  xC2,W
06748:  MOVWF  FE9
0674A:  MOVLW  00
0674C:  ADDWFC xC3,W
0674E:  MOVWF  FEA
06750:  MOVFF  FEF,00
06754:  MOVFF  FEC,CCA
06758:  MOVFF  FEC,CCB
0675C:  MOVFF  FEC,CCC
06760:  MOVF   xCA,W
06762:  ANDLW  0F
06764:  MOVWF  01
06766:  CLRF   02
06768:  CLRF   03
0676A:  MOVLW  00
0676C:  BSF    FD8.0
0676E:  SUBFWB 00,W
06770:  MOVWF  xC9
06772:  MOVLW  10
06774:  SUBFWB 01,W
06776:  MOVWF  xCA
06778:  MOVLW  00
0677A:  SUBFWB 02,W
0677C:  MOVLW  00
0677E:  SUBFWB 03,W
06780:  MOVFF  CC9,CC4
06784:  MOVF   xCA,W
06786:  ANDLW  0F
06788:  MOVWF  xC5
0678A:  CLRF   xC6
0678C:  CLRF   xC7
....................     if (remaining_addressess < fctrl->delta) { 
0678E:  MOVLW  0C
06790:  ADDWF  xC2,W
06792:  MOVWF  FE9
06794:  MOVLW  00
06796:  ADDWFC xC3,W
06798:  MOVWF  FEA
0679A:  MOVF   FEF,W
0679C:  MOVF   xC7,F
0679E:  BNZ   67FC
067A0:  MOVF   xC6,F
067A2:  BNZ   67FC
067A4:  MOVF   xC5,F
067A6:  BNZ   67FC
067A8:  SUBWF  xC4,W
067AA:  BC    67FC
....................         flash_erase(spi_functions, fctrl->current + remaining_addressess, ERASE_PAGE); 
067AC:  MOVLW  08
067AE:  ADDWF  xC2,W
067B0:  MOVWF  FE9
067B2:  MOVLW  00
067B4:  ADDWFC xC3,W
067B6:  MOVWF  FEA
067B8:  MOVFF  FEF,CC9
067BC:  MOVFF  FEC,CCA
067C0:  MOVFF  FEC,CCB
067C4:  MOVFF  FEC,CCC
067C8:  MOVF   xC4,W
067CA:  ADDWF  xC9,F
067CC:  MOVF   xC5,W
067CE:  ADDWFC xCA,F
067D0:  MOVF   xC6,W
067D2:  ADDWFC xCB,F
067D4:  MOVF   xC7,W
067D6:  ADDWFC xCC,F
067D8:  MOVFF  CBF,D49
067DC:  MOVFF  CBE,D48
067E0:  MOVFF  CCC,D4D
067E4:  MOVFF  CCB,D4C
067E8:  MOVFF  CCA,D4B
067EC:  MOVFF  CC9,D4A
067F0:  MOVLW  21
067F2:  MOVLB  D
067F4:  MOVWF  x4E
067F6:  MOVLB  0
067F8:  RCALL  604C
067FA:  MOVLB  C
....................     } 
....................     for (int i = 0; i < fctrl->delta; i++) { 
067FC:  CLRF   xC8
067FE:  MOVLW  0C
06800:  ADDWF  xC2,W
06802:  MOVWF  FE9
06804:  MOVLW  00
06806:  ADDWFC xC3,W
06808:  MOVWF  FEA
0680A:  MOVF   FEF,W
0680C:  SUBWF  xC8,W
0680E:  BC    6866
....................         flash_write(spi_functions, fctrl->current, data[i]); 
06810:  MOVLW  08
06812:  ADDWF  xC2,W
06814:  MOVWF  FE9
06816:  MOVLW  00
06818:  ADDWFC xC3,W
0681A:  MOVWF  FEA
0681C:  MOVFF  FEF,D59
06820:  MOVFF  FEC,D5A
06824:  MOVFF  FEC,D5B
06828:  MOVFF  FEC,D5C
0682C:  MOVF   xC8,W
0682E:  ADDWF  xC0,W
06830:  MOVWF  FE9
06832:  MOVLW  00
06834:  ADDWFC xC1,W
06836:  MOVWF  FEA
06838:  MOVFF  FEF,D5D
0683C:  MOVFF  CBF,D58
06840:  MOVFF  CBE,D57
06844:  MOVLB  0
06846:  RCALL  62F6
....................         fctrl->current++; 
06848:  MOVLW  08
0684A:  MOVLB  C
0684C:  ADDWF  xC2,W
0684E:  MOVWF  FE9
06850:  MOVLW  00
06852:  ADDWFC xC3,W
06854:  MOVWF  FEA
06856:  MOVLW  01
06858:  ADDWF  FEE,F
0685A:  MOVLW  00
0685C:  ADDWFC FEE,F
0685E:  ADDWFC FEE,F
06860:  ADDWFC FED,F
06862:  INCF   xC8,F
06864:  BRA    67FE
....................     } 
06866:  MOVLB  0
06868:  RETURN 0
.................... } 
....................  
.................... // Recover last available address from a flash control structure (fctrl) 
.................... void flash_recover_last_addr(spi_fn* spi_functions, flash_ctrl* fctrl) 
.................... { 
....................     uint8_t data; 
....................     for (fctrl->current = fctrl->end - fctrl->delta; fctrl->current >= fctrl->start; fctrl->current -= fctrl->delta) { 
*
06AD4:  MOVLW  08
06AD6:  MOVLB  B
06AD8:  ADDWF  xE8,W
06ADA:  MOVWF  01
06ADC:  MOVLW  00
06ADE:  ADDWFC xE9,W
06AE0:  MOVWF  03
06AE2:  MOVFF  01,BEC
06AE6:  MOVWF  xED
06AE8:  MOVLW  04
06AEA:  ADDWF  xE8,W
06AEC:  MOVWF  FE9
06AEE:  MOVLW  00
06AF0:  ADDWFC xE9,W
06AF2:  MOVWF  FEA
06AF4:  MOVFF  FEF,BEE
06AF8:  MOVFF  FEC,BEF
06AFC:  MOVFF  FEC,BF0
06B00:  MOVFF  FEC,BF1
06B04:  MOVLW  0C
06B06:  ADDWF  xE8,W
06B08:  MOVWF  FE9
06B0A:  MOVLW  00
06B0C:  ADDWFC xE9,W
06B0E:  MOVWF  FEA
06B10:  MOVF   FEF,W
06B12:  SUBWF  xEE,W
06B14:  MOVWF  00
06B16:  MOVLW  00
06B18:  SUBWFB xEF,W
06B1A:  MOVWF  01
06B1C:  MOVLW  00
06B1E:  SUBWFB xF0,W
06B20:  MOVWF  02
06B22:  MOVLW  00
06B24:  SUBWFB xF1,W
06B26:  MOVWF  03
06B28:  MOVWF  xF1
06B2A:  MOVFF  02,BF0
06B2E:  MOVFF  01,BEF
06B32:  MOVFF  00,BEE
06B36:  MOVFF  BED,FEA
06B3A:  MOVFF  BEC,FE9
06B3E:  MOVFF  00,FEF
06B42:  MOVFF  01,FEC
06B46:  MOVFF  02,FEC
06B4A:  MOVWF  FEC
06B4C:  MOVLW  08
06B4E:  ADDWF  xE8,W
06B50:  MOVWF  FE9
06B52:  MOVLW  00
06B54:  ADDWFC xE9,W
06B56:  MOVWF  FEA
06B58:  MOVFF  FEF,BEC
06B5C:  MOVFF  FEC,BED
06B60:  MOVFF  FEC,BEE
06B64:  MOVFF  FEC,BEF
06B68:  MOVFF  BE8,FE9
06B6C:  MOVFF  BE9,FEA
06B70:  MOVFF  FEF,00
06B74:  MOVFF  FEC,01
06B78:  MOVFF  FEC,02
06B7C:  MOVFF  FEC,03
06B80:  MOVF   03,W
06B82:  SUBWF  xEF,W
06B84:  BTFSS  FD8.0
06B86:  BRA    6CE2
06B88:  BNZ   6BA6
06B8A:  MOVF   02,W
06B8C:  SUBWF  xEE,W
06B8E:  BTFSS  FD8.0
06B90:  BRA    6CE2
06B92:  BNZ   6BA6
06B94:  MOVF   01,W
06B96:  SUBWF  xED,W
06B98:  BTFSS  FD8.0
06B9A:  BRA    6CE2
06B9C:  BNZ   6BA6
06B9E:  MOVF   00,W
06BA0:  SUBWF  xEC,W
06BA2:  BTFSS  FD8.0
06BA4:  BRA    6CE2
....................         for (uint8_t i = 0; i < fctrl->delta; i++) { 
06BA6:  CLRF   xEB
06BA8:  MOVLW  0C
06BAA:  ADDWF  xE8,W
06BAC:  MOVWF  FE9
06BAE:  MOVLW  00
06BB0:  ADDWFC xE9,W
06BB2:  MOVWF  FEA
06BB4:  MOVF   FEF,W
06BB6:  SUBWF  xEB,W
06BB8:  BC    6C70
....................             data = flash_read(spi_functions, fctrl->current + i); 
06BBA:  MOVLW  08
06BBC:  ADDWF  xE8,W
06BBE:  MOVWF  FE9
06BC0:  MOVLW  00
06BC2:  ADDWFC xE9,W
06BC4:  MOVWF  FEA
06BC6:  MOVFF  FEF,BEC
06BCA:  MOVFF  FEC,BED
06BCE:  MOVFF  FEC,BEE
06BD2:  MOVFF  FEC,BEF
06BD6:  MOVF   xEB,W
06BD8:  ADDWF  xEC,F
06BDA:  MOVLW  00
06BDC:  ADDWFC xED,F
06BDE:  ADDWFC xEE,F
06BE0:  ADDWFC xEF,F
06BE2:  MOVFF  BE7,D5E
06BE6:  MOVFF  BE6,D5D
06BEA:  MOVFF  BEF,D62
06BEE:  MOVFF  BEE,D61
06BF2:  MOVFF  BED,D60
06BF6:  MOVFF  BEC,D5F
06BFA:  MOVLB  0
06BFC:  CALL   5632
06C00:  MOVFF  01,BEA
....................             if (data != 0xFF) { 
06C04:  MOVLB  B
06C06:  INCFSZ xEA,W
06C08:  BRA    6C0C
06C0A:  BRA    6C6C
....................                 fctrl->current += fctrl->delta; 
06C0C:  MOVLW  08
06C0E:  ADDWF  xE8,W
06C10:  MOVWF  01
06C12:  MOVLW  00
06C14:  ADDWFC xE9,W
06C16:  MOVFF  01,BEC
06C1A:  MOVWF  xED
06C1C:  MOVWF  FEA
06C1E:  MOVFF  01,FE9
06C22:  MOVFF  FEF,BEE
06C26:  MOVFF  FEC,BEF
06C2A:  MOVFF  FEC,BF0
06C2E:  MOVFF  FEC,BF1
06C32:  MOVLW  0C
06C34:  ADDWF  xE8,W
06C36:  MOVWF  FE9
06C38:  MOVLW  00
06C3A:  ADDWFC xE9,W
06C3C:  MOVWF  FEA
06C3E:  MOVF   FEF,W
06C40:  ADDWF  xEE,W
06C42:  MOVWF  00
06C44:  MOVLW  00
06C46:  ADDWFC xEF,W
06C48:  MOVWF  01
06C4A:  MOVLW  00
06C4C:  ADDWFC xF0,W
06C4E:  MOVWF  02
06C50:  MOVLW  00
06C52:  ADDWFC xF1,W
06C54:  MOVFF  BED,FEA
06C58:  MOVFF  BEC,FE9
06C5C:  MOVFF  00,FEF
06C60:  MOVFF  01,FEC
06C64:  MOVFF  02,FEC
06C68:  MOVWF  FEC
....................                 goto loop_end; 
06C6A:  BRA    6CE2
....................             } 
06C6C:  INCF   xEB,F
06C6E:  BRA    6BA8
....................         } 
06C70:  MOVLW  08
06C72:  ADDWF  xE8,W
06C74:  MOVWF  01
06C76:  MOVLW  00
06C78:  ADDWFC xE9,W
06C7A:  MOVWF  03
06C7C:  MOVFF  01,BEC
06C80:  MOVWF  xED
06C82:  MOVWF  FEA
06C84:  MOVFF  01,FE9
06C88:  MOVFF  FEF,BEE
06C8C:  MOVFF  FEC,BEF
06C90:  MOVFF  FEC,BF0
06C94:  MOVFF  FEC,BF1
06C98:  MOVLW  0C
06C9A:  ADDWF  xE8,W
06C9C:  MOVWF  FE9
06C9E:  MOVLW  00
06CA0:  ADDWFC xE9,W
06CA2:  MOVWF  FEA
06CA4:  MOVF   FEF,W
06CA6:  SUBWF  xEE,W
06CA8:  MOVWF  00
06CAA:  MOVLW  00
06CAC:  SUBWFB xEF,W
06CAE:  MOVWF  01
06CB0:  MOVLW  00
06CB2:  SUBWFB xF0,W
06CB4:  MOVWF  02
06CB6:  MOVLW  00
06CB8:  SUBWFB xF1,W
06CBA:  MOVWF  03
06CBC:  MOVWF  xF1
06CBE:  MOVFF  02,BF0
06CC2:  MOVFF  01,BEF
06CC6:  MOVFF  00,BEE
06CCA:  MOVFF  BED,FEA
06CCE:  MOVFF  BEC,FE9
06CD2:  MOVFF  00,FEF
06CD6:  MOVFF  01,FEC
06CDA:  MOVFF  02,FEC
06CDE:  MOVWF  FEC
06CE0:  BRA    6B4C
....................     } 
.................... loop_end: 
....................     if (fctrl->current >= fctrl->end) 
06CE2:  MOVLW  08
06CE4:  ADDWF  xE8,W
06CE6:  MOVWF  FE9
06CE8:  MOVLW  00
06CEA:  ADDWFC xE9,W
06CEC:  MOVWF  FEA
06CEE:  MOVFF  FEF,BEC
06CF2:  MOVFF  FEC,BED
06CF6:  MOVFF  FEC,BEE
06CFA:  MOVFF  FEC,BEF
06CFE:  MOVLW  04
06D00:  ADDWF  xE8,W
06D02:  MOVWF  FE9
06D04:  MOVLW  00
06D06:  ADDWFC xE9,W
06D08:  MOVWF  FEA
06D0A:  MOVFF  FEF,00
06D0E:  MOVFF  FEC,01
06D12:  MOVFF  FEC,02
06D16:  MOVFF  FEC,03
06D1A:  MOVF   03,W
06D1C:  SUBWF  xEF,W
06D1E:  BNC   6D7C
06D20:  BNZ   6D38
06D22:  MOVF   02,W
06D24:  SUBWF  xEE,W
06D26:  BNC   6D7C
06D28:  BNZ   6D38
06D2A:  MOVF   01,W
06D2C:  SUBWF  xED,W
06D2E:  BNC   6D7C
06D30:  BNZ   6D38
06D32:  MOVF   00,W
06D34:  SUBWF  xEC,W
06D36:  BNC   6D7C
....................         fctrl->current = fctrl->start; 
06D38:  MOVLW  08
06D3A:  ADDWF  xE8,W
06D3C:  MOVWF  01
06D3E:  MOVLW  00
06D40:  ADDWFC xE9,W
06D42:  MOVWF  03
06D44:  MOVFF  01,BEC
06D48:  MOVFF  03,BED
06D4C:  MOVFF  BE8,FE9
06D50:  MOVFF  BE9,FEA
06D54:  MOVFF  FEF,00
06D58:  MOVFF  FEC,01
06D5C:  MOVFF  FEC,02
06D60:  MOVFF  FEC,03
06D64:  MOVFF  BED,FEA
06D68:  MOVFF  BEC,FE9
06D6C:  MOVFF  00,FEF
06D70:  MOVFF  01,FEC
06D74:  MOVFF  02,FEC
06D78:  MOVFF  03,FEC
06D7C:  MOVLB  0
06D7E:  GOTO   6E44 (RETURN)
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_FN_H 
....................  
.................... #include <scheduler.h> 
.................... #ifndef SCHEDULER_H 
.................... #define SCHEDULER_H 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled); 
....................  
.................... void scheduler_initialize() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
0700E:  MOVLB  B
07010:  CLRF   xD4
07012:  MOVF   xD4,W
07014:  SUBLW  1F
07016:  BNC   7048
....................         scheduled_commands[i].time = TIME_T_MAX; 
07018:  MOVLB  C
0701A:  CLRF   xC4
0701C:  MOVFF  BD4,CC3
07020:  CLRF   xC6
07022:  MOVLW  20
07024:  MOVWF  xC5
07026:  MOVLB  0
07028:  CALL   4D06
0702C:  MOVLW  5A
0702E:  MOVLB  B
07030:  ADDWF  01,W
07032:  MOVWF  FE9
07034:  MOVLW  01
07036:  ADDWFC 02,W
07038:  MOVWF  FEA
0703A:  SETF   FEF
0703C:  SETF   FEC
0703E:  SETF   FEC
07040:  MOVLW  7F
07042:  MOVWF  FEC
07044:  INCF   xD4,F
07046:  BRA    7012
....................     } 
07048:  MOVLB  0
0704A:  RETURN 0
.................... } 
....................  
.................... int scheduled_command_add(time_t time, uint8_t* command) 
.................... { 
....................     scheduled_command cmd; 
....................     cmd.time = time; 
0704C:  MOVFF  C98,C9E
07050:  MOVFF  C97,C9D
07054:  MOVFF  C96,C9C
07058:  MOVFF  C95,C9B
....................     memcpy(cmd.command, command, BUFF_LENGTH); 
0705C:  MOVLW  0C
0705E:  MOVWF  FEA
07060:  MOVLW  9F
07062:  MOVWF  FE9
07064:  MOVFF  C9A,FE2
07068:  MOVFF  C99,FE1
0706C:  MOVLW  1C
0706E:  MOVWF  01
07070:  MOVFF  FE6,FEE
07074:  DECFSZ 01,F
07076:  BRA    7070
....................  
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
07078:  MOVLB  C
0707A:  CLRF   xBB
0707C:  MOVF   xBB,W
0707E:  SUBLW  1F
07080:  BNC   711C
....................         if (scheduled_commands[i].time == TIME_T_MAX) { 
07082:  CLRF   xC4
07084:  MOVFF  CBB,CC3
07088:  CLRF   xC6
0708A:  MOVLW  20
0708C:  MOVWF  xC5
0708E:  MOVLB  0
07090:  CALL   4D06
07094:  MOVFF  02,CBD
07098:  MOVFF  01,CBC
0709C:  MOVLW  5A
0709E:  MOVLB  C
070A0:  ADDWF  01,W
070A2:  MOVWF  FE9
070A4:  MOVLW  01
070A6:  ADDWFC 02,W
070A8:  MOVWF  FEA
070AA:  MOVFF  FEF,CBE
070AE:  MOVFF  FEC,CBF
070B2:  MOVFF  FEC,CC0
070B6:  MOVFF  FEC,CC1
070BA:  INCFSZ xBE,W
070BC:  BRA    7118
070BE:  INCFSZ xBF,W
070C0:  BRA    7118
070C2:  INCFSZ xC0,W
070C4:  BRA    7118
070C6:  MOVF   xC1,W
070C8:  SUBLW  7F
070CA:  BNZ   7118
....................             memcpy(&scheduled_commands[i], &cmd, sizeof(scheduled_command)); 
070CC:  CLRF   xC4
070CE:  MOVFF  CBB,CC3
070D2:  CLRF   xC6
070D4:  MOVLW  20
070D6:  MOVWF  xC5
070D8:  MOVLB  0
070DA:  CALL   4D06
070DE:  MOVFF  02,03
070E2:  MOVF   01,W
070E4:  ADDLW  5A
070E6:  MOVWF  01
070E8:  MOVLW  01
070EA:  ADDWFC 03,F
070EC:  MOVFF  01,CBC
070F0:  MOVLB  C
070F2:  MOVFF  03,CBD
070F6:  MOVFF  03,FEA
070FA:  MOVFF  01,FE9
070FE:  MOVLW  0C
07100:  MOVWF  FE2
07102:  MOVLW  9B
07104:  MOVWF  FE1
07106:  MOVLW  20
07108:  MOVWF  01
0710A:  MOVFF  FE6,FEE
0710E:  DECFSZ 01,F
07110:  BRA    710A
....................             return 0; 
07112:  MOVLW  00
07114:  MOVWF  01
07116:  BRA    7120
....................         } 
07118:  INCF   xBB,F
0711A:  BRA    707C
....................     } 
....................  
....................     return -1; // Error signaling 
0711C:  MOVLW  FF
0711E:  MOVWF  01
07120:  MOVLB  0
07122:  RETURN 0
.................... } 
....................  
.................... int scheduled_command_count() 
*
07830:  MOVLB  C
07832:  CLRF   x5A
.................... { 
....................     int count = 0; 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
07834:  CLRF   x5B
07836:  MOVF   x5B,W
07838:  SUBLW  1F
0783A:  BNC   788C
....................         if (scheduled_commands[i].time != TIME_T_MAX) { 
0783C:  CLRF   xC4
0783E:  MOVFF  C5B,CC3
07842:  CLRF   xC6
07844:  MOVLW  20
07846:  MOVWF  xC5
07848:  MOVLB  0
0784A:  CALL   4D06
0784E:  MOVFF  02,C5D
07852:  MOVFF  01,C5C
07856:  MOVLW  5A
07858:  MOVLB  C
0785A:  ADDWF  01,W
0785C:  MOVWF  FE9
0785E:  MOVLW  01
07860:  ADDWFC 02,W
07862:  MOVWF  FEA
07864:  MOVFF  FEF,C5E
07868:  MOVFF  FEC,C5F
0786C:  MOVFF  FEC,C60
07870:  MOVFF  FEC,C61
07874:  INCFSZ x5E,W
07876:  BRA    7886
07878:  INCFSZ x5F,W
0787A:  BRA    7886
0787C:  INCFSZ x60,W
0787E:  BRA    7886
07880:  MOVF   x61,W
07882:  SUBLW  7F
07884:  BZ    7888
....................             count++; 
07886:  INCF   x5A,F
....................         } 
07888:  INCF   x5B,F
0788A:  BRA    7836
....................     } 
....................     return count; 
0788C:  MOVFF  C5A,01
07890:  MOVLB  0
07892:  RETURN 0
.................... } 
....................  
.................... void scheduled_command_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
095CE:  MOVLB  C
095D0:  CLRF   x41
095D2:  MOVF   x41,W
095D4:  SUBLW  1F
095D6:  BNC   9606
....................         scheduled_commands[i].time = TIME_T_MAX; 
095D8:  CLRF   xC4
095DA:  MOVFF  C41,CC3
095DE:  CLRF   xC6
095E0:  MOVLW  20
095E2:  MOVWF  xC5
095E4:  MOVLB  0
095E6:  CALL   4D06
095EA:  MOVLW  5A
095EC:  MOVLB  C
095EE:  ADDWF  01,W
095F0:  MOVWF  FE9
095F2:  MOVLW  01
095F4:  ADDWFC 02,W
095F6:  MOVWF  FEA
095F8:  SETF   FEF
095FA:  SETF   FEC
095FC:  SETF   FEC
095FE:  MOVLW  7F
09600:  MOVWF  FEC
09602:  INCF   x41,F
09604:  BRA    95D2
....................     } 
09606:  MOVLB  0
09608:  RETURN 0
.................... } 
....................  
.................... void scheduled_command_clear_specified_command(uint8_t source, uint8_t command) 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
07E00:  MOVLB  C
07E02:  CLRF   xC0
07E04:  MOVF   xC0,W
07E06:  SUBLW  1F
07E08:  BNC   7EB0
....................         if (scheduled_commands[i].command[0] == source && scheduled_commands[i].command[1] == command) { 
07E0A:  CLRF   xC4
07E0C:  MOVFF  CC0,CC3
07E10:  CLRF   xC6
07E12:  MOVLW  20
07E14:  MOVWF  xC5
07E16:  MOVLB  0
07E18:  CALL   4D06
07E1C:  MOVFF  02,CC2
07E20:  MOVFF  01,CC1
07E24:  MOVLW  04
07E26:  MOVLB  C
07E28:  ADDWF  xC1,F
07E2A:  MOVLW  00
07E2C:  ADDWFC xC2,F
07E2E:  MOVLW  5A
07E30:  ADDWF  xC1,W
07E32:  MOVWF  FE9
07E34:  MOVLW  01
07E36:  ADDWFC xC2,W
07E38:  MOVWF  FEA
07E3A:  MOVF   xBE,W
07E3C:  SUBWF  FEF,W
07E3E:  BNZ   7EAC
07E40:  CLRF   xC4
07E42:  MOVFF  CC0,CC3
07E46:  CLRF   xC6
07E48:  MOVLW  20
07E4A:  MOVWF  xC5
07E4C:  MOVLB  0
07E4E:  CALL   4D06
07E52:  MOVFF  02,CC4
07E56:  MOVFF  01,CC3
07E5A:  MOVLW  04
07E5C:  MOVLB  C
07E5E:  ADDWF  xC3,F
07E60:  MOVLW  00
07E62:  ADDWFC xC4,F
07E64:  MOVLW  01
07E66:  ADDWF  xC3,W
07E68:  MOVWF  01
07E6A:  MOVLW  00
07E6C:  ADDWFC xC4,W
07E6E:  MOVWF  03
07E70:  MOVF   01,W
07E72:  ADDLW  5A
07E74:  MOVWF  FE9
07E76:  MOVLW  01
07E78:  ADDWFC 03,W
07E7A:  MOVWF  FEA
07E7C:  MOVF   xBF,W
07E7E:  SUBWF  FEF,W
07E80:  BNZ   7EAC
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
07E82:  CLRF   xC4
07E84:  MOVFF  CC0,CC3
07E88:  CLRF   xC6
07E8A:  MOVLW  20
07E8C:  MOVWF  xC5
07E8E:  MOVLB  0
07E90:  CALL   4D06
07E94:  MOVLW  5A
07E96:  MOVLB  C
07E98:  ADDWF  01,W
07E9A:  MOVWF  FE9
07E9C:  MOVLW  01
07E9E:  ADDWFC 02,W
07EA0:  MOVWF  FEA
07EA2:  SETF   FEF
07EA4:  SETF   FEC
07EA6:  SETF   FEC
07EA8:  MOVLW  7F
07EAA:  MOVWF  FEC
....................         } 
07EAC:  INCF   xC0,F
07EAE:  BRA    7E04
....................     } 
07EB0:  MOVLB  0
07EB2:  RETURN 0
.................... } 
....................  
.................... void scheduled_command_check() 
.................... { 
....................     // time_t current_time = time(0); 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
1973E:  MOVLB  B
19740:  CLRF   xD2
19742:  MOVF   xD2,W
19744:  SUBLW  1F
19746:  BTFSS  FD8.0
19748:  BRA    19832
....................         if (current_time >= scheduled_commands[i].time) { 
1974A:  MOVLB  C
1974C:  CLRF   xC4
1974E:  MOVFF  BD2,CC3
19752:  CLRF   xC6
19754:  MOVLW  20
19756:  MOVWF  xC5
19758:  MOVLB  0
1975A:  CALL   4D06
1975E:  MOVFF  02,BD4
19762:  MOVFF  01,BD3
19766:  MOVLW  5A
19768:  MOVLB  B
1976A:  ADDWF  01,W
1976C:  MOVWF  FE9
1976E:  MOVLW  01
19770:  ADDWFC 02,W
19772:  MOVWF  FEA
19774:  MOVFF  FEF,00
19778:  MOVFF  FEC,01
1977C:  MOVFF  FEC,02
19780:  MOVFF  FEC,03
19784:  BTFSS  03.7
19786:  BRA    1978E
19788:  BTFSS  3E.7
1978A:  BRA    197B0
1978C:  BRA    19792
1978E:  BTFSC  3E.7
19790:  BRA    1982E
19792:  MOVF   03,W
19794:  SUBWF  3E,W
19796:  BNC   1982E
19798:  BNZ   197B0
1979A:  MOVF   02,W
1979C:  SUBWF  3D,W
1979E:  BNC   1982E
197A0:  BNZ   197B0
197A2:  MOVF   01,W
197A4:  SUBWF  3C,W
197A6:  BNC   1982E
197A8:  BNZ   197B0
197AA:  MOVF   00,W
197AC:  SUBWF  3B,W
197AE:  BNC   1982E
....................             command_execute(scheduled_commands[i].command, MSG_COMM, 1); // scheduled commands can only be COMM commands 
197B0:  MOVLB  C
197B2:  CLRF   xC4
197B4:  MOVFF  BD2,CC3
197B8:  CLRF   xC6
197BA:  MOVLW  20
197BC:  MOVWF  xC5
197BE:  MOVLB  0
197C0:  CALL   4D06
197C4:  MOVFF  01,BD3
197C8:  MOVLW  04
197CA:  MOVLB  B
197CC:  ADDWF  01,W
197CE:  MOVWF  01
197D0:  MOVLW  00
197D2:  ADDWFC 02,W
197D4:  MOVWF  03
197D6:  MOVF   01,W
197D8:  ADDLW  5A
197DA:  MOVWF  01
197DC:  MOVLW  01
197DE:  ADDWFC 03,F
197E0:  MOVFF  01,BD3
197E4:  MOVFF  03,BD4
197E8:  MOVFF  03,C27
197EC:  MOVFF  01,C26
197F0:  MOVLW  C0
197F2:  MOVLB  C
197F4:  MOVWF  x28
197F6:  MOVLW  01
197F8:  MOVWF  x29
197FA:  MOVLB  0
197FC:  CALL   17C34
....................             scheduled_commands[i].time = TIME_T_MAX;                     // Disable the command from executing again (== reschedule it at infinity). 
19800:  MOVLB  C
19802:  CLRF   xC4
19804:  MOVFF  BD2,CC3
19808:  CLRF   xC6
1980A:  MOVLW  20
1980C:  MOVWF  xC5
1980E:  MOVLB  0
19810:  CALL   4D06
19814:  MOVLW  5A
19816:  MOVLB  B
19818:  ADDWF  01,W
1981A:  MOVWF  FE9
1981C:  MOVLW  01
1981E:  ADDWFC 02,W
19820:  MOVWF  FEA
19822:  SETF   FEF
19824:  SETF   FEC
19826:  SETF   FEC
19828:  MOVLW  7F
1982A:  MOVWF  FEC
....................             i = 0; // Check the whole table again for changes 
1982C:  CLRF   xD2
....................         } 
1982E:  INCF   xD2,F
19830:  BRA    19742
....................     } 
19832:  MOVLB  0
19834:  GOTO   1AD28 (RETURN)
.................... } 
....................  
.................... #ifndef PC_SIM 
.................... #define ZERO (0, 0) 
.................... #else 
.................... #define ZERO (0) 
.................... #endif 
....................  
.................... // Schedule a constant 
.................... #define schedule(time, ...)               \ 
....................     do {                                  \ 
....................         uint8_t cmd[] = __VA_ARGS__;      \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Schedule a variable 
.................... #define vschedule(time, cmd)              \ 
....................     do {                                  \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Execute a command immediately 
.................... #define execute(log, ...)                        \ 
....................     do {                                         \ 
....................         uint8_t cmd[] = __VA_ARGS__;             \ 
....................         command_execute(cmd, MSG_WILDCARD, log); \ 
....................     } while ZERO 
....................  
.................... #define periodic_command_clear_rx_flag(period, delta) \ 
....................     do {                                              \ 
....................         if ((current_time % period == delta)) {       \ 
....................             response_rx = 0;                          \ 
....................         }                                             \ 
....................     } while ZERO 
....................  
.................... #define periodic_command(period, delta, log, ...) \ 
....................     do {                                          \ 
....................         if ((current_time % period == delta)) {   \ 
....................             if (!response_rx)                     \ 
....................                 execute(log, __VA_ARGS__);        \ 
....................         }                                         \ 
....................     } while ZERO 
....................  
.................... #endif /* SCHEDULER_H */ 
....................  
....................  
.................... void boot_commands_write() 
*
06602:  MOVLW  07
06604:  MOVLB  C
06606:  MOVWF  x5F
06608:  MOVLW  58
0660A:  MOVFF  C5F,C5D
0660E:  MOVWF  x5C
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_erase_pages(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, BOOT_COMMANDS_ADDR + sizeof(boot_commands)); 
06610:  MOVLW  0A
06612:  MOVWF  x67
06614:  MOVLW  AD
06616:  MOVWF  x66
06618:  CLRF   x6B
0661A:  CLRF   x6A
0661C:  CLRF   x69
0661E:  CLRF   x68
06620:  CLRF   x6F
06622:  CLRF   x6E
06624:  MOVLW  01
06626:  MOVWF  x6D
06628:  CLRF   x6C
0662A:  MOVLB  0
0662C:  RCALL  6292
....................     flash_transfer_data_from_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
0662E:  MOVLW  0A
06630:  MOVLB  D
06632:  MOVWF  x47
06634:  MOVLW  AD
06636:  MOVWF  x46
06638:  CLRF   x4B
0663A:  CLRF   x4A
0663C:  CLRF   x49
0663E:  CLRF   x48
06640:  MOVFF  C5D,D4D
06644:  MOVFF  C5C,D4C
06648:  CLRF   x51
0664A:  CLRF   x50
0664C:  MOVLW  01
0664E:  MOVWF  x4F
06650:  CLRF   x4E
06652:  MOVLB  0
06654:  RCALL  653E
06656:  RETURN 0
.................... } 
....................  
.................... void boot_commands_read() 
*
06D82:  MOVLW  07
06D84:  MOVLB  B
06D86:  MOVWF  xE9
06D88:  MOVLW  58
06D8A:  MOVFF  BE9,BE7
06D8E:  MOVWF  xE6
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_transfer_data_to_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
06D90:  MOVLW  0A
06D92:  MOVLB  D
06D94:  MOVWF  x4C
06D96:  MOVLW  AD
06D98:  MOVWF  x4B
06D9A:  CLRF   x50
06D9C:  CLRF   x4F
06D9E:  CLRF   x4E
06DA0:  CLRF   x4D
06DA2:  MOVFF  BE7,D52
06DA6:  MOVFF  BE6,D51
06DAA:  CLRF   x56
06DAC:  CLRF   x55
06DAE:  MOVLW  01
06DB0:  MOVWF  x54
06DB2:  CLRF   x53
06DB4:  MOVLB  0
06DB6:  CALL   57C8
06DBA:  GOTO   700A (RETURN)
.................... } 
....................  
.................... void boot_commands_clear_nth(uint8_t n) 
.................... { 
....................     if (n < BOOT_COMMANDS_MAX) 
*
065BA:  MOVLB  C
065BC:  MOVF   x3D,W
065BE:  SUBLW  07
065C0:  BNC   65E2
....................         boot_commands[n].time = TIME_T_MAX; 
065C2:  MOVF   x3D,W
065C4:  MULLW  20
065C6:  MOVF   FF3,W
065C8:  CLRF   x3F
065CA:  MOVWF  x3E
065CC:  MOVLW  58
065CE:  ADDWF  x3E,W
065D0:  MOVWF  FE9
065D2:  MOVLW  07
065D4:  ADDWFC x3F,W
065D6:  MOVWF  FEA
065D8:  SETF   FEF
065DA:  SETF   FEC
065DC:  SETF   FEC
065DE:  MOVLW  7F
065E0:  MOVWF  FEC
065E2:  MOVLB  0
065E4:  RETURN 0
.................... } 
....................  
.................... void boot_commands_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
065E6:  MOVLB  C
065E8:  CLRF   x3A
065EA:  MOVF   x3A,W
065EC:  SUBLW  07
065EE:  BNC   65FE
....................         boot_commands_clear_nth(i); 
065F0:  MOVFF  C3A,C3D
065F4:  MOVLB  0
065F6:  RCALL  65BA
065F8:  MOVLB  C
065FA:  INCF   x3A,F
065FC:  BRA    65EA
....................     } 
065FE:  MOVLB  0
06600:  RETURN 0
.................... } 
....................  
.................... uint8_t boot_commands_add(boot_command bc) 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
*
0C12C:  MOVLB  C
0C12E:  CLRF   x7C
0C130:  MOVF   x7C,W
0C132:  SUBLW  07
0C134:  BNC   C1AC
....................         if (boot_commands[i].time == TIME_T_MAX) { 
0C136:  MOVF   x7C,W
0C138:  MULLW  20
0C13A:  MOVF   FF3,W
0C13C:  CLRF   x7E
0C13E:  MOVWF  x7D
0C140:  MOVLW  58
0C142:  ADDWF  x7D,W
0C144:  MOVWF  FE9
0C146:  MOVLW  07
0C148:  ADDWFC x7E,W
0C14A:  MOVWF  FEA
0C14C:  MOVFF  FEF,C7F
0C150:  MOVFF  FEC,C80
0C154:  MOVFF  FEC,C81
0C158:  MOVFF  FEC,C82
0C15C:  INCFSZ x7F,W
0C15E:  BRA    C1A8
0C160:  INCFSZ x80,W
0C162:  BRA    C1A8
0C164:  INCFSZ x81,W
0C166:  BRA    C1A8
0C168:  MOVF   x82,W
0C16A:  SUBLW  7F
0C16C:  BNZ   C1A8
....................             memcpy(&boot_commands[i], &bc, sizeof(boot_command)); 
0C16E:  MOVF   x7C,W
0C170:  MULLW  20
0C172:  MOVF   FF3,W
0C174:  CLRF   03
0C176:  ADDLW  58
0C178:  MOVWF  01
0C17A:  MOVLW  07
0C17C:  ADDWFC 03,F
0C17E:  MOVFF  01,C7D
0C182:  MOVFF  03,C7E
0C186:  MOVFF  03,FEA
0C18A:  MOVFF  01,FE9
0C18E:  MOVLW  0C
0C190:  MOVWF  FE2
0C192:  MOVLW  5C
0C194:  MOVWF  FE1
0C196:  MOVLW  20
0C198:  MOVWF  01
0C19A:  MOVFF  FE6,FEE
0C19E:  DECFSZ 01,F
0C1A0:  BRA    C19A
....................             return i; 
0C1A2:  MOVFF  C7C,01
0C1A6:  BRA    C1B0
....................         } 
0C1A8:  INCF   x7C,F
0C1AA:  BRA    C130
....................     } 
....................     return -1; 
0C1AC:  MOVLW  FF
0C1AE:  MOVWF  01
0C1B0:  MOVLB  0
0C1B2:  GOTO   C28E (RETURN)
.................... } 
....................  
.................... void boot_commands_schedule() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
*
08694:  MOVLB  C
08696:  CLRF   x4F
08698:  MOVF   x4F,W
0869A:  SUBLW  07
0869C:  BTFSS  FD8.0
0869E:  BRA    879E
....................         if(boot_commands[i].time > 0 && boot_commands[i].time < TIME_T_MAX) 
086A0:  MOVF   x4F,W
086A2:  MULLW  20
086A4:  MOVF   FF3,W
086A6:  CLRF   x51
086A8:  MOVWF  x50
086AA:  MOVLW  58
086AC:  ADDWF  x50,W
086AE:  MOVWF  FE9
086B0:  MOVLW  07
086B2:  ADDWFC x51,W
086B4:  MOVWF  FEA
086B6:  MOVFF  FEF,C52
086BA:  MOVFF  FEC,C53
086BE:  MOVFF  FEC,C54
086C2:  MOVFF  FEC,C55
086C6:  BTFSC  x55.7
086C8:  BRA    879A
086CA:  MOVF   x55,F
086CC:  BNZ   86DC
086CE:  MOVF   x54,F
086D0:  BNZ   86DC
086D2:  MOVF   x53,F
086D4:  BNZ   86DC
086D6:  MOVF   x52,W
086D8:  SUBLW  00
086DA:  BC    879A
086DC:  MOVF   x4F,W
086DE:  MULLW  20
086E0:  MOVF   FF3,W
086E2:  CLRF   x53
086E4:  MOVWF  x52
086E6:  MOVLW  58
086E8:  ADDWF  x52,W
086EA:  MOVWF  FE9
086EC:  MOVLW  07
086EE:  ADDWFC x53,W
086F0:  MOVWF  FEA
086F2:  MOVFF  FEF,C54
086F6:  MOVFF  FEC,C55
086FA:  MOVFF  FEC,C56
086FE:  MOVFF  FEC,C57
08702:  INCFSZ x54,W
08704:  BRA    8714
08706:  INCFSZ x55,W
08708:  BRA    8714
0870A:  INCFSZ x56,W
0870C:  BRA    8714
0870E:  MOVF   x57,W
08710:  SUBLW  7F
08712:  BZ    879A
....................             vschedule(current_time + boot_commands[i].time, boot_commands[i].command); 
08714:  MOVF   x4F,W
08716:  MULLW  20
08718:  MOVF   FF3,W
0871A:  CLRF   x51
0871C:  MOVWF  x50
0871E:  MOVLW  58
08720:  ADDWF  x50,W
08722:  MOVWF  FE9
08724:  MOVLW  07
08726:  ADDWFC x51,W
08728:  MOVWF  FEA
0872A:  MOVFF  FEF,00
0872E:  MOVFF  FEC,01
08732:  MOVFF  FEC,02
08736:  MOVFF  FEC,03
0873A:  MOVF   00,W
0873C:  ADDWF  3B,W
0873E:  MOVWF  x52
08740:  MOVF   01,W
08742:  ADDWFC 3C,W
08744:  MOVWF  x53
08746:  MOVF   02,W
08748:  ADDWFC 3D,W
0874A:  MOVWF  x54
0874C:  MOVF   03,W
0874E:  ADDWFC 3E,W
08750:  MOVWF  x55
08752:  MOVF   x4F,W
08754:  MULLW  20
08756:  MOVF   FF3,W
08758:  CLRF   x57
0875A:  MOVWF  x56
0875C:  MOVLW  04
0875E:  ADDWF  x56,W
08760:  MOVWF  01
08762:  MOVLW  00
08764:  ADDWFC x57,W
08766:  MOVWF  03
08768:  MOVF   01,W
0876A:  ADDLW  58
0876C:  MOVWF  01
0876E:  MOVLW  07
08770:  ADDWFC 03,F
08772:  MOVFF  01,C56
08776:  MOVFF  03,C57
0877A:  MOVFF  C55,C98
0877E:  MOVFF  C54,C97
08782:  MOVFF  C53,C96
08786:  MOVFF  C52,C95
0878A:  MOVFF  03,C9A
0878E:  MOVFF  01,C99
08792:  MOVLB  0
08794:  CALL   704C
08798:  MOVLB  C
0879A:  INCF   x4F,F
0879C:  BRA    8698
....................     } 
0879E:  MOVLB  0
087A0:  GOTO   8A8A (RETURN)
.................... } 
....................  
.................... #endif /* BOOT_COMMAND_H */ 
....................  
.................... #include <interpreter.h> 
.................... #ifndef INTERPRETER_H 
.................... #define INTERPRETER_H 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include <scheduler.h> 
.................... #ifndef SCHEDULER_H 
.................... #define SCHEDULER_H 
....................  
.................... #include <string.h> 
.................... #include <definitions.h> 
....................  
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled); 
....................  
.................... void scheduler_initialize() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... int scheduled_command_add(time_t time, uint8_t* command) 
.................... { 
....................     scheduled_command cmd; 
....................     cmd.time = time; 
....................     memcpy(cmd.command, command, BUFF_LENGTH); 
....................  
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&scheduled_commands[i], &cmd, sizeof(scheduled_command)); 
....................             return 0; 
....................         } 
....................     } 
....................  
....................     return -1; // Error signaling 
.................... } 
....................  
.................... int scheduled_command_count() 
.................... { 
....................     int count = 0; 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time != TIME_T_MAX) { 
....................             count++; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
.................... void scheduled_command_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... void scheduled_command_clear_specified_command(uint8_t source, uint8_t command) 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].command[0] == source && scheduled_commands[i].command[1] == command) { 
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
....................         } 
....................     } 
.................... } 
....................  
.................... void scheduled_command_check() 
.................... { 
....................     // time_t current_time = time(0); 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (current_time >= scheduled_commands[i].time) { 
....................             command_execute(scheduled_commands[i].command, MSG_COMM, 1); // scheduled commands can only be COMM commands 
....................             scheduled_commands[i].time = TIME_T_MAX;                     // Disable the command from executing again (== reschedule it at infinity). 
....................             i = 0; // Check the whole table again for changes 
....................         } 
....................     } 
.................... } 
....................  
.................... #ifndef PC_SIM 
.................... #define ZERO (0, 0) 
.................... #else 
.................... #define ZERO (0) 
.................... #endif 
....................  
.................... // Schedule a constant 
.................... #define schedule(time, ...)               \ 
....................     do {                                  \ 
....................         uint8_t cmd[] = __VA_ARGS__;      \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Schedule a variable 
.................... #define vschedule(time, cmd)              \ 
....................     do {                                  \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Execute a command immediately 
.................... #define execute(log, ...)                        \ 
....................     do {                                         \ 
....................         uint8_t cmd[] = __VA_ARGS__;             \ 
....................         command_execute(cmd, MSG_WILDCARD, log); \ 
....................     } while ZERO 
....................  
.................... #define periodic_command_clear_rx_flag(period, delta) \ 
....................     do {                                              \ 
....................         if ((current_time % period == delta)) {       \ 
....................             response_rx = 0;                          \ 
....................         }                                             \ 
....................     } while ZERO 
....................  
.................... #define periodic_command(period, delta, log, ...) \ 
....................     do {                                          \ 
....................         if ((current_time % period == delta)) {   \ 
....................             if (!response_rx)                     \ 
....................                 execute(log, __VA_ARGS__);        \ 
....................         }                                         \ 
....................     } while ZERO 
....................  
.................... #endif /* SCHEDULER_H */ 
....................  
.................... #include <crc16.h> 
.................... #ifndef CRC16_H 
.................... #define CRC16_H 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // CRC calculation function 
.................... uint16_t mk_crc(uint8_t* data, uint8_t size) 
*
0C868:  MOVLB  C
0C86A:  CLRF   x6C
0C86C:  CLRF   x6B
0C86E:  SETF   x6A
0C870:  SETF   x69
0C872:  CLRF   x70
0C874:  CLRF   x6F
0C876:  MOVLW  84
0C878:  MOVWF  x6E
0C87A:  MOVLW  08
0C87C:  MOVWF  x6D
.................... { 
....................     uint32_t crcreg = 0xffff; 
....................     uint32_t calc = 0x8408; 
....................     for (uint32_t k = 0; k < size; k++) { 
0C87E:  CLRF   x74
0C880:  CLRF   x73
0C882:  CLRF   x72
0C884:  CLRF   x71
0C886:  MOVF   x74,F
0C888:  BNZ   C914
0C88A:  MOVF   x73,F
0C88C:  BNZ   C914
0C88E:  MOVF   x72,F
0C890:  BNZ   C914
0C892:  MOVF   x68,W
0C894:  SUBWF  x71,W
0C896:  BC    C914
....................         uint8_t cal_data = data[k]; 
0C898:  MOVF   x66,W
0C89A:  ADDWF  x71,W
0C89C:  MOVWF  FE9
0C89E:  MOVF   x67,W
0C8A0:  ADDWFC x72,W
0C8A2:  MOVWF  FEA
0C8A4:  MOVFF  FEF,C75
....................         for (uint32_t i = 0; i < 8; i++) { 
0C8A8:  CLRF   x79
0C8AA:  CLRF   x78
0C8AC:  CLRF   x77
0C8AE:  CLRF   x76
0C8B0:  MOVF   x79,F
0C8B2:  BNZ   C902
0C8B4:  MOVF   x78,F
0C8B6:  BNZ   C902
0C8B8:  MOVF   x77,F
0C8BA:  BNZ   C902
0C8BC:  MOVF   x76,W
0C8BE:  SUBLW  07
0C8C0:  BNC   C902
....................             uint8_t w = (crcreg ^ cal_data) & 0x0001; 
0C8C2:  MOVF   x69,W
0C8C4:  XORWF  x75,W
0C8C6:  MOVWF  x7B
0C8C8:  MOVF   x7B,W
0C8CA:  ANDLW  01
0C8CC:  MOVWF  x7A
....................             crcreg = crcreg >> 1; 
0C8CE:  BCF    FD8.0
0C8D0:  RRCF   x6C,F
0C8D2:  RRCF   x6B,F
0C8D4:  RRCF   x6A,F
0C8D6:  RRCF   x69,F
....................             if (w == 1) { 
0C8D8:  DECFSZ x7A,W
0C8DA:  BRA    C8EC
....................                 crcreg = crcreg ^ calc; 
0C8DC:  MOVF   x6D,W
0C8DE:  XORWF  x69,F
0C8E0:  MOVF   x6E,W
0C8E2:  XORWF  x6A,F
0C8E4:  MOVF   x6F,W
0C8E6:  XORWF  x6B,F
0C8E8:  MOVF   x70,W
0C8EA:  XORWF  x6C,F
....................             } 
....................             cal_data = cal_data >> 1; 
0C8EC:  BCF    FD8.0
0C8EE:  RRCF   x75,F
0C8F0:  MOVLW  01
0C8F2:  ADDWF  x76,F
0C8F4:  BTFSC  FD8.0
0C8F6:  INCF   x77,F
0C8F8:  BTFSC  FD8.2
0C8FA:  INCF   x78,F
0C8FC:  BTFSC  FD8.2
0C8FE:  INCF   x79,F
0C900:  BRA    C8B0
....................         } 
0C902:  MOVLW  01
0C904:  ADDWF  x71,F
0C906:  BTFSC  FD8.0
0C908:  INCF   x72,F
0C90A:  BTFSC  FD8.2
0C90C:  INCF   x73,F
0C90E:  BTFSC  FD8.2
0C910:  INCF   x74,F
0C912:  BRA    C886
....................     } 
....................     crcreg = crcreg ^ 0xffff; 
0C914:  MOVLW  FF
0C916:  XORWF  x69,F
0C918:  XORWF  x6A,F
....................     return crcreg; 
0C91A:  MOVFF  C69,01
0C91E:  MOVFF  C6A,02
0C922:  MOVLB  0
0C924:  RETURN 0
.................... } 
....................  
.................... #endif /* CRC16_H */ 
....................  
.................... #include <libuart_fn.h> 
.................... #ifndef LIBUART_FN_H 
.................... #define LIBUART_FN_H 
....................  
.................... #include "definitions.h" 
....................  
.................... void uart_print_pc_hex(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size - 1; i++) { 
....................         fprintf(PC, "%02X ", data[i]); 
....................     } 
....................     fprintf(PC, "%02X", data[size - 1]); 
.................... } 
....................  
.................... void uart_print_pc_hex_short(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size; i++) { 
....................         fprintf(PC, "%02X", data[i]); 
....................     } 
.................... } 
....................  
.................... void uart_download_packet(uart_fn* port, uint8_t* buffer, uint32_t size, uint32_t timeout) 
.................... { 
....................     uint8_t n = 0; 
....................     for (uint32_t i = 0; i < timeout; i++) { 
....................         if (port->bytes_available()) { 
....................             buffer[n++] = port->get_char(); 
....................             if (n >= size) 
....................                 break; 
....................         } 
....................     } 
.................... } 
....................  
.................... // Send packet macro; buffer is of type uint8_t*; 
.................... void uart_send_packet(uart_fn* port, uint8_t* buffer, uint32_t size) 
.................... { 
....................     for (uint8_t* i = buffer; i < size + buffer; i++) { 
....................         port->put_char(*i); 
....................     } 
.................... } 
....................  
.................... void uart_send_packet_repeat(uart_fn* port, uint8_t* buffer, uint32_t size, uint8_t repetitions, uint32_t delay) 
.................... { 
....................     for(uint8_t i=0; i<repetitions; i++){ 
....................         uart_send_packet(port, buffer, size); 
....................         delay_ms(delay); 
....................     } 
.................... } 
....................  
.................... #endif // !LIBUART_FN_H 
....................  
.................... #include <flash_memory.h> 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <xmodem.h> 
.................... #ifndef XMODEM_H 
.................... #define XMODEM_H 
....................  
.................... // Based on: 
.................... // https://web.mit.edu/6.115/www/amulet/xmodem.htm 
.................... // https://pythonhosted.org/xmodem/xmodem.html#data-flow-example-including-error-recovery 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include <flash_memory.h> 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include <libuart_fn.h> 
.................... #ifndef LIBUART_FN_H 
.................... #define LIBUART_FN_H 
....................  
.................... #include "definitions.h" 
....................  
.................... void uart_print_pc_hex(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size - 1; i++) { 
....................         fprintf(PC, "%02X ", data[i]); 
....................     } 
....................     fprintf(PC, "%02X", data[size - 1]); 
.................... } 
....................  
.................... void uart_print_pc_hex_short(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size; i++) { 
....................         fprintf(PC, "%02X", data[i]); 
....................     } 
.................... } 
....................  
.................... void uart_download_packet(uart_fn* port, uint8_t* buffer, uint32_t size, uint32_t timeout) 
.................... { 
....................     uint8_t n = 0; 
....................     for (uint32_t i = 0; i < timeout; i++) { 
....................         if (port->bytes_available()) { 
....................             buffer[n++] = port->get_char(); 
....................             if (n >= size) 
....................                 break; 
....................         } 
....................     } 
.................... } 
....................  
.................... // Send packet macro; buffer is of type uint8_t*; 
.................... void uart_send_packet(uart_fn* port, uint8_t* buffer, uint32_t size) 
.................... { 
....................     for (uint8_t* i = buffer; i < size + buffer; i++) { 
....................         port->put_char(*i); 
....................     } 
.................... } 
....................  
.................... void uart_send_packet_repeat(uart_fn* port, uint8_t* buffer, uint32_t size, uint8_t repetitions, uint32_t delay) 
.................... { 
....................     for(uint8_t i=0; i<repetitions; i++){ 
....................         uart_send_packet(port, buffer, size); 
....................         delay_ms(delay); 
....................     } 
.................... } 
....................  
.................... #endif // !LIBUART_FN_H 
....................  
....................  
.................... #define XMODEM_SOH 0x01                   // Start of Header 
.................... #define XMODEM_EOT 0x04                   // End of Transmission 
.................... #define XMODEM_ACK 0x06                   // Acknowledge 
.................... #define XMODEM_NAK 0x15                   // Not Acknowledge 
.................... #define XMODEM_DLENGTH 128                // Data length 
.................... #define XMODEM_PLENGTH XMODEM_DLENGTH + 4 // Packet length 
....................  
.................... typedef struct xmodem_packet { 
....................     uint8_t header; 
....................     uint8_t packet_no; 
....................     uint8_t packet_no_; 
....................     uint8_t packet_data[XMODEM_DLENGTH]; 
....................     uint8_t checksum; 
.................... } xmodem_packet; 
....................  
.................... uint8_t xmodem_calc_chksum(uint8_t* ptr, uint8_t count) 
*
0988A:  MOVLB  D
0988C:  CLRF   x54
.................... { 
....................     uint8_t result = 0; 
....................     for (uint8_t* i = ptr; i < ptr + count; i++) { 
0988E:  MOVFF  D52,D56
09892:  MOVFF  D51,D55
09896:  MOVF   x53,W
09898:  ADDWF  x51,W
0989A:  MOVWF  01
0989C:  MOVLW  00
0989E:  ADDWFC x52,W
098A0:  MOVWF  03
098A2:  MOVF   x56,W
098A4:  SUBWF  03,W
098A6:  BNC   98C8
098A8:  BNZ   98B0
098AA:  MOVF   01,W
098AC:  SUBWF  x55,W
098AE:  BC    98C8
....................         result += *i; 
098B0:  MOVFF  D56,03
098B4:  MOVFF  D55,FE9
098B8:  MOVFF  03,FEA
098BC:  MOVF   FEF,W
098BE:  ADDWF  x54,F
098C0:  INCF   x55,F
098C2:  BTFSC  FD8.2
098C4:  INCF   x56,F
098C6:  BRA    9896
....................     } 
....................     return result; 
098C8:  MOVFF  D54,01
098CC:  MOVLB  0
098CE:  RETURN 0
.................... } 
....................  
.................... void xmodem_create_packet(spi_fn* spi_port, uint32_t fm_address, uint32_t packet_no, uint8_t* packet_data) 
*
0A416:  MOVFF  D46,D48
0A41A:  MOVFF  D45,D47
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)packet_data; 
....................     packet->header = XMODEM_SOH; 
0A41E:  MOVLB  D
0A420:  MOVFF  D47,FE9
0A424:  MOVFF  D48,FEA
0A428:  MOVLW  01
0A42A:  MOVWF  FEF
....................     packet->packet_no = packet_no & 0xFF; 
0A42C:  ADDWF  x47,W
0A42E:  MOVWF  FE9
0A430:  MOVLW  00
0A432:  ADDWFC x48,W
0A434:  MOVWF  FEA
0A436:  MOVFF  D41,FEF
....................     packet->packet_no_ = 0xFF - packet->packet_no; 
0A43A:  MOVLW  02
0A43C:  ADDWF  x47,W
0A43E:  MOVWF  01
0A440:  MOVLW  00
0A442:  ADDWFC x48,W
0A444:  MOVWF  03
0A446:  MOVLW  01
0A448:  ADDWF  x47,W
0A44A:  MOVWF  FE9
0A44C:  MOVLW  00
0A44E:  ADDWFC x48,W
0A450:  MOVWF  FEA
0A452:  MOVF   FEF,W
0A454:  SUBLW  FF
0A456:  MOVFF  03,FEA
0A45A:  MOVFF  01,FE9
0A45E:  MOVWF  FEF
....................     flash_transfer_data_to_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
0A460:  MOVLW  03
0A462:  ADDWF  x47,W
0A464:  MOVWF  01
0A466:  MOVLW  00
0A468:  ADDWFC x48,W
0A46A:  MOVWF  03
0A46C:  MOVFF  01,D49
0A470:  MOVWF  x4A
0A472:  MOVFF  D3C,D4C
0A476:  MOVFF  D3B,D4B
0A47A:  MOVFF  D40,D50
0A47E:  MOVFF  D3F,D4F
0A482:  MOVFF  D3E,D4E
0A486:  MOVFF  D3D,D4D
0A48A:  MOVWF  x52
0A48C:  MOVFF  01,D51
0A490:  CLRF   x56
0A492:  CLRF   x55
0A494:  CLRF   x54
0A496:  MOVLW  80
0A498:  MOVWF  x53
0A49A:  MOVLB  0
0A49C:  CALL   57C8
....................     packet->checksum = xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH); 
0A4A0:  MOVLW  83
0A4A2:  MOVLB  D
0A4A4:  ADDWF  x47,W
0A4A6:  MOVWF  01
0A4A8:  MOVLW  00
0A4AA:  ADDWFC x48,W
0A4AC:  MOVWF  03
0A4AE:  MOVFF  01,D49
0A4B2:  MOVWF  x4A
0A4B4:  MOVLW  03
0A4B6:  ADDWF  x47,W
0A4B8:  MOVWF  01
0A4BA:  MOVLW  00
0A4BC:  ADDWFC x48,W
0A4BE:  MOVWF  03
0A4C0:  MOVFF  01,D4B
0A4C4:  MOVWF  x4C
0A4C6:  MOVWF  x52
0A4C8:  MOVFF  01,D51
0A4CC:  MOVLW  80
0A4CE:  MOVWF  x53
0A4D0:  MOVLB  0
0A4D2:  CALL   988A
0A4D6:  MOVFF  D4A,FEA
0A4DA:  MOVFF  D49,FE9
0A4DE:  MOVFF  01,FEF
0A4E2:  GOTO   A5FE (RETURN)
.................... } 
....................  
.................... int8_t xmodem_send(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address, uint16_t n_packets) 
0A4E6:  MOVLB  C
0A4E8:  CLRF   xB1
0A4EA:  MOVLW  01
0A4EC:  MOVWF  xB0
.................... { 
....................     const uint32_t timeout = 5000000; 
....................     uint16_t current_packet = 1; 
....................     uint8_t packet[XMODEM_PLENGTH]; 
....................     for (uint32_t t = 0; t < timeout; t++) { 
0A4EE:  MOVLB  D
0A4F0:  CLRF   x39
0A4F2:  CLRF   x38
0A4F4:  CLRF   x37
0A4F6:  CLRF   x36
0A4F8:  MOVF   x39,F
0A4FA:  BTFSS  FD8.2
0A4FC:  BRA    A636
0A4FE:  MOVF   x38,W
0A500:  SUBLW  4C
0A502:  BTFSS  FD8.0
0A504:  BRA    A636
0A506:  BNZ   A51A
0A508:  MOVF   x37,W
0A50A:  SUBLW  4B
0A50C:  BTFSS  FD8.0
0A50E:  BRA    A636
0A510:  BNZ   A51A
0A512:  MOVF   x36,W
0A514:  SUBLW  3F
0A516:  BTFSS  FD8.0
0A518:  BRA    A636
....................         if (uart_stream->bytes_available()) { 
0A51A:  MOVFF  CA6,01
0A51E:  MOVFF  CA7,03
0A522:  MOVFF  CA6,D3B
0A526:  MOVFF  CA7,D3C
0A52A:  MOVFF  CA7,FEA
0A52E:  MOVFF  CA6,FE9
0A532:  MOVLB  0
0A534:  CALL   03FC
0A538:  MOVF   01,F
0A53A:  BTFSC  FD8.2
0A53C:  BRA    A622
....................             uint8_t command = uart_stream->get_char(); 
0A53E:  MOVLW  04
0A540:  MOVLB  C
0A542:  ADDWF  xA6,W
0A544:  MOVWF  01
0A546:  MOVLW  00
0A548:  ADDWFC xA7,W
0A54A:  MOVWF  03
0A54C:  MOVFF  01,D3B
0A550:  MOVLB  D
0A552:  MOVWF  x3C
0A554:  MOVWF  FEA
0A556:  MOVFF  01,FE9
0A55A:  MOVLB  0
0A55C:  CALL   03FC
0A560:  MOVFF  01,D3A
....................             t = 0; 
0A564:  MOVLB  D
0A566:  CLRF   x39
0A568:  CLRF   x38
0A56A:  CLRF   x37
0A56C:  CLRF   x36
....................             switch (command) { 
0A56E:  MOVF   x3A,W
0A570:  XORLW  06
0A572:  MOVLB  0
0A574:  BZ    A57C
0A576:  XORLW  13
0A578:  BZ    A5CC
0A57A:  BRA    A622
....................             case XMODEM_ACK: 
....................                 current_packet++; 
0A57C:  MOVLB  C
0A57E:  INCF   xB0,F
0A580:  BTFSC  FD8.2
0A582:  INCF   xB1,F
....................                 fm_address += XMODEM_DLENGTH; 
0A584:  MOVLW  80
0A586:  ADDWF  xAA,F
0A588:  MOVLW  00
0A58A:  ADDWFC xAB,F
0A58C:  ADDWFC xAC,F
0A58E:  ADDWFC xAD,F
....................                 if (current_packet > n_packets) { 
0A590:  MOVF   xAF,W
0A592:  SUBWF  xB1,W
0A594:  BNC   A5CA
0A596:  BNZ   A59E
0A598:  MOVF   xB0,W
0A59A:  SUBWF  xAE,W
0A59C:  BC    A5CA
....................                     uart_stream->put_char(XMODEM_EOT); 
0A59E:  MOVLW  08
0A5A0:  ADDWF  xA6,W
0A5A2:  MOVWF  01
0A5A4:  MOVLW  00
0A5A6:  ADDWFC xA7,W
0A5A8:  MOVWF  03
0A5AA:  MOVFF  01,D3B
0A5AE:  MOVLB  D
0A5B0:  MOVWF  x3C
0A5B2:  MOVWF  FEA
0A5B4:  MOVFF  01,FE9
0A5B8:  MOVLW  04
0A5BA:  MOVWF  x69
0A5BC:  MOVLB  0
0A5BE:  CALL   03FC
....................                     return 0; 
0A5C2:  MOVLW  00
0A5C4:  MOVWF  01
0A5C6:  BRA    A63C
0A5C8:  MOVLB  C
0A5CA:  MOVLB  0
....................                 } 
....................             case XMODEM_NAK: 
....................                 xmodem_create_packet(spi_port, fm_address, current_packet, packet); 
0A5CC:  MOVFF  CA9,D3C
0A5D0:  MOVFF  CA8,D3B
0A5D4:  MOVFF  CAD,D40
0A5D8:  MOVFF  CAC,D3F
0A5DC:  MOVFF  CAB,D3E
0A5E0:  MOVFF  CAA,D3D
0A5E4:  MOVLB  D
0A5E6:  CLRF   x44
0A5E8:  CLRF   x43
0A5EA:  MOVFF  CB1,D42
0A5EE:  MOVFF  CB0,D41
0A5F2:  MOVLW  0C
0A5F4:  MOVWF  x46
0A5F6:  MOVLW  B2
0A5F8:  MOVWF  x45
0A5FA:  MOVLB  0
0A5FC:  BRA    A416
....................                 uart_send_packet(uart_stream, packet, XMODEM_PLENGTH); 
0A5FE:  MOVFF  CA7,D3C
0A602:  MOVFF  CA6,D3B
0A606:  MOVLW  0C
0A608:  MOVLB  D
0A60A:  MOVWF  x3E
0A60C:  MOVLW  B2
0A60E:  MOVWF  x3D
0A610:  CLRF   x42
0A612:  CLRF   x41
0A614:  CLRF   x40
0A616:  MOVLW  84
0A618:  MOVWF  x3F
0A61A:  MOVLB  0
0A61C:  CALL   8EDE
....................                 break; 
0A620:  BRA    A622
....................             default: 
....................                 break; 
....................             } 
....................         } 
0A622:  MOVLW  01
0A624:  MOVLB  D
0A626:  ADDWF  x36,F
0A628:  BTFSC  FD8.0
0A62A:  INCF   x37,F
0A62C:  BTFSC  FD8.2
0A62E:  INCF   x38,F
0A630:  BTFSC  FD8.2
0A632:  INCF   x39,F
0A634:  BRA    A4F8
....................     } 
....................     return -1; 
0A636:  MOVLW  FF
0A638:  MOVWF  01
0A63A:  MOVLB  0
0A63C:  RETURN 0
.................... } 
....................  
.................... uint8_t xmodem_validate(uint8_t* buffer, uint16_t packet_no) 
*
098D0:  MOVFF  D45,D49
098D4:  MOVFF  D44,D48
098D8:  MOVLB  D
098DA:  MOVFF  D48,FE9
098DE:  MOVFF  D49,FEA
098E2:  DECFSZ FEF,W
098E4:  BRA    98E8
098E6:  BRA    98EC
098E8:  MOVLW  00
098EA:  BRA    98EE
098EC:  MOVLW  01
098EE:  MOVWF  x4A
098F0:  MOVLW  01
098F2:  ADDWF  x48,W
098F4:  MOVWF  FE9
098F6:  MOVLW  00
098F8:  ADDWFC x49,W
098FA:  MOVWF  FEA
098FC:  MOVFF  FEF,D4E
09900:  MOVFF  D46,00
09904:  CLRF   03
09906:  MOVF   x46,W
09908:  SUBWF  x4E,W
0990A:  BNZ   9910
0990C:  MOVF   03,F
0990E:  BZ    9914
09910:  MOVLW  00
09912:  BRA    9916
09914:  MOVLW  01
09916:  MOVWF  x4B
09918:  MOVLW  02
0991A:  ADDWF  x48,W
0991C:  MOVWF  FE9
0991E:  MOVLW  00
09920:  ADDWFC x49,W
09922:  MOVWF  FEA
09924:  MOVFF  FEF,D4E
09928:  CLRF   03
0992A:  MOVF   x46,W
0992C:  SUBLW  FF
0992E:  MOVWF  00
09930:  MOVLW  00
09932:  SUBFWB 03,F
09934:  MOVF   00,W
09936:  SUBWF  x4E,W
09938:  BNZ   993E
0993A:  MOVF   03,F
0993C:  BZ    9942
0993E:  MOVLW  00
09940:  BRA    9944
09942:  MOVLW  01
09944:  MOVWF  x4C
09946:  MOVLW  83
09948:  ADDWF  x48,W
0994A:  MOVWF  FE9
0994C:  MOVLW  00
0994E:  ADDWFC x49,W
09950:  MOVWF  FEA
09952:  MOVFF  FEF,D4E
09956:  MOVLW  03
09958:  ADDWF  x48,W
0995A:  MOVWF  01
0995C:  MOVLW  00
0995E:  ADDWFC x49,W
09960:  MOVWF  03
09962:  MOVFF  01,D4F
09966:  MOVWF  x50
09968:  MOVWF  x52
0996A:  MOVFF  01,D51
0996E:  MOVLW  80
09970:  MOVWF  x53
09972:  MOVLB  0
09974:  RCALL  988A
09976:  MOVF   01,W
09978:  MOVLB  D
0997A:  SUBWF  x4E,W
0997C:  BZ    9982
0997E:  MOVLW  00
09980:  BRA    9984
09982:  MOVLW  01
09984:  MOVWF  x4D
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uint8_t correct_header = (packet->header == XMODEM_SOH); 
....................     uint8_t correct_no = (packet->packet_no == (packet_no & 0xFF)); 
....................     uint8_t correct_no_ = (packet->packet_no_ == 0xFF - (packet_no & 0xFF)); 
....................     uint8_t correct_checksum = (packet->checksum == xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH)); 
....................     return correct_header && correct_no && correct_no_ && correct_checksum; 
09986:  MOVF   x4A,F
09988:  BZ    9996
0998A:  MOVF   x4B,F
0998C:  BZ    9996
0998E:  MOVF   x4C,F
09990:  BZ    9996
09992:  MOVF   x4D,F
09994:  BNZ   999A
09996:  MOVLW  00
09998:  BRA    999C
0999A:  MOVLW  01
0999C:  MOVWF  01
0999E:  MOVLB  0
099A0:  GOTO   9B82 (RETURN)
.................... } 
....................  
.................... int16_t xmodem_receive(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address) 
099A4:  MOVLB  C
099A6:  CLRF   xB5
099A8:  MOVLW  02
099AA:  MOVWF  xB4
099AC:  CLRF   xB7
099AE:  MOVLW  01
099B0:  MOVWF  xB6
099B2:  CLRF   xB9
099B4:  CLRF   xB8
*
09AC0:  MOVLW  0C
09AC2:  MOVWF  x45
09AC4:  MOVLW  BA
09AC6:  MOVFF  D45,D3F
09ACA:  MOVWF  x3E
.................... { 
....................     const uint32_t uart_timeout = 1000000; 
....................     uint16_t max_nak = 2; 
....................     uint16_t packet_no = 1; 
....................     uint16_t nak_count = 0; 
....................     uint8_t buffer[XMODEM_PLENGTH] = { 0 }; 
*
099B6:  CLRF   xBA
099B8:  CLRF   xBB
099BA:  CLRF   xBC
099BC:  CLRF   xBD
099BE:  CLRF   xBE
099C0:  CLRF   xBF
099C2:  CLRF   xC0
099C4:  CLRF   xC1
099C6:  CLRF   xC2
099C8:  CLRF   xC3
099CA:  CLRF   xC4
099CC:  CLRF   xC5
099CE:  CLRF   xC6
099D0:  CLRF   xC7
099D2:  CLRF   xC8
099D4:  CLRF   xC9
099D6:  CLRF   xCA
099D8:  CLRF   xCB
099DA:  CLRF   xCC
099DC:  CLRF   xCD
099DE:  CLRF   xCE
099E0:  CLRF   xCF
099E2:  CLRF   xD0
099E4:  CLRF   xD1
099E6:  CLRF   xD2
099E8:  CLRF   xD3
099EA:  CLRF   xD4
099EC:  CLRF   xD5
099EE:  CLRF   xD6
099F0:  CLRF   xD7
099F2:  CLRF   xD8
099F4:  CLRF   xD9
099F6:  CLRF   xDA
099F8:  CLRF   xDB
099FA:  CLRF   xDC
099FC:  CLRF   xDD
099FE:  CLRF   xDE
09A00:  CLRF   xDF
09A02:  CLRF   xE0
09A04:  CLRF   xE1
09A06:  CLRF   xE2
09A08:  CLRF   xE3
09A0A:  CLRF   xE4
09A0C:  CLRF   xE5
09A0E:  CLRF   xE6
09A10:  CLRF   xE7
09A12:  CLRF   xE8
09A14:  CLRF   xE9
09A16:  CLRF   xEA
09A18:  CLRF   xEB
09A1A:  CLRF   xEC
09A1C:  CLRF   xED
09A1E:  CLRF   xEE
09A20:  CLRF   xEF
09A22:  CLRF   xF0
09A24:  CLRF   xF1
09A26:  CLRF   xF2
09A28:  CLRF   xF3
09A2A:  CLRF   xF4
09A2C:  CLRF   xF5
09A2E:  CLRF   xF6
09A30:  CLRF   xF7
09A32:  CLRF   xF8
09A34:  CLRF   xF9
09A36:  CLRF   xFA
09A38:  CLRF   xFB
09A3A:  CLRF   xFC
09A3C:  CLRF   xFD
09A3E:  CLRF   xFE
09A40:  CLRF   xFF
09A42:  MOVLB  D
09A44:  CLRF   x00
09A46:  CLRF   x01
09A48:  CLRF   x02
09A4A:  CLRF   x03
09A4C:  CLRF   x04
09A4E:  CLRF   x05
09A50:  CLRF   x06
09A52:  CLRF   x07
09A54:  CLRF   x08
09A56:  CLRF   x09
09A58:  CLRF   x0A
09A5A:  CLRF   x0B
09A5C:  CLRF   x0C
09A5E:  CLRF   x0D
09A60:  CLRF   x0E
09A62:  CLRF   x0F
09A64:  CLRF   x10
09A66:  CLRF   x11
09A68:  CLRF   x12
09A6A:  CLRF   x13
09A6C:  CLRF   x14
09A6E:  CLRF   x15
09A70:  CLRF   x16
09A72:  CLRF   x17
09A74:  CLRF   x18
09A76:  CLRF   x19
09A78:  CLRF   x1A
09A7A:  CLRF   x1B
09A7C:  CLRF   x1C
09A7E:  CLRF   x1D
09A80:  CLRF   x1E
09A82:  CLRF   x1F
09A84:  CLRF   x20
09A86:  CLRF   x21
09A88:  CLRF   x22
09A8A:  CLRF   x23
09A8C:  CLRF   x24
09A8E:  CLRF   x25
09A90:  CLRF   x26
09A92:  CLRF   x27
09A94:  CLRF   x28
09A96:  CLRF   x29
09A98:  CLRF   x2A
09A9A:  CLRF   x2B
09A9C:  CLRF   x2C
09A9E:  CLRF   x2D
09AA0:  CLRF   x2E
09AA2:  CLRF   x2F
09AA4:  CLRF   x30
09AA6:  CLRF   x31
09AA8:  CLRF   x32
09AAA:  CLRF   x33
09AAC:  CLRF   x34
09AAE:  CLRF   x35
09AB0:  CLRF   x36
09AB2:  CLRF   x37
09AB4:  CLRF   x38
09AB6:  CLRF   x39
09AB8:  CLRF   x3A
09ABA:  CLRF   x3B
09ABC:  CLRF   x3C
09ABE:  CLRF   x3D
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uart_stream->put_char(XMODEM_NAK); // Request 1st packet 
*
09ACC:  MOVLW  08
09ACE:  MOVLB  C
09AD0:  ADDWF  xAC,W
09AD2:  MOVWF  01
09AD4:  MOVLW  00
09AD6:  ADDWFC xAD,W
09AD8:  MOVWF  03
09ADA:  MOVFF  01,D44
09ADE:  MOVLB  D
09AE0:  MOVWF  x45
09AE2:  MOVWF  FEA
09AE4:  MOVFF  01,FE9
09AE8:  MOVLW  15
09AEA:  MOVWF  x69
09AEC:  MOVLB  0
09AEE:  CALL   03FC
....................     while (nak_count < max_nak) { 
09AF2:  MOVLB  C
09AF4:  MOVF   xB9,W
09AF6:  SUBWF  xB5,W
09AF8:  BTFSS  FD8.0
09AFA:  BRA    9CCA
09AFC:  BNZ   9B06
09AFE:  MOVF   xB4,W
09B00:  SUBWF  xB8,W
09B02:  BTFSC  FD8.0
09B04:  BRA    9CCA
....................         uart_download_packet(uart_stream, buffer, XMODEM_PLENGTH, uart_timeout); 
09B06:  MOVFF  CAD,D45
09B0A:  MOVFF  CAC,D44
09B0E:  MOVLW  0C
09B10:  MOVLB  D
09B12:  MOVWF  x47
09B14:  MOVLW  BA
09B16:  MOVWF  x46
09B18:  CLRF   x4B
09B1A:  CLRF   x4A
09B1C:  CLRF   x49
09B1E:  MOVLW  84
09B20:  MOVWF  x48
09B22:  CLRF   x4F
09B24:  MOVLW  0F
09B26:  MOVWF  x4E
09B28:  MOVLW  42
09B2A:  MOVWF  x4D
09B2C:  MOVLW  40
09B2E:  MOVWF  x4C
09B30:  MOVLB  0
09B32:  RCALL  97CE
....................         if (buffer[0] == XMODEM_EOT) { 
09B34:  MOVLB  C
09B36:  MOVF   xBA,W
09B38:  SUBLW  04
09B3A:  BNZ   9B6C
....................             uart_stream->put_char(XMODEM_ACK); 
09B3C:  MOVLW  08
09B3E:  ADDWF  xAC,W
09B40:  MOVWF  01
09B42:  MOVLW  00
09B44:  ADDWFC xAD,W
09B46:  MOVWF  03
09B48:  MOVFF  01,D44
09B4C:  MOVLB  D
09B4E:  MOVWF  x45
09B50:  MOVWF  FEA
09B52:  MOVFF  01,FE9
09B56:  MOVLW  06
09B58:  MOVWF  x69
09B5A:  MOVLB  0
09B5C:  CALL   03FC
....................             return packet_no; 
09B60:  MOVLB  C
09B62:  MOVFF  CB6,01
09B66:  MOVFF  CB7,02
09B6A:  BRA    9CD0
....................         } 
....................         if (xmodem_validate(buffer, packet_no)) { 
09B6C:  MOVLW  0C
09B6E:  MOVLB  D
09B70:  MOVWF  x45
09B72:  MOVLW  BA
09B74:  MOVWF  x44
09B76:  MOVFF  CB7,D47
09B7A:  MOVFF  CB6,D46
09B7E:  MOVLB  0
09B80:  BRA    98D0
09B82:  MOVF   01,F
09B84:  BTFSC  FD8.2
09B86:  BRA    9C96
....................             // uart_send_packet(uart_stream, packet->packet_data, XMODEM_DLENGTH); // for debug 
....................             uint32_t remaining_addressess = (MEMORY_SECTOR_SIZE - (fm_address % MEMORY_SECTOR_SIZE)) % MEMORY_SECTOR_SIZE; 
09B88:  MOVLB  C
09B8A:  MOVFF  CB1,01
09B8E:  CLRF   02
09B90:  CLRF   03
09B92:  MOVLW  00
09B94:  BSF    FD8.0
09B96:  SUBFWB xB0,W
09B98:  MOVLB  D
09B9A:  MOVWF  x44
09B9C:  MOVLW  00
09B9E:  SUBFWB 01,W
09BA0:  MOVWF  x45
09BA2:  MOVLW  01
09BA4:  SUBFWB 02,W
09BA6:  MOVLW  00
09BA8:  SUBFWB 03,W
09BAA:  MOVFF  D44,D40
09BAE:  MOVFF  D45,D41
09BB2:  CLRF   x42
09BB4:  CLRF   x43
....................             if (remaining_addressess < XMODEM_DLENGTH) { 
09BB6:  MOVF   x43,F
09BB8:  BNZ   9C12
09BBA:  MOVF   x42,F
09BBC:  BNZ   9C12
09BBE:  MOVF   x41,F
09BC0:  BNZ   9C12
09BC2:  MOVF   x40,W
09BC4:  SUBLW  7F
09BC6:  BNC   9C12
....................                 flash_erase(spi_port, fm_address + remaining_addressess, ERASE_SECTOR); 
09BC8:  MOVF   x40,W
09BCA:  MOVLB  C
09BCC:  ADDWF  xB0,W
09BCE:  MOVLB  D
09BD0:  MOVWF  x44
09BD2:  MOVF   x41,W
09BD4:  MOVLB  C
09BD6:  ADDWFC xB1,W
09BD8:  MOVLB  D
09BDA:  MOVWF  x45
09BDC:  MOVF   x42,W
09BDE:  MOVLB  C
09BE0:  ADDWFC xB2,W
09BE2:  MOVLB  D
09BE4:  MOVWF  x46
09BE6:  MOVF   x43,W
09BE8:  MOVLB  C
09BEA:  ADDWFC xB3,W
09BEC:  MOVLB  D
09BEE:  MOVWF  x47
09BF0:  MOVFF  CAF,D49
09BF4:  MOVFF  CAE,D48
09BF8:  MOVWF  x4D
09BFA:  MOVFF  D46,D4C
09BFE:  MOVFF  D45,D4B
09C02:  MOVFF  D44,D4A
09C06:  MOVLW  DC
09C08:  MOVWF  x4E
09C0A:  MOVLB  0
09C0C:  CALL   604C
09C10:  MOVLB  D
....................             } 
....................             flash_transfer_data_from_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
09C12:  MOVLW  03
09C14:  ADDWF  x3E,W
09C16:  MOVWF  01
09C18:  MOVLW  00
09C1A:  ADDWFC x3F,W
09C1C:  MOVWF  03
09C1E:  MOVFF  01,D44
09C22:  MOVWF  x45
09C24:  MOVFF  CAF,D47
09C28:  MOVFF  CAE,D46
09C2C:  MOVFF  CB3,D4B
09C30:  MOVFF  CB2,D4A
09C34:  MOVFF  CB1,D49
09C38:  MOVFF  CB0,D48
09C3C:  MOVWF  x4D
09C3E:  MOVFF  01,D4C
09C42:  CLRF   x51
09C44:  CLRF   x50
09C46:  CLRF   x4F
09C48:  MOVLW  80
09C4A:  MOVWF  x4E
09C4C:  MOVLB  0
09C4E:  CALL   653E
....................             packet_no++; 
09C52:  MOVLB  C
09C54:  INCF   xB6,F
09C56:  BTFSC  FD8.2
09C58:  INCF   xB7,F
....................             fm_address += XMODEM_DLENGTH; 
09C5A:  MOVLW  80
09C5C:  ADDWF  xB0,F
09C5E:  MOVLW  00
09C60:  ADDWFC xB1,F
09C62:  ADDWFC xB2,F
09C64:  ADDWFC xB3,F
....................             nak_count = 0; 
09C66:  CLRF   xB9
09C68:  CLRF   xB8
....................             max_nak = 64; // Increase max number of nak once communication is established 
09C6A:  CLRF   xB5
09C6C:  MOVLW  40
09C6E:  MOVWF  xB4
....................             uart_stream->put_char(XMODEM_ACK); 
09C70:  MOVLW  08
09C72:  ADDWF  xAC,W
09C74:  MOVWF  01
09C76:  MOVLW  00
09C78:  ADDWFC xAD,W
09C7A:  MOVWF  03
09C7C:  MOVFF  01,D44
09C80:  MOVLB  D
09C82:  MOVWF  x45
09C84:  MOVWF  FEA
09C86:  MOVFF  01,FE9
09C8A:  MOVLW  06
09C8C:  MOVWF  x69
09C8E:  MOVLB  0
09C90:  CALL   03FC
....................         } else { 
09C94:  BRA    9CC6
....................             uart_stream->put_char(XMODEM_NAK); 
09C96:  MOVLW  08
09C98:  MOVLB  C
09C9A:  ADDWF  xAC,W
09C9C:  MOVWF  01
09C9E:  MOVLW  00
09CA0:  ADDWFC xAD,W
09CA2:  MOVWF  03
09CA4:  MOVFF  01,D44
09CA8:  MOVLB  D
09CAA:  MOVWF  x45
09CAC:  MOVWF  FEA
09CAE:  MOVFF  01,FE9
09CB2:  MOVLW  15
09CB4:  MOVWF  x69
09CB6:  MOVLB  0
09CB8:  CALL   03FC
....................             nak_count++; 
09CBC:  MOVLB  C
09CBE:  INCF   xB8,F
09CC0:  BTFSC  FD8.2
09CC2:  INCF   xB9,F
09CC4:  MOVLB  0
....................         } 
09CC6:  BRA    9AF2
09CC8:  MOVLB  C
....................     } 
....................     return -1; 
09CCA:  MOVLW  FF
09CCC:  MOVWF  01
09CCE:  MOVWF  02
09CD0:  MOVLB  0
09CD2:  RETURN 0
.................... } 
....................  
.................... #endif /* XMODEM_H */ 
....................  
.................... #include <log_control.h> 
.................... #ifndef LOG_CONTROL_H 
.................... #define LOG_CONTROL_H 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <definitions.h> 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include <device.h> 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... // These are used only for PC simulation: 
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(MSN); 
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x53 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x54 
.................... #endif // !FM 
....................  
.................... #define BUFF_LENGTH 28            // Must accomodate messages of all UART sources that may be scheduled | OPERA: 2 + 32 - sizeof(time_t) - sizeof(uint16_t) 
.................... #define MAX_LENGTH MSG_LENGTH_FAB // Maximum UART length 
.................... #define TERMINAL_COLS 80          // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64     // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // Reset PIC commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 64 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // // SEL ZES commands 
.................... // #define MSG_SEL_ZES 0x2A 
.................... // #define MSG_LENGTH_SEL_ZES 128 
.................... // #define MSG_CHECKSUM_SEL_ZES false 
....................  
.................... // // TMCR1 commands 
.................... #define MSG_TMCR1 0x1C 
.................... #define MSG_LENGTH_TMCR1 36 
.................... #define MSG_CHECKSUM_TMCR1 true 
....................  
.................... // TMCR2 commands 
.................... #define MSG_TMCR2 0x1D 
.................... #define MSG_LENGTH_TMCR2 36 
.................... #define MSG_CHECKSUM_TMCR2 true 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 44 // changed from 43 to 44 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... // OPERA commmands 
.................... #define MSG_OPERA 0xA1 
.................... #define MSG_LENGTH_OPERA 28 
.................... #define MSG_CHECKSUM_OPERA false 
....................  
.................... // MCPIC commands 
.................... #define MSG_MCPIC 0xCB 
.................... #define MSG_LENGTH_MCPIC 6 
.................... #define MSG_CHECKSUM_MCPIC true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time (30 min and 30 secs) 
.................... #define Tn 2147483646 // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t msn_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 2]; 
....................     uint8_t msn_time; 
....................     uint8_t msn_message[MSG_LENGTH_MCPIC - 4]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... typedef struct address_rotation { 
....................     uint32_t flash_log_current; 
....................     uint32_t flash_telemetry_current; 
....................     uint32_t flash_sel_zes_current; 
....................     uint32_t flash_sel_ref_current; 
.................... } address_rotation; 
....................  
.................... // =========================== MEMORY MAP ============================= 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA sizeof(address_rotation) // log, telemetry, SEL_ZES, SEL_REF -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... #define FLASH_CAMERA_START (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_CAMERA_END (1005 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_SEL_ZES_START (1005 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_END (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_ZES_DELTA 128 
....................  
.................... #define FLASH_SEL_REF_START (1133 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_END (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_SEL_REF_DELTA 128 
....................  
.................... #define FLASH_MAGNETOMETER_START (1261 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_MAGNETOMETER_END (1517 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_OPERA_START (1785 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_OPERA_END (2027 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_B4_START (2027 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_B4_END (2037 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_TMCR_N_START (2037 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TMCR_N_END (2048 * MEMORY_SECTOR_SIZE) 
.................... // ==================================================================== 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t MCP_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
....................     uint8_t opera_boot_duration;     // in seconds, check variable type when updating 
....................     uint8_t relay_on_off; 
....................     uint8_t camera_parameters[11]; // store parameters for camera capture command (0xC0CA) 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
....................     flash_ctrl flash_sel_zes; 
....................     flash_ctrl flash_sel_ref; 
.................... } aflags; 
....................  
.................... // Initialize the structures with values and add comments for clarity 
.................... bflags boot_flags = { 
....................     0xFF // deployment_flag 
.................... }; 
....................  
.................... oflags obc_flags = { 
....................     0,     // leap_seconds 
....................     1,     // adcs_on_off 
....................     1,     // MCP_on_off 
....................     0,     // gps_time_sync_state 
....................     0,     // adcs_initial_value 
....................     2,     // cw_mode 
....................     0xC3F, // heater_ref_temperature 
....................     0xC48, // heater_ref_voltage 
....................     120,   // opera_boot_duration 
....................     1,     // relay_on_off 
....................     { 0 }  // camera_parameters[15] 
.................... }; 
....................  
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "boot_flag = %02X\r\n", boot_flags.deployment_flag);                     // uint8_t 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds);                        // int8_t 
....................     fprintf(PC, "adcs_on_off = %u\r\n", obc_flags.adcs_on_off);                          // uint8_t 
....................     fprintf(PC, "MCP_on_off = %u\r\n", obc_flags.MCP_on_off);                            // uint8_t 
....................     fprintf(PC, "gps_time_sync_state = %u\r\n", obc_flags.gps_time_sync_state);          // uint8_t 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value);            // int8_t 
....................     fprintf(PC, "cw_mode = %u\r\n", obc_flags.cw_mode);                                  // uint8_t 
....................     fprintf(PC, "heater_ref_temperature = %04lX\r\n", obc_flags.heater_ref_temperature); // uint16_t in hexadecimal 
....................     fprintf(PC, "heater_ref_voltage = %04lX\r\n", obc_flags.heater_ref_voltage);         // uint16_t in hexadecimal 
....................     fprintf(PC, "opera_boot_duration = %us\r\n", obc_flags.opera_boot_duration);         // uint8_t 
....................     fprintf(PC, "relay_on_off = %u\r\n", obc_flags.relay_on_off);                        // uint8_t 
....................     fprintf(PC, "camera_parameters = ");                                                 // uint8_t[] 
....................     for(uint8_t i = 0; i < sizeof(obc_flags.camera_parameters); i++){ 
....................         fprintf(PC, "%02X", obc_flags.camera_parameters[i]); 
....................     } 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t verbose = false;     // True to set verbose mode 
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
.................... uint8_t mux_lock = false;    // True if long operation is locking the mux 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... typedef enum { 
....................     mux_sel_zes = 0, 
....................     mux_tmcr1 = 1, 
....................     mux_adcs = 2, 
....................     mux_tmcr2 = 3, 
....................     mux_opera = 4, 
....................     mux_mcpic = 5, 
....................     mux_pcib = 6, 
....................     mux_sel_ref = 7, 
.................... } cpld_mux_sel; 
....................  
.................... char* mux_str_list[] = { 
....................     "ZES", 
....................     "TM1", 
....................     "ADC", 
....................     "TM2", 
....................     "OPE", 
....................     "MCP", 
....................     "CAM", 
....................     "REF" 
.................... }; 
....................  
.................... uint8_t mux_cpld_position = mux_mcpic; 
....................  
.................... // Change mission control pic MUX position 
.................... uint8_t mux_sel(cpld_mux_sel sel) 
.................... { 
....................     if (mux_lock) 
....................         return mux_cpld_position; // Do not change if locked 
....................  
....................     // MUX_CPLD_SEL_0 is the MSB 
....................     output_bit(MUX_CPLD_SEL_0, (sel >> 2) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_1, (sel >> 1) & 0x1); 
....................     output_bit(MUX_CPLD_SEL_2, (sel >> 0) & 0x1); 
....................  
.................... #ifndef SIM 
....................     if (sel == mux_sel_ref || sel == mux_sel_zes) { 
....................         set_uart_speed(9600, MSN); 
....................     } else { 
....................         set_uart_speed(115200, MSN); 
....................     } 
.................... #endif 
....................  
....................     mux_cpld_position = sel; 
....................  
....................     delay_ms(10); 
....................  
....................     if (verbose) 
....................         fprintf(PC, "|MUX changed to %s|", mux_str_list[mux_cpld_position]); 
....................  
....................     return mux_cpld_position; 
.................... } 
....................  
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... uint8_t adcs_raw_part_a[16] = { 0 }; // First part of raw ADCS command 
.................... uint8_t adcs_raw_part_b[16] = { 0 }; // Second part of raw ADCS command 
.................... uint8_t adcs_raw_part_a_crc0 = 0xFF; // CRC[0] of first part of raw ADCS command 
.................... uint8_t adcs_raw_part_b_crc0 = 0xFF; // CRC[0] of second part of raw ADCS command 
....................  
.................... enum { 
....................     GA_part_a_size = 16, // First 4 bytes is mission time 
....................     GA_part_b_size = 16 
.................... }; 
....................  
.................... uint8_t opera_GA_part_a[GA_part_a_size] = { 0 }; 
....................  
.................... uint8_t sband_tx_status = 0; 
.................... uint8_t rpi_status = 0; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include <flash_memory.h> 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
....................  
.................... // Adds a log entry to buffer in RAM 
.................... void log_add(log_entry e) 
.................... { 
....................     if (log_index < MAX_LOGS_IN_RAM) { 
*
17BDA:  MOVLB  7
17BDC:  MOVF   x1D,W
17BDE:  SUBLW  3F
17BE0:  BNC   17C2E
....................         memcpy(&log_buffer[log_index], &e, sizeof(log_entry)); 
17BE2:  MOVLB  C
17BE4:  CLRF   xC4
17BE6:  MOVFF  71D,CC3
17BEA:  CLRF   xC6
17BEC:  MOVLW  07
17BEE:  MOVWF  xC5
17BF0:  MOVLB  0
17BF2:  CALL   4D06
17BF6:  MOVFF  02,03
17BFA:  MOVF   01,W
17BFC:  ADDLW  5D
17BFE:  MOVWF  01
17C00:  MOVLW  05
17C02:  ADDWFC 03,F
17C04:  MOVFF  01,C3F
17C08:  MOVLB  C
17C0A:  MOVFF  03,C40
17C0E:  MOVFF  03,FEA
17C12:  MOVFF  01,FE9
17C16:  MOVLW  0C
17C18:  MOVWF  FE2
17C1A:  MOVLW  38
17C1C:  MOVWF  FE1
17C1E:  MOVLW  07
17C20:  MOVWF  01
17C22:  MOVFF  FE6,FEE
17C26:  DECFSZ 01,F
17C28:  BRA    17C22
....................         log_index++; 
17C2A:  MOVLB  7
17C2C:  INCF   x1D,F
....................     } 
17C2E:  MOVLB  0
17C30:  GOTO   19102 (RETURN)
.................... } 
....................  
.................... // Clears buffer in RAM 
.................... void log_clear() 
.................... { 
....................     log_index = 0; 
.................... } 
....................  
.................... // Flushes RAM buffer to flash memory 
.................... void log_flush() 
.................... { 
....................     for(uint8_t i=0; i<log_index; i++){ 
*
16476:  MOVLB  C
16478:  CLRF   x4E
1647A:  MOVLB  7
1647C:  MOVF   x1D,W
1647E:  MOVLB  C
16480:  SUBWF  x4E,W
16482:  BC    164D2
....................         uint8_t *ptr = (uint8_t*)&log_buffer[i]; 
16484:  CLRF   xC4
16486:  MOVFF  C4E,CC3
1648A:  CLRF   xC6
1648C:  MOVLW  07
1648E:  MOVWF  xC5
16490:  MOVLB  0
16492:  CALL   4D06
16496:  MOVFF  02,03
1649A:  MOVF   01,W
1649C:  ADDLW  5D
1649E:  MOVWF  01
164A0:  MOVLW  05
164A2:  ADDWFC 03,F
164A4:  MOVFF  01,C4F
164A8:  MOVLB  C
164AA:  MOVFF  03,C50
....................         flash_cycle_write(&spi_port_COM_FM, ptr, &addr_flags.flash_log); 
164AE:  MOVLW  0A
164B0:  MOVWF  xBF
164B2:  MOVLW  A3
164B4:  MOVWF  xBE
164B6:  MOVFF  C50,CC1
164BA:  MOVFF  C4F,CC0
164BE:  MOVLW  01
164C0:  MOVWF  xC3
164C2:  MOVLW  24
164C4:  MOVWF  xC2
164C6:  MOVLB  0
164C8:  CALL   6658
164CC:  MOVLB  C
164CE:  INCF   x4E,F
164D0:  BRA    1647A
....................     } 
....................     fprintf(PC, "Log: 0x%08lX => 0x%08lX", addr_flags.flash_log.current - log_index*sizeof(log_entry), addr_flags.flash_log.current); 
164D2:  MOVLB  7
164D4:  MOVF   x1D,W
164D6:  MULLW  07
164D8:  MOVF   FF3,W
164DA:  MOVLB  1
164DC:  SUBWF  x2C,W
164DE:  MOVLB  C
164E0:  MOVWF  x51
164E2:  MOVLW  00
164E4:  MOVLB  1
164E6:  SUBWFB x2D,W
164E8:  MOVLB  C
164EA:  MOVWF  x52
164EC:  MOVLW  00
164EE:  MOVLB  1
164F0:  SUBWFB x2E,W
164F2:  MOVLB  C
164F4:  MOVWF  x53
164F6:  MOVLW  00
164F8:  MOVLB  1
164FA:  SUBWFB x2F,W
164FC:  MOVLB  C
164FE:  MOVWF  x54
16500:  MOVLW  04
16502:  MOVWF  FF6
16504:  MOVLW  06
16506:  MOVWF  FF7
16508:  MOVLW  00
1650A:  MOVWF  FF8
1650C:  MOVLW  07
1650E:  MOVWF  xC1
16510:  MOVLB  0
16512:  CALL   5290
16516:  MOVFF  C54,CBF
1651A:  MOVLW  37
1651C:  MOVLB  C
1651E:  MOVWF  xC0
16520:  MOVLB  0
16522:  CALL   5A92
16526:  MOVFF  C53,CBF
1652A:  MOVLW  37
1652C:  MOVLB  C
1652E:  MOVWF  xC0
16530:  MOVLB  0
16532:  CALL   5A92
16536:  MOVFF  C52,CBF
1653A:  MOVLW  37
1653C:  MOVLB  C
1653E:  MOVWF  xC0
16540:  MOVLB  0
16542:  CALL   5A92
16546:  MOVFF  C51,CBF
1654A:  MOVLW  37
1654C:  MOVLB  C
1654E:  MOVWF  xC0
16550:  MOVLB  0
16552:  CALL   5A92
16556:  MOVLW  10
16558:  MOVWF  FF6
1655A:  MOVLW  06
1655C:  MOVWF  FF7
1655E:  MOVLW  00
16560:  MOVWF  FF8
16562:  MOVLW  06
16564:  MOVLB  C
16566:  MOVWF  xC1
16568:  MOVLB  0
1656A:  CALL   5290
1656E:  MOVFF  12F,CBF
16572:  MOVLW  37
16574:  MOVLB  C
16576:  MOVWF  xC0
16578:  MOVLB  0
1657A:  CALL   5A92
1657E:  MOVFF  12E,CBF
16582:  MOVLW  37
16584:  MOVLB  C
16586:  MOVWF  xC0
16588:  MOVLB  0
1658A:  CALL   5A92
1658E:  MOVFF  12D,CBF
16592:  MOVLW  37
16594:  MOVLB  C
16596:  MOVWF  xC0
16598:  MOVLB  0
1659A:  CALL   5A92
1659E:  MOVFF  12C,CBF
165A2:  MOVLW  37
165A4:  MOVLB  C
165A6:  MOVWF  xC0
165A8:  MOVLB  0
165AA:  CALL   5A92
....................     log_index = 0; 
165AE:  MOVLB  7
165B0:  CLRF   x1D
165B2:  MOVLB  0
165B4:  GOTO   168DC (RETURN)
.................... } 
....................  
.................... #endif /* LOG_CONTROL_H */ 
....................  
.................... #include <boot_command.h> 
.................... #ifndef BOOT_COMMAND_H 
.................... #define BOOT_COMMAND_H 
....................  
.................... #include <definitions.h> 
.................... #include <flash_memory.h> 
.................... #include <flash_memory_fn.h> 
.................... #include <scheduler.h> 
....................  
.................... void boot_commands_write() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_erase_pages(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, BOOT_COMMANDS_ADDR + sizeof(boot_commands)); 
....................     flash_transfer_data_from_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_read() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_transfer_data_to_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_clear_nth(uint8_t n) 
.................... { 
....................     if (n < BOOT_COMMANDS_MAX) 
....................         boot_commands[n].time = TIME_T_MAX; 
.................... } 
....................  
.................... void boot_commands_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         boot_commands_clear_nth(i); 
....................     } 
.................... } 
....................  
.................... uint8_t boot_commands_add(boot_command bc) 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if (boot_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&boot_commands[i], &bc, sizeof(boot_command)); 
....................             return i; 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... void boot_commands_schedule() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if(boot_commands[i].time > 0 && boot_commands[i].time < TIME_T_MAX) 
....................             vschedule(current_time + boot_commands[i].time, boot_commands[i].command); 
....................     } 
.................... } 
....................  
.................... #endif /* BOOT_COMMAND_H */ 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0F5AA:  MOVLB  C
0F5AC:  BCF    xA2.0
....................    y = x; 
0F5AE:  MOVFF  C96,C9B
0F5B2:  MOVFF  C95,C9A
0F5B6:  MOVFF  C94,C99
0F5BA:  MOVFF  C93,C98
....................  
....................    if (x < 0) 
0F5BE:  MOVFF  C96,CA6
0F5C2:  MOVFF  C95,CA5
0F5C6:  MOVFF  C94,CA4
0F5CA:  MOVFF  C93,CA3
0F5CE:  CLRF   xAA
0F5D0:  CLRF   xA9
0F5D2:  CLRF   xA8
0F5D4:  CLRF   xA7
0F5D6:  MOVLB  0
0F5D8:  RCALL  F028
0F5DA:  BNC   F5E8
....................    { 
....................       s = 1; 
0F5DC:  MOVLB  C
0F5DE:  BSF    xA2.0
....................       y = -y; 
0F5E0:  MOVF   x99,W
0F5E2:  XORLW  80
0F5E4:  MOVWF  x99
0F5E6:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
0F5E8:  MOVFF  C9B,CA6
0F5EC:  MOVFF  C9A,CA5
0F5F0:  MOVFF  C99,CA4
0F5F4:  MOVFF  C98,CA3
0F5F8:  MOVLB  C
0F5FA:  CLRF   xAA
0F5FC:  CLRF   xA9
0F5FE:  CLRF   xA8
0F600:  MOVLW  8E
0F602:  MOVWF  xA7
0F604:  MOVLB  0
0F606:  RCALL  F028
0F608:  BC    F60C
0F60A:  BNZ   F63A
....................       res = (float32)(unsigned int16)y; 
0F60C:  MOVFF  C9B,CA6
0F610:  MOVFF  C9A,CA5
0F614:  MOVFF  C99,CA4
0F618:  MOVFF  C98,CA3
0F61C:  RCALL  F200
0F61E:  MOVFF  02,CA8
0F622:  MOVFF  01,CA7
0F626:  RCALL  EFF2
0F628:  MOVFF  03,C9F
0F62C:  MOVFF  02,C9E
0F630:  MOVFF  01,C9D
0F634:  MOVFF  00,C9C
0F638:  BRA    F7C8
....................  
....................  else if (y < 10000000.0) 
0F63A:  MOVFF  C9B,CA6
0F63E:  MOVFF  C9A,CA5
0F642:  MOVFF  C99,CA4
0F646:  MOVFF  C98,CA3
0F64A:  MOVLW  80
0F64C:  MOVLB  C
0F64E:  MOVWF  xAA
0F650:  MOVLW  96
0F652:  MOVWF  xA9
0F654:  MOVLW  18
0F656:  MOVWF  xA8
0F658:  MOVLW  96
0F65A:  MOVWF  xA7
0F65C:  MOVLB  0
0F65E:  RCALL  F028
0F660:  BTFSS  FD8.0
0F662:  BRA    F7B8
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0F664:  MOVFF  C9B,CA6
0F668:  MOVFF  C9A,CA5
0F66C:  MOVFF  C99,CA4
0F670:  MOVFF  C98,CA3
0F674:  MOVLB  C
0F676:  CLRF   xAA
0F678:  CLRF   xA9
0F67A:  CLRF   xA8
0F67C:  MOVLW  70
0F67E:  MOVWF  xA7
0F680:  MOVLB  0
0F682:  RCALL  F23C
0F684:  MOVFF  03,CA6
0F688:  MOVFF  02,CA5
0F68C:  MOVFF  01,CA4
0F690:  MOVFF  00,CA3
0F694:  RCALL  F200
0F696:  MOVFF  02,CA1
0F69A:  MOVFF  01,CA0
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0F69E:  MOVFF  C9B,CA6
0F6A2:  MOVFF  C9A,CA5
0F6A6:  MOVFF  C99,CA4
0F6AA:  MOVFF  C98,CA3
0F6AE:  MOVLB  C
0F6B0:  CLRF   xAA
0F6B2:  CLRF   xA9
0F6B4:  CLRF   xA8
0F6B6:  MOVLW  70
0F6B8:  MOVWF  xA7
0F6BA:  MOVLB  0
0F6BC:  RCALL  F23C
0F6BE:  MOVFF  03,CA6
0F6C2:  MOVFF  02,CA5
0F6C6:  MOVFF  01,CA4
0F6CA:  MOVFF  00,CA3
0F6CE:  MOVFF  CA1,CA8
0F6D2:  MOVFF  CA0,CA7
0F6D6:  RCALL  EFF2
0F6D8:  BSF    FD8.1
0F6DA:  MOVFF  CA6,CAA
0F6DE:  MOVFF  CA5,CA9
0F6E2:  MOVFF  CA4,CA8
0F6E6:  MOVFF  CA3,CA7
0F6EA:  MOVFF  03,CAE
0F6EE:  MOVFF  02,CAD
0F6F2:  MOVFF  01,CAC
0F6F6:  MOVFF  00,CAB
0F6FA:  RCALL  F332
0F6FC:  MOVLB  C
0F6FE:  CLRF   xA6
0F700:  CLRF   xA5
0F702:  CLRF   xA4
0F704:  MOVLW  8E
0F706:  MOVWF  xA3
0F708:  MOVFF  03,CAA
0F70C:  MOVFF  02,CA9
0F710:  MOVFF  01,CA8
0F714:  MOVFF  00,CA7
0F718:  MOVLB  0
0F71A:  RCALL  F23C
0F71C:  MOVFF  03,C9B
0F720:  MOVFF  02,C9A
0F724:  MOVFF  01,C99
0F728:  MOVFF  00,C98
....................       res = 32768.0*(float32)l; 
0F72C:  MOVFF  CA1,CA8
0F730:  MOVFF  CA0,CA7
0F734:  RCALL  EFF2
0F736:  MOVLB  C
0F738:  CLRF   xA6
0F73A:  CLRF   xA5
0F73C:  CLRF   xA4
0F73E:  MOVLW  8E
0F740:  MOVWF  xA3
0F742:  MOVFF  03,CAA
0F746:  MOVFF  02,CA9
0F74A:  MOVFF  01,CA8
0F74E:  MOVFF  00,CA7
0F752:  MOVLB  0
0F754:  RCALL  F23C
0F756:  MOVFF  03,C9F
0F75A:  MOVFF  02,C9E
0F75E:  MOVFF  01,C9D
0F762:  MOVFF  00,C9C
....................       res += (float32)(unsigned int16)y; 
0F766:  MOVFF  C9B,CA6
0F76A:  MOVFF  C9A,CA5
0F76E:  MOVFF  C99,CA4
0F772:  MOVFF  C98,CA3
0F776:  RCALL  F200
0F778:  MOVFF  02,CA8
0F77C:  MOVFF  01,CA7
0F780:  RCALL  EFF2
0F782:  BCF    FD8.1
0F784:  MOVFF  C9F,CAA
0F788:  MOVFF  C9E,CA9
0F78C:  MOVFF  C9D,CA8
0F790:  MOVFF  C9C,CA7
0F794:  MOVFF  03,CAE
0F798:  MOVFF  02,CAD
0F79C:  MOVFF  01,CAC
0F7A0:  MOVFF  00,CAB
0F7A4:  RCALL  F332
0F7A6:  MOVFF  03,C9F
0F7AA:  MOVFF  02,C9E
0F7AE:  MOVFF  01,C9D
0F7B2:  MOVFF  00,C9C
....................    } 
0F7B6:  BRA    F7C8
....................  
....................  else 
....................   res = y; 
0F7B8:  MOVFF  C9B,C9F
0F7BC:  MOVFF  C9A,C9E
0F7C0:  MOVFF  C99,C9D
0F7C4:  MOVFF  C98,C9C
....................  
....................  y = y - (float32)(unsigned int16)y; 
0F7C8:  MOVFF  C9B,CA6
0F7CC:  MOVFF  C9A,CA5
0F7D0:  MOVFF  C99,CA4
0F7D4:  MOVFF  C98,CA3
0F7D8:  RCALL  F200
0F7DA:  MOVFF  02,CA8
0F7DE:  MOVFF  01,CA7
0F7E2:  RCALL  EFF2
0F7E4:  BSF    FD8.1
0F7E6:  MOVFF  C9B,CAA
0F7EA:  MOVFF  C9A,CA9
0F7EE:  MOVFF  C99,CA8
0F7F2:  MOVFF  C98,CA7
0F7F6:  MOVFF  03,CAE
0F7FA:  MOVFF  02,CAD
0F7FE:  MOVFF  01,CAC
0F802:  MOVFF  00,CAB
0F806:  RCALL  F332
0F808:  MOVFF  03,C9B
0F80C:  MOVFF  02,C9A
0F810:  MOVFF  01,C99
0F814:  MOVFF  00,C98
....................  
....................  if (s) 
0F818:  MOVLB  C
0F81A:  BTFSS  xA2.0
0F81C:  BRA    F824
....................   res = -res; 
0F81E:  MOVF   x9D,W
0F820:  XORLW  80
0F822:  MOVWF  x9D
....................  
....................  if (y != 0) 
0F824:  MOVFF  C9B,CA6
0F828:  MOVFF  C9A,CA5
0F82C:  MOVFF  C99,CA4
0F830:  MOVFF  C98,CA3
0F834:  CLRF   xAA
0F836:  CLRF   xA9
0F838:  CLRF   xA8
0F83A:  CLRF   xA7
0F83C:  MOVLB  0
0F83E:  CALL   F028
0F842:  BZ    F8B8
....................  { 
....................   if (s == 1 && n == 0) 
0F844:  MOVLB  C
0F846:  BTFSS  xA2.0
0F848:  BRA    F880
0F84A:  MOVF   x97,F
0F84C:  BNZ   F880
....................    res -= 1.0; 
0F84E:  BSF    FD8.1
0F850:  MOVFF  C9F,CAA
0F854:  MOVFF  C9E,CA9
0F858:  MOVFF  C9D,CA8
0F85C:  MOVFF  C9C,CA7
0F860:  CLRF   xAE
0F862:  CLRF   xAD
0F864:  CLRF   xAC
0F866:  MOVLW  7F
0F868:  MOVWF  xAB
0F86A:  MOVLB  0
0F86C:  RCALL  F332
0F86E:  MOVFF  03,C9F
0F872:  MOVFF  02,C9E
0F876:  MOVFF  01,C9D
0F87A:  MOVFF  00,C9C
0F87E:  MOVLB  C
....................  
....................   if (s == 0 && n == 1) 
0F880:  BTFSC  xA2.0
0F882:  BRA    F8BA
0F884:  DECFSZ x97,W
0F886:  BRA    F8BA
....................    res += 1.0; 
0F888:  BCF    FD8.1
0F88A:  MOVFF  C9F,CAA
0F88E:  MOVFF  C9E,CA9
0F892:  MOVFF  C9D,CA8
0F896:  MOVFF  C9C,CA7
0F89A:  CLRF   xAE
0F89C:  CLRF   xAD
0F89E:  CLRF   xAC
0F8A0:  MOVLW  7F
0F8A2:  MOVWF  xAB
0F8A4:  MOVLB  0
0F8A6:  RCALL  F332
0F8A8:  MOVFF  03,C9F
0F8AC:  MOVFF  02,C9E
0F8B0:  MOVFF  01,C9D
0F8B4:  MOVFF  00,C9C
0F8B8:  MOVLB  C
....................  } 
....................  if (x == 0) 
0F8BA:  MOVFF  C96,CA6
0F8BE:  MOVFF  C95,CA5
0F8C2:  MOVFF  C94,CA4
0F8C6:  MOVFF  C93,CA3
0F8CA:  CLRF   xAA
0F8CC:  CLRF   xA9
0F8CE:  CLRF   xA8
0F8D0:  CLRF   xA7
0F8D2:  MOVLB  0
0F8D4:  CALL   F028
0F8D8:  BNZ   F8E6
....................     res = 0; 
0F8DA:  MOVLB  C
0F8DC:  CLRF   x9F
0F8DE:  CLRF   x9E
0F8E0:  CLRF   x9D
0F8E2:  CLRF   x9C
0F8E4:  MOVLB  0
....................  
....................  return (res); 
0F8E6:  MOVFF  C9C,00
0F8EA:  MOVFF  C9D,01
0F8EE:  MOVFF  C9E,02
0F8F2:  MOVFF  C9F,03
0F8F6:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0F916:  MOVFF  C92,C96
0F91A:  MOVFF  C91,C95
0F91E:  MOVFF  C90,C94
0F922:  MOVFF  C8F,C93
0F926:  MOVLB  C
0F928:  CLRF   x97
0F92A:  MOVLB  0
0F92C:  RCALL  F5AA
0F92E:  GOTO   FA3A (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0F8F8:  MOVFF  C92,C96
0F8FC:  MOVFF  C91,C95
0F900:  MOVFF  C90,C94
0F904:  MOVFF  C8F,C93
0F908:  MOVLW  01
0F90A:  MOVLB  C
0F90C:  MOVWF  x97
0F90E:  MOVLB  0
0F910:  RCALL  F5AA
0F912:  GOTO   F9F2 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0F932:  MOVFF  C86,CA6
0F936:  MOVFF  C85,CA5
0F93A:  MOVFF  C84,CA4
0F93E:  MOVFF  C83,CA3
0F942:  MOVLB  C
0F944:  CLRF   xAA
0F946:  CLRF   xA9
0F948:  CLRF   xA8
0F94A:  CLRF   xA7
0F94C:  MOVLB  0
0F94E:  CALL   F028
0F952:  BTFSC  FD8.2
0F954:  BRA    FA94
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0F956:  MOVFF  C82,C9F
0F95A:  MOVFF  C81,C9E
0F95E:  MOVFF  C80,C9D
0F962:  MOVFF  C7F,C9C
0F966:  MOVFF  C86,CA3
0F96A:  MOVFF  C85,CA2
0F96E:  MOVFF  C84,CA1
0F972:  MOVFF  C83,CA0
0F976:  CALL   F0A2
0F97A:  MOVFF  03,C8E
0F97E:  MOVFF  02,C8D
0F982:  MOVFF  01,C8C
0F986:  MOVFF  00,C8B
0F98A:  MOVFF  03,CA6
0F98E:  MOVFF  02,CA5
0F992:  MOVFF  01,CA4
0F996:  MOVFF  00,CA3
0F99A:  MOVLB  C
0F99C:  CLRF   xAA
0F99E:  CLRF   xA9
0F9A0:  CLRF   xA8
0F9A2:  CLRF   xA7
0F9A4:  MOVLB  0
0F9A6:  CALL   F028
0F9AA:  BNC   F9F4
0F9AC:  MOVFF  C82,C9F
0F9B0:  MOVFF  C81,C9E
0F9B4:  MOVFF  C80,C9D
0F9B8:  MOVFF  C7F,C9C
0F9BC:  MOVFF  C86,CA3
0F9C0:  MOVFF  C85,CA2
0F9C4:  MOVFF  C84,CA1
0F9C8:  MOVFF  C83,CA0
0F9CC:  CALL   F0A2
0F9D0:  MOVFF  03,C8E
0F9D4:  MOVFF  02,C8D
0F9D8:  MOVFF  01,C8C
0F9DC:  MOVFF  00,C8B
0F9E0:  MOVFF  03,C92
0F9E4:  MOVFF  02,C91
0F9E8:  MOVFF  01,C90
0F9EC:  MOVFF  00,C8F
0F9F0:  BRA    F8F8
0F9F2:  BRA    FA3A
0F9F4:  MOVFF  C82,C9F
0F9F8:  MOVFF  C81,C9E
0F9FC:  MOVFF  C80,C9D
0FA00:  MOVFF  C7F,C9C
0FA04:  MOVFF  C86,CA3
0FA08:  MOVFF  C85,CA2
0FA0C:  MOVFF  C84,CA1
0FA10:  MOVFF  C83,CA0
0FA14:  CALL   F0A2
0FA18:  MOVFF  03,C8E
0FA1C:  MOVFF  02,C8D
0FA20:  MOVFF  01,C8C
0FA24:  MOVFF  00,C8B
0FA28:  MOVFF  03,C92
0FA2C:  MOVFF  02,C91
0FA30:  MOVFF  01,C90
0FA34:  MOVFF  00,C8F
0FA38:  BRA    F916
0FA3A:  MOVFF  03,C8A
0FA3E:  MOVFF  02,C89
0FA42:  MOVFF  01,C88
0FA46:  MOVFF  00,C87
....................       return(x-(i*y)); 
0FA4A:  MOVFF  C8A,CA6
0FA4E:  MOVFF  C89,CA5
0FA52:  MOVFF  C88,CA4
0FA56:  MOVFF  C87,CA3
0FA5A:  MOVFF  C86,CAA
0FA5E:  MOVFF  C85,CA9
0FA62:  MOVFF  C84,CA8
0FA66:  MOVFF  C83,CA7
0FA6A:  CALL   F23C
0FA6E:  BSF    FD8.1
0FA70:  MOVFF  C82,CAA
0FA74:  MOVFF  C81,CA9
0FA78:  MOVFF  C80,CA8
0FA7C:  MOVFF  C7F,CA7
0FA80:  MOVFF  03,CAE
0FA84:  MOVFF  02,CAD
0FA88:  MOVFF  01,CAC
0FA8C:  MOVFF  00,CAB
0FA90:  RCALL  F332
0FA92:  BRA    FA94
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0FA94:  RETURN 0
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
*
10000:  MOVFF  C86,CA6
10004:  MOVFF  C85,CA5
10008:  MOVFF  C84,CA4
1000C:  MOVFF  C83,CA3
10010:  MOVLW  3B
10012:  MOVLB  C
10014:  MOVWF  xAA
10016:  MOVLW  AA
10018:  MOVWF  xA9
1001A:  MOVLW  38
1001C:  MOVWF  xA8
1001E:  MOVLW  7F
10020:  MOVWF  xA7
10022:  MOVLB  0
10024:  CALL   F23C
10028:  MOVFF  03,CA6
1002C:  MOVFF  02,CA5
10030:  MOVFF  01,CA4
10034:  MOVFF  00,CA3
10038:  CALL   F200
1003C:  MOVFF  01,C93
....................    s = 0; 
10040:  MOVLB  C
10042:  BCF    x94.0
....................    y = x; 
10044:  MOVFF  C86,C8A
10048:  MOVFF  C85,C89
1004C:  MOVFF  C84,C88
10050:  MOVFF  C83,C87
....................  
....................    if (x < 0) 
10054:  MOVFF  C86,CA6
10058:  MOVFF  C85,CA5
1005C:  MOVFF  C84,CA4
10060:  MOVFF  C83,CA3
10064:  CLRF   xAA
10066:  CLRF   xA9
10068:  CLRF   xA8
1006A:  CLRF   xA7
1006C:  MOVLB  0
1006E:  CALL   F028
10072:  BNC   10082
....................    { 
....................       s = 1; 
10074:  MOVLB  C
10076:  BSF    x94.0
....................       n = -n; 
10078:  NEGF   x93
....................       y = -y; 
1007A:  MOVF   x88,W
1007C:  XORLW  80
1007E:  MOVWF  x88
10080:  MOVLB  0
....................    } 
....................  
....................    res = 0.0; 
10082:  MOVLB  C
10084:  CLRF   x8E
10086:  CLRF   x8D
10088:  CLRF   x8C
1008A:  CLRF   x8B
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
1008C:  MOVLW  0C
1008E:  MOVWF  x96
10090:  MOVLW  8B
10092:  MOVWF  x95
10094:  MOVFF  C95,FE9
10098:  MOVFF  C96,FEA
1009C:  MOVLW  7F
1009E:  ADDWF  x93,W
100A0:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
100A2:  MOVFF  C8A,CA6
100A6:  MOVFF  C89,CA5
100AA:  MOVFF  C88,CA4
100AE:  MOVFF  C87,CA3
100B2:  MOVLW  3B
100B4:  MOVWF  xAA
100B6:  MOVLW  AA
100B8:  MOVWF  xA9
100BA:  MOVLW  38
100BC:  MOVWF  xA8
100BE:  MOVLW  7F
100C0:  MOVWF  xA7
100C2:  MOVLB  0
100C4:  CALL   F23C
100C8:  MOVFF  03,C98
100CC:  MOVFF  02,C97
100D0:  MOVFF  01,C96
100D4:  MOVFF  00,C95
100D8:  MOVLB  C
100DA:  CLRF   x9A
100DC:  MOVFF  C93,C99
100E0:  BTFSC  x99.7
100E2:  DECF   x9A,F
100E4:  MOVLB  0
100E6:  RCALL  FA96
100E8:  BSF    FD8.1
100EA:  MOVFF  C98,CAA
100EE:  MOVFF  C97,CA9
100F2:  MOVFF  C96,CA8
100F6:  MOVFF  C95,CA7
100FA:  MOVFF  03,CAE
100FE:  MOVFF  02,CAD
10102:  MOVFF  01,CAC
10106:  MOVFF  00,CAB
1010A:  CALL   F332
1010E:  MOVFF  03,C8A
10112:  MOVFF  02,C89
10116:  MOVFF  01,C88
1011A:  MOVFF  00,C87
....................  
....................    r = pe[0]*y + pe[1]; 
1011E:  MOVLW  7C
10120:  MOVLB  C
10122:  MOVWF  xA6
10124:  MOVLW  88
10126:  MOVWF  xA5
10128:  MOVLW  59
1012A:  MOVWF  xA4
1012C:  MOVLW  72
1012E:  MOVWF  xA3
10130:  MOVFF  C8A,CAA
10134:  MOVFF  C89,CA9
10138:  MOVFF  C88,CA8
1013C:  MOVFF  C87,CA7
10140:  MOVLB  0
10142:  CALL   F23C
10146:  MOVFF  03,C98
1014A:  MOVFF  02,C97
1014E:  MOVFF  01,C96
10152:  MOVFF  00,C95
10156:  BCF    FD8.1
10158:  MOVFF  C98,CAA
1015C:  MOVFF  C97,CA9
10160:  MOVFF  C96,CA8
10164:  MOVFF  C95,CA7
10168:  MOVLW  E0
1016A:  MOVLB  C
1016C:  MOVWF  xAE
1016E:  MOVLW  97
10170:  MOVWF  xAD
10172:  MOVLW  26
10174:  MOVWF  xAC
10176:  MOVLW  75
10178:  MOVWF  xAB
1017A:  MOVLB  0
1017C:  CALL   F332
10180:  MOVFF  03,C92
10184:  MOVFF  02,C91
10188:  MOVFF  01,C90
1018C:  MOVFF  00,C8F
....................    r = r*y + pe[2]; 
10190:  MOVFF  C92,CA6
10194:  MOVFF  C91,CA5
10198:  MOVFF  C90,CA4
1019C:  MOVFF  C8F,CA3
101A0:  MOVFF  C8A,CAA
101A4:  MOVFF  C89,CA9
101A8:  MOVFF  C88,CA8
101AC:  MOVFF  C87,CA7
101B0:  CALL   F23C
101B4:  MOVFF  03,C98
101B8:  MOVFF  02,C97
101BC:  MOVFF  01,C96
101C0:  MOVFF  00,C95
101C4:  BCF    FD8.1
101C6:  MOVFF  C98,CAA
101CA:  MOVFF  C97,CA9
101CE:  MOVFF  C96,CA8
101D2:  MOVFF  C95,CA7
101D6:  MOVLW  C4
101D8:  MOVLB  C
101DA:  MOVWF  xAE
101DC:  MOVLW  1D
101DE:  MOVWF  xAD
101E0:  MOVLW  1E
101E2:  MOVWF  xAC
101E4:  MOVLW  78
101E6:  MOVWF  xAB
101E8:  MOVLB  0
101EA:  CALL   F332
101EE:  MOVFF  03,C92
101F2:  MOVFF  02,C91
101F6:  MOVFF  01,C90
101FA:  MOVFF  00,C8F
....................    r = r*y + pe[3]; 
101FE:  MOVFF  C92,CA6
10202:  MOVFF  C91,CA5
10206:  MOVFF  C90,CA4
1020A:  MOVFF  C8F,CA3
1020E:  MOVFF  C8A,CAA
10212:  MOVFF  C89,CA9
10216:  MOVFF  C88,CA8
1021A:  MOVFF  C87,CA7
1021E:  CALL   F23C
10222:  MOVFF  03,C98
10226:  MOVFF  02,C97
1022A:  MOVFF  01,C96
1022E:  MOVFF  00,C95
10232:  BCF    FD8.1
10234:  MOVFF  C98,CAA
10238:  MOVFF  C97,CA9
1023C:  MOVFF  C96,CA8
10240:  MOVFF  C95,CA7
10244:  MOVLW  5E
10246:  MOVLB  C
10248:  MOVWF  xAE
1024A:  MOVLW  50
1024C:  MOVWF  xAD
1024E:  MOVLW  63
10250:  MOVWF  xAC
10252:  MOVLW  7A
10254:  MOVWF  xAB
10256:  MOVLB  0
10258:  CALL   F332
1025C:  MOVFF  03,C92
10260:  MOVFF  02,C91
10264:  MOVFF  01,C90
10268:  MOVFF  00,C8F
....................    r = r*y + pe[4]; 
1026C:  MOVFF  C92,CA6
10270:  MOVFF  C91,CA5
10274:  MOVFF  C90,CA4
10278:  MOVFF  C8F,CA3
1027C:  MOVFF  C8A,CAA
10280:  MOVFF  C89,CA9
10284:  MOVFF  C88,CA8
10288:  MOVFF  C87,CA7
1028C:  CALL   F23C
10290:  MOVFF  03,C98
10294:  MOVFF  02,C97
10298:  MOVFF  01,C96
1029C:  MOVFF  00,C95
102A0:  BCF    FD8.1
102A2:  MOVFF  C98,CAA
102A6:  MOVFF  C97,CA9
102AA:  MOVFF  C96,CA8
102AE:  MOVFF  C95,CA7
102B2:  MOVLW  1A
102B4:  MOVLB  C
102B6:  MOVWF  xAE
102B8:  MOVLW  FE
102BA:  MOVWF  xAD
102BC:  MOVLW  75
102BE:  MOVWF  xAC
102C0:  MOVLW  7C
102C2:  MOVWF  xAB
102C4:  MOVLB  0
102C6:  CALL   F332
102CA:  MOVFF  03,C92
102CE:  MOVFF  02,C91
102D2:  MOVFF  01,C90
102D6:  MOVFF  00,C8F
....................    r = r*y + pe[5]; 
102DA:  MOVFF  C92,CA6
102DE:  MOVFF  C91,CA5
102E2:  MOVFF  C90,CA4
102E6:  MOVFF  C8F,CA3
102EA:  MOVFF  C8A,CAA
102EE:  MOVFF  C89,CA9
102F2:  MOVFF  C88,CA8
102F6:  MOVFF  C87,CA7
102FA:  CALL   F23C
102FE:  MOVFF  03,C98
10302:  MOVFF  02,C97
10306:  MOVFF  01,C96
1030A:  MOVFF  00,C95
1030E:  BCF    FD8.1
10310:  MOVFF  C98,CAA
10314:  MOVFF  C97,CA9
10318:  MOVFF  C96,CA8
1031C:  MOVFF  C95,CA7
10320:  MOVLW  18
10322:  MOVLB  C
10324:  MOVWF  xAE
10326:  MOVLW  72
10328:  MOVWF  xAD
1032A:  MOVLW  31
1032C:  MOVWF  xAC
1032E:  MOVLW  7E
10330:  MOVWF  xAB
10332:  MOVLB  0
10334:  CALL   F332
10338:  MOVFF  03,C92
1033C:  MOVFF  02,C91
10340:  MOVFF  01,C90
10344:  MOVFF  00,C8F
....................  
....................    res = res*(1.0 + y*r); 
10348:  MOVFF  C8A,CA6
1034C:  MOVFF  C89,CA5
10350:  MOVFF  C88,CA4
10354:  MOVFF  C87,CA3
10358:  MOVFF  C92,CAA
1035C:  MOVFF  C91,CA9
10360:  MOVFF  C90,CA8
10364:  MOVFF  C8F,CA7
10368:  CALL   F23C
1036C:  BCF    FD8.1
1036E:  MOVLB  C
10370:  CLRF   xAA
10372:  CLRF   xA9
10374:  CLRF   xA8
10376:  MOVLW  7F
10378:  MOVWF  xA7
1037A:  MOVFF  03,CAE
1037E:  MOVFF  02,CAD
10382:  MOVFF  01,CAC
10386:  MOVFF  00,CAB
1038A:  MOVLB  0
1038C:  CALL   F332
10390:  MOVFF  C8E,CA6
10394:  MOVFF  C8D,CA5
10398:  MOVFF  C8C,CA4
1039C:  MOVFF  C8B,CA3
103A0:  MOVFF  03,CAA
103A4:  MOVFF  02,CA9
103A8:  MOVFF  01,CA8
103AC:  MOVFF  00,CA7
103B0:  CALL   F23C
103B4:  MOVFF  03,C8E
103B8:  MOVFF  02,C8D
103BC:  MOVFF  01,C8C
103C0:  MOVFF  00,C8B
....................  
....................    if (s) 
103C4:  MOVLB  C
103C6:  BTFSS  x94.0
103C8:  BRA    103FC
....................       res = 1.0/res; 
103CA:  CLRF   x9F
103CC:  CLRF   x9E
103CE:  CLRF   x9D
103D0:  MOVLW  7F
103D2:  MOVWF  x9C
103D4:  MOVFF  C8E,CA3
103D8:  MOVFF  C8D,CA2
103DC:  MOVFF  C8C,CA1
103E0:  MOVFF  C8B,CA0
103E4:  MOVLB  0
103E6:  CALL   F0A2
103EA:  MOVFF  03,C8E
103EE:  MOVFF  02,C8D
103F2:  MOVFF  01,C8C
103F6:  MOVFF  00,C8B
103FA:  MOVLB  C
....................    return(res); 
103FC:  MOVFF  C8B,00
10400:  MOVFF  C8C,01
10404:  MOVFF  C8D,02
10408:  MOVFF  C8E,03
1040C:  MOVLB  0
1040E:  RETURN 0
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0FAE6:  MOVFF  C86,C8A
0FAEA:  MOVFF  C85,C89
0FAEE:  MOVFF  C84,C88
0FAF2:  MOVFF  C83,C87
....................  
....................    if (y != 1.0) 
0FAF6:  MOVFF  C8A,CA6
0FAFA:  MOVFF  C89,CA5
0FAFE:  MOVFF  C88,CA4
0FB02:  MOVFF  C87,CA3
0FB06:  MOVLB  C
0FB08:  CLRF   xAA
0FB0A:  CLRF   xA9
0FB0C:  CLRF   xA8
0FB0E:  MOVLW  7F
0FB10:  MOVWF  xA7
0FB12:  MOVLB  0
0FB14:  CALL   F028
0FB18:  BTFSC  FD8.2
0FB1A:  BRA    FE58
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0FB1C:  MOVLW  0C
0FB1E:  MOVLB  C
0FB20:  MOVWF  x99
0FB22:  MOVLW  87
0FB24:  MOVWF  FE9
0FB26:  MOVFF  C99,FEA
0FB2A:  MOVLW  7E
0FB2C:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0FB2E:  BSF    FD8.1
0FB30:  MOVFF  C8A,CAA
0FB34:  MOVFF  C89,CA9
0FB38:  MOVFF  C88,CA8
0FB3C:  MOVFF  C87,CA7
0FB40:  CLRF   xAE
0FB42:  CLRF   xAD
0FB44:  CLRF   xAC
0FB46:  MOVLW  7F
0FB48:  MOVWF  xAB
0FB4A:  MOVLB  0
0FB4C:  CALL   F332
0FB50:  MOVFF  03,C9B
0FB54:  MOVFF  02,C9A
0FB58:  MOVFF  01,C99
0FB5C:  MOVFF  00,C98
0FB60:  BCF    FD8.1
0FB62:  MOVFF  C8A,CAA
0FB66:  MOVFF  C89,CA9
0FB6A:  MOVFF  C88,CA8
0FB6E:  MOVFF  C87,CA7
0FB72:  MOVLB  C
0FB74:  CLRF   xAE
0FB76:  CLRF   xAD
0FB78:  CLRF   xAC
0FB7A:  MOVLW  7F
0FB7C:  MOVWF  xAB
0FB7E:  MOVLB  0
0FB80:  CALL   F332
0FB84:  MOVFF  C9B,C9F
0FB88:  MOVFF  C9A,C9E
0FB8C:  MOVFF  C99,C9D
0FB90:  MOVFF  C98,C9C
0FB94:  MOVFF  03,CA3
0FB98:  MOVFF  02,CA2
0FB9C:  MOVFF  01,CA1
0FBA0:  MOVFF  00,CA0
0FBA4:  CALL   F0A2
0FBA8:  MOVFF  03,C8A
0FBAC:  MOVFF  02,C89
0FBB0:  MOVFF  01,C88
0FBB4:  MOVFF  00,C87
....................  
....................       y2=y*y; 
0FBB8:  MOVFF  C8A,CA6
0FBBC:  MOVFF  C89,CA5
0FBC0:  MOVFF  C88,CA4
0FBC4:  MOVFF  C87,CA3
0FBC8:  MOVFF  C8A,CAA
0FBCC:  MOVFF  C89,CA9
0FBD0:  MOVFF  C88,CA8
0FBD4:  MOVFF  C87,CA7
0FBD8:  CALL   F23C
0FBDC:  MOVFF  03,C96
0FBE0:  MOVFF  02,C95
0FBE4:  MOVFF  01,C94
0FBE8:  MOVFF  00,C93
....................  
....................       res = pl[0]*y2 + pl[1]; 
0FBEC:  MOVLW  99
0FBEE:  MOVLB  C
0FBF0:  MOVWF  xA6
0FBF2:  MOVLW  47
0FBF4:  MOVWF  xA5
0FBF6:  MOVLW  8A
0FBF8:  MOVWF  xA4
0FBFA:  MOVLW  7F
0FBFC:  MOVWF  xA3
0FBFE:  MOVFF  C96,CAA
0FC02:  MOVFF  C95,CA9
0FC06:  MOVFF  C94,CA8
0FC0A:  MOVFF  C93,CA7
0FC0E:  MOVLB  0
0FC10:  CALL   F23C
0FC14:  MOVFF  03,C9B
0FC18:  MOVFF  02,C9A
0FC1C:  MOVFF  01,C99
0FC20:  MOVFF  00,C98
0FC24:  BCF    FD8.1
0FC26:  MOVFF  03,CAA
0FC2A:  MOVFF  02,CA9
0FC2E:  MOVFF  01,CA8
0FC32:  MOVFF  00,CA7
0FC36:  MOVLB  C
0FC38:  CLRF   xAE
0FC3A:  CLRF   xAD
0FC3C:  CLRF   xAC
0FC3E:  MOVLW  80
0FC40:  MOVWF  xAB
0FC42:  MOVLB  0
0FC44:  CALL   F332
0FC48:  MOVFF  03,C8E
0FC4C:  MOVFF  02,C8D
0FC50:  MOVFF  01,C8C
0FC54:  MOVFF  00,C8B
....................  
....................       r = ql[0]*y2 + ql[1]; 
0FC58:  MOVLW  4C
0FC5A:  MOVLB  C
0FC5C:  MOVWF  xA6
0FC5E:  MOVLW  F3
0FC60:  MOVWF  xA5
0FC62:  MOVLW  3A
0FC64:  MOVWF  xA4
0FC66:  MOVLW  7B
0FC68:  MOVWF  xA3
0FC6A:  MOVFF  C96,CAA
0FC6E:  MOVFF  C95,CA9
0FC72:  MOVFF  C94,CA8
0FC76:  MOVFF  C93,CA7
0FC7A:  MOVLB  0
0FC7C:  CALL   F23C
0FC80:  MOVFF  03,C9B
0FC84:  MOVFF  02,C9A
0FC88:  MOVFF  01,C99
0FC8C:  MOVFF  00,C98
0FC90:  BCF    FD8.1
0FC92:  MOVFF  03,CAA
0FC96:  MOVFF  02,CA9
0FC9A:  MOVFF  01,CA8
0FC9E:  MOVFF  00,CA7
0FCA2:  MOVLW  2B
0FCA4:  MOVLB  C
0FCA6:  MOVWF  xAE
0FCA8:  MOVLW  9D
0FCAA:  MOVWF  xAD
0FCAC:  MOVLW  DF
0FCAE:  MOVWF  xAC
0FCB0:  MOVLW  7E
0FCB2:  MOVWF  xAB
0FCB4:  MOVLB  0
0FCB6:  CALL   F332
0FCBA:  MOVFF  03,C92
0FCBE:  MOVFF  02,C91
0FCC2:  MOVFF  01,C90
0FCC6:  MOVFF  00,C8F
....................       r = r*y2 + 1.0; 
0FCCA:  MOVFF  C92,CA6
0FCCE:  MOVFF  C91,CA5
0FCD2:  MOVFF  C90,CA4
0FCD6:  MOVFF  C8F,CA3
0FCDA:  MOVFF  C96,CAA
0FCDE:  MOVFF  C95,CA9
0FCE2:  MOVFF  C94,CA8
0FCE6:  MOVFF  C93,CA7
0FCEA:  CALL   F23C
0FCEE:  MOVFF  03,C9B
0FCF2:  MOVFF  02,C9A
0FCF6:  MOVFF  01,C99
0FCFA:  MOVFF  00,C98
0FCFE:  BCF    FD8.1
0FD00:  MOVFF  03,CAA
0FD04:  MOVFF  02,CA9
0FD08:  MOVFF  01,CA8
0FD0C:  MOVFF  00,CA7
0FD10:  MOVLB  C
0FD12:  CLRF   xAE
0FD14:  CLRF   xAD
0FD16:  CLRF   xAC
0FD18:  MOVLW  7F
0FD1A:  MOVWF  xAB
0FD1C:  MOVLB  0
0FD1E:  CALL   F332
0FD22:  MOVFF  03,C92
0FD26:  MOVFF  02,C91
0FD2A:  MOVFF  01,C90
0FD2E:  MOVFF  00,C8F
....................  
....................       res = y*res/r; 
0FD32:  MOVFF  C8A,CA6
0FD36:  MOVFF  C89,CA5
0FD3A:  MOVFF  C88,CA4
0FD3E:  MOVFF  C87,CA3
0FD42:  MOVFF  C8E,CAA
0FD46:  MOVFF  C8D,CA9
0FD4A:  MOVFF  C8C,CA8
0FD4E:  MOVFF  C8B,CA7
0FD52:  CALL   F23C
0FD56:  MOVFF  03,C9B
0FD5A:  MOVFF  02,C9A
0FD5E:  MOVFF  01,C99
0FD62:  MOVFF  00,C98
0FD66:  MOVFF  03,C9F
0FD6A:  MOVFF  02,C9E
0FD6E:  MOVFF  01,C9D
0FD72:  MOVFF  00,C9C
0FD76:  MOVFF  C92,CA3
0FD7A:  MOVFF  C91,CA2
0FD7E:  MOVFF  C90,CA1
0FD82:  MOVFF  C8F,CA0
0FD86:  CALL   F0A2
0FD8A:  MOVFF  03,C8E
0FD8E:  MOVFF  02,C8D
0FD92:  MOVFF  01,C8C
0FD96:  MOVFF  00,C8B
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0FD9A:  MOVLW  0C
0FD9C:  MOVLB  C
0FD9E:  MOVWF  x99
0FDA0:  MOVLW  83
0FDA2:  MOVWF  FE9
0FDA4:  MOVFF  C99,FEA
0FDA8:  MOVLW  7E
0FDAA:  SUBWF  FEF,W
0FDAC:  MOVWF  x97
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0FDAE:  BTFSS  x97.7
0FDB0:  BRA    FDDA
....................          r = -(float32)-n; 
0FDB2:  MOVLW  00
0FDB4:  BSF    FD8.0
0FDB6:  SUBFWB x97,W
0FDB8:  CLRF   x9A
0FDBA:  MOVWF  x99
0FDBC:  BTFSC  x99.7
0FDBE:  DECF   x9A,F
0FDC0:  MOVLB  0
0FDC2:  RCALL  FA96
0FDC4:  MOVFF  00,C8F
0FDC8:  MOVF   01,W
0FDCA:  XORLW  80
0FDCC:  MOVLB  C
0FDCE:  MOVWF  x90
0FDD0:  MOVFF  02,C91
0FDD4:  MOVFF  03,C92
0FDD8:  BRA    FDFA
....................       else 
....................          r = (float32)n; 
0FDDA:  CLRF   x9A
0FDDC:  MOVFF  C97,C99
0FDE0:  BTFSC  x99.7
0FDE2:  DECF   x9A,F
0FDE4:  MOVLB  0
0FDE6:  RCALL  FA96
0FDE8:  MOVFF  03,C92
0FDEC:  MOVFF  02,C91
0FDF0:  MOVFF  01,C90
0FDF4:  MOVFF  00,C8F
0FDF8:  MOVLB  C
....................  
....................       res += r*LN2; 
0FDFA:  MOVFF  C92,CA6
0FDFE:  MOVFF  C91,CA5
0FE02:  MOVFF  C90,CA4
0FE06:  MOVFF  C8F,CA3
0FE0A:  MOVLW  18
0FE0C:  MOVWF  xAA
0FE0E:  MOVLW  72
0FE10:  MOVWF  xA9
0FE12:  MOVLW  31
0FE14:  MOVWF  xA8
0FE16:  MOVLW  7E
0FE18:  MOVWF  xA7
0FE1A:  MOVLB  0
0FE1C:  CALL   F23C
0FE20:  BCF    FD8.1
0FE22:  MOVFF  C8E,CAA
0FE26:  MOVFF  C8D,CA9
0FE2A:  MOVFF  C8C,CA8
0FE2E:  MOVFF  C8B,CA7
0FE32:  MOVFF  03,CAE
0FE36:  MOVFF  02,CAD
0FE3A:  MOVFF  01,CAC
0FE3E:  MOVFF  00,CAB
0FE42:  CALL   F332
0FE46:  MOVFF  03,C8E
0FE4A:  MOVFF  02,C8D
0FE4E:  MOVFF  01,C8C
0FE52:  MOVFF  00,C8B
....................    } 
0FE56:  BRA    FE64
....................  
....................    else 
....................       res = 0.0; 
0FE58:  MOVLB  C
0FE5A:  CLRF   x8E
0FE5C:  CLRF   x8D
0FE5E:  CLRF   x8C
0FE60:  CLRF   x8B
0FE62:  MOVLB  0
....................  
....................    return(res); 
0FE64:  MOVFF  C8B,00
0FE68:  MOVFF  C8C,01
0FE6C:  MOVFF  C8D,02
0FE70:  MOVFF  C8E,03
0FE74:  RETURN 0
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
*
10410:  MOVFF  C7A,CA6
10414:  MOVFF  C79,CA5
10418:  MOVFF  C78,CA4
1041C:  MOVFF  C77,CA3
10420:  MOVLB  C
10422:  CLRF   xAA
10424:  CLRF   xA9
10426:  CLRF   xA8
10428:  CLRF   xA7
1042A:  MOVLB  0
1042C:  CALL   F028
10430:  BTFSS  FD8.0
10432:  BRA    105E6
10434:  MOVFF  C7E,C82
10438:  MOVFF  C7D,C81
1043C:  MOVFF  C7C,C80
10440:  MOVFF  C7B,C7F
10444:  MOVLB  C
10446:  CLRF   x86
10448:  CLRF   x85
1044A:  CLRF   x84
1044C:  MOVLW  7F
1044E:  MOVWF  x83
10450:  MOVLB  0
10452:  CALL   F932
10456:  MOVFF  03,C82
1045A:  MOVFF  02,C81
1045E:  MOVFF  01,C80
10462:  MOVFF  00,C7F
10466:  MOVFF  03,CA6
1046A:  MOVFF  02,CA5
1046E:  MOVFF  01,CA4
10472:  MOVFF  00,CA3
10476:  MOVLB  C
10478:  CLRF   xAA
1047A:  CLRF   xA9
1047C:  CLRF   xA8
1047E:  CLRF   xA7
10480:  MOVLB  0
10482:  CALL   F028
10486:  BTFSS  FD8.2
10488:  BRA    105E6
....................       if(fmod(y, 2) == 0) { 
1048A:  MOVFF  C7E,C82
1048E:  MOVFF  C7D,C81
10492:  MOVFF  C7C,C80
10496:  MOVFF  C7B,C7F
1049A:  MOVLB  C
1049C:  CLRF   x86
1049E:  CLRF   x85
104A0:  CLRF   x84
104A2:  MOVLW  80
104A4:  MOVWF  x83
104A6:  MOVLB  0
104A8:  CALL   F932
104AC:  MOVFF  03,C82
104B0:  MOVFF  02,C81
104B4:  MOVFF  01,C80
104B8:  MOVFF  00,C7F
104BC:  MOVFF  03,CA6
104C0:  MOVFF  02,CA5
104C4:  MOVFF  01,CA4
104C8:  MOVFF  00,CA3
104CC:  MOVLB  C
104CE:  CLRF   xAA
104D0:  CLRF   xA9
104D2:  CLRF   xA8
104D4:  CLRF   xA7
104D6:  MOVLB  0
104D8:  CALL   F028
104DC:  BNZ   10560
....................          return (exp(log(-x) * y)); 
104DE:  MOVFF  C77,C7F
104E2:  MOVLB  C
104E4:  MOVF   x78,W
104E6:  XORLW  80
104E8:  MOVWF  x80
104EA:  MOVFF  C79,C81
104EE:  MOVFF  C7A,C82
104F2:  MOVFF  C7A,C86
104F6:  MOVFF  C79,C85
104FA:  MOVWF  x84
104FC:  MOVFF  C77,C83
10500:  MOVLB  0
10502:  CALL   FAE6
10506:  MOVFF  03,C82
1050A:  MOVFF  02,C81
1050E:  MOVFF  01,C80
10512:  MOVFF  00,C7F
10516:  MOVFF  03,CA6
1051A:  MOVFF  02,CA5
1051E:  MOVFF  01,CA4
10522:  MOVFF  00,CA3
10526:  MOVFF  C7E,CAA
1052A:  MOVFF  C7D,CA9
1052E:  MOVFF  C7C,CA8
10532:  MOVFF  C7B,CA7
10536:  CALL   F23C
1053A:  MOVFF  03,C82
1053E:  MOVFF  02,C81
10542:  MOVFF  01,C80
10546:  MOVFF  00,C7F
1054A:  MOVFF  03,C86
1054E:  MOVFF  02,C85
10552:  MOVFF  01,C84
10556:  MOVFF  00,C83
1055A:  RCALL  10000
1055C:  BRA    10718
....................       } else { 
1055E:  BRA    105E4
....................          return (-exp(log(-x) * y)); 
10560:  MOVFF  C77,C7F
10564:  MOVLB  C
10566:  MOVF   x78,W
10568:  XORLW  80
1056A:  MOVWF  x80
1056C:  MOVFF  C79,C81
10570:  MOVFF  C7A,C82
10574:  MOVFF  C7A,C86
10578:  MOVFF  C79,C85
1057C:  MOVWF  x84
1057E:  MOVFF  C77,C83
10582:  MOVLB  0
10584:  CALL   FAE6
10588:  MOVFF  03,C82
1058C:  MOVFF  02,C81
10590:  MOVFF  01,C80
10594:  MOVFF  00,C7F
10598:  MOVFF  03,CA6
1059C:  MOVFF  02,CA5
105A0:  MOVFF  01,CA4
105A4:  MOVFF  00,CA3
105A8:  MOVFF  C7E,CAA
105AC:  MOVFF  C7D,CA9
105B0:  MOVFF  C7C,CA8
105B4:  MOVFF  C7B,CA7
105B8:  CALL   F23C
105BC:  MOVFF  03,C82
105C0:  MOVFF  02,C81
105C4:  MOVFF  01,C80
105C8:  MOVFF  00,C7F
105CC:  MOVFF  03,C86
105D0:  MOVFF  02,C85
105D4:  MOVFF  01,C84
105D8:  MOVFF  00,C83
105DC:  RCALL  10000
105DE:  MOVLW  80
105E0:  XORWF  01,F
105E2:  BRA    10718
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
105E4:  BRA    10718
105E6:  MOVFF  C7A,CA6
105EA:  MOVFF  C79,CA5
105EE:  MOVFF  C78,CA4
105F2:  MOVFF  C77,CA3
105F6:  MOVLB  C
105F8:  CLRF   xAA
105FA:  CLRF   xA9
105FC:  CLRF   xA8
105FE:  CLRF   xA7
10600:  MOVLB  0
10602:  CALL   F028
10606:  BNC   10668
10608:  MOVFF  C7E,C82
1060C:  MOVFF  C7D,C81
10610:  MOVFF  C7C,C80
10614:  MOVFF  C7B,C7F
10618:  MOVLB  C
1061A:  CLRF   x86
1061C:  CLRF   x85
1061E:  CLRF   x84
10620:  MOVLW  7F
10622:  MOVWF  x83
10624:  MOVLB  0
10626:  CALL   F932
1062A:  MOVFF  03,C82
1062E:  MOVFF  02,C81
10632:  MOVFF  01,C80
10636:  MOVFF  00,C7F
1063A:  MOVFF  03,CA6
1063E:  MOVFF  02,CA5
10642:  MOVFF  01,CA4
10646:  MOVFF  00,CA3
1064A:  MOVLB  C
1064C:  CLRF   xAA
1064E:  CLRF   xA9
10650:  CLRF   xA8
10652:  CLRF   xA7
10654:  MOVLB  0
10656:  CALL   F028
1065A:  BZ    10668
....................       return 0; 
1065C:  CLRF   00
1065E:  CLRF   01
10660:  CLRF   02
10662:  CLRF   03
10664:  BRA    10718
....................    } else { 
10666:  BRA    10718
....................       if(x != 0 || 0 >= y) { 
10668:  MOVFF  C7A,CA6
1066C:  MOVFF  C79,CA5
10670:  MOVFF  C78,CA4
10674:  MOVFF  C77,CA3
10678:  MOVLB  C
1067A:  CLRF   xAA
1067C:  CLRF   xA9
1067E:  CLRF   xA8
10680:  CLRF   xA7
10682:  MOVLB  0
10684:  CALL   F028
10688:  BNZ   106AE
1068A:  MOVFF  C7E,CA6
1068E:  MOVFF  C7D,CA5
10692:  MOVFF  C7C,CA4
10696:  MOVFF  C7B,CA3
1069A:  MOVLB  C
1069C:  CLRF   xAA
1069E:  CLRF   xA9
106A0:  CLRF   xA8
106A2:  CLRF   xA7
106A4:  MOVLB  0
106A6:  CALL   F028
106AA:  BC    106AE
106AC:  BNZ   10718
....................          return (exp(log(x) * y)); 
106AE:  MOVFF  C7A,C86
106B2:  MOVFF  C79,C85
106B6:  MOVFF  C78,C84
106BA:  MOVFF  C77,C83
106BE:  CALL   FAE6
106C2:  MOVFF  03,C82
106C6:  MOVFF  02,C81
106CA:  MOVFF  01,C80
106CE:  MOVFF  00,C7F
106D2:  MOVFF  03,CA6
106D6:  MOVFF  02,CA5
106DA:  MOVFF  01,CA4
106DE:  MOVFF  00,CA3
106E2:  MOVFF  C7E,CAA
106E6:  MOVFF  C7D,CA9
106EA:  MOVFF  C7C,CA8
106EE:  MOVFF  C7B,CA7
106F2:  CALL   F23C
106F6:  MOVFF  03,C82
106FA:  MOVFF  02,C81
106FE:  MOVFF  01,C80
10702:  MOVFF  00,C7F
10706:  MOVFF  03,C86
1070A:  MOVFF  02,C85
1070E:  MOVFF  01,C84
10712:  MOVFF  00,C83
10716:  RCALL  10000
....................       } 
....................    } 
10718:  GOTO   107FA (RETURN)
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Interpreter: The procedures here are concerned with interpreting 
.................... // received commands and executing the appropriate commands. 
....................  
.................... // Definition of commands. Should follow the prototype: "uint8_t command_name(uint8_t *data)" 
.................... // Return value = 0 indicates that the command was successful 
.................... // Return value > 0 indicates that there was an error 
....................  
.................... // ============ Helper functions ============ 
....................  
.................... // Get access to shared FM 
.................... void get_com_shared_fm_access() 
.................... { 
....................     if (memory_busy) { 
*
08672:  MOVLB  5
08674:  MOVF   x5B,F
08676:  BZ    8690
....................         scheduled_command_clear_specified_command(0xC0, 0x58); // Disable scheduled command to regain access to memory in the future 
08678:  MOVLW  C0
0867A:  MOVLB  C
0867C:  MOVWF  xBE
0867E:  MOVLW  58
08680:  MOVWF  xBF
08682:  MOVLB  0
08684:  CALL   7E00
....................         output_low(MUX_SEL_COM_SHARED_FM);                     // Regain access to memory now 
08688:  BCF    F94.5
0868A:  BCF    F8B.5
....................         memory_busy = 0;                                       // Now memory is free 
0868C:  MOVLB  5
0868E:  CLRF   x5B
....................     } 
08690:  MOVLB  0
08692:  RETURN 0
.................... } 
....................  
.................... uint8_t mux_lock_unlock(uint8_t mux_state, time_t time) 
.................... { 
....................     if (time > 1800L) { // Maximum time that the mux can be reserved is 30 minutes 
*
07EB4:  MOVLB  C
07EB6:  BTFSC  x86.7
07EB8:  BRA    7EF2
07EBA:  MOVF   x86,F
07EBC:  BNZ   7ED2
07EBE:  MOVF   x85,F
07EC0:  BNZ   7ED2
07EC2:  MOVF   x84,W
07EC4:  SUBLW  06
07EC6:  BC    7EF2
07EC8:  XORLW  FF
07ECA:  BNZ   7ED2
07ECC:  MOVF   x83,W
07ECE:  SUBLW  08
07ED0:  BC    7EF2
....................         fprintf(PC, "Warning: mux reservation time too long!"); 
07ED2:  MOVLW  1C
07ED4:  MOVWF  FF6
07ED6:  MOVLW  06
07ED8:  MOVWF  FF7
07EDA:  MOVLW  00
07EDC:  MOVWF  FF8
07EDE:  MOVLB  0
07EE0:  CALL   4534
....................         time = 1800L; 
07EE4:  MOVLB  C
07EE6:  CLRF   x86
07EE8:  CLRF   x85
07EEA:  MOVLW  07
07EEC:  MOVWF  x84
07EEE:  MOVLW  08
07EF0:  MOVWF  x83
....................     } 
....................     if (mux_state) { 
07EF2:  MOVF   x82,F
07EF4:  BZ    7F4C
....................         scheduled_command_clear_specified_command(0xC0, 0x02); // Disable scheduled command to regain access to memory in the future 
07EF6:  MOVLW  C0
07EF8:  MOVWF  xBE
07EFA:  MOVLW  02
07EFC:  MOVWF  xBF
07EFE:  MOVLB  0
07F00:  RCALL  7E00
....................         schedule(current_time + time, { 0xC0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 }); // Release the lock in the future 
07F02:  MOVLW  C0
07F04:  MOVLB  C
07F06:  MOVWF  x87
07F08:  MOVLW  02
07F0A:  MOVWF  x88
07F0C:  CLRF   x89
07F0E:  CLRF   x8A
07F10:  CLRF   x8B
07F12:  CLRF   x8C
07F14:  CLRF   x8D
07F16:  MOVF   x83,W
07F18:  ADDWF  3B,W
07F1A:  MOVWF  x8E
07F1C:  MOVF   x84,W
07F1E:  ADDWFC 3C,W
07F20:  MOVWF  x8F
07F22:  MOVF   x85,W
07F24:  ADDWFC 3D,W
07F26:  MOVWF  x90
07F28:  MOVF   x86,W
07F2A:  ADDWFC 3E,W
07F2C:  MOVWF  x91
07F2E:  MOVWF  x98
07F30:  MOVFF  C90,C97
07F34:  MOVFF  C8F,C96
07F38:  MOVFF  C8E,C95
07F3C:  MOVLW  0C
07F3E:  MOVWF  x9A
07F40:  MOVLW  87
07F42:  MOVWF  x99
07F44:  MOVLB  0
07F46:  CALL   704C
07F4A:  MOVLB  C
....................     } 
....................     mux_lock = mux_state; 
07F4C:  MOVFF  C82,55C
....................     return mux_state; 
07F50:  MOVFF  C82,01
07F54:  MOVLB  0
07F56:  RETURN 0
.................... } 
....................  
.................... uint8_t command_mux_lock_unlock(uint8_t* data) 
07F58:  MOVFF  C39,C3B
07F5C:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mux_state; // 0: unlock, 1: lock 
....................         time_t time;       // in seconds 
....................     }* packet = (struct packet*)data; 
....................  
....................     uart_print_pc_hex(data, 7); 
07F60:  MOVFF  C39,C90
07F64:  MOVFF  C38,C8F
07F68:  MOVLW  07
07F6A:  MOVLB  C
07F6C:  MOVWF  x91
07F6E:  MOVLB  0
07F70:  RCALL  7A5C
....................     return mux_lock_unlock(packet->mux_state, packet->time); 
07F72:  MOVLW  02
07F74:  MOVLB  C
07F76:  ADDWF  x3A,W
07F78:  MOVWF  FE9
07F7A:  MOVLW  00
07F7C:  ADDWFC x3B,W
07F7E:  MOVWF  FEA
07F80:  MOVFF  FEF,C82
07F84:  MOVLW  03
07F86:  ADDWF  x3A,W
07F88:  MOVWF  FE9
07F8A:  MOVLW  00
07F8C:  ADDWFC x3B,W
07F8E:  MOVWF  FEA
07F90:  MOVFF  FEF,C83
07F94:  MOVFF  FEC,C84
07F98:  MOVFF  FEC,C85
07F9C:  MOVFF  FEC,C86
07FA0:  MOVLB  0
07FA2:  RCALL  7EB4
07FA4:  MOVF   01,W
07FA6:  RETURN 0
.................... } 
....................  
.................... uint8_t command_mux_sel_sfm(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Changed MUX to position %d", data[2]); 
*
14E76:  MOVLW  02
14E78:  MOVLB  C
14E7A:  ADDWF  x38,W
14E7C:  MOVWF  FE9
14E7E:  MOVLW  00
14E80:  ADDWFC x39,W
14E82:  MOVWF  FEA
14E84:  MOVFF  FEF,C3A
14E88:  MOVLW  44
14E8A:  MOVWF  FF6
14E8C:  MOVLW  06
14E8E:  MOVWF  FF7
14E90:  MOVLW  00
14E92:  MOVWF  FF8
14E94:  MOVLW  18
14E96:  MOVWF  xC1
14E98:  MOVLB  0
14E9A:  CALL   5290
14E9E:  MOVFF  C3A,CBE
14EA2:  MOVLW  18
14EA4:  MOVLB  C
14EA6:  MOVWF  xBF
14EA8:  MOVLB  0
14EAA:  CALL   73A8
....................     return mux_sel(data[2]); 
14EAE:  MOVLW  02
14EB0:  MOVLB  C
14EB2:  ADDWF  x38,W
14EB4:  MOVWF  FE9
14EB6:  MOVLW  00
14EB8:  ADDWFC x39,W
14EBA:  MOVWF  FEA
14EBC:  MOVFF  FEF,CBE
14EC0:  MOVLB  0
14EC2:  CALL   52E8
14EC6:  MOVF   01,W
14EC8:  GOTO   18EC6 (RETURN)
.................... } 
....................  
.................... // Helper function to calculate OBC checksum 
.................... void checksum_obc(uint8_t* data, uint8_t size) 
*
08E80:  MOVLB  C
08E82:  CLRF   xB1
.................... { 
....................     uint8_t checksum = 0; 
....................     for (uint8_t i = 1; i < size - 2; i++) { 
08E84:  MOVLW  01
08E86:  MOVWF  xB2
08E88:  MOVLW  02
08E8A:  SUBWF  xB0,W
08E8C:  SUBWF  xB2,W
08E8E:  BC    8EA4
....................         checksum ^= data[i]; 
08E90:  MOVF   xB2,W
08E92:  ADDWF  xAE,W
08E94:  MOVWF  FE9
08E96:  MOVLW  00
08E98:  ADDWFC xAF,W
08E9A:  MOVWF  FEA
08E9C:  MOVF   FEF,W
08E9E:  XORWF  xB1,F
08EA0:  INCF   xB2,F
08EA2:  BRA    8E88
....................     } 
....................     data[size - 2] = checksum; 
08EA4:  MOVLW  02
08EA6:  SUBWF  xB0,W
08EA8:  ADDWF  xAE,W
08EAA:  MOVWF  FE9
08EAC:  MOVLW  00
08EAE:  ADDWFC xAF,W
08EB0:  MOVWF  FEA
08EB2:  MOVFF  CB1,FEF
....................     data[size - 1] = data[0] + 1; // Footer 
08EB6:  MOVLW  01
08EB8:  SUBWF  xB0,W
08EBA:  ADDWF  xAE,W
08EBC:  MOVWF  01
08EBE:  MOVLW  00
08EC0:  ADDWFC xAF,W
08EC2:  MOVWF  03
08EC4:  MOVFF  CAE,FE9
08EC8:  MOVFF  CAF,FEA
08ECC:  MOVLW  01
08ECE:  ADDWF  FEF,W
08ED0:  MOVFF  03,FEA
08ED4:  MOVFF  01,FE9
08ED8:  MOVWF  FEF
08EDA:  MOVLB  0
08EDC:  RETURN 0
.................... } 
....................  
.................... // Helper function to check if uplink is valid 
.................... uint8_t uplink_valid(uint8_t* buffer) 
*
0C926:  MOVFF  C5F,C61
0C92A:  MOVFF  C5E,C60
.................... { 
....................     const uint8_t cmd_length = 22;        // Extended packet length 
....................     const uint8_t cmd_legacy_length = 14; // Legacy packet length 
....................  
....................     struct packet { 
....................         uint8_t packet_format_id; 
....................         uint8_t satellite_id; 
....................         uint8_t cmd_format_id; 
....................     }* packet = (struct packet*)buffer; 
....................  
....................     uint16_t cr, pk;                                                                 // these are the crc check variables 
....................     if (packet->packet_format_id == 0x42 && packet->satellite_id == SPACECRAFT_ID) { // This packet is meant for CURTIS 
0C92E:  MOVLB  C
0C930:  MOVFF  C60,FE9
0C934:  MOVFF  C61,FEA
0C938:  MOVF   FEF,W
0C93A:  SUBLW  42
0C93C:  BNZ   C9EA
0C93E:  MOVLW  01
0C940:  ADDWF  x60,W
0C942:  MOVWF  FE9
0C944:  MOVLW  00
0C946:  ADDWFC x61,W
0C948:  MOVWF  FEA
0C94A:  MOVF   FEF,W
0C94C:  SUBLW  53
0C94E:  BNZ   C9EA
....................         if (packet->cmd_format_id == 0xCC) {                                         // Extended KITSUNE format (22 bytes) 
0C950:  MOVLW  02
0C952:  ADDWF  x60,W
0C954:  MOVWF  FE9
0C956:  MOVLW  00
0C958:  ADDWFC x61,W
0C95A:  MOVWF  FEA
0C95C:  MOVF   FEF,W
0C95E:  SUBLW  CC
0C960:  BNZ   C99E
....................             cr = mk_crc(buffer, cmd_length - 2); 
0C962:  MOVFF  C5F,C67
0C966:  MOVFF  C5E,C66
0C96A:  MOVLW  14
0C96C:  MOVWF  x68
0C96E:  MOVLB  0
0C970:  RCALL  C868
0C972:  MOVFF  02,C63
0C976:  MOVFF  01,C62
....................             pk = make16(buffer[cmd_length - 1], buffer[cmd_length - 2]); 
0C97A:  MOVLW  15
0C97C:  MOVLB  C
0C97E:  ADDWF  x5E,W
0C980:  MOVWF  FE9
0C982:  MOVLW  00
0C984:  ADDWFC x5F,W
0C986:  MOVWF  FEA
0C988:  MOVFF  FEF,C65
0C98C:  MOVLW  14
0C98E:  ADDWF  x5E,W
0C990:  MOVWF  FE9
0C992:  MOVLW  00
0C994:  ADDWFC x5F,W
0C996:  MOVWF  FEA
0C998:  MOVFF  FEF,C64
....................         } else { // Herritage BIRDS format (14 bytes) 
0C99C:  BRA    C9D8
....................             cr = mk_crc(buffer, cmd_legacy_length - 2); 
0C99E:  MOVFF  C5F,C67
0C9A2:  MOVFF  C5E,C66
0C9A6:  MOVLW  0C
0C9A8:  MOVWF  x68
0C9AA:  MOVLB  0
0C9AC:  RCALL  C868
0C9AE:  MOVFF  02,C63
0C9B2:  MOVFF  01,C62
....................             pk = make16(buffer[cmd_legacy_length - 1], buffer[cmd_legacy_length - 2]); 
0C9B6:  MOVLW  0D
0C9B8:  MOVLB  C
0C9BA:  ADDWF  x5E,W
0C9BC:  MOVWF  FE9
0C9BE:  MOVLW  00
0C9C0:  ADDWFC x5F,W
0C9C2:  MOVWF  FEA
0C9C4:  MOVFF  FEF,C65
0C9C8:  MOVLW  0C
0C9CA:  ADDWF  x5E,W
0C9CC:  MOVWF  FE9
0C9CE:  MOVLW  00
0C9D0:  ADDWFC x5F,W
0C9D2:  MOVWF  FEA
0C9D4:  MOVFF  FEF,C64
....................         } 
....................         if (cr == pk) { // CRC is good to go 
0C9D8:  MOVF   x64,W
0C9DA:  SUBWF  x62,W
0C9DC:  BNZ   C9EA
0C9DE:  MOVF   x65,W
0C9E0:  SUBWF  x63,W
0C9E2:  BNZ   C9EA
....................             return 1;   // Packet is valid 
0C9E4:  MOVLW  01
0C9E6:  MOVWF  01
0C9E8:  BRA    C9EE
....................         } 
....................     } 
....................     return 0; // Packet is invalid 
0C9EA:  MOVLW  00
0C9EC:  MOVWF  01
0C9EE:  MOVLB  0
0C9F0:  GOTO   CAEE (RETURN)
.................... } 
....................  
.................... // Helper function to send an acknowledge back to COM 
.................... void send_com_ack(uint8_t* data) 
.................... { 
....................     uint8_t cmd[24] = { 0 }; 
*
077A2:  MOVLB  C
077A4:  CLRF   x50
077A6:  CLRF   x51
077A8:  CLRF   x52
077AA:  CLRF   x53
077AC:  CLRF   x54
077AE:  CLRF   x55
077B0:  CLRF   x56
077B2:  CLRF   x57
077B4:  CLRF   x58
077B6:  CLRF   x59
077B8:  CLRF   x5A
077BA:  CLRF   x5B
077BC:  CLRF   x5C
077BE:  CLRF   x5D
077C0:  CLRF   x5E
077C2:  CLRF   x5F
077C4:  CLRF   x60
077C6:  CLRF   x61
077C8:  CLRF   x62
077CA:  CLRF   x63
077CC:  CLRF   x64
077CE:  CLRF   x65
077D0:  CLRF   x66
077D2:  CLRF   x67
....................     cmd[0] = 0x0B; 
077D4:  MOVLW  0B
077D6:  MOVWF  x50
....................     cmd[1] = 0xAA; 
077D8:  MOVLW  AA
077DA:  MOVWF  x51
....................     cmd[2] = 0xCC; 
077DC:  MOVLW  CC
077DE:  MOVWF  x52
....................     memcpy(cmd + 3, data, 8); 
077E0:  MOVLW  0C
077E2:  MOVWF  FEA
077E4:  MOVLW  53
077E6:  MOVWF  FE9
077E8:  MOVFF  C4F,FE2
077EC:  MOVFF  C4E,FE1
077F0:  MOVLW  08
077F2:  MOVWF  01
077F4:  MOVFF  FE6,FEE
077F8:  DECFSZ 01,F
077FA:  BRA    77F4
....................     cmd[12] = 0x66; 
077FC:  MOVLW  66
077FE:  MOVWF  x5C
....................     cmd[23] = 0x0C; 
07800:  MOVLW  0C
07802:  MOVWF  x67
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
07804:  CLRF   x68
07806:  MOVF   x68,W
07808:  SUBLW  17
0780A:  BNC   782C
....................         fputc(cmd[i], COMM); 
0780C:  CLRF   03
0780E:  MOVF   x68,W
07810:  ADDLW  50
07812:  MOVWF  FE9
07814:  MOVLW  0C
07816:  ADDWFC 03,W
07818:  MOVWF  FEA
0781A:  MOVFF  FEF,C69
0781E:  MOVF   x69,W
07820:  MOVLB  0
07822:  CALL   5422
07826:  MOVLB  C
07828:  INCF   x68,F
0782A:  BRA    7806
....................     } 
0782C:  MOVLB  0
0782E:  RETURN 0
.................... } 
....................  
.................... // Helper function to change reset time 
.................... void reset_pic_update_clock(time_t time) 
*
0816A:  MOVLW  0C
0816C:  MOVLB  C
0816E:  MOVWF  x84
08170:  MOVLW  4F
08172:  MOVWF  x83
08174:  MOVLB  0
08176:  CALL   4D28
0817A:  MOVFF  02,C54
0817E:  MOVFF  01,C53
.................... { 
....................     struct_tm* tstr = localtime(&time); 
....................     struct rst_msg { 
....................         uint8_t rst_command; 
....................         uint8_t year; 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................     } msg; 
....................  
....................     msg.rst_command = 0x70; 
08182:  MOVLW  70
08184:  MOVLB  C
08186:  MOVWF  x55
....................     msg.year = tstr->tm_year - 100; 
08188:  MOVLW  05
0818A:  ADDWF  x53,W
0818C:  MOVWF  FE9
0818E:  MOVLW  00
08190:  ADDWFC x54,W
08192:  MOVWF  FEA
08194:  MOVFF  FEC,C84
08198:  MOVF   FED,F
0819A:  MOVFF  FEF,C83
0819E:  MOVLW  64
081A0:  SUBWF  x83,W
081A2:  MOVWF  x56
....................     msg.month = tstr->tm_mon + 1; 
081A4:  MOVLW  04
081A6:  ADDWF  x53,W
081A8:  MOVWF  FE9
081AA:  MOVLW  00
081AC:  ADDWFC x54,W
081AE:  MOVWF  FEA
081B0:  MOVLW  01
081B2:  ADDWF  FEF,W
081B4:  MOVWF  x57
....................     msg.day = tstr->tm_mday; 
081B6:  MOVLW  03
081B8:  ADDWF  x53,W
081BA:  MOVWF  FE9
081BC:  MOVLW  00
081BE:  ADDWFC x54,W
081C0:  MOVWF  FEA
081C2:  MOVFF  FEF,C58
....................     msg.hour = tstr->tm_hour; 
081C6:  MOVLW  02
081C8:  ADDWF  x53,W
081CA:  MOVWF  FE9
081CC:  MOVLW  00
081CE:  ADDWFC x54,W
081D0:  MOVWF  FEA
081D2:  MOVFF  FEF,C59
....................     msg.minute = tstr->tm_min; 
081D6:  MOVLW  01
081D8:  ADDWF  x53,W
081DA:  MOVWF  FE9
081DC:  MOVLW  00
081DE:  ADDWFC x54,W
081E0:  MOVWF  FEA
081E2:  MOVFF  FEF,C5A
....................     msg.second = tstr->tm_sec; 
081E6:  MOVFF  C53,FE9
081EA:  MOVFF  C54,FEA
081EE:  MOVFF  FEF,C5B
....................  
....................     uint8_t i; 
....................     uint8_t cmd[36] = { 0 }; 
081F2:  CLRF   x5D
081F4:  CLRF   x5E
081F6:  CLRF   x5F
081F8:  CLRF   x60
081FA:  CLRF   x61
081FC:  CLRF   x62
081FE:  CLRF   x63
08200:  CLRF   x64
08202:  CLRF   x65
08204:  CLRF   x66
08206:  CLRF   x67
08208:  CLRF   x68
0820A:  CLRF   x69
0820C:  CLRF   x6A
0820E:  CLRF   x6B
08210:  CLRF   x6C
08212:  CLRF   x6D
08214:  CLRF   x6E
08216:  CLRF   x6F
08218:  CLRF   x70
0821A:  CLRF   x71
0821C:  CLRF   x72
0821E:  CLRF   x73
08220:  CLRF   x74
08222:  CLRF   x75
08224:  CLRF   x76
08226:  CLRF   x77
08228:  CLRF   x78
0822A:  CLRF   x79
0822C:  CLRF   x7A
0822E:  CLRF   x7B
08230:  CLRF   x7C
08232:  CLRF   x7D
08234:  CLRF   x7E
08236:  CLRF   x7F
08238:  CLRF   x80
....................     cmd[0] = 0xB0; 
0823A:  MOVLW  B0
0823C:  MOVWF  x5D
....................     uint8_t* ptr = (uint8_t*)&msg; 
0823E:  MOVLW  0C
08240:  MOVWF  x84
08242:  MOVLW  55
08244:  MOVFF  C84,C82
08248:  MOVWF  x81
....................     for (i = 0; i < sizeof(msg); i++) { 
0824A:  CLRF   x5C
0824C:  MOVF   x5C,W
0824E:  SUBLW  06
08250:  BNC   8280
....................         cmd[i + 1] = ptr[i]; 
08252:  MOVLW  01
08254:  ADDWF  x5C,W
08256:  CLRF   03
08258:  ADDLW  5D
0825A:  MOVWF  01
0825C:  MOVLW  0C
0825E:  ADDWFC 03,F
08260:  MOVF   x5C,W
08262:  ADDWF  x81,W
08264:  MOVWF  FE9
08266:  MOVLW  00
08268:  ADDWFC x82,W
0826A:  MOVWF  FEA
0826C:  MOVFF  FEF,C85
08270:  MOVFF  03,FEA
08274:  MOVFF  01,FE9
08278:  MOVFF  C85,FEF
0827C:  INCF   x5C,F
0827E:  BRA    824C
....................     } 
....................     cmd[35] = 0xB1; 
08280:  MOVLW  B1
08282:  MOVWF  x80
....................     for (i = 0; i < sizeof(cmd); i++) { 
08284:  CLRF   x5C
08286:  MOVF   x5C,W
08288:  SUBLW  23
0828A:  BNC   82AC
....................         fputc(cmd[i], RST); 
0828C:  CLRF   03
0828E:  MOVF   x5C,W
08290:  ADDLW  5D
08292:  MOVWF  FE9
08294:  MOVLW  0C
08296:  ADDWFC 03,W
08298:  MOVWF  FEA
0829A:  MOVFF  FEF,C83
0829E:  MOVF   x83,W
082A0:  MOVLB  0
082A2:  CALL   544E
082A6:  MOVLB  C
082A8:  INCF   x5C,F
082AA:  BRA    8286
....................     } 
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
082AC:  MOVLW  0C
082AE:  MOVWF  x90
082B0:  MOVLW  5D
082B2:  MOVWF  x8F
082B4:  MOVLW  24
082B6:  MOVWF  x91
082B8:  MOVLB  0
082BA:  CALL   7A5C
082BE:  RETURN 0
.................... } 
....................  
.................... // Helper function to print binary data 
.................... void print_binary16(uint16_t data) 
.................... { 
....................     const uint8_t size = 16; 
....................     for (uint8_t i = 1; i <= size; i++) { 
*
12BF8:  MOVLW  01
12BFA:  MOVLB  C
12BFC:  MOVWF  x3D
12BFE:  MOVF   x3D,W
12C00:  SUBLW  10
12C02:  BNC   12C40
....................         fprintf(PC, "%Lu", ((data >> (size - i)) & 1)); 
12C04:  MOVLW  10
12C06:  BSF    FD8.0
12C08:  SUBFWB x3D,W
12C0A:  MOVWF  00
12C0C:  MOVFF  C3C,C3F
12C10:  MOVFF  C3B,C3E
12C14:  MOVF   00,F
12C16:  BZ    12C22
12C18:  BCF    FD8.0
12C1A:  RRCF   x3F,F
12C1C:  RRCF   x3E,F
12C1E:  DECFSZ 00,F
12C20:  BRA    12C18
12C22:  MOVLW  01
12C24:  ANDWF  x3E,F
12C26:  CLRF   x3F
12C28:  MOVLW  10
12C2A:  MOVWF  FE9
12C2C:  MOVFF  C3F,C76
12C30:  MOVFF  C3E,C75
12C34:  MOVLB  0
12C36:  CALL   59CA
12C3A:  MOVLB  C
12C3C:  INCF   x3D,F
12C3E:  BRA    12BFE
....................     } 
12C40:  MOVLB  0
12C42:  RETURN 0
.................... } 
....................  
.................... // Helper funtion to initialize the telemetry array. 
.................... void initialize_telemetry() 
.................... { 
....................     memset(&telemetry_time, 0, sizeof(telemetry_time)); 
*
0523C:  CLRF   FEA
0523E:  MOVLW  DB
05240:  MOVWF  FE9
05242:  CLRF   00
05244:  CLRF   02
05246:  MOVLW  18
05248:  MOVWF  01
0524A:  RCALL  5222
....................     memset(&telemetry, 0, sizeof(telemetry)); 
0524C:  CLRF   FEA
0524E:  MOVLW  43
05250:  MOVWF  FE9
05252:  CLRF   00
05254:  CLRF   02
05256:  MOVLW  98
05258:  MOVWF  01
0525A:  RCALL  5222
....................     telemetry.master_footer[0] = 0xB0; 
0525C:  MOVLW  B0
0525E:  MOVWF  xD9
....................     telemetry.master_footer[1] = 0x0B; 
05260:  MOVLW  0B
05262:  MOVWF  xDA
05264:  RETURN 0
.................... } 
....................  
.................... // Convert gyro data 16 -> 8 bits (-128 to 127 with LSB = 1deg/s, with overflow protection) 
.................... int8_t gyro_to_cw(uint8_t msb, uint8_t lsb) 
*
152B6:  MOVFF  C5A,C62
152BA:  MOVFF  C5B,C61
152BE:  MOVFF  C5A,C9A
152C2:  MOVFF  C5B,C99
152C6:  CALL   FA96
152CA:  MOVFF  03,C9F
152CE:  MOVFF  02,C9E
152D2:  MOVFF  01,C9D
152D6:  MOVFF  00,C9C
152DA:  MOVLB  C
152DC:  CLRF   xA3
152DE:  CLRF   xA2
152E0:  MOVLW  03
152E2:  MOVWF  xA1
152E4:  MOVLW  86
152E6:  MOVWF  xA0
152E8:  MOVLB  0
152EA:  CALL   F0A2
152EE:  MOVFF  03,C60
152F2:  MOVFF  02,C5F
152F6:  MOVFF  01,C5E
152FA:  MOVFF  00,C5D
.................... { 
....................     int8_t gyro_cw; 
....................     float gyro = ((int16_t)make16(msb, lsb)) / 131.; 
....................     if (gyro > 127.) { 
152FE:  MOVLB  C
15300:  CLRF   xA6
15302:  CLRF   xA5
15304:  MOVLW  7E
15306:  MOVWF  xA4
15308:  MOVLW  85
1530A:  MOVWF  xA3
1530C:  MOVFF  C60,CAA
15310:  MOVFF  C5F,CA9
15314:  MOVFF  C5E,CA8
15318:  MOVFF  C5D,CA7
1531C:  MOVLB  0
1531E:  CALL   F028
15322:  BNC   1532C
....................         gyro_cw = 127; 
15324:  MOVLW  7F
15326:  MOVLB  C
15328:  MOVWF  x5C
....................     } else if (gyro < -128.) { 
1532A:  BRA    153FA
1532C:  MOVFF  C60,CA6
15330:  MOVFF  C5F,CA5
15334:  MOVFF  C5E,CA4
15338:  MOVFF  C5D,CA3
1533C:  MOVLB  C
1533E:  CLRF   xAA
15340:  CLRF   xA9
15342:  MOVLW  80
15344:  MOVWF  xA8
15346:  MOVLW  86
15348:  MOVWF  xA7
1534A:  MOVLB  0
1534C:  CALL   F028
15350:  BNC   1535C
....................         gyro_cw = -128; 
15352:  MOVLW  80
15354:  MOVLB  C
15356:  MOVWF  x5C
....................     } else { 
15358:  BRA    153FA
1535A:  MOVLB  0
....................         if (gyro > 0.) { 
1535C:  MOVLB  C
1535E:  CLRF   xA6
15360:  CLRF   xA5
15362:  CLRF   xA4
15364:  CLRF   xA3
15366:  MOVFF  C60,CAA
1536A:  MOVFF  C5F,CA9
1536E:  MOVFF  C5E,CA8
15372:  MOVFF  C5D,CA7
15376:  MOVLB  0
15378:  CALL   F028
1537C:  BNC   153BC
....................             gyro_cw = (int8_t)(gyro + 0.5); 
1537E:  BCF    FD8.1
15380:  MOVFF  C60,CAA
15384:  MOVFF  C5F,CA9
15388:  MOVFF  C5E,CA8
1538C:  MOVFF  C5D,CA7
15390:  MOVLB  C
15392:  CLRF   xAE
15394:  CLRF   xAD
15396:  CLRF   xAC
15398:  MOVLW  7E
1539A:  MOVWF  xAB
1539C:  MOVLB  0
1539E:  CALL   F332
153A2:  MOVFF  03,CA6
153A6:  MOVFF  02,CA5
153AA:  MOVFF  01,CA4
153AE:  MOVFF  00,CA3
153B2:  CALL   F200
153B6:  MOVFF  01,C5C
....................         } else { 
153BA:  BRA    153F8
....................             gyro_cw = (int8_t)(gyro - 0.5); 
153BC:  BSF    FD8.1
153BE:  MOVFF  C60,CAA
153C2:  MOVFF  C5F,CA9
153C6:  MOVFF  C5E,CA8
153CA:  MOVFF  C5D,CA7
153CE:  MOVLB  C
153D0:  CLRF   xAE
153D2:  CLRF   xAD
153D4:  CLRF   xAC
153D6:  MOVLW  7E
153D8:  MOVWF  xAB
153DA:  MOVLB  0
153DC:  CALL   F332
153E0:  MOVFF  03,CA6
153E4:  MOVFF  02,CA5
153E8:  MOVFF  01,CA4
153EC:  MOVFF  00,CA3
153F0:  CALL   F200
153F4:  MOVFF  01,C5C
153F8:  MOVLB  C
....................         } 
....................     } 
....................     return gyro_cw; 
153FA:  MOVFF  C5C,01
153FE:  MOVLB  0
15400:  RETURN 0
.................... } 
....................  
.................... // Conversion for CW beacon in the range 0-15 
.................... uint8_t get_adcs_mode_index(uint8_t adcs_mode) { 
....................     switch (adcs_mode) { 
*
15234:  MOVLB  C
15236:  MOVF   x5A,W
15238:  XORLW  00
1523A:  MOVLB  0
1523C:  BZ    1527C
1523E:  XORLW  01
15240:  BZ    1527C
15242:  XORLW  03
15244:  BZ    1527C
15246:  XORLW  01
15248:  BZ    1527C
1524A:  XORLW  07
1524C:  BZ    1527C
1524E:  XORLW  0E
15250:  BZ    15286
15252:  XORLW  01
15254:  BZ    15286
15256:  XORLW  07
15258:  BZ    15286
1525A:  XORLW  01
1525C:  BZ    15286
1525E:  XORLW  19
15260:  BZ    15292
15262:  XORLW  01
15264:  BZ    15292
15266:  XORLW  0C
15268:  BZ    1529E
1526A:  XORLW  03
1526C:  BZ    1529E
1526E:  XORLW  01
15270:  BZ    1529E
15272:  XORLW  07
15274:  BZ    1529E
15276:  XORLW  01
15278:  BZ    1529E
1527A:  BRA    152AA
....................         case 0: 
....................         case 1: 
....................         case 2: 
....................         case 3: 
....................         case 4: 
....................             return adcs_mode;  // Direct mapping for 0 to 4 
1527C:  MOVLB  C
1527E:  MOVFF  C5A,01
15282:  BRA    152B0
15284:  MOVLB  0
....................         case 10: 
....................         case 11: 
....................         case 12: 
....................         case 13: 
....................             return adcs_mode - 5;  // Adjust for 10 to 13 
15286:  MOVLW  05
15288:  MOVLB  C
1528A:  SUBWF  x5A,W
1528C:  MOVWF  01
1528E:  BRA    152B0
15290:  MOVLB  0
....................         case 20: 
....................         case 21: 
....................             return adcs_mode - 11; // Adjust for 20 to 21 
15292:  MOVLW  0B
15294:  MOVLB  C
15296:  SUBWF  x5A,W
15298:  MOVWF  01
1529A:  BRA    152B0
1529C:  MOVLB  0
....................         case 25: 
....................         case 26: 
....................         case 27: 
....................         case 28: 
....................         case 29: 
....................             return adcs_mode - 14; // Adjust for 25 to 28 
1529E:  MOVLW  0E
152A0:  MOVLB  C
152A2:  SUBWF  x5A,W
152A4:  MOVWF  01
152A6:  BRA    152B0
152A8:  MOVLB  0
....................         default: 
....................             return 0; // Return 0 if the mode is out of range or not mapped 
152AA:  MOVLW  00
152AC:  MOVWF  01
152AE:  MOVLB  C
....................     } 
152B0:  MOVLB  0
152B2:  GOTO   158BE (RETURN)
.................... } 
....................  
.................... // Helper function for data serialization 
.................... void set_bits(uint8_t *data, uint32_t value, uint16_t *bit_offset, uint8_t bits) { 
....................     while (bits > 0) { 
*
15144:  MOVLB  C
15146:  MOVF   x64,F
15148:  BTFSC  FD8.2
1514A:  BRA    15230
....................         uint8_t byte_offset = *bit_offset / 8; 
....................         uint8_t bit_in_byte_offset = *bit_offset % 8; 
....................         uint8_t bits_to_write = (bits > 8 - bit_in_byte_offset) ? 8 - bit_in_byte_offset : bits; 
1514C:  MOVFF  C62,FE9
15150:  MOVFF  C63,FEA
15154:  MOVFF  FEC,C69
15158:  MOVF   FED,F
1515A:  MOVFF  FEF,C68
1515E:  RRCF   x69,W
15160:  MOVWF  03
15162:  RRCF   x68,W
15164:  MOVWF  02
15166:  RRCF   03,F
15168:  RRCF   02,F
1516A:  RRCF   03,F
1516C:  RRCF   02,F
1516E:  MOVFF  02,C65
15172:  MOVFF  C63,03
15176:  MOVFF  C62,FE9
1517A:  MOVFF  C63,FEA
1517E:  MOVFF  FEC,C69
15182:  MOVF   FED,F
15184:  MOVFF  FEF,C68
15188:  MOVF   x68,W
1518A:  ANDLW  07
1518C:  MOVWF  x66
1518E:  MOVLW  08
15190:  BSF    FD8.0
15192:  SUBFWB x66,W
15194:  SUBWF  x64,W
15196:  BZ    151A2
15198:  BNC   151A2
1519A:  MOVLW  08
1519C:  BSF    FD8.0
1519E:  SUBFWB x66,W
151A0:  BRA    151A4
151A2:  MOVF   x64,W
151A4:  MOVWF  x67
....................  
....................         data[byte_offset] |= ((value & ((1U << bits_to_write) - 1U)) << bit_in_byte_offset); 
151A6:  MOVF   x65,W
151A8:  ADDWF  x5C,W
151AA:  MOVWF  FE9
151AC:  MOVLW  00
151AE:  ADDWFC x5D,W
151B0:  MOVWF  FEA
151B2:  MOVLW  01
151B4:  MOVWF  00
151B6:  MOVF   x67,W
151B8:  MOVWF  01
151BA:  BZ    151C4
151BC:  BCF    FD8.0
151BE:  RLCF   00,F
151C0:  DECFSZ 01,F
151C2:  BRA    151BC
151C4:  MOVF   00,W
151C6:  ADDLW  FF
151C8:  ANDWF  x5E,W
151CA:  MOVWF  x6B
151CC:  CLRF   x6C
151CE:  CLRF   x6D
151D0:  CLRF   x6E
151D2:  MOVFF  C6E,03
151D6:  MOVFF  C6D,02
151DA:  MOVFF  C6C,01
151DE:  MOVWF  00
151E0:  MOVF   x66,W
151E2:  MOVWF  x6F
151E4:  BZ    151F4
151E6:  BCF    FD8.0
151E8:  RLCF   00,F
151EA:  RLCF   01,F
151EC:  RLCF   02,F
151EE:  RLCF   03,F
151F0:  DECFSZ x6F,F
151F2:  BRA    151E6
151F4:  MOVF   00,W
151F6:  IORWF  FEF,W
151F8:  MOVWF  FEF
....................  
....................         value >>= bits_to_write; 
151FA:  MOVF   x67,W
151FC:  MOVWF  x68
151FE:  BZ    1520E
15200:  BCF    FD8.0
15202:  RRCF   x61,F
15204:  RRCF   x60,F
15206:  RRCF   x5F,F
15208:  RRCF   x5E,F
1520A:  DECFSZ x68,F
1520C:  BRA    15200
....................         bits -= bits_to_write; 
1520E:  MOVF   x67,W
15210:  SUBWF  x64,F
....................         *bit_offset += bits_to_write; 
15212:  MOVFF  C62,FE9
15216:  MOVFF  C63,FEA
1521A:  MOVF   x67,W
1521C:  ADDWF  FEF,W
1521E:  MOVWF  01
15220:  MOVLW  00
15222:  ADDWFC FEC,W
15224:  MOVWF  03
15226:  MOVF   FED,F
15228:  MOVFF  01,FEF
1522C:  MOVWF  FEC
1522E:  BRA    15146
....................     } 
15230:  MOVLB  0
15232:  RETURN 0
.................... } 
....................  
.................... // Helper function for data deserialization 
.................... uint32_t get_bits(uint8_t *data, uint16_t *bit_offset, uint8_t bits) { 
*
0EED4:  MOVLB  C
0EED6:  CLRF   x7F
0EED8:  CLRF   x7E
0EEDA:  CLRF   x7D
0EEDC:  CLRF   x7C
0EEDE:  CLRF   x80
....................     uint32_t value = 0; 
....................     uint8_t value_offset = 0; 
....................  
....................     while (bits > 0) { 
0EEE0:  MOVF   x7B,F
0EEE2:  BTFSC  FD8.2
0EEE4:  BRA    EFDE
....................         uint8_t byte_offset = *bit_offset / 8; 
....................         uint8_t bit_in_byte_offset = *bit_offset % 8; 
....................         uint8_t bits_to_read = (bits > 8 - bit_in_byte_offset) ? 8 - bit_in_byte_offset : bits; 
0EEE6:  MOVFF  C79,FE9
0EEEA:  MOVFF  C7A,FEA
0EEEE:  MOVFF  FEC,C85
0EEF2:  MOVF   FED,F
0EEF4:  MOVFF  FEF,C84
0EEF8:  RRCF   x85,W
0EEFA:  MOVWF  03
0EEFC:  RRCF   x84,W
0EEFE:  MOVWF  02
0EF00:  RRCF   03,F
0EF02:  RRCF   02,F
0EF04:  RRCF   03,F
0EF06:  RRCF   02,F
0EF08:  MOVFF  02,C81
0EF0C:  MOVFF  C7A,03
0EF10:  MOVFF  C79,FE9
0EF14:  MOVFF  C7A,FEA
0EF18:  MOVFF  FEC,C85
0EF1C:  MOVF   FED,F
0EF1E:  MOVFF  FEF,C84
0EF22:  MOVF   x84,W
0EF24:  ANDLW  07
0EF26:  MOVWF  x82
0EF28:  MOVLW  08
0EF2A:  BSF    FD8.0
0EF2C:  SUBFWB x82,W
0EF2E:  SUBWF  x7B,W
0EF30:  BZ    EF3C
0EF32:  BNC   EF3C
0EF34:  MOVLW  08
0EF36:  BSF    FD8.0
0EF38:  SUBFWB x82,W
0EF3A:  BRA    EF3E
0EF3C:  MOVF   x7B,W
0EF3E:  MOVWF  x83
....................  
....................         value |= ((uint32_t)(data[byte_offset] >> bit_in_byte_offset) & ((1U << bits_to_read) - 1U)) << value_offset; 
0EF40:  MOVF   x81,W
0EF42:  ADDWF  x77,W
0EF44:  MOVWF  FE9
0EF46:  MOVLW  00
0EF48:  ADDWFC x78,W
0EF4A:  MOVWF  FEA
0EF4C:  MOVFF  FEF,00
0EF50:  MOVF   x82,W
0EF52:  MOVWF  01
0EF54:  BZ    EF5E
0EF56:  BCF    FD8.0
0EF58:  RRCF   00,F
0EF5A:  DECFSZ 01,F
0EF5C:  BRA    EF56
0EF5E:  MOVF   00,W
0EF60:  CLRF   x87
0EF62:  CLRF   x86
0EF64:  CLRF   x85
0EF66:  MOVWF  x84
0EF68:  MOVLW  01
0EF6A:  MOVWF  00
0EF6C:  MOVF   x83,W
0EF6E:  MOVWF  01
0EF70:  BZ    EF7A
0EF72:  BCF    FD8.0
0EF74:  RLCF   00,F
0EF76:  DECFSZ 01,F
0EF78:  BRA    EF72
0EF7A:  MOVF   00,W
0EF7C:  ADDLW  FF
0EF7E:  ANDWF  x84,F
0EF80:  CLRF   x85
0EF82:  CLRF   x86
0EF84:  CLRF   x87
0EF86:  MOVFF  C87,03
0EF8A:  MOVFF  C86,02
0EF8E:  MOVFF  C85,01
0EF92:  MOVFF  C84,00
0EF96:  MOVF   x80,W
0EF98:  MOVWF  x89
0EF9A:  BZ    EFAA
0EF9C:  BCF    FD8.0
0EF9E:  RLCF   00,F
0EFA0:  RLCF   01,F
0EFA2:  RLCF   02,F
0EFA4:  RLCF   03,F
0EFA6:  DECFSZ x89,F
0EFA8:  BRA    EF9C
0EFAA:  MOVF   00,W
0EFAC:  IORWF  x7C,F
0EFAE:  MOVF   01,W
0EFB0:  IORWF  x7D,F
0EFB2:  MOVF   02,W
0EFB4:  IORWF  x7E,F
0EFB6:  MOVF   03,W
0EFB8:  IORWF  x7F,F
....................  
....................         bits -= bits_to_read; 
0EFBA:  MOVF   x83,W
0EFBC:  SUBWF  x7B,F
....................         *bit_offset += bits_to_read; 
0EFBE:  MOVFF  C79,FE9
0EFC2:  MOVFF  C7A,FEA
0EFC6:  MOVF   x83,W
0EFC8:  ADDWF  FEF,W
0EFCA:  MOVWF  01
0EFCC:  MOVLW  00
0EFCE:  ADDWFC FEC,W
0EFD0:  MOVF   FED,F
0EFD2:  MOVFF  01,FEF
0EFD6:  MOVWF  FEC
....................         value_offset += bits_to_read; 
0EFD8:  MOVF   x83,W
0EFDA:  ADDWF  x80,F
0EFDC:  BRA    EEE0
....................     } 
....................  
....................     return value; 
0EFDE:  MOVFF  C7C,00
0EFE2:  MOVFF  C7D,01
0EFE6:  MOVFF  C7E,02
0EFEA:  MOVFF  C7F,03
0EFEE:  MOVLB  0
0EFF0:  RETURN 0
.................... } 
....................  
.................... void deserialize_cw() 
*
15B1C:  MOVLB  C
15B1E:  CLRF   x4F
15B20:  CLRF   x4E
15B22:  CLRF   x78
15B24:  MOVLW  F3
15B26:  MOVWF  x77
15B28:  MOVLW  0C
15B2A:  MOVWF  x7A
15B2C:  MOVLW  4E
15B2E:  MOVWF  x79
15B30:  MOVLW  08
15B32:  MOVWF  x7B
15B34:  MOVLB  0
15B36:  CALL   EED4
15B3A:  MOVFF  00,C50
15B3E:  MOVLB  C
15B40:  CLRF   x78
15B42:  MOVLW  F3
15B44:  MOVWF  x77
15B46:  MOVLW  0C
15B48:  MOVWF  x7A
15B4A:  MOVLW  4E
15B4C:  MOVWF  x79
15B4E:  MOVLW  08
15B50:  MOVWF  x7B
15B52:  MOVLB  0
15B54:  CALL   EED4
15B58:  MOVFF  00,C51
15B5C:  MOVLB  C
15B5E:  CLRF   x78
15B60:  MOVLW  F3
15B62:  MOVWF  x77
15B64:  MOVLW  0C
15B66:  MOVWF  x7A
15B68:  MOVLW  4E
15B6A:  MOVWF  x79
15B6C:  MOVLW  08
15B6E:  MOVWF  x7B
15B70:  MOVLB  0
15B72:  CALL   EED4
15B76:  MOVFF  00,C52
15B7A:  MOVLB  C
15B7C:  CLRF   x78
15B7E:  MOVLW  F3
15B80:  MOVWF  x77
15B82:  MOVLW  0C
15B84:  MOVWF  x7A
15B86:  MOVLW  4E
15B88:  MOVWF  x79
15B8A:  MOVLW  08
15B8C:  MOVWF  x7B
15B8E:  MOVLB  0
15B90:  CALL   EED4
15B94:  MOVFF  00,C53
15B98:  MOVLB  C
15B9A:  CLRF   x78
15B9C:  MOVLW  F3
15B9E:  MOVWF  x77
15BA0:  MOVLW  0C
15BA2:  MOVWF  x7A
15BA4:  MOVLW  4E
15BA6:  MOVWF  x79
15BA8:  MOVLW  01
15BAA:  MOVWF  x7B
15BAC:  MOVLB  0
15BAE:  CALL   EED4
15BB2:  MOVFF  00,C54
15BB6:  MOVLB  C
15BB8:  CLRF   x78
15BBA:  MOVLW  F3
15BBC:  MOVWF  x77
15BBE:  MOVLW  0C
15BC0:  MOVWF  x7A
15BC2:  MOVLW  4E
15BC4:  MOVWF  x79
15BC6:  MOVLW  01
15BC8:  MOVWF  x7B
15BCA:  MOVLB  0
15BCC:  CALL   EED4
15BD0:  MOVFF  00,C55
15BD4:  MOVLB  C
15BD6:  CLRF   x78
15BD8:  MOVLW  F3
15BDA:  MOVWF  x77
15BDC:  MOVLW  0C
15BDE:  MOVWF  x7A
15BE0:  MOVLW  4E
15BE2:  MOVWF  x79
15BE4:  MOVLW  01
15BE6:  MOVWF  x7B
15BE8:  MOVLB  0
15BEA:  CALL   EED4
15BEE:  MOVFF  00,C56
15BF2:  MOVLB  C
15BF4:  CLRF   x78
15BF6:  MOVLW  F3
15BF8:  MOVWF  x77
15BFA:  MOVLW  0C
15BFC:  MOVWF  x7A
15BFE:  MOVLW  4E
15C00:  MOVWF  x79
15C02:  MOVLW  01
15C04:  MOVWF  x7B
15C06:  MOVLB  0
15C08:  CALL   EED4
15C0C:  MOVFF  00,C57
15C10:  MOVLB  C
15C12:  CLRF   x78
15C14:  MOVLW  F3
15C16:  MOVWF  x77
15C18:  MOVLW  0C
15C1A:  MOVWF  x7A
15C1C:  MOVLW  4E
15C1E:  MOVWF  x79
15C20:  MOVLW  01
15C22:  MOVWF  x7B
15C24:  MOVLB  0
15C26:  CALL   EED4
15C2A:  MOVFF  00,C58
15C2E:  MOVLB  C
15C30:  CLRF   x78
15C32:  MOVLW  F3
15C34:  MOVWF  x77
15C36:  MOVLW  0C
15C38:  MOVWF  x7A
15C3A:  MOVLW  4E
15C3C:  MOVWF  x79
15C3E:  MOVLW  01
15C40:  MOVWF  x7B
15C42:  MOVLB  0
15C44:  CALL   EED4
15C48:  MOVFF  00,C59
15C4C:  MOVLB  C
15C4E:  CLRF   x78
15C50:  MOVLW  F3
15C52:  MOVWF  x77
15C54:  MOVLW  0C
15C56:  MOVWF  x7A
15C58:  MOVLW  4E
15C5A:  MOVWF  x79
15C5C:  MOVLW  02
15C5E:  MOVWF  x7B
15C60:  MOVLB  0
15C62:  CALL   EED4
15C66:  MOVFF  00,C5A
15C6A:  MOVLB  C
15C6C:  CLRF   x78
15C6E:  MOVLW  F3
15C70:  MOVWF  x77
15C72:  MOVLW  0C
15C74:  MOVWF  x7A
15C76:  MOVLW  4E
15C78:  MOVWF  x79
15C7A:  MOVLW  01
15C7C:  MOVWF  x7B
15C7E:  MOVLB  0
15C80:  CALL   EED4
15C84:  MOVFF  00,C5B
15C88:  MOVLB  C
15C8A:  CLRF   x78
15C8C:  MOVLW  F3
15C8E:  MOVWF  x77
15C90:  MOVLW  0C
15C92:  MOVWF  x7A
15C94:  MOVLW  4E
15C96:  MOVWF  x79
15C98:  MOVLW  01
15C9A:  MOVWF  x7B
15C9C:  MOVLB  0
15C9E:  CALL   EED4
15CA2:  MOVFF  00,C5C
15CA6:  MOVLB  C
15CA8:  CLRF   x78
15CAA:  MOVLW  F3
15CAC:  MOVWF  x77
15CAE:  MOVLW  0C
15CB0:  MOVWF  x7A
15CB2:  MOVLW  4E
15CB4:  MOVWF  x79
15CB6:  MOVLW  01
15CB8:  MOVWF  x7B
15CBA:  MOVLB  0
15CBC:  CALL   EED4
15CC0:  MOVFF  00,C5D
15CC4:  MOVLB  C
15CC6:  CLRF   x78
15CC8:  MOVLW  F3
15CCA:  MOVWF  x77
15CCC:  MOVLW  0C
15CCE:  MOVWF  x7A
15CD0:  MOVLW  4E
15CD2:  MOVWF  x79
15CD4:  MOVLW  04
15CD6:  MOVWF  x7B
15CD8:  MOVLB  0
15CDA:  CALL   EED4
15CDE:  MOVFF  00,C5E
15CE2:  MOVLB  C
15CE4:  CLRF   x78
15CE6:  MOVLW  F3
15CE8:  MOVWF  x77
15CEA:  MOVLW  0C
15CEC:  MOVWF  x7A
15CEE:  MOVLW  4E
15CF0:  MOVWF  x79
15CF2:  MOVLW  01
15CF4:  MOVWF  x7B
15CF6:  MOVLB  0
15CF8:  CALL   EED4
15CFC:  MOVFF  00,C5F
.................... { 
....................     uint16_t bit_offset = 0; 
....................  
....................     // Page 0 Deserialization 
....................     uint8_t battery_voltage = get_bits(cw[0], &bit_offset, 8);                 // Battery Voltage (RST RAW voltage) 
....................     uint8_t battery_current = get_bits(cw[0], &bit_offset, 8);                 // Battery Current 
....................     uint8_t battery_temperature = get_bits(cw[0], &bit_offset, 8);             // Battery Temperature 
....................     uint8_t cpld_temperature = get_bits(cw[0], &bit_offset, 8);                // CPLD Temperature 
....................     uint8_t solar_cell_sap_z_plus_y_undepl = get_bits(cw[0], &bit_offset, 1);  // Solar Cell SAP +Z (+Y undepl.) 
....................     uint8_t solar_cell_y_plus = get_bits(cw[0], &bit_offset, 1);               // Solar Cell +Y 
....................     uint8_t solar_cell_x_plus = get_bits(cw[0], &bit_offset, 1);               // Solar Cell +X 
....................     uint8_t solar_cell_y_minus = get_bits(cw[0], &bit_offset, 1);              // Solar Cell -Y 
....................     uint8_t solar_cell_sap_z_minus_y_undepl = get_bits(cw[0], &bit_offset, 1); // Solar Cell SAP +Z (-Y undepl.) 
....................     uint8_t solar_cell_z_minus = get_bits(cw[0], &bit_offset, 1);              // Solar Cell -Z 
....................     uint8_t scheduled_commands = get_bits(cw[0], &bit_offset, 2);              // Scheduled commands in memory 
....................     uint8_t battery_heater_flag = get_bits(cw[0], &bit_offset, 1);             // Battery Heater Flag 
....................     uint8_t kill_switch_main_pic = get_bits(cw[0], &bit_offset, 1);            // Kill Switch Main PIC 
....................     uint8_t kill_switch_eps = get_bits(cw[0], &bit_offset, 1);                 // Kill Switch EPS 
....................     uint8_t adcs_mode = get_bits(cw[0], &bit_offset, 4);                       // ADCS mode 
....................     uint8_t format_identifier_0 = get_bits(cw[0], &bit_offset, 1);             // Format identifier 
....................  
....................     fprintf(PC, "Page 0 Deserialized Data:\r\n"); 
15D00:  MOVLW  60
15D02:  MOVWF  FF6
15D04:  MOVLW  06
15D06:  MOVWF  FF7
15D08:  MOVLW  00
15D0A:  MOVWF  FF8
15D0C:  CALL   4534
....................     fprintf(PC, "Battery Voltage (RST RAW voltage): %u\r\n", battery_voltage); 
15D10:  MOVLW  7C
15D12:  MOVWF  FF6
15D14:  MOVLW  06
15D16:  MOVWF  FF7
15D18:  MOVLW  00
15D1A:  MOVWF  FF8
15D1C:  MOVLW  23
15D1E:  MOVLB  C
15D20:  MOVWF  xC1
15D22:  MOVLB  0
15D24:  CALL   5290
15D28:  MOVFF  C50,C78
15D2C:  MOVLW  1B
15D2E:  MOVLB  C
15D30:  MOVWF  x79
15D32:  MOVLB  0
15D34:  CALL   5ADC
15D38:  MOVLW  0D
15D3A:  MOVLB  D
15D3C:  MOVWF  x6A
15D3E:  MOVLB  0
15D40:  CALL   44EE
15D44:  MOVLW  0A
15D46:  MOVLB  D
15D48:  MOVWF  x6A
15D4A:  MOVLB  0
15D4C:  CALL   44EE
....................     fprintf(PC, "Battery Current: %u\r\n", battery_current); 
15D50:  MOVLW  A4
15D52:  MOVWF  FF6
15D54:  MOVLW  06
15D56:  MOVWF  FF7
15D58:  MOVLW  00
15D5A:  MOVWF  FF8
15D5C:  MOVLW  11
15D5E:  MOVLB  C
15D60:  MOVWF  xC1
15D62:  MOVLB  0
15D64:  CALL   5290
15D68:  MOVFF  C51,C78
15D6C:  MOVLW  1B
15D6E:  MOVLB  C
15D70:  MOVWF  x79
15D72:  MOVLB  0
15D74:  CALL   5ADC
15D78:  MOVLW  0D
15D7A:  MOVLB  D
15D7C:  MOVWF  x6A
15D7E:  MOVLB  0
15D80:  CALL   44EE
15D84:  MOVLW  0A
15D86:  MOVLB  D
15D88:  MOVWF  x6A
15D8A:  MOVLB  0
15D8C:  CALL   44EE
....................     fprintf(PC, "Battery Temperature: %u\r\n", battery_temperature); 
15D90:  MOVLW  BA
15D92:  MOVWF  FF6
15D94:  MOVLW  06
15D96:  MOVWF  FF7
15D98:  MOVLW  00
15D9A:  MOVWF  FF8
15D9C:  MOVLW  15
15D9E:  MOVLB  C
15DA0:  MOVWF  xC1
15DA2:  MOVLB  0
15DA4:  CALL   5290
15DA8:  MOVFF  C52,C78
15DAC:  MOVLW  1B
15DAE:  MOVLB  C
15DB0:  MOVWF  x79
15DB2:  MOVLB  0
15DB4:  CALL   5ADC
15DB8:  MOVLW  0D
15DBA:  MOVLB  D
15DBC:  MOVWF  x6A
15DBE:  MOVLB  0
15DC0:  CALL   44EE
15DC4:  MOVLW  0A
15DC6:  MOVLB  D
15DC8:  MOVWF  x6A
15DCA:  MOVLB  0
15DCC:  CALL   44EE
....................     fprintf(PC, "CPLD Temperature: %u\r\n", cpld_temperature); 
15DD0:  MOVLW  D4
15DD2:  MOVWF  FF6
15DD4:  MOVLW  06
15DD6:  MOVWF  FF7
15DD8:  MOVLW  00
15DDA:  MOVWF  FF8
15DDC:  MOVLW  12
15DDE:  MOVLB  C
15DE0:  MOVWF  xC1
15DE2:  MOVLB  0
15DE4:  CALL   5290
15DE8:  MOVFF  C53,C78
15DEC:  MOVLW  1B
15DEE:  MOVLB  C
15DF0:  MOVWF  x79
15DF2:  MOVLB  0
15DF4:  CALL   5ADC
15DF8:  MOVLW  0D
15DFA:  MOVLB  D
15DFC:  MOVWF  x6A
15DFE:  MOVLB  0
15E00:  CALL   44EE
15E04:  MOVLW  0A
15E06:  MOVLB  D
15E08:  MOVWF  x6A
15E0A:  MOVLB  0
15E0C:  CALL   44EE
....................     fprintf(PC, "Solar Cell SAP +Z (+Y undepl.): %u\r\n", solar_cell_sap_z_plus_y_undepl); 
15E10:  MOVLW  EC
15E12:  MOVWF  FF6
15E14:  MOVLW  06
15E16:  MOVWF  FF7
15E18:  MOVLW  00
15E1A:  MOVWF  FF8
15E1C:  MOVLW  20
15E1E:  MOVLB  C
15E20:  MOVWF  xC1
15E22:  MOVLB  0
15E24:  CALL   5290
15E28:  MOVFF  C54,C78
15E2C:  MOVLW  1B
15E2E:  MOVLB  C
15E30:  MOVWF  x79
15E32:  MOVLB  0
15E34:  CALL   5ADC
15E38:  MOVLW  0D
15E3A:  MOVLB  D
15E3C:  MOVWF  x6A
15E3E:  MOVLB  0
15E40:  CALL   44EE
15E44:  MOVLW  0A
15E46:  MOVLB  D
15E48:  MOVWF  x6A
15E4A:  MOVLB  0
15E4C:  CALL   44EE
....................     fprintf(PC, "Solar Cell +Y: %u\r\n", solar_cell_y_plus); 
15E50:  MOVLW  12
15E52:  MOVWF  FF6
15E54:  MOVLW  07
15E56:  MOVWF  FF7
15E58:  MOVLW  00
15E5A:  MOVWF  FF8
15E5C:  MOVLW  0F
15E5E:  MOVLB  C
15E60:  MOVWF  xC1
15E62:  MOVLB  0
15E64:  CALL   5290
15E68:  MOVFF  C55,C78
15E6C:  MOVLW  1B
15E6E:  MOVLB  C
15E70:  MOVWF  x79
15E72:  MOVLB  0
15E74:  CALL   5ADC
15E78:  MOVLW  0D
15E7A:  MOVLB  D
15E7C:  MOVWF  x6A
15E7E:  MOVLB  0
15E80:  CALL   44EE
15E84:  MOVLW  0A
15E86:  MOVLB  D
15E88:  MOVWF  x6A
15E8A:  MOVLB  0
15E8C:  CALL   44EE
....................     fprintf(PC, "Solar Cell +X: %u\r\n", solar_cell_x_plus); 
15E90:  MOVLW  26
15E92:  MOVWF  FF6
15E94:  MOVLW  07
15E96:  MOVWF  FF7
15E98:  MOVLW  00
15E9A:  MOVWF  FF8
15E9C:  MOVLW  0F
15E9E:  MOVLB  C
15EA0:  MOVWF  xC1
15EA2:  MOVLB  0
15EA4:  CALL   5290
15EA8:  MOVFF  C56,C78
15EAC:  MOVLW  1B
15EAE:  MOVLB  C
15EB0:  MOVWF  x79
15EB2:  MOVLB  0
15EB4:  CALL   5ADC
15EB8:  MOVLW  0D
15EBA:  MOVLB  D
15EBC:  MOVWF  x6A
15EBE:  MOVLB  0
15EC0:  CALL   44EE
15EC4:  MOVLW  0A
15EC6:  MOVLB  D
15EC8:  MOVWF  x6A
15ECA:  MOVLB  0
15ECC:  CALL   44EE
....................     fprintf(PC, "Solar Cell -Y: %u\r\n", solar_cell_y_minus); 
15ED0:  MOVLW  3A
15ED2:  MOVWF  FF6
15ED4:  MOVLW  07
15ED6:  MOVWF  FF7
15ED8:  MOVLW  00
15EDA:  MOVWF  FF8
15EDC:  MOVLW  0F
15EDE:  MOVLB  C
15EE0:  MOVWF  xC1
15EE2:  MOVLB  0
15EE4:  CALL   5290
15EE8:  MOVFF  C57,C78
15EEC:  MOVLW  1B
15EEE:  MOVLB  C
15EF0:  MOVWF  x79
15EF2:  MOVLB  0
15EF4:  CALL   5ADC
15EF8:  MOVLW  0D
15EFA:  MOVLB  D
15EFC:  MOVWF  x6A
15EFE:  MOVLB  0
15F00:  CALL   44EE
15F04:  MOVLW  0A
15F06:  MOVLB  D
15F08:  MOVWF  x6A
15F0A:  MOVLB  0
15F0C:  CALL   44EE
....................     fprintf(PC, "Solar Cell SAP +Z (-Y undepl.): %u\r\n", solar_cell_sap_z_minus_y_undepl); 
15F10:  MOVLW  4E
15F12:  MOVWF  FF6
15F14:  MOVLW  07
15F16:  MOVWF  FF7
15F18:  MOVLW  00
15F1A:  MOVWF  FF8
15F1C:  MOVLW  20
15F1E:  MOVLB  C
15F20:  MOVWF  xC1
15F22:  MOVLB  0
15F24:  CALL   5290
15F28:  MOVFF  C58,C78
15F2C:  MOVLW  1B
15F2E:  MOVLB  C
15F30:  MOVWF  x79
15F32:  MOVLB  0
15F34:  CALL   5ADC
15F38:  MOVLW  0D
15F3A:  MOVLB  D
15F3C:  MOVWF  x6A
15F3E:  MOVLB  0
15F40:  CALL   44EE
15F44:  MOVLW  0A
15F46:  MOVLB  D
15F48:  MOVWF  x6A
15F4A:  MOVLB  0
15F4C:  CALL   44EE
....................     fprintf(PC, "Solar Cell -Z: %u\r\n", solar_cell_z_minus); 
15F50:  MOVLW  74
15F52:  MOVWF  FF6
15F54:  MOVLW  07
15F56:  MOVWF  FF7
15F58:  MOVLW  00
15F5A:  MOVWF  FF8
15F5C:  MOVLW  0F
15F5E:  MOVLB  C
15F60:  MOVWF  xC1
15F62:  MOVLB  0
15F64:  CALL   5290
15F68:  MOVFF  C59,C78
15F6C:  MOVLW  1B
15F6E:  MOVLB  C
15F70:  MOVWF  x79
15F72:  MOVLB  0
15F74:  CALL   5ADC
15F78:  MOVLW  0D
15F7A:  MOVLB  D
15F7C:  MOVWF  x6A
15F7E:  MOVLB  0
15F80:  CALL   44EE
15F84:  MOVLW  0A
15F86:  MOVLB  D
15F88:  MOVWF  x6A
15F8A:  MOVLB  0
15F8C:  CALL   44EE
....................     fprintf(PC, "Scheduled commands in memory: %u\r\n", scheduled_commands); 
15F90:  MOVLW  88
15F92:  MOVWF  FF6
15F94:  MOVLW  07
15F96:  MOVWF  FF7
15F98:  MOVLW  00
15F9A:  MOVWF  FF8
15F9C:  MOVLW  1E
15F9E:  MOVLB  C
15FA0:  MOVWF  xC1
15FA2:  MOVLB  0
15FA4:  CALL   5290
15FA8:  MOVFF  C5A,C78
15FAC:  MOVLW  1B
15FAE:  MOVLB  C
15FB0:  MOVWF  x79
15FB2:  MOVLB  0
15FB4:  CALL   5ADC
15FB8:  MOVLW  0D
15FBA:  MOVLB  D
15FBC:  MOVWF  x6A
15FBE:  MOVLB  0
15FC0:  CALL   44EE
15FC4:  MOVLW  0A
15FC6:  MOVLB  D
15FC8:  MOVWF  x6A
15FCA:  MOVLB  0
15FCC:  CALL   44EE
....................     fprintf(PC, "Battery Heater Flag: %u\r\n", battery_heater_flag); 
15FD0:  MOVLW  AC
15FD2:  MOVWF  FF6
15FD4:  MOVLW  07
15FD6:  MOVWF  FF7
15FD8:  MOVLW  00
15FDA:  MOVWF  FF8
15FDC:  MOVLW  15
15FDE:  MOVLB  C
15FE0:  MOVWF  xC1
15FE2:  MOVLB  0
15FE4:  CALL   5290
15FE8:  MOVFF  C5B,C78
15FEC:  MOVLW  1B
15FEE:  MOVLB  C
15FF0:  MOVWF  x79
15FF2:  MOVLB  0
15FF4:  CALL   5ADC
15FF8:  MOVLW  0D
15FFA:  MOVLB  D
15FFC:  MOVWF  x6A
15FFE:  MOVLB  0
16000:  CALL   44EE
16004:  MOVLW  0A
16006:  MOVLB  D
16008:  MOVWF  x6A
1600A:  MOVLB  0
1600C:  CALL   44EE
....................     fprintf(PC, "Kill Switch Main PIC: %u\r\n", kill_switch_main_pic); 
16010:  MOVLW  C6
16012:  MOVWF  FF6
16014:  MOVLW  07
16016:  MOVWF  FF7
16018:  MOVLW  00
1601A:  MOVWF  FF8
1601C:  MOVLW  16
1601E:  MOVLB  C
16020:  MOVWF  xC1
16022:  MOVLB  0
16024:  CALL   5290
16028:  MOVFF  C5C,C78
1602C:  MOVLW  1B
1602E:  MOVLB  C
16030:  MOVWF  x79
16032:  MOVLB  0
16034:  CALL   5ADC
16038:  MOVLW  0D
1603A:  MOVLB  D
1603C:  MOVWF  x6A
1603E:  MOVLB  0
16040:  CALL   44EE
16044:  MOVLW  0A
16046:  MOVLB  D
16048:  MOVWF  x6A
1604A:  MOVLB  0
1604C:  CALL   44EE
....................     fprintf(PC, "Kill Switch EPS: %u\r\n", kill_switch_eps); 
16050:  MOVLW  E2
16052:  MOVWF  FF6
16054:  MOVLW  07
16056:  MOVWF  FF7
16058:  MOVLW  00
1605A:  MOVWF  FF8
1605C:  MOVLW  11
1605E:  MOVLB  C
16060:  MOVWF  xC1
16062:  MOVLB  0
16064:  CALL   5290
16068:  MOVFF  C5D,C78
1606C:  MOVLW  1B
1606E:  MOVLB  C
16070:  MOVWF  x79
16072:  MOVLB  0
16074:  CALL   5ADC
16078:  MOVLW  0D
1607A:  MOVLB  D
1607C:  MOVWF  x6A
1607E:  MOVLB  0
16080:  CALL   44EE
16084:  MOVLW  0A
16086:  MOVLB  D
16088:  MOVWF  x6A
1608A:  MOVLB  0
1608C:  CALL   44EE
....................     fprintf(PC, "ADCS mode: %u\r\n", adcs_mode); 
16090:  MOVLW  F8
16092:  MOVWF  FF6
16094:  MOVLW  07
16096:  MOVWF  FF7
16098:  MOVLW  00
1609A:  MOVWF  FF8
1609C:  MOVLW  0B
1609E:  MOVLB  C
160A0:  MOVWF  xC1
160A2:  MOVLB  0
160A4:  CALL   5290
160A8:  MOVFF  C5E,C78
160AC:  MOVLW  1B
160AE:  MOVLB  C
160B0:  MOVWF  x79
160B2:  MOVLB  0
160B4:  CALL   5ADC
160B8:  MOVLW  0D
160BA:  MOVLB  D
160BC:  MOVWF  x6A
160BE:  MOVLB  0
160C0:  CALL   44EE
160C4:  MOVLW  0A
160C6:  MOVLB  D
160C8:  MOVWF  x6A
160CA:  MOVLB  0
160CC:  CALL   44EE
....................     fprintf(PC, "Format identifier: %u\r\n", format_identifier_0); 
160D0:  MOVLW  08
160D2:  MOVWF  FF6
160D4:  MOVLW  08
160D6:  MOVWF  FF7
160D8:  MOVLW  00
160DA:  MOVWF  FF8
160DC:  MOVLW  13
160DE:  MOVLB  C
160E0:  MOVWF  xC1
160E2:  MOVLB  0
160E4:  CALL   5290
160E8:  MOVFF  C5F,C78
160EC:  MOVLW  1B
160EE:  MOVLB  C
160F0:  MOVWF  x79
160F2:  MOVLB  0
160F4:  CALL   5ADC
160F8:  MOVLW  0D
160FA:  MOVLB  D
160FC:  MOVWF  x6A
160FE:  MOVLB  0
16100:  CALL   44EE
16104:  MOVLW  0A
16106:  MOVLB  D
16108:  MOVWF  x6A
1610A:  MOVLB  0
1610C:  CALL   44EE
....................  
....................     bit_offset = 0; // Reset bit offset for page 1 
16110:  MOVLB  C
16112:  CLRF   x4F
16114:  CLRF   x4E
....................  
....................     // Page 1 Deserialization 
....................     uint8_t gyro_x = get_bits(cw[1], &bit_offset, 8);                   // Gyro X axis 
....................     uint8_t gyro_y_minus = get_bits(cw[1], &bit_offset, 8);             // Gyro -Y axis 
....................     uint8_t gyro_z_minus = get_bits(cw[1], &bit_offset, 8);             // Gyro -Z axis 
....................     uint8_t magnetometer_x = get_bits(cw[1], &bit_offset, 5);           // Magnetometer X 
....................     uint8_t magnetometer_y = get_bits(cw[1], &bit_offset, 5);           // Magnetometer Y 
....................     uint8_t magnetometer_z = get_bits(cw[1], &bit_offset, 5);           // Magnetometer Z 
....................     uint8_t subsystems_communicating = get_bits(cw[1], &bit_offset, 3); // Subsystems communicating 
....................     uint8_t time_after_reset = get_bits(cw[1], &bit_offset, 5);         // Time after last reset (hours) 
....................     uint8_t format_identifier_1 = get_bits(cw[1], &bit_offset, 1);      // Format identifier 
16116:  CLRF   x78
16118:  MOVLW  F9
1611A:  MOVWF  x77
1611C:  MOVLW  0C
1611E:  MOVWF  x7A
16120:  MOVLW  4E
16122:  MOVWF  x79
16124:  MOVLW  08
16126:  MOVWF  x7B
16128:  MOVLB  0
1612A:  CALL   EED4
1612E:  MOVFF  00,C60
16132:  MOVLB  C
16134:  CLRF   x78
16136:  MOVLW  F9
16138:  MOVWF  x77
1613A:  MOVLW  0C
1613C:  MOVWF  x7A
1613E:  MOVLW  4E
16140:  MOVWF  x79
16142:  MOVLW  08
16144:  MOVWF  x7B
16146:  MOVLB  0
16148:  CALL   EED4
1614C:  MOVFF  00,C61
16150:  MOVLB  C
16152:  CLRF   x78
16154:  MOVLW  F9
16156:  MOVWF  x77
16158:  MOVLW  0C
1615A:  MOVWF  x7A
1615C:  MOVLW  4E
1615E:  MOVWF  x79
16160:  MOVLW  08
16162:  MOVWF  x7B
16164:  MOVLB  0
16166:  CALL   EED4
1616A:  MOVFF  00,C62
1616E:  MOVLB  C
16170:  CLRF   x78
16172:  MOVLW  F9
16174:  MOVWF  x77
16176:  MOVLW  0C
16178:  MOVWF  x7A
1617A:  MOVLW  4E
1617C:  MOVWF  x79
1617E:  MOVLW  05
16180:  MOVWF  x7B
16182:  MOVLB  0
16184:  CALL   EED4
16188:  MOVFF  00,C63
1618C:  MOVLB  C
1618E:  CLRF   x78
16190:  MOVLW  F9
16192:  MOVWF  x77
16194:  MOVLW  0C
16196:  MOVWF  x7A
16198:  MOVLW  4E
1619A:  MOVWF  x79
1619C:  MOVLW  05
1619E:  MOVWF  x7B
161A0:  MOVLB  0
161A2:  CALL   EED4
161A6:  MOVFF  00,C64
161AA:  MOVLB  C
161AC:  CLRF   x78
161AE:  MOVLW  F9
161B0:  MOVWF  x77
161B2:  MOVLW  0C
161B4:  MOVWF  x7A
161B6:  MOVLW  4E
161B8:  MOVWF  x79
161BA:  MOVLW  05
161BC:  MOVWF  x7B
161BE:  MOVLB  0
161C0:  CALL   EED4
161C4:  MOVFF  00,C65
161C8:  MOVLB  C
161CA:  CLRF   x78
161CC:  MOVLW  F9
161CE:  MOVWF  x77
161D0:  MOVLW  0C
161D2:  MOVWF  x7A
161D4:  MOVLW  4E
161D6:  MOVWF  x79
161D8:  MOVLW  03
161DA:  MOVWF  x7B
161DC:  MOVLB  0
161DE:  CALL   EED4
161E2:  MOVFF  00,C66
161E6:  MOVLB  C
161E8:  CLRF   x78
161EA:  MOVLW  F9
161EC:  MOVWF  x77
161EE:  MOVLW  0C
161F0:  MOVWF  x7A
161F2:  MOVLW  4E
161F4:  MOVWF  x79
161F6:  MOVLW  05
161F8:  MOVWF  x7B
161FA:  MOVLB  0
161FC:  CALL   EED4
16200:  MOVFF  00,C67
16204:  MOVLB  C
16206:  CLRF   x78
16208:  MOVLW  F9
1620A:  MOVWF  x77
1620C:  MOVLW  0C
1620E:  MOVWF  x7A
16210:  MOVLW  4E
16212:  MOVWF  x79
16214:  MOVLW  01
16216:  MOVWF  x7B
16218:  MOVLB  0
1621A:  CALL   EED4
1621E:  MOVFF  00,C68
....................  
....................     fprintf(PC, "Page 1 Deserialized Data:\r\n"); 
16222:  MOVLW  20
16224:  MOVWF  FF6
16226:  MOVLW  08
16228:  MOVWF  FF7
1622A:  MOVLW  00
1622C:  MOVWF  FF8
1622E:  CALL   4534
....................     fprintf(PC, "Gyro X axis: %u\r\n", gyro_x); 
16232:  MOVLW  3C
16234:  MOVWF  FF6
16236:  MOVLW  08
16238:  MOVWF  FF7
1623A:  MOVLW  00
1623C:  MOVWF  FF8
1623E:  MOVLW  0D
16240:  MOVLB  C
16242:  MOVWF  xC1
16244:  MOVLB  0
16246:  CALL   5290
1624A:  MOVFF  C60,C78
1624E:  MOVLW  1B
16250:  MOVLB  C
16252:  MOVWF  x79
16254:  MOVLB  0
16256:  CALL   5ADC
1625A:  MOVLW  0D
1625C:  MOVLB  D
1625E:  MOVWF  x6A
16260:  MOVLB  0
16262:  CALL   44EE
16266:  MOVLW  0A
16268:  MOVLB  D
1626A:  MOVWF  x6A
1626C:  MOVLB  0
1626E:  CALL   44EE
....................     fprintf(PC, "Gyro -Y axis: %u\r\n", gyro_y_minus); 
16272:  MOVLW  4E
16274:  MOVWF  FF6
16276:  MOVLW  08
16278:  MOVWF  FF7
1627A:  MOVLW  00
1627C:  MOVWF  FF8
1627E:  MOVLW  0E
16280:  MOVLB  C
16282:  MOVWF  xC1
16284:  MOVLB  0
16286:  CALL   5290
1628A:  MOVFF  C61,C78
1628E:  MOVLW  1B
16290:  MOVLB  C
16292:  MOVWF  x79
16294:  MOVLB  0
16296:  CALL   5ADC
1629A:  MOVLW  0D
1629C:  MOVLB  D
1629E:  MOVWF  x6A
162A0:  MOVLB  0
162A2:  CALL   44EE
162A6:  MOVLW  0A
162A8:  MOVLB  D
162AA:  MOVWF  x6A
162AC:  MOVLB  0
162AE:  CALL   44EE
....................     fprintf(PC, "Gyro -Z axis: %u\r\n", gyro_z_minus); 
162B2:  MOVLW  62
162B4:  MOVWF  FF6
162B6:  MOVLW  08
162B8:  MOVWF  FF7
162BA:  MOVLW  00
162BC:  MOVWF  FF8
162BE:  MOVLW  0E
162C0:  MOVLB  C
162C2:  MOVWF  xC1
162C4:  MOVLB  0
162C6:  CALL   5290
162CA:  MOVFF  C62,C78
162CE:  MOVLW  1B
162D0:  MOVLB  C
162D2:  MOVWF  x79
162D4:  MOVLB  0
162D6:  CALL   5ADC
162DA:  MOVLW  0D
162DC:  MOVLB  D
162DE:  MOVWF  x6A
162E0:  MOVLB  0
162E2:  CALL   44EE
162E6:  MOVLW  0A
162E8:  MOVLB  D
162EA:  MOVWF  x6A
162EC:  MOVLB  0
162EE:  CALL   44EE
....................     fprintf(PC, "Magnetometer X: %u\r\n", magnetometer_x); 
162F2:  MOVLW  76
162F4:  MOVWF  FF6
162F6:  MOVLW  08
162F8:  MOVWF  FF7
162FA:  MOVLW  00
162FC:  MOVWF  FF8
162FE:  MOVLW  10
16300:  MOVLB  C
16302:  MOVWF  xC1
16304:  MOVLB  0
16306:  CALL   5290
1630A:  MOVFF  C63,C78
1630E:  MOVLW  1B
16310:  MOVLB  C
16312:  MOVWF  x79
16314:  MOVLB  0
16316:  CALL   5ADC
1631A:  MOVLW  0D
1631C:  MOVLB  D
1631E:  MOVWF  x6A
16320:  MOVLB  0
16322:  CALL   44EE
16326:  MOVLW  0A
16328:  MOVLB  D
1632A:  MOVWF  x6A
1632C:  MOVLB  0
1632E:  CALL   44EE
....................     fprintf(PC, "Magnetometer Y: %u\r\n", magnetometer_y); 
16332:  MOVLW  8C
16334:  MOVWF  FF6
16336:  MOVLW  08
16338:  MOVWF  FF7
1633A:  MOVLW  00
1633C:  MOVWF  FF8
1633E:  MOVLW  10
16340:  MOVLB  C
16342:  MOVWF  xC1
16344:  MOVLB  0
16346:  CALL   5290
1634A:  MOVFF  C64,C78
1634E:  MOVLW  1B
16350:  MOVLB  C
16352:  MOVWF  x79
16354:  MOVLB  0
16356:  CALL   5ADC
1635A:  MOVLW  0D
1635C:  MOVLB  D
1635E:  MOVWF  x6A
16360:  MOVLB  0
16362:  CALL   44EE
16366:  MOVLW  0A
16368:  MOVLB  D
1636A:  MOVWF  x6A
1636C:  MOVLB  0
1636E:  CALL   44EE
....................     fprintf(PC, "Magnetometer Z: %u\r\n", magnetometer_z); 
16372:  MOVLW  A2
16374:  MOVWF  FF6
16376:  MOVLW  08
16378:  MOVWF  FF7
1637A:  MOVLW  00
1637C:  MOVWF  FF8
1637E:  MOVLW  10
16380:  MOVLB  C
16382:  MOVWF  xC1
16384:  MOVLB  0
16386:  CALL   5290
1638A:  MOVFF  C65,C78
1638E:  MOVLW  1B
16390:  MOVLB  C
16392:  MOVWF  x79
16394:  MOVLB  0
16396:  CALL   5ADC
1639A:  MOVLW  0D
1639C:  MOVLB  D
1639E:  MOVWF  x6A
163A0:  MOVLB  0
163A2:  CALL   44EE
163A6:  MOVLW  0A
163A8:  MOVLB  D
163AA:  MOVWF  x6A
163AC:  MOVLB  0
163AE:  CALL   44EE
....................     fprintf(PC, "Subsystems communicating: %u\r\n", subsystems_communicating); 
163B2:  MOVLW  B8
163B4:  MOVWF  FF6
163B6:  MOVLW  08
163B8:  MOVWF  FF7
163BA:  MOVLW  00
163BC:  MOVWF  FF8
163BE:  MOVLW  1A
163C0:  MOVLB  C
163C2:  MOVWF  xC1
163C4:  MOVLB  0
163C6:  CALL   5290
163CA:  MOVFF  C66,C78
163CE:  MOVLW  1B
163D0:  MOVLB  C
163D2:  MOVWF  x79
163D4:  MOVLB  0
163D6:  CALL   5ADC
163DA:  MOVLW  0D
163DC:  MOVLB  D
163DE:  MOVWF  x6A
163E0:  MOVLB  0
163E2:  CALL   44EE
163E6:  MOVLW  0A
163E8:  MOVLB  D
163EA:  MOVWF  x6A
163EC:  MOVLB  0
163EE:  CALL   44EE
....................     fprintf(PC, "Time after last reset (hours): %u\r\n", time_after_reset); 
163F2:  MOVLW  D8
163F4:  MOVWF  FF6
163F6:  MOVLW  08
163F8:  MOVWF  FF7
163FA:  MOVLW  00
163FC:  MOVWF  FF8
163FE:  MOVLW  1F
16400:  MOVLB  C
16402:  MOVWF  xC1
16404:  MOVLB  0
16406:  CALL   5290
1640A:  MOVFF  C67,C78
1640E:  MOVLW  1B
16410:  MOVLB  C
16412:  MOVWF  x79
16414:  MOVLB  0
16416:  CALL   5ADC
1641A:  MOVLW  0D
1641C:  MOVLB  D
1641E:  MOVWF  x6A
16420:  MOVLB  0
16422:  CALL   44EE
16426:  MOVLW  0A
16428:  MOVLB  D
1642A:  MOVWF  x6A
1642C:  MOVLB  0
1642E:  CALL   44EE
....................     fprintf(PC, "Format identifier: %u\r\n", format_identifier_1); 
16432:  MOVLW  FC
16434:  MOVWF  FF6
16436:  MOVLW  08
16438:  MOVWF  FF7
1643A:  MOVLW  00
1643C:  MOVWF  FF8
1643E:  MOVLW  13
16440:  MOVLB  C
16442:  MOVWF  xC1
16444:  MOVLB  0
16446:  CALL   5290
1644A:  MOVFF  C68,C78
1644E:  MOVLW  1B
16450:  MOVLB  C
16452:  MOVWF  x79
16454:  MOVLB  0
16456:  CALL   5ADC
1645A:  MOVLW  0D
1645C:  MOVLB  D
1645E:  MOVWF  x6A
16460:  MOVLB  0
16462:  CALL   44EE
16466:  MOVLW  0A
16468:  MOVLB  D
1646A:  MOVWF  x6A
1646C:  MOVLB  0
1646E:  CALL   44EE
16472:  GOTO   168D2 (RETURN)
.................... } 
....................  
.................... // Helper funtion to initialize the cw beacon array. 
.................... void build_cw() 
*
15434:  CALL   7830
15438:  MOVFF  01,C4E
1543C:  MOVLB  7
1543E:  MOVF   x51,W
15440:  SUBWF  3B,W
15442:  MOVLB  C
15444:  MOVWF  x5A
15446:  MOVLB  7
15448:  MOVF   x52,W
1544A:  SUBWFB 3C,W
1544C:  MOVLB  C
1544E:  MOVWF  x5B
15450:  MOVLB  7
15452:  MOVF   x53,W
15454:  SUBWFB 3D,W
15456:  MOVLB  C
15458:  MOVWF  x5C
1545A:  MOVLB  7
1545C:  MOVF   x54,W
1545E:  SUBWFB 3E,W
15460:  MOVLB  C
15462:  MOVWF  x5D
15464:  MOVFF  FEA,C5F
15468:  MOVFF  FE9,C5E
1546C:  BCF    FD8.1
1546E:  MOVWF  x95
15470:  MOVFF  C5C,C94
15474:  MOVFF  C5B,C93
15478:  MOVFF  C5A,C92
1547C:  CLRF   x99
1547E:  CLRF   x98
15480:  MOVLW  0E
15482:  MOVWF  x97
15484:  MOVLW  10
15486:  MOVWF  x96
15488:  MOVLB  0
1548A:  CALL   4726
1548E:  MOVFF  C5F,FEA
15492:  MOVFF  C5E,FE9
15496:  MOVFF  03,C52
1549A:  MOVFF  02,C51
1549E:  MOVFF  01,C50
154A2:  MOVFF  00,C4F
154A6:  MOVLB  C
154A8:  BTFSC  x52.7
154AA:  BRA    154C2
154AC:  MOVF   x52,F
154AE:  BNZ   154BE
154B0:  MOVF   x51,F
154B2:  BNZ   154BE
154B4:  MOVF   x50,F
154B6:  BNZ   154BE
154B8:  MOVF   x4F,W
154BA:  SUBLW  18
154BC:  BC    154C2
154BE:  MOVLW  1F
154C0:  BRA    154C4
154C2:  MOVF   x4F,W
154C4:  MOVWF  x53
154C6:  CLRF   x54
154C8:  CLRF   x5B
154CA:  MOVLW  DB
154CC:  MOVFF  C5B,C56
154D0:  MOVWF  x55
.................... { 
....................     uint8_t sc = scheduled_command_count(); 
....................  
....................     time_t time_after_reset_ = (current_time - reset_time) / 3600; 
....................     uint8_t time_after_reset = time_after_reset_ > 24 ? 0x1F : time_after_reset_; 
....................  
....................     uint8_t subsystems_communicating = 0; 
....................     time_t* t = (time_t*)&telemetry_time; 
....................     for (uint8_t i = 0; i < sizeof(telemetry_time) / sizeof(time_t); i++) { 
154D2:  CLRF   x57
154D4:  MOVF   x57,W
154D6:  SUBLW  05
154D8:  BNC   15530
....................         subsystems_communicating += (t[i] > 0); 
154DA:  CLRF   xC4
154DC:  MOVFF  C57,CC3
154E0:  CLRF   xC6
154E2:  MOVLW  04
154E4:  MOVWF  xC5
154E6:  MOVLB  0
154E8:  CALL   4D06
154EC:  MOVFF  02,03
154F0:  MOVF   01,W
154F2:  MOVLB  C
154F4:  ADDWF  x55,W
154F6:  MOVWF  FE9
154F8:  MOVF   x56,W
154FA:  ADDWFC 02,W
154FC:  MOVWF  FEA
154FE:  MOVFF  FEF,C5A
15502:  MOVFF  FEC,C5B
15506:  MOVFF  FEC,C5C
1550A:  MOVFF  FEC,C5D
1550E:  BTFSC  x5D.7
15510:  BRA    15524
15512:  MOVF   x5D,F
15514:  BNZ   15528
15516:  MOVF   x5C,F
15518:  BNZ   15528
1551A:  MOVF   x5B,F
1551C:  BNZ   15528
1551E:  MOVF   x5A,W
15520:  SUBLW  00
15522:  BNC   15528
15524:  MOVLW  00
15526:  BRA    1552A
15528:  MOVLW  01
1552A:  ADDWF  x54,F
1552C:  INCF   x57,F
1552E:  BRA    154D4
....................     } 
....................     subsystems_communicating -= (telemetry_time.com_time > 0); // Remove COM pic from the report 
15530:  MOVLB  0
15532:  BTFSC  xF2.7
15534:  BRA    15548
15536:  MOVF   xF2,F
15538:  BNZ   1554C
1553A:  MOVF   xF1,F
1553C:  BNZ   1554C
1553E:  MOVF   xF0,F
15540:  BNZ   1554C
15542:  MOVF   xEF,W
15544:  SUBLW  00
15546:  BNC   1554C
15548:  MOVLW  00
1554A:  BRA    1554E
1554C:  MOVLW  01
1554E:  MOVLB  C
15550:  SUBWF  x54,F
....................  
....................     memset(&cw, 0, sizeof(cw)); // Erase old data. 
15552:  CLRF   FEA
15554:  MOVLW  F3
15556:  MOVWF  FE9
15558:  CLRF   00
1555A:  CLRF   02
1555C:  MOVLW  0C
1555E:  MOVWF  01
15560:  MOVLB  0
15562:  CALL   5222
....................  
....................     uint16_t bit_offset = 0; 
15566:  MOVLB  C
15568:  CLRF   x59
1556A:  CLRF   x58
....................  
....................     // Page 0 
....................     set_bits(cw[0], make16(telemetry.reset_message[6], telemetry.reset_message[7]) >> 4, &bit_offset, 8);  // Battery Voltage (RST RAW voltage) 
1556C:  MOVFF  4A,C5B
15570:  MOVFF  4B,C5A
15574:  RRCF   x5B,F
15576:  RRCF   x5A,F
15578:  RRCF   x5B,F
1557A:  RRCF   x5A,F
1557C:  RRCF   x5B,F
1557E:  RRCF   x5A,F
15580:  RRCF   x5B,F
15582:  RRCF   x5A,F
15584:  MOVLW  0F
15586:  ANDWF  x5B,F
15588:  CLRF   x5D
1558A:  MOVLW  F3
1558C:  MOVWF  x5C
1558E:  CLRF   x61
15590:  CLRF   x60
15592:  MOVFF  C5B,C5F
15596:  MOVFF  C5A,C5E
1559A:  MOVLW  0C
1559C:  MOVWF  x63
1559E:  MOVLW  58
155A0:  MOVWF  x62
155A2:  MOVLW  08
155A4:  MOVWF  x64
155A6:  MOVLB  0
155A8:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[52], telemetry.fab_message[43]) >> 4, &bit_offset, 8);    // Battery Current 
155AA:  MOVFF  91,C5B
155AE:  MOVFF  88,C5A
155B2:  MOVLB  C
155B4:  RRCF   x5B,F
155B6:  RRCF   x5A,F
155B8:  RRCF   x5B,F
155BA:  RRCF   x5A,F
155BC:  RRCF   x5B,F
155BE:  RRCF   x5A,F
155C0:  RRCF   x5B,F
155C2:  RRCF   x5A,F
155C4:  MOVLW  0F
155C6:  ANDWF  x5B,F
155C8:  CLRF   x5D
155CA:  MOVLW  F3
155CC:  MOVWF  x5C
155CE:  CLRF   x61
155D0:  CLRF   x60
155D2:  MOVFF  C5B,C5F
155D6:  MOVFF  C5A,C5E
155DA:  MOVLW  0C
155DC:  MOVWF  x63
155DE:  MOVLW  58
155E0:  MOVWF  x62
155E2:  MOVLW  08
155E4:  MOVWF  x64
155E6:  MOVLB  0
155E8:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[54], telemetry.fab_message[55]) >> 4, &bit_offset, 8);    // Battery Temperature 
155EA:  MOVFF  93,C5B
155EE:  MOVFF  94,C5A
155F2:  MOVLB  C
155F4:  RRCF   x5B,F
155F6:  RRCF   x5A,F
155F8:  RRCF   x5B,F
155FA:  RRCF   x5A,F
155FC:  RRCF   x5B,F
155FE:  RRCF   x5A,F
15600:  RRCF   x5B,F
15602:  RRCF   x5A,F
15604:  MOVLW  0F
15606:  ANDWF  x5B,F
15608:  CLRF   x5D
1560A:  MOVLW  F3
1560C:  MOVWF  x5C
1560E:  CLRF   x61
15610:  CLRF   x60
15612:  MOVFF  C5B,C5F
15616:  MOVFF  C5A,C5E
1561A:  MOVLW  0C
1561C:  MOVWF  x63
1561E:  MOVLW  58
15620:  MOVWF  x62
15622:  MOVLW  08
15624:  MOVWF  x64
15626:  MOVLB  0
15628:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[10], telemetry.fab_message[11]) >> 4, &bit_offset, 8);    // CPLD Temperature 
1562A:  MOVFF  67,C5B
1562E:  MOVFF  68,C5A
15632:  MOVLB  C
15634:  RRCF   x5B,F
15636:  RRCF   x5A,F
15638:  RRCF   x5B,F
1563A:  RRCF   x5A,F
1563C:  RRCF   x5B,F
1563E:  RRCF   x5A,F
15640:  RRCF   x5B,F
15642:  RRCF   x5A,F
15644:  MOVLW  0F
15646:  ANDWF  x5B,F
15648:  CLRF   x5D
1564A:  MOVLW  F3
1564C:  MOVWF  x5C
1564E:  CLRF   x61
15650:  CLRF   x60
15652:  MOVFF  C5B,C5F
15656:  MOVFF  C5A,C5E
1565A:  MOVLW  0C
1565C:  MOVWF  x63
1565E:  MOVLW  58
15660:  MOVWF  x62
15662:  MOVLW  08
15664:  MOVWF  x64
15666:  MOVLB  0
15668:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[30], telemetry.fab_message[31]) > 0x2F0, &bit_offset, 1); // Solar Cell SAP +Z (+Y undepl.) 
1566A:  MOVFF  7B,C5B
1566E:  MOVFF  7C,C5A
15672:  MOVLB  C
15674:  MOVF   x5B,W
15676:  SUBLW  01
15678:  BC    15684
1567A:  XORLW  FF
1567C:  BNZ   15688
1567E:  MOVF   x5A,W
15680:  SUBLW  F0
15682:  BNC   15688
15684:  MOVLW  00
15686:  BRA    1568A
15688:  MOVLW  01
1568A:  MOVWF  x5A
1568C:  CLRF   x5D
1568E:  MOVLW  F3
15690:  MOVWF  x5C
15692:  CLRF   x61
15694:  CLRF   x60
15696:  CLRF   x5F
15698:  MOVFF  C5A,C5E
1569C:  MOVLW  0C
1569E:  MOVWF  x63
156A0:  MOVLW  58
156A2:  MOVWF  x62
156A4:  MOVLW  01
156A6:  MOVWF  x64
156A8:  MOVLB  0
156AA:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[32], telemetry.fab_message[33]) > 0x2F0, &bit_offset, 1); // Solar Cell +Y 
156AC:  MOVFF  7D,C5B
156B0:  MOVFF  7E,C5A
156B4:  MOVLB  C
156B6:  MOVF   x5B,W
156B8:  SUBLW  01
156BA:  BC    156C6
156BC:  XORLW  FF
156BE:  BNZ   156CA
156C0:  MOVF   x5A,W
156C2:  SUBLW  F0
156C4:  BNC   156CA
156C6:  MOVLW  00
156C8:  BRA    156CC
156CA:  MOVLW  01
156CC:  MOVWF  x5A
156CE:  CLRF   x5D
156D0:  MOVLW  F3
156D2:  MOVWF  x5C
156D4:  CLRF   x61
156D6:  CLRF   x60
156D8:  CLRF   x5F
156DA:  MOVFF  C5A,C5E
156DE:  MOVLW  0C
156E0:  MOVWF  x63
156E2:  MOVLW  58
156E4:  MOVWF  x62
156E6:  MOVLW  01
156E8:  MOVWF  x64
156EA:  MOVLB  0
156EC:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[34], telemetry.fab_message[35]) > 0x2F0, &bit_offset, 1); // Solar Cell +X 
156EE:  MOVFF  7F,C5B
156F2:  MOVFF  80,C5A
156F6:  MOVLB  C
156F8:  MOVF   x5B,W
156FA:  SUBLW  01
156FC:  BC    15708
156FE:  XORLW  FF
15700:  BNZ   1570C
15702:  MOVF   x5A,W
15704:  SUBLW  F0
15706:  BNC   1570C
15708:  MOVLW  00
1570A:  BRA    1570E
1570C:  MOVLW  01
1570E:  MOVWF  x5A
15710:  CLRF   x5D
15712:  MOVLW  F3
15714:  MOVWF  x5C
15716:  CLRF   x61
15718:  CLRF   x60
1571A:  CLRF   x5F
1571C:  MOVFF  C5A,C5E
15720:  MOVLW  0C
15722:  MOVWF  x63
15724:  MOVLW  58
15726:  MOVWF  x62
15728:  MOVLW  01
1572A:  MOVWF  x64
1572C:  MOVLB  0
1572E:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[36], telemetry.fab_message[37]) > 0x2F0, &bit_offset, 1); // Solar Cell -Y 
15730:  MOVFF  81,C5B
15734:  MOVFF  82,C5A
15738:  MOVLB  C
1573A:  MOVF   x5B,W
1573C:  SUBLW  01
1573E:  BC    1574A
15740:  XORLW  FF
15742:  BNZ   1574E
15744:  MOVF   x5A,W
15746:  SUBLW  F0
15748:  BNC   1574E
1574A:  MOVLW  00
1574C:  BRA    15750
1574E:  MOVLW  01
15750:  MOVWF  x5A
15752:  CLRF   x5D
15754:  MOVLW  F3
15756:  MOVWF  x5C
15758:  CLRF   x61
1575A:  CLRF   x60
1575C:  CLRF   x5F
1575E:  MOVFF  C5A,C5E
15762:  MOVLW  0C
15764:  MOVWF  x63
15766:  MOVLW  58
15768:  MOVWF  x62
1576A:  MOVLW  01
1576C:  MOVWF  x64
1576E:  MOVLB  0
15770:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[38], telemetry.fab_message[39]) > 0x2F0, &bit_offset, 1); // Solar Cell SAP +Z (-Y undepl.) 
15772:  MOVFF  83,C5B
15776:  MOVFF  84,C5A
1577A:  MOVLB  C
1577C:  MOVF   x5B,W
1577E:  SUBLW  01
15780:  BC    1578C
15782:  XORLW  FF
15784:  BNZ   15790
15786:  MOVF   x5A,W
15788:  SUBLW  F0
1578A:  BNC   15790
1578C:  MOVLW  00
1578E:  BRA    15792
15790:  MOVLW  01
15792:  MOVWF  x5A
15794:  CLRF   x5D
15796:  MOVLW  F3
15798:  MOVWF  x5C
1579A:  CLRF   x61
1579C:  CLRF   x60
1579E:  CLRF   x5F
157A0:  MOVFF  C5A,C5E
157A4:  MOVLW  0C
157A6:  MOVWF  x63
157A8:  MOVLW  58
157AA:  MOVWF  x62
157AC:  MOVLW  01
157AE:  MOVWF  x64
157B0:  MOVLB  0
157B2:  RCALL  15144
....................     set_bits(cw[0], make16(telemetry.fab_message[40], telemetry.fab_message[41]) > 0x090, &bit_offset, 1); // Solar Cell -Z 
157B4:  MOVFF  85,C5B
157B8:  MOVFF  86,C5A
157BC:  MOVLB  C
157BE:  MOVF   x5B,F
157C0:  BNZ   157CC
157C2:  MOVF   x5A,W
157C4:  SUBLW  90
157C6:  BNC   157CC
157C8:  MOVLW  00
157CA:  BRA    157CE
157CC:  MOVLW  01
157CE:  MOVWF  x5A
157D0:  CLRF   x5D
157D2:  MOVLW  F3
157D4:  MOVWF  x5C
157D6:  CLRF   x61
157D8:  CLRF   x60
157DA:  CLRF   x5F
157DC:  MOVFF  C5A,C5E
157E0:  MOVLW  0C
157E2:  MOVWF  x63
157E4:  MOVLW  58
157E6:  MOVWF  x62
157E8:  MOVLW  01
157EA:  MOVWF  x64
157EC:  MOVLB  0
157EE:  RCALL  15144
....................     set_bits(cw[0], sc > 3 ? 3 : sc, &bit_offset, 2);                                                      // Scheduled commands in memory 
157F0:  MOVLB  C
157F2:  MOVF   x4E,W
157F4:  SUBLW  03
157F6:  BC    157FE
157F8:  CLRF   03
157FA:  MOVLW  03
157FC:  BRA    15802
157FE:  CLRF   03
15800:  MOVF   x4E,W
15802:  MOVWF  x5A
15804:  MOVFF  03,C5B
15808:  CLRF   x5D
1580A:  MOVLW  F3
1580C:  MOVWF  x5C
1580E:  CLRF   x61
15810:  CLRF   x60
15812:  MOVFF  03,C5F
15816:  MOVFF  C5A,C5E
1581A:  MOVLW  0C
1581C:  MOVWF  x63
1581E:  MOVLW  58
15820:  MOVWF  x62
15822:  MOVLW  02
15824:  MOVWF  x64
15826:  MOVLB  0
15828:  RCALL  15144
....................     set_bits(cw[0], telemetry.fab_message[56] > 0, &bit_offset, 1);                                        // Battery Heater Flag 
1582A:  MOVF   x95,F
1582C:  BNZ   15832
1582E:  MOVLW  00
15830:  BRA    15834
15832:  MOVLW  01
15834:  MOVLB  C
15836:  MOVWF  x5A
15838:  CLRF   x5D
1583A:  MOVLW  F3
1583C:  MOVWF  x5C
1583E:  CLRF   x61
15840:  CLRF   x60
15842:  CLRF   x5F
15844:  MOVFF  C5A,C5E
15848:  MOVLW  0C
1584A:  MOVWF  x63
1584C:  MOVLW  58
1584E:  MOVWF  x62
15850:  MOVLW  01
15852:  MOVWF  x64
15854:  MOVLB  0
15856:  RCALL  15144
....................     set_bits(cw[0], (telemetry.fab_message[57] & 0x01) > 0, &bit_offset, 1);                               // Kill Switch Main PIC 
15858:  MOVF   x96,W
1585A:  ANDLW  01
1585C:  BNZ   15862
1585E:  MOVLW  00
15860:  BRA    15864
15862:  MOVLW  01
15864:  MOVLB  C
15866:  MOVWF  x5A
15868:  CLRF   x5D
1586A:  MOVLW  F3
1586C:  MOVWF  x5C
1586E:  CLRF   x61
15870:  CLRF   x60
15872:  CLRF   x5F
15874:  MOVFF  C5A,C5E
15878:  MOVLW  0C
1587A:  MOVWF  x63
1587C:  MOVLW  58
1587E:  MOVWF  x62
15880:  MOVLW  01
15882:  MOVWF  x64
15884:  MOVLB  0
15886:  RCALL  15144
....................     set_bits(cw[0], (telemetry.fab_message[57] & 0x10) > 0, &bit_offset, 1);                               // Kill Switch EPS 
15888:  MOVF   x96,W
1588A:  ANDLW  10
1588C:  BNZ   15892
1588E:  MOVLW  00
15890:  BRA    15894
15892:  MOVLW  01
15894:  MOVLB  C
15896:  MOVWF  x5A
15898:  CLRF   x5D
1589A:  MOVLW  F3
1589C:  MOVWF  x5C
1589E:  CLRF   x61
158A0:  CLRF   x60
158A2:  CLRF   x5F
158A4:  MOVFF  C5A,C5E
158A8:  MOVLW  0C
158AA:  MOVWF  x63
158AC:  MOVLW  58
158AE:  MOVWF  x62
158B0:  MOVLW  01
158B2:  MOVWF  x64
158B4:  MOVLB  0
158B6:  RCALL  15144
....................     set_bits(cw[0], get_adcs_mode_index(telemetry.adcs_message[0]), &bit_offset, 4);                       // ADCS mode 
158B8:  MOVFF  AA,C5A
158BC:  BRA    15234
158BE:  MOVFF  01,C5A
158C2:  MOVLB  C
158C4:  CLRF   x5D
158C6:  MOVLW  F3
158C8:  MOVWF  x5C
158CA:  CLRF   x61
158CC:  CLRF   x60
158CE:  CLRF   x5F
158D0:  MOVFF  01,C5E
158D4:  MOVLW  0C
158D6:  MOVWF  x63
158D8:  MOVLW  58
158DA:  MOVWF  x62
158DC:  MOVLW  04
158DE:  MOVWF  x64
158E0:  MOVLB  0
158E2:  RCALL  15144
....................     set_bits(cw[0], 0, &bit_offset, 1);                                                                    // Format identifier 
158E4:  MOVLB  C
158E6:  CLRF   x5D
158E8:  MOVLW  F3
158EA:  MOVWF  x5C
158EC:  CLRF   x61
158EE:  CLRF   x60
158F0:  CLRF   x5F
158F2:  CLRF   x5E
158F4:  MOVLW  0C
158F6:  MOVWF  x63
158F8:  MOVLW  58
158FA:  MOVWF  x62
158FC:  MOVLW  01
158FE:  MOVWF  x64
15900:  MOVLB  0
15902:  RCALL  15144
....................  
....................     bit_offset = 0; 
15904:  MOVLB  C
15906:  CLRF   x59
15908:  CLRF   x58
....................  
....................     // Page 1 
....................     set_bits(cw[1], gyro_to_cw(telemetry.adcs_message[5], telemetry.adcs_message[6]), &bit_offset, 8);   // Gyro X axis 
1590A:  MOVFF  AF,C5A
1590E:  MOVFF  B0,C5B
15912:  MOVLB  0
15914:  RCALL  152B6
15916:  MOVFF  01,C5A
1591A:  MOVLB  C
1591C:  CLRF   x5D
1591E:  MOVLW  F9
15920:  MOVWF  x5C
15922:  CLRF   x61
15924:  CLRF   x60
15926:  CLRF   x5F
15928:  MOVFF  01,C5E
1592C:  MOVLW  0C
1592E:  MOVWF  x63
15930:  MOVLW  58
15932:  MOVWF  x62
15934:  MOVLW  08
15936:  MOVWF  x64
15938:  MOVLB  0
1593A:  RCALL  15144
....................     set_bits(cw[1], gyro_to_cw(telemetry.adcs_message[7], telemetry.adcs_message[8]), &bit_offset, 8);   // Gyro -Y axis 
1593C:  MOVFF  B1,C5A
15940:  MOVFF  B2,C5B
15944:  RCALL  152B6
15946:  MOVFF  01,C5A
1594A:  MOVLB  C
1594C:  CLRF   x5D
1594E:  MOVLW  F9
15950:  MOVWF  x5C
15952:  CLRF   x61
15954:  CLRF   x60
15956:  CLRF   x5F
15958:  MOVFF  01,C5E
1595C:  MOVLW  0C
1595E:  MOVWF  x63
15960:  MOVLW  58
15962:  MOVWF  x62
15964:  MOVLW  08
15966:  MOVWF  x64
15968:  MOVLB  0
1596A:  CALL   15144
....................     set_bits(cw[1], gyro_to_cw(telemetry.adcs_message[9], telemetry.adcs_message[10]), &bit_offset, 8);  // Gyro -Z axis 
1596E:  MOVFF  B3,C5A
15972:  MOVFF  B4,C5B
15976:  RCALL  152B6
15978:  MOVFF  01,C5A
1597C:  MOVLB  C
1597E:  CLRF   x5D
15980:  MOVLW  F9
15982:  MOVWF  x5C
15984:  CLRF   x61
15986:  CLRF   x60
15988:  CLRF   x5F
1598A:  MOVFF  01,C5E
1598E:  MOVLW  0C
15990:  MOVWF  x63
15992:  MOVLW  58
15994:  MOVWF  x62
15996:  MOVLW  08
15998:  MOVWF  x64
1599A:  MOVLB  0
1599C:  CALL   15144
....................     set_bits(cw[1], make16(telemetry.pcib_message[4], telemetry.pcib_message[5]) >> 11, &bit_offset, 5); // Magnetometer X 
159A0:  MOVFF  A3,C5B
159A4:  MOVLB  C
159A6:  MOVFF  A3,C5A
159AA:  CLRF   x5B
159AC:  RRCF   x5B,F
159AE:  RRCF   x5A,F
159B0:  RRCF   x5B,F
159B2:  RRCF   x5A,F
159B4:  RRCF   x5B,F
159B6:  RRCF   x5A,F
159B8:  MOVLW  1F
159BA:  ANDWF  x5B,F
159BC:  CLRF   x5D
159BE:  MOVLW  F9
159C0:  MOVWF  x5C
159C2:  CLRF   x61
159C4:  CLRF   x60
159C6:  MOVFF  C5B,C5F
159CA:  MOVFF  C5A,C5E
159CE:  MOVLW  0C
159D0:  MOVWF  x63
159D2:  MOVLW  58
159D4:  MOVWF  x62
159D6:  MOVLW  05
159D8:  MOVWF  x64
159DA:  MOVLB  0
159DC:  CALL   15144
....................     set_bits(cw[1], make16(telemetry.pcib_message[6], telemetry.pcib_message[7]) >> 11, &bit_offset, 5); // Magnetometer Y 
159E0:  MOVFF  A5,C5B
159E4:  MOVLB  C
159E6:  MOVFF  A5,C5A
159EA:  CLRF   x5B
159EC:  RRCF   x5B,F
159EE:  RRCF   x5A,F
159F0:  RRCF   x5B,F
159F2:  RRCF   x5A,F
159F4:  RRCF   x5B,F
159F6:  RRCF   x5A,F
159F8:  MOVLW  1F
159FA:  ANDWF  x5B,F
159FC:  CLRF   x5D
159FE:  MOVLW  F9
15A00:  MOVWF  x5C
15A02:  CLRF   x61
15A04:  CLRF   x60
15A06:  MOVFF  C5B,C5F
15A0A:  MOVFF  C5A,C5E
15A0E:  MOVLW  0C
15A10:  MOVWF  x63
15A12:  MOVLW  58
15A14:  MOVWF  x62
15A16:  MOVLW  05
15A18:  MOVWF  x64
15A1A:  MOVLB  0
15A1C:  CALL   15144
....................     set_bits(cw[1], make16(telemetry.pcib_message[8], telemetry.pcib_message[9]) >> 11, &bit_offset, 5); // Magnetometer Z 
15A20:  MOVFF  A7,C5B
15A24:  MOVLB  C
15A26:  MOVFF  A7,C5A
15A2A:  CLRF   x5B
15A2C:  RRCF   x5B,F
15A2E:  RRCF   x5A,F
15A30:  RRCF   x5B,F
15A32:  RRCF   x5A,F
15A34:  RRCF   x5B,F
15A36:  RRCF   x5A,F
15A38:  MOVLW  1F
15A3A:  ANDWF  x5B,F
15A3C:  CLRF   x5D
15A3E:  MOVLW  F9
15A40:  MOVWF  x5C
15A42:  CLRF   x61
15A44:  CLRF   x60
15A46:  MOVFF  C5B,C5F
15A4A:  MOVFF  C5A,C5E
15A4E:  MOVLW  0C
15A50:  MOVWF  x63
15A52:  MOVLW  58
15A54:  MOVWF  x62
15A56:  MOVLW  05
15A58:  MOVWF  x64
15A5A:  MOVLB  0
15A5C:  CALL   15144
....................     set_bits(cw[1], subsystems_communicating, &bit_offset, 3);                                           // Subsystems communicating 
15A60:  MOVLB  C
15A62:  CLRF   x5D
15A64:  MOVLW  F9
15A66:  MOVWF  x5C
15A68:  CLRF   x61
15A6A:  CLRF   x60
15A6C:  CLRF   x5F
15A6E:  MOVFF  C54,C5E
15A72:  MOVLW  0C
15A74:  MOVWF  x63
15A76:  MOVLW  58
15A78:  MOVWF  x62
15A7A:  MOVLW  03
15A7C:  MOVWF  x64
15A7E:  MOVLB  0
15A80:  CALL   15144
....................     set_bits(cw[1], time_after_reset, &bit_offset, 5);                                                   // Time after last reset (hours) 
15A84:  MOVLB  C
15A86:  CLRF   x5D
15A88:  MOVLW  F9
15A8A:  MOVWF  x5C
15A8C:  CLRF   x61
15A8E:  CLRF   x60
15A90:  CLRF   x5F
15A92:  MOVFF  C53,C5E
15A96:  MOVLW  0C
15A98:  MOVWF  x63
15A9A:  MOVLW  58
15A9C:  MOVWF  x62
15A9E:  MOVLW  05
15AA0:  MOVWF  x64
15AA2:  MOVLB  0
15AA4:  CALL   15144
....................     set_bits(cw[1], 1, &bit_offset, 1);                                                                  // Format identifier 
15AA8:  MOVLB  C
15AAA:  CLRF   x5D
15AAC:  MOVLW  F9
15AAE:  MOVWF  x5C
15AB0:  CLRF   x61
15AB2:  CLRF   x60
15AB4:  CLRF   x5F
15AB6:  MOVLW  01
15AB8:  MOVWF  x5E
15ABA:  MOVLW  0C
15ABC:  MOVWF  x63
15ABE:  MOVLW  58
15AC0:  MOVWF  x62
15AC2:  MOVLW  01
15AC4:  MOVWF  x64
15AC6:  MOVLB  0
15AC8:  CALL   15144
....................  
....................     fprintf(PC, "CW: 0x"); 
15ACC:  MOVLW  14
15ACE:  MOVWF  FF6
15AD0:  MOVLW  09
15AD2:  MOVWF  FF7
15AD4:  MOVLW  00
15AD6:  MOVWF  FF8
15AD8:  CALL   4534
....................     uart_print_pc_hex_short(cw[0], sizeof(cw[0])); 
15ADC:  MOVLB  C
15ADE:  CLRF   x5B
15AE0:  MOVLW  F3
15AE2:  MOVWF  x5A
15AE4:  MOVLW  06
15AE6:  MOVWF  x5C
15AE8:  MOVLB  0
15AEA:  RCALL  15402
....................     fprintf(PC, " 0x"); 
15AEC:  MOVLW  1C
15AEE:  MOVWF  FF6
15AF0:  MOVLW  09
15AF2:  MOVWF  FF7
15AF4:  MOVLW  00
15AF6:  MOVWF  FF8
15AF8:  CALL   4534
....................     uart_print_pc_hex_short(cw[1], sizeof(cw[1])); 
15AFC:  MOVLB  C
15AFE:  CLRF   x5B
15B00:  MOVLW  F9
15B02:  MOVWF  x5A
15B04:  MOVLW  06
15B06:  MOVWF  x5C
15B08:  MOVLB  0
15B0A:  RCALL  15402
....................     fputc(' ', PC); 
15B0C:  MOVLW  20
15B0E:  MOVLB  D
15B10:  MOVWF  x6A
15B12:  MOVLB  0
15B14:  CALL   44EE
15B18:  GOTO   168C6 (RETURN)
.................... } 
....................  
.................... void save_flags() 
*
09574:  MOVLB  C
09576:  CLRF   x44
09578:  SETF   x43
0957A:  MOVFF  C44,C42
0957E:  MOVFF  C43,C41
.................... { 
....................     uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
....................     flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
09582:  MOVLW  0A
09584:  MOVWF  x67
09586:  MOVLW  A3
09588:  MOVWF  x66
0958A:  CLRF   x6B
0958C:  CLRF   x6A
0958E:  CLRF   x69
09590:  CLRF   x68
09592:  CLRF   x6F
09594:  CLRF   x6E
09596:  CLRF   x6D
09598:  MOVLW  01
0959A:  MOVWF  x6C
0959C:  MOVLB  0
0959E:  CALL   6292
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
095A2:  MOVLW  0A
095A4:  MOVLB  D
095A6:  MOVWF  x47
095A8:  MOVLW  A3
095AA:  MOVWF  x46
095AC:  CLRF   x4B
095AE:  CLRF   x4A
095B0:  CLRF   x49
095B2:  CLRF   x48
095B4:  MOVFF  C42,D4D
095B8:  MOVFF  C41,D4C
095BC:  CLRF   x51
095BE:  CLRF   x50
095C0:  CLRF   x4F
095C2:  MOVLW  01
095C4:  MOVWF  x4E
095C6:  MOVLB  0
095C8:  CALL   653E
095CC:  RETURN 0
.................... } 
....................  
.................... // Helper function to save state to flash 
.................... void save_state(uint8_t current_command) 
.................... { 
....................     get_com_shared_fm_access(); 
*
08CAE:  RCALL  8672
....................  
....................     // Save state of obc_flags: 
....................     flash_erase_pages(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, OBC_FLAGS_ADDRESS + sizeof(obc_flags)); 
08CB0:  MOVLW  0A
08CB2:  MOVLB  C
08CB4:  MOVWF  x67
08CB6:  MOVLW  A3
08CB8:  MOVWF  x66
08CBA:  CLRF   x6B
08CBC:  CLRF   x6A
08CBE:  MOVLW  10
08CC0:  MOVWF  x69
08CC2:  CLRF   x68
08CC4:  CLRF   x6F
08CC6:  CLRF   x6E
08CC8:  MOVWF  x6D
08CCA:  MOVLW  17
08CCC:  MOVWF  x6C
08CCE:  MOVLB  0
08CD0:  CALL   6292
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
08CD4:  MOVLW  01
08CD6:  MOVLB  C
08CD8:  CLRF   x66
08CDA:  MOVWF  x62
08CDC:  MOVFF  C66,C61
....................     flash_transfer_data_from_ram( 
....................         &spi_port_COM_FM, 
....................         OBC_FLAGS_ADDRESS, 
....................         obc_flag_ptr, 
....................         sizeof(obc_flags)); 
08CE0:  MOVLW  0A
08CE2:  MOVLB  D
08CE4:  MOVWF  x47
08CE6:  MOVLW  A3
08CE8:  MOVWF  x46
08CEA:  CLRF   x4B
08CEC:  CLRF   x4A
08CEE:  MOVLW  10
08CF0:  MOVWF  x49
08CF2:  CLRF   x48
08CF4:  MOVFF  C62,D4D
08CF8:  MOVFF  C61,D4C
08CFC:  CLRF   x51
08CFE:  CLRF   x50
08D00:  CLRF   x4F
08D02:  MOVLW  17
08D04:  MOVWF  x4E
08D06:  MOVLB  0
08D08:  CALL   653E
....................  
....................     // Disable the current command before saving 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
08D0C:  MOVLB  C
08D0E:  CLRF   x63
08D10:  MOVF   x63,W
08D12:  SUBLW  1F
08D14:  BTFSS  FD8.0
08D16:  BRA    8E22
....................         if (scheduled_commands[i].command[0] == MSG_COMM && scheduled_commands[i].command[1] == current_command && scheduled_commands[i].time <= current_time) { 
08D18:  CLRF   xC4
08D1A:  MOVFF  C63,CC3
08D1E:  CLRF   xC6
08D20:  MOVLW  20
08D22:  MOVWF  xC5
08D24:  MOVLB  0
08D26:  CALL   4D06
08D2A:  MOVFF  02,C67
08D2E:  MOVFF  01,C66
08D32:  MOVLW  04
08D34:  MOVLB  C
08D36:  ADDWF  x66,F
08D38:  MOVLW  00
08D3A:  ADDWFC x67,F
08D3C:  MOVLW  5A
08D3E:  ADDWF  x66,W
08D40:  MOVWF  FE9
08D42:  MOVLW  01
08D44:  ADDWFC x67,W
08D46:  MOVWF  FEA
08D48:  MOVF   FEF,W
08D4A:  SUBLW  C0
08D4C:  BNZ   8E1E
08D4E:  CLRF   xC4
08D50:  MOVFF  C63,CC3
08D54:  CLRF   xC6
08D56:  MOVLW  20
08D58:  MOVWF  xC5
08D5A:  MOVLB  0
08D5C:  CALL   4D06
08D60:  MOVFF  02,C69
08D64:  MOVFF  01,C68
08D68:  MOVLW  04
08D6A:  MOVLB  C
08D6C:  ADDWF  x68,F
08D6E:  MOVLW  00
08D70:  ADDWFC x69,F
08D72:  MOVLW  01
08D74:  ADDWF  x68,W
08D76:  MOVWF  01
08D78:  MOVLW  00
08D7A:  ADDWFC x69,W
08D7C:  MOVWF  03
08D7E:  MOVF   01,W
08D80:  ADDLW  5A
08D82:  MOVWF  FE9
08D84:  MOVLW  01
08D86:  ADDWFC 03,W
08D88:  MOVWF  FEA
08D8A:  MOVF   x60,W
08D8C:  SUBWF  FEF,W
08D8E:  BNZ   8E1E
08D90:  CLRF   xC4
08D92:  MOVFF  C63,CC3
08D96:  CLRF   xC6
08D98:  MOVLW  20
08D9A:  MOVWF  xC5
08D9C:  MOVLB  0
08D9E:  CALL   4D06
08DA2:  MOVFF  02,C69
08DA6:  MOVFF  01,C68
08DAA:  MOVLW  5A
08DAC:  MOVLB  C
08DAE:  ADDWF  01,W
08DB0:  MOVWF  FE9
08DB2:  MOVLW  01
08DB4:  ADDWFC 02,W
08DB6:  MOVWF  FEA
08DB8:  MOVFF  FEF,C6A
08DBC:  MOVFF  FEC,C6B
08DC0:  MOVFF  FEC,C6C
08DC4:  MOVFF  FEC,C6D
08DC8:  BTFSS  x6D.7
08DCA:  BRA    8DD2
08DCC:  BTFSS  3E.7
08DCE:  BRA    8DF4
08DD0:  BRA    8DD6
08DD2:  BTFSC  3E.7
08DD4:  BRA    8E1E
08DD6:  MOVF   x6D,W
08DD8:  SUBWF  3E,W
08DDA:  BNC   8E1E
08DDC:  BNZ   8DF4
08DDE:  MOVF   x6C,W
08DE0:  SUBWF  3D,W
08DE2:  BNC   8E1E
08DE4:  BNZ   8DF4
08DE6:  MOVF   x6B,W
08DE8:  SUBWF  3C,W
08DEA:  BNC   8E1E
08DEC:  BNZ   8DF4
08DEE:  MOVF   x6A,W
08DF0:  SUBWF  3B,W
08DF2:  BNC   8E1E
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
08DF4:  CLRF   xC4
08DF6:  MOVFF  C63,CC3
08DFA:  CLRF   xC6
08DFC:  MOVLW  20
08DFE:  MOVWF  xC5
08E00:  MOVLB  0
08E02:  CALL   4D06
08E06:  MOVLW  5A
08E08:  MOVLB  C
08E0A:  ADDWF  01,W
08E0C:  MOVWF  FE9
08E0E:  MOVLW  01
08E10:  ADDWFC 02,W
08E12:  MOVWF  FEA
08E14:  SETF   FEF
08E16:  SETF   FEC
08E18:  SETF   FEC
08E1A:  MOVLW  7F
08E1C:  MOVWF  FEC
....................         } 
08E1E:  INCF   x63,F
08E20:  BRA    8D10
....................     } 
....................  
....................     // Save state of scheduled commands: 
....................     flash_erase_pages(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, SCHEDULED_CMD_ADDRESS + sizeof(scheduled_commands)); 
08E22:  MOVLW  0A
08E24:  MOVWF  x67
08E26:  MOVLW  A3
08E28:  MOVWF  x66
08E2A:  CLRF   x6B
08E2C:  CLRF   x6A
08E2E:  MOVLW  30
08E30:  MOVWF  x69
08E32:  CLRF   x68
08E34:  CLRF   x6F
08E36:  CLRF   x6E
08E38:  MOVLW  34
08E3A:  MOVWF  x6D
08E3C:  CLRF   x6C
08E3E:  MOVLB  0
08E40:  CALL   6292
....................     uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
08E44:  MOVLW  01
08E46:  MOVLB  C
08E48:  MOVWF  x67
08E4A:  MOVLW  5A
08E4C:  MOVFF  C67,C65
08E50:  MOVWF  x64
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, cmd_ptr, sizeof(scheduled_commands)); 
08E52:  MOVLW  0A
08E54:  MOVLB  D
08E56:  MOVWF  x47
08E58:  MOVLW  A3
08E5A:  MOVWF  x46
08E5C:  CLRF   x4B
08E5E:  CLRF   x4A
08E60:  MOVLW  30
08E62:  MOVWF  x49
08E64:  CLRF   x48
08E66:  MOVFF  C65,D4D
08E6A:  MOVFF  C64,D4C
08E6E:  CLRF   x51
08E70:  CLRF   x50
08E72:  MOVLW  04
08E74:  MOVWF  x4F
08E76:  CLRF   x4E
08E78:  MOVLB  0
08E7A:  CALL   653E
08E7E:  RETURN 0
.................... } 
....................  
.................... void send_mcp_command(uint8_t mcp_command, uint16_t data, uint8_t silent) 
.................... { 
....................     if (mux_sel(mux_mcpic) != mux_mcpic) { // If MUX did not change 
*
0BAD6:  MOVLW  05
0BAD8:  MOVLB  C
0BADA:  MOVWF  xBE
0BADC:  MOVLB  0
0BADE:  CALL   52E8
0BAE2:  MOVF   01,W
0BAE4:  SUBLW  05
0BAE6:  BZ    BB06
....................         if (verbose) { 
0BAE8:  MOVLB  5
0BAEA:  MOVF   x5A,F
0BAEC:  BZ    BB02
....................             fprintf(PC, "MUX change failed!"); 
0BAEE:  MOVLW  20
0BAF0:  MOVWF  FF6
0BAF2:  MOVLW  09
0BAF4:  MOVWF  FF7
0BAF6:  MOVLW  00
0BAF8:  MOVWF  FF8
0BAFA:  MOVLB  0
0BAFC:  CALL   4534
0BB00:  MOVLB  5
....................         } 
....................         return; 
0BB02:  BRA    BBBC
0BB04:  MOVLB  0
....................     } 
....................  
....................     uint8_t cmd[MSG_LENGTH_MCPIC] = { 0 }; 
0BB06:  MOVLB  C
0BB08:  CLRF   x84
0BB0A:  CLRF   x85
0BB0C:  CLRF   x86
0BB0E:  CLRF   x87
0BB10:  CLRF   x88
0BB12:  CLRF   x89
....................  
....................     struct mcp_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t data; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* mcp_packet = (struct mcp_packet*)cmd; 
0BB14:  MOVLW  0C
0BB16:  MOVWF  x8E
0BB18:  MOVLW  84
0BB1A:  MOVFF  C8E,C8B
0BB1E:  MOVWF  x8A
....................  
....................     mcp_packet->origin = MSG_OBC; 
0BB20:  MOVFF  C8A,FE9
0BB24:  MOVFF  C8B,FEA
0BB28:  MOVLW  0B
0BB2A:  MOVWF  FEF
....................     mcp_packet->command = mcp_command; 
0BB2C:  MOVLW  01
0BB2E:  ADDWF  x8A,W
0BB30:  MOVWF  FE9
0BB32:  MOVLW  00
0BB34:  ADDWFC x8B,W
0BB36:  MOVWF  FEA
0BB38:  MOVFF  C80,FEF
....................     mcp_packet->data = data; 
0BB3C:  MOVLW  02
0BB3E:  ADDWF  x8A,W
0BB40:  MOVWF  FE9
0BB42:  MOVLW  00
0BB44:  ADDWFC x8B,W
0BB46:  MOVWF  FEA
0BB48:  MOVFF  C82,FEC
0BB4C:  MOVF   FED,F
0BB4E:  MOVFF  C81,FEF
....................  
....................     checksum_obc(cmd, sizeof(cmd)); 
0BB52:  MOVLW  0C
0BB54:  MOVWF  xAF
0BB56:  MOVLW  84
0BB58:  MOVWF  xAE
0BB5A:  MOVLW  06
0BB5C:  MOVWF  xB0
0BB5E:  MOVLB  0
0BB60:  CALL   8E80
....................  
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
0BB64:  MOVLB  C
0BB66:  CLRF   x8C
0BB68:  MOVF   x8C,W
0BB6A:  SUBLW  05
0BB6C:  BNC   BB8E
....................         fputc(cmd[i], MCPIC); 
0BB6E:  CLRF   03
0BB70:  MOVF   x8C,W
0BB72:  ADDLW  84
0BB74:  MOVWF  FE9
0BB76:  MOVLW  0C
0BB78:  ADDWFC 03,W
0BB7A:  MOVWF  FEA
0BB7C:  MOVFF  FEF,C8D
0BB80:  MOVF   x8D,W
0BB82:  MOVLB  0
0BB84:  CALL   5464
0BB88:  MOVLB  C
0BB8A:  INCF   x8C,F
0BB8C:  BRA    BB68
....................     } 
....................  
....................     if (!silent) { 
0BB8E:  MOVF   x83,F
0BB90:  BNZ   BBBA
....................         fprintf(PC, "MCPIC cmd: "); 
0BB92:  MOVLW  34
0BB94:  MOVWF  FF6
0BB96:  MOVLW  09
0BB98:  MOVWF  FF7
0BB9A:  MOVLW  00
0BB9C:  MOVWF  FF8
0BB9E:  MOVLB  0
0BBA0:  CALL   4534
....................         uart_print_pc_hex(cmd, sizeof(cmd)); 
0BBA4:  MOVLW  0C
0BBA6:  MOVLB  C
0BBA8:  MOVWF  x90
0BBAA:  MOVLW  84
0BBAC:  MOVWF  x8F
0BBAE:  MOVLW  06
0BBB0:  MOVWF  x91
0BBB2:  MOVLB  0
0BBB4:  CALL   7A5C
0BBB8:  MOVLB  C
0BBBA:  MOVLB  5
....................     } 
0BBBC:  MOVLB  0
0BBBE:  RETURN 0
.................... } 
....................  
.................... // ============ Commands for Telemetry request ============ 
....................  
.................... // Request for reset telemetry 
.................... uint8_t command_request_reset(uint8_t* data) 
.................... { 
....................     uart_clean(RST); 
*
0D9FE:  MOVLW  09
0DA00:  MOVLB  D
0DA02:  MOVWF  x85
0DA04:  MOVLW  6F
0DA06:  MOVWF  x84
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
*
0DA6E:  MOVLB  C
0DA70:  CLRF   x3A
0DA72:  MOVF   x3A,W
0DA74:  SUBLW  23
0DA76:  BNC   DA8C
....................         fputc(cmd[i], RST); 
0DA78:  CLRF   03
0DA7A:  MOVF   x3A,W
0DA7C:  MOVLB  0
0DA7E:  CALL   0194
0DA82:  CALL   544E
0DA86:  MOVLB  C
0DA88:  INCF   x3A,F
0DA8A:  BRA    DA72
....................     } 
....................     return 0; 
0DA8C:  MOVLW  00
0DA8E:  MOVWF  01
0DA90:  MOVLB  0
0DA92:  GOTO   18B6C (RETURN)
.................... } 
....................  
.................... // Request for eps telemetry 
.................... uint8_t command_request_eps(uint8_t* data) 
.................... { 
....................     uart_clean(FAB); 
0DA96:  MOVLW  09
0DA98:  MOVLB  D
0DA9A:  MOVWF  x85
0DA9C:  MOVLW  26
0DA9E:  MOVWF  x84
....................  
....................     uint8_t i; 
....................     enum { cmd_size = 6 }; 
....................  
....................     uint8_t cmd[cmd_size] = { 0 }; 
*
0DB06:  MOVLB  C
0DB08:  CLRF   x3B
0DB0A:  CLRF   x3C
0DB0C:  CLRF   x3D
0DB0E:  CLRF   x3E
0DB10:  CLRF   x3F
0DB12:  CLRF   x40
....................  
....................     cmd[0] = 0xE0; 
0DB14:  MOVLW  E0
0DB16:  MOVWF  x3B
....................     cmd[1] = 0x61; 
0DB18:  MOVLW  61
0DB1A:  MOVWF  x3C
....................     *(uint32_t*)&cmd[2] = current_time; 
0DB1C:  MOVLW  0C
0DB1E:  MOVWF  x42
0DB20:  MOVLW  3D
0DB22:  MOVWF  FE9
0DB24:  MOVFF  C42,FEA
0DB28:  MOVFF  3B,FEF
0DB2C:  MOVFF  3C,FEC
0DB30:  MOVFF  3D,FEC
0DB34:  MOVFF  3E,FEC
....................  
....................     for (i = 0; i < sizeof(cmd); i++) { 
0DB38:  CLRF   x3A
0DB3A:  MOVF   x3A,W
0DB3C:  SUBLW  05
0DB3E:  BNC   DB60
....................         fputc(cmd[i], FAB); 
0DB40:  CLRF   03
0DB42:  MOVF   x3A,W
0DB44:  ADDLW  3B
0DB46:  MOVWF  FE9
0DB48:  MOVLW  0C
0DB4A:  ADDWFC 03,W
0DB4C:  MOVWF  FEA
0DB4E:  MOVFF  FEF,C41
0DB52:  MOVF   x41,W
0DB54:  MOVLB  0
0DB56:  CALL   5438
0DB5A:  MOVLB  C
0DB5C:  INCF   x3A,F
0DB5E:  BRA    DB3A
....................     } 
....................  
....................     return 0; 
0DB60:  MOVLW  00
0DB62:  MOVWF  01
0DB64:  MOVLB  0
0DB66:  GOTO   18B7E (RETURN)
.................... } 
....................  
.................... // request for adcs telemetry 
.................... uint8_t command_request_adcs(uint8_t* data) 
.................... { 
....................     uart_clean(ADCS); 
*
0DC2E:  MOVLW  09
0DC30:  MOVLB  D
0DC32:  MOVWF  x85
0DC34:  MOVLW  9C
0DC36:  MOVWF  x84
....................  
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0DC9E:  MOVLW  02
0DCA0:  MOVLB  C
0DCA2:  MOVWF  xBE
0DCA4:  MOVLB  0
0DCA6:  CALL   52E8
0DCAA:  MOVF   01,W
0DCAC:  SUBLW  02
0DCAE:  BZ    DCD2
....................         if (verbose) { 
0DCB0:  MOVLB  5
0DCB2:  MOVF   x5A,F
0DCB4:  BZ    DCCA
....................             fprintf(PC, "MUX change failed!"); 
0DCB6:  MOVLW  40
0DCB8:  MOVWF  FF6
0DCBA:  MOVLW  09
0DCBC:  MOVWF  FF7
0DCBE:  MOVLW  00
0DCC0:  MOVWF  FF8
0DCC2:  MOVLB  0
0DCC4:  CALL   4534
0DCC8:  MOVLB  5
....................         } 
....................         return 1; 
0DCCA:  MOVLW  01
0DCCC:  MOVWF  01
0DCCE:  BRA    DD90
0DCD0:  MOVLB  0
....................     } 
....................  
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B }; 
0DCD2:  MOVLW  0B
0DCD4:  MOVLB  C
0DCD6:  MOVWF  x3A
0DCD8:  CLRF   x3B
0DCDA:  CLRF   x3C
0DCDC:  CLRF   x3D
0DCDE:  CLRF   x3E
0DCE0:  CLRF   x3F
0DCE2:  CLRF   x40
0DCE4:  CLRF   x41
0DCE6:  CLRF   x42
0DCE8:  CLRF   x43
0DCEA:  CLRF   x44
0DCEC:  CLRF   x45
0DCEE:  CLRF   x46
0DCF0:  CLRF   x47
0DCF2:  CLRF   x48
0DCF4:  CLRF   x49
0DCF6:  CLRF   x4A
0DCF8:  CLRF   x4B
0DCFA:  CLRF   x4C
0DCFC:  CLRF   x4D
0DCFE:  CLRF   x4E
0DD00:  CLRF   x4F
0DD02:  CLRF   x50
0DD04:  CLRF   x51
0DD06:  CLRF   x52
0DD08:  CLRF   x53
0DD0A:  CLRF   x54
0DD0C:  CLRF   x55
0DD0E:  CLRF   x56
0DD10:  CLRF   x57
0DD12:  CLRF   x58
0DD14:  CLRF   x59
0DD16:  CLRF   x5A
0DD18:  CLRF   x5B
0DD1A:  CLRF   x5C
0DD1C:  CLRF   x5D
0DD1E:  CLRF   x5E
0DD20:  CLRF   x5F
0DD22:  CLRF   x60
0DD24:  CLRF   x61
0DD26:  CLRF   x62
0DD28:  CLRF   x63
0DD2A:  CLRF   x64
0DD2C:  CLRF   x65
....................     adcs_command[1] = 0xAB; 
0DD2E:  MOVLW  AB
0DD30:  MOVWF  x3B
....................     *(time_t*)&adcs_command[2] = current_time; 
0DD32:  MOVLW  0C
0DD34:  MOVWF  x68
0DD36:  MOVLW  3C
0DD38:  MOVWF  FE9
0DD3A:  MOVFF  C68,FEA
0DD3E:  MOVFF  3B,FEF
0DD42:  MOVFF  3C,FEC
0DD46:  MOVFF  3D,FEC
0DD4A:  MOVFF  3E,FEC
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
0DD4E:  MOVLW  0C
0DD50:  MOVWF  xAF
0DD52:  MOVLW  3A
0DD54:  MOVWF  xAE
0DD56:  MOVLW  2C
0DD58:  MOVWF  xB0
0DD5A:  MOVLB  0
0DD5C:  CALL   8E80
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
0DD60:  MOVLB  C
0DD62:  CLRF   x66
0DD64:  MOVF   x66,W
0DD66:  SUBLW  2B
0DD68:  BNC   DD8A
....................         fputc(adcs_command[i], ADCS); 
0DD6A:  CLRF   03
0DD6C:  MOVF   x66,W
0DD6E:  ADDLW  3A
0DD70:  MOVWF  FE9
0DD72:  MOVLW  0C
0DD74:  ADDWFC 03,W
0DD76:  MOVWF  FEA
0DD78:  MOVFF  FEF,C67
0DD7C:  MOVF   x67,W
0DD7E:  MOVLB  0
0DD80:  CALL   5464
0DD84:  MOVLB  C
0DD86:  INCF   x66,F
0DD88:  BRA    DD64
....................     } 
....................     return 0; 
0DD8A:  MOVLW  00
0DD8C:  MOVWF  01
0DD8E:  MOVLB  5
0DD90:  MOVLB  0
0DD92:  GOTO   18BA2 (RETURN)
.................... } 
....................  
.................... // Request for Mission Control PIC Status 
.................... uint8_t command_request_mission_control_PIC_status(uint8_t* data) 
.................... { 
....................     uart_clean(MCPIC); 
*
0DB6A:  MOVLW  09
0DB6C:  MOVLB  D
0DB6E:  MOVWF  x85
0DB70:  MOVLW  D1
0DB72:  MOVWF  x84
....................  
....................     if (mux_sel(mux_mcpic) != mux_mcpic) { // If MUX did not change 
*
0DBDA:  MOVLW  05
0DBDC:  MOVLB  C
0DBDE:  MOVWF  xBE
0DBE0:  MOVLB  0
0DBE2:  CALL   52E8
0DBE6:  MOVF   01,W
0DBE8:  SUBLW  05
0DBEA:  BZ    DC0E
....................         if (verbose) { 
0DBEC:  MOVLB  5
0DBEE:  MOVF   x5A,F
0DBF0:  BZ    DC06
....................             fprintf(PC, "MUX change failed!"); 
0DBF2:  MOVLW  54
0DBF4:  MOVWF  FF6
0DBF6:  MOVLW  09
0DBF8:  MOVWF  FF7
0DBFA:  MOVLW  00
0DBFC:  MOVWF  FF8
0DBFE:  MOVLB  0
0DC00:  CALL   4534
0DC04:  MOVLB  5
....................         } 
....................         return 1; 
0DC06:  MOVLW  01
0DC08:  MOVWF  01
0DC0A:  BRA    DC28
0DC0C:  MOVLB  0
....................     } 
....................  
....................     send_mcp_command(0x10, 0, true); 
0DC0E:  MOVLW  10
0DC10:  MOVLB  C
0DC12:  MOVWF  x80
0DC14:  CLRF   x82
0DC16:  CLRF   x81
0DC18:  MOVLW  01
0DC1A:  MOVWF  x83
0DC1C:  MOVLB  0
0DC1E:  CALL   BAD6
....................     return 0; 
0DC22:  MOVLW  00
0DC24:  MOVWF  01
0DC26:  MOVLB  5
0DC28:  MOVLB  0
0DC2A:  GOTO   18B90 (RETURN)
.................... } 
....................  
.................... // Request for pcib telemetry 
.................... uint8_t command_request_pcib(uint8_t* data) 
.................... { 
....................     uart_clean(PCIB); 
*
0DD96:  MOVLW  09
0DD98:  MOVLB  D
0DD9A:  MOVWF  x85
0DD9C:  MOVLW  E0
0DD9E:  MOVWF  x84
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
0DE06:  MOVLW  06
0DE08:  MOVLB  C
0DE0A:  MOVWF  xBE
0DE0C:  MOVLB  0
0DE0E:  CALL   52E8
0DE12:  MOVF   01,W
0DE14:  SUBLW  06
0DE16:  BZ    DE3A
....................         if (verbose) { 
0DE18:  MOVLB  5
0DE1A:  MOVF   x5A,F
0DE1C:  BZ    DE32
....................             fprintf(PC, "MUX change failed!"); 
0DE1E:  MOVLW  68
0DE20:  MOVWF  FF6
0DE22:  MOVLW  09
0DE24:  MOVWF  FF7
0DE26:  MOVLW  00
0DE28:  MOVWF  FF8
0DE2A:  MOVLB  0
0DE2C:  CALL   4534
0DE30:  MOVLB  5
....................         } 
....................         return 1; 
0DE32:  MOVLW  01
0DE34:  MOVWF  01
0DE36:  BRA    DEB8
0DE38:  MOVLB  0
....................     } 
....................  
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_PCIB - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
0DE3A:  MOVLW  0C
0DE3C:  MOVLB  C
0DE3E:  MOVWF  x62
0DE40:  MOVLW  3A
0DE42:  MOVFF  C62,C5F
0DE46:  MOVWF  x5E
....................     memset(cmd, 0, sizeof(request)); 
0DE48:  MOVFF  C5F,FEA
0DE4C:  MOVFF  C5E,FE9
0DE50:  CLRF   00
0DE52:  CLRF   02
0DE54:  MOVLW  24
0DE56:  MOVWF  01
0DE58:  MOVLB  0
0DE5A:  CALL   5222
....................  
....................     request.origin = 0x0B; 
0DE5E:  MOVLW  0B
0DE60:  MOVLB  C
0DE62:  MOVWF  x3A
....................     request.cmd = 0xAA; 
0DE64:  MOVLW  AA
0DE66:  MOVWF  x3B
....................     request.obc_time = current_time; 
0DE68:  MOVFF  3E,C3F
0DE6C:  MOVFF  3D,C3E
0DE70:  MOVFF  3C,C3D
0DE74:  MOVFF  3B,C3C
....................  
....................     checksum_obc(cmd, sizeof(request)); 
0DE78:  MOVFF  C5F,CAF
0DE7C:  MOVFF  C5E,CAE
0DE80:  MOVLW  24
0DE82:  MOVWF  xB0
0DE84:  MOVLB  0
0DE86:  CALL   8E80
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
0DE8A:  MOVLB  C
0DE8C:  CLRF   x60
0DE8E:  MOVF   x60,W
0DE90:  SUBLW  23
0DE92:  BNC   DEB2
....................         fputc(cmd[i], PCIB); 
0DE94:  MOVF   x60,W
0DE96:  ADDWF  x5E,W
0DE98:  MOVWF  FE9
0DE9A:  MOVLW  00
0DE9C:  ADDWFC x5F,W
0DE9E:  MOVWF  FEA
0DEA0:  MOVFF  FEF,C61
0DEA4:  MOVF   x61,W
0DEA6:  MOVLB  0
0DEA8:  CALL   5464
0DEAC:  MOVLB  C
0DEAE:  INCF   x60,F
0DEB0:  BRA    DE8E
....................     } 
....................     return 0; 
0DEB2:  MOVLW  00
0DEB4:  MOVWF  01
0DEB6:  MOVLB  5
0DEB8:  MOVLB  0
0DEBA:  GOTO   18BB4 (RETURN)
.................... } 
....................  
.................... // Request for tmcr1 telemetry 
.................... uint8_t command_request_tmcr1(uint8_t* data) 
.................... { 
....................     uart_clean(TMCR1); 
0DEBE:  MOVLW  0A
0DEC0:  MOVLB  D
0DEC2:  MOVWF  x85
0DEC4:  MOVLW  0D
0DEC6:  MOVWF  x84
....................  
....................     if (mux_sel(mux_tmcr1) != mux_tmcr1) { // If MUX did not change 
*
0DF2E:  MOVLW  01
0DF30:  MOVLB  C
0DF32:  MOVWF  xBE
0DF34:  MOVLB  0
0DF36:  CALL   52E8
0DF3A:  DECFSZ 01,W
0DF3C:  BRA    DF40
0DF3E:  BRA    DF62
....................         if (verbose) { 
0DF40:  MOVLB  5
0DF42:  MOVF   x5A,F
0DF44:  BZ    DF5A
....................             fprintf(PC, "MUX change failed!"); 
0DF46:  MOVLW  7C
0DF48:  MOVWF  FF6
0DF4A:  MOVLW  09
0DF4C:  MOVWF  FF7
0DF4E:  MOVLW  00
0DF50:  MOVWF  FF8
0DF52:  MOVLB  0
0DF54:  CALL   4534
0DF58:  MOVLB  5
....................         } 
....................         return 1; 
0DF5A:  MOVLW  01
0DF5C:  MOVWF  01
0DF5E:  BRA    DFE0
0DF60:  MOVLB  0
....................     } 
....................  
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_TMCR1 - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
0DF62:  MOVLW  0C
0DF64:  MOVLB  C
0DF66:  MOVWF  x62
0DF68:  MOVLW  3A
0DF6A:  MOVFF  C62,C5F
0DF6E:  MOVWF  x5E
....................     memset(cmd, 0, sizeof(request)); 
0DF70:  MOVFF  C5F,FEA
0DF74:  MOVFF  C5E,FE9
0DF78:  CLRF   00
0DF7A:  CLRF   02
0DF7C:  MOVLW  24
0DF7E:  MOVWF  01
0DF80:  MOVLB  0
0DF82:  CALL   5222
....................  
....................     request.origin = 0x0B; 
0DF86:  MOVLW  0B
0DF88:  MOVLB  C
0DF8A:  MOVWF  x3A
....................     request.cmd = 0xAA; 
0DF8C:  MOVLW  AA
0DF8E:  MOVWF  x3B
....................     request.obc_time = current_time; 
0DF90:  MOVFF  3E,C3F
0DF94:  MOVFF  3D,C3E
0DF98:  MOVFF  3C,C3D
0DF9C:  MOVFF  3B,C3C
....................  
....................     checksum_obc(cmd, sizeof(request)); 
0DFA0:  MOVFF  C5F,CAF
0DFA4:  MOVFF  C5E,CAE
0DFA8:  MOVLW  24
0DFAA:  MOVWF  xB0
0DFAC:  MOVLB  0
0DFAE:  CALL   8E80
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
0DFB2:  MOVLB  C
0DFB4:  CLRF   x60
0DFB6:  MOVF   x60,W
0DFB8:  SUBLW  23
0DFBA:  BNC   DFDA
....................         fputc(cmd[i], TMCR1); 
0DFBC:  MOVF   x60,W
0DFBE:  ADDWF  x5E,W
0DFC0:  MOVWF  FE9
0DFC2:  MOVLW  00
0DFC4:  ADDWFC x5F,W
0DFC6:  MOVWF  FEA
0DFC8:  MOVFF  FEF,C61
0DFCC:  MOVF   x61,W
0DFCE:  MOVLB  0
0DFD0:  CALL   5464
0DFD4:  MOVLB  C
0DFD6:  INCF   x60,F
0DFD8:  BRA    DFB6
....................     } 
....................     return 0; 
0DFDA:  MOVLW  00
0DFDC:  MOVWF  01
0DFDE:  MOVLB  5
0DFE0:  MOVLB  0
0DFE2:  GOTO   18BC6 (RETURN)
.................... } 
....................  
.................... // Request for tmcr2 telemetry 
.................... uint8_t command_request_tmcr2(uint8_t* data) 
.................... { 
....................     uart_clean(TMCR2); 
0DFE6:  MOVLW  0A
0DFE8:  MOVLB  D
0DFEA:  MOVWF  x85
0DFEC:  MOVLW  3A
0DFEE:  MOVWF  x84
....................  
....................     if (mux_sel(mux_tmcr2) != mux_tmcr2) { // If MUX did not change 
*
0E056:  MOVLW  03
0E058:  MOVLB  C
0E05A:  MOVWF  xBE
0E05C:  MOVLB  0
0E05E:  CALL   52E8
0E062:  MOVF   01,W
0E064:  SUBLW  03
0E066:  BZ    E08A
....................         if (verbose) { 
0E068:  MOVLB  5
0E06A:  MOVF   x5A,F
0E06C:  BZ    E082
....................             fprintf(PC, "MUX change failed!"); 
0E06E:  MOVLW  90
0E070:  MOVWF  FF6
0E072:  MOVLW  09
0E074:  MOVWF  FF7
0E076:  MOVLW  00
0E078:  MOVWF  FF8
0E07A:  MOVLB  0
0E07C:  CALL   4534
0E080:  MOVLB  5
....................         } 
....................         return 1; 
0E082:  MOVLW  01
0E084:  MOVWF  01
0E086:  BRA    E108
0E088:  MOVLB  0
....................     } 
....................  
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_TMCR2 - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
0E08A:  MOVLW  0C
0E08C:  MOVLB  C
0E08E:  MOVWF  x62
0E090:  MOVLW  3A
0E092:  MOVFF  C62,C5F
0E096:  MOVWF  x5E
....................     memset(cmd, 0, sizeof(request)); 
0E098:  MOVFF  C5F,FEA
0E09C:  MOVFF  C5E,FE9
0E0A0:  CLRF   00
0E0A2:  CLRF   02
0E0A4:  MOVLW  24
0E0A6:  MOVWF  01
0E0A8:  MOVLB  0
0E0AA:  CALL   5222
....................  
....................     request.origin = 0x0B; 
0E0AE:  MOVLW  0B
0E0B0:  MOVLB  C
0E0B2:  MOVWF  x3A
....................     request.cmd = 0xAA; 
0E0B4:  MOVLW  AA
0E0B6:  MOVWF  x3B
....................     request.obc_time = current_time; 
0E0B8:  MOVFF  3E,C3F
0E0BC:  MOVFF  3D,C3E
0E0C0:  MOVFF  3C,C3D
0E0C4:  MOVFF  3B,C3C
....................  
....................     checksum_obc(cmd, sizeof(request)); 
0E0C8:  MOVFF  C5F,CAF
0E0CC:  MOVFF  C5E,CAE
0E0D0:  MOVLW  24
0E0D2:  MOVWF  xB0
0E0D4:  MOVLB  0
0E0D6:  CALL   8E80
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
0E0DA:  MOVLB  C
0E0DC:  CLRF   x60
0E0DE:  MOVF   x60,W
0E0E0:  SUBLW  23
0E0E2:  BNC   E102
....................         fputc(cmd[i], TMCR2); 
0E0E4:  MOVF   x60,W
0E0E6:  ADDWF  x5E,W
0E0E8:  MOVWF  FE9
0E0EA:  MOVLW  00
0E0EC:  ADDWFC x5F,W
0E0EE:  MOVWF  FEA
0E0F0:  MOVFF  FEF,C61
0E0F4:  MOVF   x61,W
0E0F6:  MOVLB  0
0E0F8:  CALL   5464
0E0FC:  MOVLB  C
0E0FE:  INCF   x60,F
0E100:  BRA    E0DE
....................     } 
....................     return 0; 
0E102:  MOVLW  00
0E104:  MOVWF  01
0E106:  MOVLB  5
0E108:  MOVLB  0
0E10A:  GOTO   18BD8 (RETURN)
.................... } 
....................  
.................... // ============ ADCS Commands ============ 
....................  
.................... enum adcs_modes { // updated on 2023/05/01 
....................     adcs_mode_tumbling = 0, 
....................     adcs_mode_detumbling = 1, 
....................     adcs_mode_detumble_sun_tracking_auto = 2, 
....................     adcs_mode_sun_tracking = 3, 
....................     adcs_mode_nadir_sband = 4, 
....................     adcs_mode_nadir_camera = 5, 
....................     adcs_mode_target = 6, 
....................     adcs_mode_sun_tracking_quat = 7, 
....................     adcs_mode_target_camera = 8, 
....................     adcs_mode_horizon_camera = 9, 
....................     adcs_mode_nadir_sband_pz = 10, 
....................     adcs_mode_nadir_camera_pz = 11 
.................... }; 
....................  
.................... // Helper function to send STM32 commands (up to 32-bytes) 
.................... void stm32_raw_command(uint8_t* data, uint8_t length, uint8_t tle) 
.................... { 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B, 0x06 }; 
*
0CD30:  MOVLW  0B
0CD32:  MOVLB  C
0CD34:  MOVWF  x5A
0CD36:  MOVLW  06
0CD38:  MOVWF  x5B
0CD3A:  CLRF   x5C
0CD3C:  CLRF   x5D
0CD3E:  CLRF   x5E
0CD40:  CLRF   x5F
0CD42:  CLRF   x60
0CD44:  CLRF   x61
0CD46:  CLRF   x62
0CD48:  CLRF   x63
0CD4A:  CLRF   x64
0CD4C:  CLRF   x65
0CD4E:  CLRF   x66
0CD50:  CLRF   x67
0CD52:  CLRF   x68
0CD54:  CLRF   x69
0CD56:  CLRF   x6A
0CD58:  CLRF   x6B
0CD5A:  CLRF   x6C
0CD5C:  CLRF   x6D
0CD5E:  CLRF   x6E
0CD60:  CLRF   x6F
0CD62:  CLRF   x70
0CD64:  CLRF   x71
0CD66:  CLRF   x72
0CD68:  CLRF   x73
0CD6A:  CLRF   x74
0CD6C:  CLRF   x75
0CD6E:  CLRF   x76
0CD70:  CLRF   x77
0CD72:  CLRF   x78
0CD74:  CLRF   x79
0CD76:  CLRF   x7A
0CD78:  CLRF   x7B
0CD7A:  CLRF   x7C
0CD7C:  CLRF   x7D
0CD7E:  CLRF   x7E
0CD80:  CLRF   x7F
0CD82:  CLRF   x80
0CD84:  CLRF   x81
0CD86:  CLRF   x82
0CD88:  CLRF   x83
0CD8A:  CLRF   x84
0CD8C:  CLRF   x85
....................     if (tle) { 
0CD8E:  MOVF   x59,F
0CD90:  BZ    CD96
....................         adcs_command[1] = 0x07; 
0CD92:  MOVLW  07
0CD94:  MOVWF  x5B
....................     } 
....................     memcpy(adcs_command + 2, data, length); 
0CD96:  MOVLW  0C
0CD98:  MOVWF  FEA
0CD9A:  MOVLW  5C
0CD9C:  MOVWF  FE9
0CD9E:  MOVFF  C57,FE2
0CDA2:  MOVFF  C56,FE1
0CDA6:  MOVF   x58,W
0CDA8:  MOVWF  01
0CDAA:  BZ    CDB4
0CDAC:  MOVFF  FE6,FEE
0CDB0:  DECFSZ 01,F
0CDB2:  BRA    CDAC
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
0CDB4:  MOVLW  0C
0CDB6:  MOVWF  xAF
0CDB8:  MOVLW  5A
0CDBA:  MOVWF  xAE
0CDBC:  MOVLW  2C
0CDBE:  MOVWF  xB0
0CDC0:  MOVLB  0
0CDC2:  CALL   8E80
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
0CDC6:  MOVLB  C
0CDC8:  CLRF   x86
0CDCA:  MOVF   x86,W
0CDCC:  SUBLW  2B
0CDCE:  BNC   CDF0
....................         fputc(adcs_command[i], ADCS); 
0CDD0:  CLRF   03
0CDD2:  MOVF   x86,W
0CDD4:  ADDLW  5A
0CDD6:  MOVWF  FE9
0CDD8:  MOVLW  0C
0CDDA:  ADDWFC 03,W
0CDDC:  MOVWF  FEA
0CDDE:  MOVFF  FEF,C87
0CDE2:  MOVF   x87,W
0CDE4:  MOVLB  0
0CDE6:  CALL   5464
0CDEA:  MOVLB  C
0CDEC:  INCF   x86,F
0CDEE:  BRA    CDCA
....................     } 
....................     fprintf(PC, "STM RAW CMD: "); 
0CDF0:  MOVLW  A4
0CDF2:  MOVWF  FF6
0CDF4:  MOVLW  09
0CDF6:  MOVWF  FF7
0CDF8:  MOVLW  00
0CDFA:  MOVWF  FF8
0CDFC:  MOVLB  0
0CDFE:  CALL   4534
....................     uart_print_pc_hex(adcs_command, sizeof(adcs_command)); 
0CE02:  MOVLW  0C
0CE04:  MOVLB  C
0CE06:  MOVWF  x90
0CE08:  MOVLW  5A
0CE0A:  MOVWF  x8F
0CE0C:  MOVLW  2C
0CE0E:  MOVWF  x91
0CE10:  MOVLB  0
0CE12:  CALL   7A5C
0CE16:  RETURN 0
.................... } 
....................  
.................... // Change ADCS mode internally and externally (helper function) 
.................... void change_adcs_mode(uint8_t mode, uint8_t permanent) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0E70E:  MOVLW  02
0E710:  MOVLB  C
0E712:  MOVWF  xBE
0E714:  MOVLB  0
0E716:  CALL   52E8
0E71A:  MOVF   01,W
0E71C:  SUBLW  02
0E71E:  BZ    E738
....................         if (verbose) { 
0E720:  MOVLB  5
0E722:  MOVF   x5A,F
0E724:  BZ    E73A
....................             fprintf(PC, "MUX change failed!"); 
0E726:  MOVLW  B2
0E728:  MOVWF  FF6
0E72A:  MOVLW  09
0E72C:  MOVWF  FF7
0E72E:  MOVLW  00
0E730:  MOVWF  FF8
0E732:  MOVLB  0
0E734:  CALL   4534
0E738:  MOVLB  5
....................         } 
....................     } 
....................  
....................     uint8_t adcs_command[3] = { 0x01 }; 
0E73A:  MOVLW  01
0E73C:  MOVLB  C
0E73E:  MOVWF  x43
0E740:  CLRF   x44
0E742:  CLRF   x45
....................     adcs_mode = mode; 
0E744:  MOVFF  C41,757
....................     adcs_command[1] = mode; 
0E748:  MOVFF  C41,C44
....................     adcs_command[2] = permanent; 
0E74C:  MOVFF  C42,C45
....................     stm32_raw_command(adcs_command, sizeof(adcs_command), 0); 
0E750:  MOVLW  0C
0E752:  MOVWF  x57
0E754:  MOVLW  43
0E756:  MOVWF  x56
0E758:  MOVLW  03
0E75A:  MOVWF  x58
0E75C:  CLRF   x59
0E75E:  MOVLB  0
0E760:  CALL   CD30
0E764:  RETURN 0
.................... } 
....................  
.................... // Change ADCS mode internally and externally 
.................... uint8_t command_adcs_mode(uint8_t* data) 
0E766:  MOVFF  C39,C3B
0E76A:  MOVFF  C38,C3A
.................... { 
....................     // Mux is changed in the helper function change_adcs_mode() 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; // when true, change mode permanently 
....................     }* packet = (struct packet*)data; 
....................     change_adcs_mode(packet->mode, packet->permanent); 
0E76E:  MOVLW  02
0E770:  MOVLB  C
0E772:  ADDWF  x3A,W
0E774:  MOVWF  FE9
0E776:  MOVLW  00
0E778:  ADDWFC x3B,W
0E77A:  MOVWF  FEA
0E77C:  MOVFF  FEF,C41
0E780:  MOVLW  03
0E782:  ADDWF  x3A,W
0E784:  MOVWF  FE9
0E786:  MOVLW  00
0E788:  ADDWFC x3B,W
0E78A:  MOVWF  FEA
0E78C:  MOVFF  FEF,C42
0E790:  MOVLB  0
0E792:  RCALL  E70E
....................     return packet->mode; 
0E794:  MOVLW  02
0E796:  MOVLB  C
0E798:  ADDWF  x3A,W
0E79A:  MOVWF  FE9
0E79C:  MOVLW  00
0E79E:  ADDWFC x3B,W
0E7A0:  MOVWF  FEA
0E7A2:  MOVFF  FEF,01
0E7A6:  MOVLB  0
0E7A8:  GOTO   18C68 (RETURN)
.................... } 
....................  
.................... // Change ADCS default mode 
.................... uint8_t command_adcs_default_mode(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0E21E:  MOVLW  02
0E220:  MOVLB  C
0E222:  MOVWF  xBE
0E224:  MOVLB  0
0E226:  CALL   52E8
0E22A:  MOVF   01,W
0E22C:  SUBLW  02
0E22E:  BZ    E252
....................         if (verbose) { 
0E230:  MOVLB  5
0E232:  MOVF   x5A,F
0E234:  BZ    E24A
....................             fprintf(PC, "MUX change failed!"); 
0E236:  MOVLW  C6
0E238:  MOVWF  FF6
0E23A:  MOVLW  09
0E23C:  MOVWF  FF7
0E23E:  MOVLW  00
0E240:  MOVWF  FF8
0E242:  MOVLB  0
0E244:  CALL   4534
0E248:  MOVLB  5
....................         } 
....................         return 1; 
0E24A:  MOVLW  01
0E24C:  MOVWF  01
0E24E:  BRA    E2D4
0E250:  MOVLB  0
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t new_mode; 
....................     }* packet = (struct packet*)data; 
0E252:  MOVFF  C39,C3B
0E256:  MOVFF  C38,C3A
....................  
....................     // Change stored vale in OBC 
....................     obc_flags.adcs_initial_value = packet->new_mode; 
0E25A:  MOVLW  02
0E25C:  MOVLB  C
0E25E:  ADDWF  x3A,W
0E260:  MOVWF  FE9
0E262:  MOVLW  00
0E264:  ADDWFC x3B,W
0E266:  MOVWF  FEA
0E268:  MOVFF  FEF,104
0E26C:  MOVLB  1
....................     adcs_mode = obc_flags.adcs_initial_value; 
0E26E:  MOVFF  104,757
....................     save_state(packet->command); 
0E272:  MOVLW  01
0E274:  MOVLB  C
0E276:  ADDWF  x3A,W
0E278:  MOVWF  FE9
0E27A:  MOVLW  00
0E27C:  ADDWFC x3B,W
0E27E:  MOVWF  FEA
0E280:  MOVFF  FEF,C60
0E284:  MOVLB  0
0E286:  CALL   8CAE
....................  
....................     // Change stored value in ADCS 
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................     adcs_mode_st.origin = MSG_COMM; 
0E28A:  MOVLW  C0
0E28C:  MOVLB  C
0E28E:  MOVWF  x3C
....................     adcs_mode_st.command = 0xAD; 
0E290:  MOVLW  AD
0E292:  MOVWF  x3D
....................     adcs_mode_st.mode = packet->new_mode; 
0E294:  MOVLW  02
0E296:  ADDWF  x3A,W
0E298:  MOVWF  FE9
0E29A:  MOVLW  00
0E29C:  ADDWFC x3B,W
0E29E:  MOVWF  FEA
0E2A0:  MOVFF  FEF,C3E
....................     adcs_mode_st.permanent = true; 
0E2A4:  MOVLW  01
0E2A6:  MOVWF  x3F
....................     vschedule(current_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
0E2A8:  MOVLW  0C
0E2AA:  MOVWF  x41
0E2AC:  MOVLW  3C
0E2AE:  MOVWF  x40
0E2B0:  MOVFF  3E,C98
0E2B4:  MOVFF  3D,C97
0E2B8:  MOVFF  3C,C96
0E2BC:  MOVFF  3B,C95
0E2C0:  MOVFF  C41,C9A
0E2C4:  MOVWF  x99
0E2C6:  MOVLB  0
0E2C8:  CALL   704C
....................  
....................     return adcs_mode; 
0E2CC:  MOVLB  7
0E2CE:  MOVFF  757,01
0E2D2:  MOVLB  5
0E2D4:  MOVLB  0
0E2D6:  GOTO   18C20 (RETURN)
.................... } 
....................  
.................... // Schedule ADCS mode (without coordinates) 
.................... uint8_t command_schedule_mode(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
15002:  MOVLW  02
15004:  MOVLB  C
15006:  MOVWF  xBE
15008:  MOVLB  0
1500A:  CALL   52E8
1500E:  MOVF   01,W
15010:  SUBLW  02
15012:  BZ    15036
....................         if (verbose) { 
15014:  MOVLB  5
15016:  MOVF   x5A,F
15018:  BZ    1502E
....................             fprintf(PC, "MUX change failed!"); 
1501A:  MOVLW  DA
1501C:  MOVWF  FF6
1501E:  MOVLW  09
15020:  MOVWF  FF7
15022:  MOVLW  00
15024:  MOVWF  FF8
15026:  MOVLB  0
15028:  CALL   4534
1502C:  MOVLB  5
....................         } 
....................         return 1; 
1502E:  MOVLW  01
15030:  MOVWF  01
15032:  BRA    1513E
15034:  MOVLB  0
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_mode; 
....................         time_t mode_scheduled_time; 
....................         uint16_t total_duration; 
....................     }* packet = (struct packet*)data; 
15036:  MOVFF  C39,C3B
1503A:  MOVFF  C38,C3A
....................  
....................     if (packet->mode_scheduled_time == 0) { // debug case 
1503E:  MOVLW  03
15040:  MOVLB  C
15042:  ADDWF  x3A,W
15044:  MOVWF  FE9
15046:  MOVLW  00
15048:  ADDWFC x3B,W
1504A:  MOVWF  FEA
1504C:  MOVFF  FEF,C40
15050:  MOVFF  FEC,C41
15054:  MOVFF  FEC,C42
15058:  MOVFF  FEC,C43
1505C:  MOVF   x40,F
1505E:  BNZ   15088
15060:  MOVF   x41,F
15062:  BNZ   15088
15064:  MOVF   x42,F
15066:  BNZ   15088
15068:  MOVF   x43,F
1506A:  BNZ   15088
....................         packet->mode_scheduled_time = current_time; 
1506C:  MOVLW  03
1506E:  ADDWF  x3A,W
15070:  MOVWF  FE9
15072:  MOVLW  00
15074:  ADDWFC x3B,W
15076:  MOVWF  FEA
15078:  MOVFF  3B,FEF
1507C:  MOVFF  3C,FEC
15080:  MOVFF  3D,FEC
15084:  MOVFF  3E,FEC
....................     } 
....................  
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................  
....................     adcs_mode_st.origin = MSG_COMM; 
15088:  MOVLW  C0
1508A:  MOVWF  x3C
....................     adcs_mode_st.command = 0xAD; 
1508C:  MOVLW  AD
1508E:  MOVWF  x3D
....................     adcs_mode_st.mode = packet->adcs_mode; 
15090:  MOVLW  02
15092:  ADDWF  x3A,W
15094:  MOVWF  FE9
15096:  MOVLW  00
15098:  ADDWFC x3B,W
1509A:  MOVWF  FEA
1509C:  MOVFF  FEF,C3E
....................     adcs_mode_st.permanent = false; 
150A0:  CLRF   x3F
....................     vschedule(packet->mode_scheduled_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
150A2:  MOVLW  03
150A4:  ADDWF  x3A,W
150A6:  MOVWF  FE9
150A8:  MOVLW  00
150AA:  ADDWFC x3B,W
150AC:  MOVWF  FEA
150AE:  MOVFF  FEF,C95
150B2:  MOVFF  FEC,C96
150B6:  MOVFF  FEC,C97
150BA:  MOVFF  FEC,C98
150BE:  MOVLW  0C
150C0:  MOVWF  x45
150C2:  MOVLW  3C
150C4:  MOVWF  x44
150C6:  MOVFF  C45,C9A
150CA:  MOVWF  x99
150CC:  MOVLB  0
150CE:  CALL   704C
....................  
....................     adcs_mode_st.mode = obc_flags.adcs_initial_value; 
150D2:  MOVFF  104,C3E
....................     vschedule(packet->mode_scheduled_time + packet->total_duration, (uint8_t*)&adcs_mode_st); // ADCS back to default mode 
150D6:  MOVLW  03
150D8:  MOVLB  C
150DA:  ADDWF  x3A,W
150DC:  MOVWF  FE9
150DE:  MOVLW  00
150E0:  ADDWFC x3B,W
150E2:  MOVWF  FEA
150E4:  MOVFF  FEF,C40
150E8:  MOVFF  FEC,C41
150EC:  MOVFF  FEC,C42
150F0:  MOVFF  FEC,C43
150F4:  MOVLW  07
150F6:  ADDWF  x3A,W
150F8:  MOVWF  FE9
150FA:  MOVLW  00
150FC:  ADDWFC x3B,W
150FE:  MOVWF  FEA
15100:  MOVFF  FEC,03
15104:  MOVF   FED,F
15106:  MOVF   FEF,W
15108:  ADDWF  x40,F
1510A:  MOVF   03,W
1510C:  ADDWFC x41,F
1510E:  MOVLW  00
15110:  ADDWFC x42,F
15112:  ADDWFC x43,F
15114:  MOVLW  0C
15116:  MOVWF  x45
15118:  MOVLW  3C
1511A:  MOVWF  x44
1511C:  MOVFF  C43,C98
15120:  MOVFF  C42,C97
15124:  MOVFF  C41,C96
15128:  MOVFF  C40,C95
1512C:  MOVFF  C45,C9A
15130:  MOVWF  x99
15132:  MOVLB  0
15134:  CALL   704C
....................  
....................     return 0; 
15138:  MOVLW  00
1513A:  MOVWF  01
1513C:  MOVLB  5
1513E:  MOVLB  0
15140:  GOTO   18EFC (RETURN)
.................... } 
....................  
.................... // Print the satellite flags to the debug line 
.................... uint8_t command_print_flags(uint8_t* data) 
.................... { 
....................     print_flags(); 
*
0FFDC:  CALL   7470
....................     return 0; 
0FFE0:  MOVLW  00
0FFE2:  MOVWF  01
0FFE4:  GOTO   18F32 (RETURN)
.................... } 
....................  
.................... // Send a raw command to ADCS 
.................... uint8_t command_adcs_comm_test(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0E52C:  MOVLW  02
0E52E:  MOVLB  C
0E530:  MOVWF  xBE
0E532:  MOVLB  0
0E534:  CALL   52E8
0E538:  MOVF   01,W
0E53A:  SUBLW  02
0E53C:  BZ    E560
....................         if (verbose) { 
0E53E:  MOVLB  5
0E540:  MOVF   x5A,F
0E542:  BZ    E558
....................             fprintf(PC, "MUX change failed!"); 
0E544:  MOVLW  EE
0E546:  MOVWF  FF6
0E548:  MOVLW  09
0E54A:  MOVWF  FF7
0E54C:  MOVLW  00
0E54E:  MOVWF  FF8
0E550:  MOVLB  0
0E552:  CALL   4534
0E556:  MOVLB  5
....................         } 
....................         return 1; 
0E558:  MOVLW  01
0E55A:  MOVWF  01
0E55C:  BRA    E708
0E55E:  MOVLB  0
....................     } 
....................  
....................     enum { 
....................         adcs_cmd_size = 16, 
....................         repetitions = 100, 
....................         delay = 2100 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_command[adcs_cmd_size]; 
....................     }* packet = (struct packet*)data; 
0E560:  MOVFF  C39,C3B
0E564:  MOVFF  C38,C3A
....................  
....................     fprintf(PC, "Sending command %02X %d times to ADCS.\r\n", packet->adcs_command[0], repetitions); 
0E568:  MOVLW  02
0E56A:  MOVLB  C
0E56C:  ADDWF  x3A,W
0E56E:  MOVWF  FE9
0E570:  MOVLW  00
0E572:  ADDWFC x3B,W
0E574:  MOVWF  FEA
0E576:  MOVFF  FEF,C6A
0E57A:  MOVLW  02
0E57C:  MOVWF  FF6
0E57E:  MOVLW  0A
0E580:  MOVWF  FF7
0E582:  MOVLW  00
0E584:  MOVWF  FF8
0E586:  MOVLW  10
0E588:  MOVWF  xC1
0E58A:  MOVLB  0
0E58C:  CALL   5290
0E590:  MOVFF  C6A,CBF
0E594:  MOVLW  37
0E596:  MOVLB  C
0E598:  MOVWF  xC0
0E59A:  MOVLB  0
0E59C:  CALL   5A92
0E5A0:  MOVLW  20
0E5A2:  MOVLB  D
0E5A4:  MOVWF  x6A
0E5A6:  MOVLB  0
0E5A8:  CALL   44EE
0E5AC:  MOVLW  64
0E5AE:  MOVLB  C
0E5B0:  MOVWF  xBE
0E5B2:  MOVLW  18
0E5B4:  MOVWF  xBF
0E5B6:  MOVLB  0
0E5B8:  CALL   73A8
0E5BC:  MOVLW  19
0E5BE:  MOVWF  FF6
0E5C0:  MOVLW  0A
0E5C2:  MOVWF  FF7
0E5C4:  MOVLW  00
0E5C6:  MOVWF  FF8
0E5C8:  MOVLW  11
0E5CA:  MOVLB  C
0E5CC:  MOVWF  xC1
0E5CE:  MOVLB  0
0E5D0:  CALL   5290
....................  
....................     uint8_t msg[MSG_LENGTH_ADCS] = { 0 }; 
0E5D4:  MOVLB  C
0E5D6:  CLRF   x3C
0E5D8:  CLRF   x3D
0E5DA:  CLRF   x3E
0E5DC:  CLRF   x3F
0E5DE:  CLRF   x40
0E5E0:  CLRF   x41
0E5E2:  CLRF   x42
0E5E4:  CLRF   x43
0E5E6:  CLRF   x44
0E5E8:  CLRF   x45
0E5EA:  CLRF   x46
0E5EC:  CLRF   x47
0E5EE:  CLRF   x48
0E5F0:  CLRF   x49
0E5F2:  CLRF   x4A
0E5F4:  CLRF   x4B
0E5F6:  CLRF   x4C
0E5F8:  CLRF   x4D
0E5FA:  CLRF   x4E
0E5FC:  CLRF   x4F
0E5FE:  CLRF   x50
0E600:  CLRF   x51
0E602:  CLRF   x52
0E604:  CLRF   x53
0E606:  CLRF   x54
0E608:  CLRF   x55
0E60A:  CLRF   x56
0E60C:  CLRF   x57
0E60E:  CLRF   x58
0E610:  CLRF   x59
0E612:  CLRF   x5A
0E614:  CLRF   x5B
0E616:  CLRF   x5C
0E618:  CLRF   x5D
0E61A:  CLRF   x5E
0E61C:  CLRF   x5F
0E61E:  CLRF   x60
0E620:  CLRF   x61
0E622:  CLRF   x62
0E624:  CLRF   x63
0E626:  CLRF   x64
0E628:  CLRF   x65
0E62A:  CLRF   x66
0E62C:  CLRF   x67
....................     msg[0] = 0x0B; 
0E62E:  MOVLW  0B
0E630:  MOVWF  x3C
....................     memcpy(msg + 1, packet->adcs_command, adcs_cmd_size); 
0E632:  MOVLW  02
0E634:  ADDWF  x3A,W
0E636:  MOVWF  01
0E638:  MOVLW  00
0E63A:  ADDWFC x3B,W
0E63C:  MOVWF  03
0E63E:  MOVFF  01,C6A
0E642:  MOVWF  x6B
0E644:  MOVLW  0C
0E646:  MOVWF  FEA
0E648:  MOVLW  3D
0E64A:  MOVWF  FE9
0E64C:  MOVFF  03,FE2
0E650:  MOVFF  01,FE1
0E654:  MOVLW  10
0E656:  MOVWF  01
0E658:  MOVFF  FE6,FEE
0E65C:  DECFSZ 01,F
0E65E:  BRA    E658
....................     msg[MSG_LENGTH_ADCS - 1] = 0x0C; 
0E660:  MOVLW  0C
0E662:  MOVWF  x67
....................  
....................     for (uint8_t j = 0; j < repetitions; j++) { 
0E664:  CLRF   x68
0E666:  MOVF   x68,W
0E668:  SUBLW  63
0E66A:  BNC   E702
....................         uart_print_pc_hex(msg, sizeof(msg)); 
0E66C:  MOVLW  0C
0E66E:  MOVWF  x90
0E670:  MOVLW  3C
0E672:  MOVWF  x8F
0E674:  MOVLW  2C
0E676:  MOVWF  x91
0E678:  MOVLB  0
0E67A:  CALL   7A5C
....................         fprintf(PC, " (attempt %d)\r\n", j); 
0E67E:  MOVLW  2C
0E680:  MOVWF  FF6
0E682:  MOVLW  0A
0E684:  MOVWF  FF7
0E686:  MOVLW  00
0E688:  MOVWF  FF8
0E68A:  MOVLW  0A
0E68C:  MOVLB  C
0E68E:  MOVWF  xC1
0E690:  MOVLB  0
0E692:  CALL   5290
0E696:  MOVFF  C68,CBE
0E69A:  MOVLW  18
0E69C:  MOVLB  C
0E69E:  MOVWF  xBF
0E6A0:  MOVLB  0
0E6A2:  CALL   73A8
0E6A6:  MOVLW  38
0E6A8:  MOVWF  FF6
0E6AA:  MOVLW  0A
0E6AC:  MOVWF  FF7
0E6AE:  MOVLW  00
0E6B0:  MOVWF  FF8
0E6B2:  MOVLW  03
0E6B4:  MOVLB  C
0E6B6:  MOVWF  xC1
0E6B8:  MOVLB  0
0E6BA:  CALL   5290
....................         for (uint8_t i = 0; i < sizeof(msg); i++) { 
0E6BE:  MOVLB  C
0E6C0:  CLRF   x69
0E6C2:  MOVF   x69,W
0E6C4:  SUBLW  2B
0E6C6:  BNC   E6E8
....................             fputc(msg[i], ADCS); 
0E6C8:  CLRF   03
0E6CA:  MOVF   x69,W
0E6CC:  ADDLW  3C
0E6CE:  MOVWF  FE9
0E6D0:  MOVLW  0C
0E6D2:  ADDWFC 03,W
0E6D4:  MOVWF  FEA
0E6D6:  MOVFF  FEF,C6A
0E6DA:  MOVF   x6A,W
0E6DC:  MOVLB  0
0E6DE:  CALL   5464
0E6E2:  MOVLB  C
0E6E4:  INCF   x69,F
0E6E6:  BRA    E6C2
....................         } 
....................         delay_ms(delay); 
0E6E8:  MOVLW  0A
0E6EA:  MOVWF  x6A
0E6EC:  MOVLW  D2
0E6EE:  MOVLB  D
0E6F0:  MOVWF  x52
0E6F2:  MOVLB  0
0E6F4:  CALL   5266
0E6F8:  MOVLB  C
0E6FA:  DECFSZ x6A,F
0E6FC:  BRA    E6EC
0E6FE:  INCF   x68,F
0E700:  BRA    E666
....................     } 
....................  
....................     return 0; 
0E702:  MOVLW  00
0E704:  MOVWF  01
0E706:  MOVLB  5
0E708:  MOVLB  0
0E70A:  GOTO   18C56 (RETURN)
.................... } 
....................  
.................... // Send a raw command to ADCS 
.................... uint8_t command_adcs_raw(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0E8BE:  MOVLW  02
0E8C0:  MOVLB  C
0E8C2:  MOVWF  xBE
0E8C4:  MOVLB  0
0E8C6:  CALL   52E8
0E8CA:  MOVF   01,W
0E8CC:  SUBLW  02
0E8CE:  BZ    E8F2
....................         if (verbose) { 
0E8D0:  MOVLB  5
0E8D2:  MOVF   x5A,F
0E8D4:  BZ    E8EA
....................             fprintf(PC, "MUX change failed!"); 
0E8D6:  MOVLW  3C
0E8D8:  MOVWF  FF6
0E8DA:  MOVLW  0A
0E8DC:  MOVWF  FF7
0E8DE:  MOVLW  00
0E8E0:  MOVWF  FF8
0E8E2:  MOVLB  0
0E8E4:  CALL   4534
0E8E8:  MOVLB  5
....................         } 
....................         return 1; 
0E8EA:  MOVLW  01
0E8EC:  MOVWF  01
0E8EE:  BRA    E9DC
0E8F0:  MOVLB  0
....................     } 
....................     enum { adcs_cmd_size = 16 }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_command[adcs_cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t msg[MSG_LENGTH_ADCS] = { 0 }; 
0E8F2:  MOVFF  C39,C3B
0E8F6:  MOVFF  C38,C3A
0E8FA:  MOVLB  C
0E8FC:  CLRF   x3C
0E8FE:  CLRF   x3D
0E900:  CLRF   x3E
0E902:  CLRF   x3F
0E904:  CLRF   x40
0E906:  CLRF   x41
0E908:  CLRF   x42
0E90A:  CLRF   x43
0E90C:  CLRF   x44
0E90E:  CLRF   x45
0E910:  CLRF   x46
0E912:  CLRF   x47
0E914:  CLRF   x48
0E916:  CLRF   x49
0E918:  CLRF   x4A
0E91A:  CLRF   x4B
0E91C:  CLRF   x4C
0E91E:  CLRF   x4D
0E920:  CLRF   x4E
0E922:  CLRF   x4F
0E924:  CLRF   x50
0E926:  CLRF   x51
0E928:  CLRF   x52
0E92A:  CLRF   x53
0E92C:  CLRF   x54
0E92E:  CLRF   x55
0E930:  CLRF   x56
0E932:  CLRF   x57
0E934:  CLRF   x58
0E936:  CLRF   x59
0E938:  CLRF   x5A
0E93A:  CLRF   x5B
0E93C:  CLRF   x5C
0E93E:  CLRF   x5D
0E940:  CLRF   x5E
0E942:  CLRF   x5F
0E944:  CLRF   x60
0E946:  CLRF   x61
0E948:  CLRF   x62
0E94A:  CLRF   x63
0E94C:  CLRF   x64
0E94E:  CLRF   x65
0E950:  CLRF   x66
0E952:  CLRF   x67
....................     msg[0] = 0x0B; 
0E954:  MOVLW  0B
0E956:  MOVWF  x3C
....................     memcpy(msg + 1, packet->adcs_command, adcs_cmd_size); 
0E958:  MOVLW  02
0E95A:  ADDWF  x3A,W
0E95C:  MOVWF  01
0E95E:  MOVLW  00
0E960:  ADDWFC x3B,W
0E962:  MOVWF  03
0E964:  MOVFF  01,C69
0E968:  MOVWF  x6A
0E96A:  MOVLW  0C
0E96C:  MOVWF  FEA
0E96E:  MOVLW  3D
0E970:  MOVWF  FE9
0E972:  MOVFF  03,FE2
0E976:  MOVFF  01,FE1
0E97A:  MOVLW  10
0E97C:  MOVWF  01
0E97E:  MOVFF  FE6,FEE
0E982:  DECFSZ 01,F
0E984:  BRA    E97E
....................     checksum_obc(msg, sizeof(msg)); 
0E986:  MOVLW  0C
0E988:  MOVWF  xAF
0E98A:  MOVLW  3C
0E98C:  MOVWF  xAE
0E98E:  MOVLW  2C
0E990:  MOVWF  xB0
0E992:  MOVLB  0
0E994:  CALL   8E80
....................  
....................     uart_print_pc_hex(msg, sizeof(msg)); 
0E998:  MOVLW  0C
0E99A:  MOVLB  C
0E99C:  MOVWF  x90
0E99E:  MOVLW  3C
0E9A0:  MOVWF  x8F
0E9A2:  MOVLW  2C
0E9A4:  MOVWF  x91
0E9A6:  MOVLB  0
0E9A8:  CALL   7A5C
....................  
....................     for (uint8_t i = 0; i < sizeof(msg); i++) { 
0E9AC:  MOVLB  C
0E9AE:  CLRF   x68
0E9B0:  MOVF   x68,W
0E9B2:  SUBLW  2B
0E9B4:  BNC   E9D6
....................         fputc(msg[i], ADCS); 
0E9B6:  CLRF   03
0E9B8:  MOVF   x68,W
0E9BA:  ADDLW  3C
0E9BC:  MOVWF  FE9
0E9BE:  MOVLW  0C
0E9C0:  ADDWFC 03,W
0E9C2:  MOVWF  FEA
0E9C4:  MOVFF  FEF,C69
0E9C8:  MOVF   x69,W
0E9CA:  MOVLB  0
0E9CC:  CALL   5464
0E9D0:  MOVLB  C
0E9D2:  INCF   x68,F
0E9D4:  BRA    E9B0
....................     } 
....................  
....................     return 0; 
0E9D6:  MOVLW  00
0E9D8:  MOVWF  01
0E9DA:  MOVLB  5
0E9DC:  MOVLB  0
0E9DE:  GOTO   18C8C (RETURN)
.................... } 
....................  
.................... uint8_t command_stm32_raw_8_16(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0D48E:  MOVLW  02
0D490:  MOVLB  C
0D492:  MOVWF  xBE
0D494:  MOVLB  0
0D496:  CALL   52E8
0D49A:  MOVF   01,W
0D49C:  SUBLW  02
0D49E:  BZ    D4C2
....................         if (verbose) { 
0D4A0:  MOVLB  5
0D4A2:  MOVF   x5A,F
0D4A4:  BZ    D4BA
....................             fprintf(PC, "MUX change failed!"); 
0D4A6:  MOVLW  50
0D4A8:  MOVWF  FF6
0D4AA:  MOVLW  0A
0D4AC:  MOVWF  FF7
0D4AE:  MOVLW  00
0D4B0:  MOVWF  FF8
0D4B2:  MOVLB  0
0D4B4:  CALL   4534
0D4B8:  MOVLB  5
....................         } 
....................         return 1; 
0D4BA:  MOVLW  01
0D4BC:  MOVWF  01
0D4BE:  BRA    D54A
0D4C0:  MOVLB  0
....................     } 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
0D4C2:  MOVFF  C39,C3B
0D4C6:  MOVFF  C38,C3A
....................  
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
0D4CA:  MOVLW  08
0D4CC:  MOVWF  FEA
0D4CE:  MOVLW  58
0D4D0:  MOVWF  FE9
0D4D2:  CLRF   00
0D4D4:  CLRF   02
0D4D6:  MOVLW  20
0D4D8:  MOVWF  01
0D4DA:  CALL   5222
....................     memcpy(stm32_command_uhf, packet->part, length); 
0D4DE:  MOVLW  02
0D4E0:  MOVLB  C
0D4E2:  ADDWF  x3A,W
0D4E4:  MOVWF  01
0D4E6:  MOVLW  00
0D4E8:  ADDWFC x3B,W
0D4EA:  MOVWF  03
0D4EC:  MOVFF  01,C3C
0D4F0:  MOVWF  x3D
0D4F2:  MOVLW  08
0D4F4:  MOVWF  FEA
0D4F6:  MOVLW  58
0D4F8:  MOVWF  FE9
0D4FA:  MOVFF  03,FE2
0D4FE:  MOVFF  01,FE1
0D502:  MOVLW  10
0D504:  MOVWF  01
0D506:  MOVFF  FE6,FEE
0D50A:  DECFSZ 01,F
0D50C:  BRA    D506
....................     stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
0D50E:  MOVLW  08
0D510:  MOVWF  x57
0D512:  MOVLW  58
0D514:  MOVWF  x56
0D516:  MOVLW  20
0D518:  MOVWF  x58
0D51A:  CLRF   x59
0D51C:  MOVLB  0
0D51E:  RCALL  CD30
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
0D520:  MOVLW  08
0D522:  MOVWF  FEA
0D524:  MOVLW  58
0D526:  MOVWF  FE9
0D528:  CLRF   00
0D52A:  CLRF   02
0D52C:  MOVLW  20
0D52E:  MOVWF  01
0D530:  CALL   5222
....................  
....................     fprintf(PC, "STM32 command (8/16)"); 
0D534:  MOVLW  64
0D536:  MOVWF  FF6
0D538:  MOVLW  0A
0D53A:  MOVWF  FF7
0D53C:  MOVLW  00
0D53E:  MOVWF  FF8
0D540:  CALL   4534
....................  
....................     return 0; 
0D544:  MOVLW  00
0D546:  MOVWF  01
0D548:  MOVLB  5
0D54A:  MOVLB  0
0D54C:  GOTO   18B12 (RETURN)
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
0D550:  MOVLW  02
0D552:  MOVLB  C
0D554:  MOVWF  xBE
0D556:  MOVLB  0
0D558:  CALL   52E8
0D55C:  MOVF   01,W
0D55E:  SUBLW  02
0D560:  BZ    D584
....................         if (verbose) { 
0D562:  MOVLB  5
0D564:  MOVF   x5A,F
0D566:  BZ    D57C
....................             fprintf(PC, "MUX change failed!"); 
0D568:  MOVLW  7A
0D56A:  MOVWF  FF6
0D56C:  MOVLW  0A
0D56E:  MOVWF  FF7
0D570:  MOVLW  00
0D572:  MOVWF  FF8
0D574:  MOVLB  0
0D576:  CALL   4534
0D57A:  MOVLB  5
....................         } 
....................         return 1; 
0D57C:  MOVLW  01
0D57E:  MOVWF  01
0D580:  BRA    D65A
0D582:  MOVLB  0
....................     } 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
0D584:  MOVFF  C39,C3B
0D588:  MOVFF  C38,C3A
0D58C:  MOVLW  01
0D58E:  MOVLB  C
0D590:  ADDWF  x3A,W
0D592:  MOVWF  FE9
0D594:  MOVLW  00
0D596:  ADDWFC x3B,W
0D598:  MOVWF  FEA
0D59A:  MOVF   FEF,W
0D59C:  ANDLW  0F
0D59E:  ADDLW  FF
0D5A0:  MOVWF  x3C
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
0D5A2:  MOVF   x3C,W
0D5A4:  MULLW  10
0D5A6:  MOVF   FF3,W
0D5A8:  ADDLW  58
0D5AA:  MOVWF  x3D
0D5AC:  MOVLW  08
0D5AE:  MOVWF  x3E
0D5B0:  BTFSC  FD8.0
0D5B2:  INCF   x3E,F
0D5B4:  MOVLW  02
0D5B6:  ADDWF  x3A,W
0D5B8:  MOVWF  01
0D5BA:  MOVLW  00
0D5BC:  ADDWFC x3B,W
0D5BE:  MOVWF  03
0D5C0:  MOVFF  01,C3F
0D5C4:  MOVWF  x40
0D5C6:  MOVFF  C3E,FEA
0D5CA:  MOVFF  C3D,FE9
0D5CE:  MOVWF  FE2
0D5D0:  MOVFF  01,FE1
0D5D4:  MOVLW  10
0D5D6:  MOVWF  01
0D5D8:  MOVFF  FE6,FEE
0D5DC:  DECFSZ 01,F
0D5DE:  BRA    D5D8
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
0D5E0:  MOVLW  01
0D5E2:  ADDWF  x3C,W
0D5E4:  MOVWF  x3D
0D5E6:  MOVLW  8E
0D5E8:  MOVWF  FF6
0D5EA:  MOVLW  0A
0D5EC:  MOVWF  FF7
0D5EE:  MOVLW  00
0D5F0:  MOVWF  FF8
0D5F2:  MOVLW  18
0D5F4:  MOVWF  xC1
0D5F6:  MOVLB  0
0D5F8:  CALL   5290
0D5FC:  MOVFF  C3D,CBE
0D600:  MOVLW  18
0D602:  MOVLB  C
0D604:  MOVWF  xBF
0D606:  MOVLB  0
0D608:  CALL   73A8
0D60C:  MOVLW  2E
0D60E:  MOVLB  D
0D610:  MOVWF  x6A
0D612:  MOVLB  0
0D614:  CALL   44EE
0D618:  MOVLW  20
0D61A:  MOVLB  D
0D61C:  MOVWF  x6A
0D61E:  MOVLB  0
0D620:  CALL   44EE
....................  
....................     if (part == 1) { 
0D624:  MOVLB  C
0D626:  DECFSZ x3C,W
0D628:  BRA    D654
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
0D62A:  MOVLW  08
0D62C:  MOVWF  x57
0D62E:  MOVLW  58
0D630:  MOVWF  x56
0D632:  MOVLW  20
0D634:  MOVWF  x58
0D636:  CLRF   x59
0D638:  MOVLB  0
0D63A:  CALL   CD30
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
0D63E:  MOVLW  08
0D640:  MOVWF  FEA
0D642:  MOVLW  58
0D644:  MOVWF  FE9
0D646:  CLRF   00
0D648:  CLRF   02
0D64A:  MOVLW  20
0D64C:  MOVWF  01
0D64E:  CALL   5222
0D652:  MOVLB  C
....................     } 
....................  
....................     return 0; 
0D654:  MOVLW  00
0D656:  MOVWF  01
0D658:  MOVLB  5
0D65A:  MOVLB  0
0D65C:  RETURN 0
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32_tle(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
0E10E:  MOVLW  02
0E110:  MOVLB  C
0E112:  MOVWF  xBE
0E114:  MOVLB  0
0E116:  CALL   52E8
0E11A:  MOVF   01,W
0E11C:  SUBLW  02
0E11E:  BZ    E142
....................         if (verbose) { 
0E120:  MOVLB  5
0E122:  MOVF   x5A,F
0E124:  BZ    E13A
....................             fprintf(PC, "MUX change failed!"); 
0E126:  MOVLW  AC
0E128:  MOVWF  FF6
0E12A:  MOVLW  0A
0E12C:  MOVWF  FF7
0E12E:  MOVLW  00
0E130:  MOVWF  FF8
0E132:  MOVLB  0
0E134:  CALL   4534
0E138:  MOVLB  5
....................         } 
....................         return 1; 
0E13A:  MOVLW  01
0E13C:  MOVWF  01
0E13E:  BRA    E21A
0E140:  MOVLB  0
....................     } 
....................  
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
0E142:  MOVFF  C39,C3B
0E146:  MOVFF  C38,C3A
0E14A:  MOVLW  01
0E14C:  MOVLB  C
0E14E:  ADDWF  x3A,W
0E150:  MOVWF  FE9
0E152:  MOVLW  00
0E154:  ADDWFC x3B,W
0E156:  MOVWF  FEA
0E158:  MOVF   FEF,W
0E15A:  ANDLW  0F
0E15C:  ADDLW  FF
0E15E:  MOVWF  x3C
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
0E160:  MOVF   x3C,W
0E162:  MULLW  10
0E164:  MOVF   FF3,W
0E166:  ADDLW  58
0E168:  MOVWF  x3D
0E16A:  MOVLW  08
0E16C:  MOVWF  x3E
0E16E:  BTFSC  FD8.0
0E170:  INCF   x3E,F
0E172:  MOVLW  02
0E174:  ADDWF  x3A,W
0E176:  MOVWF  01
0E178:  MOVLW  00
0E17A:  ADDWFC x3B,W
0E17C:  MOVWF  03
0E17E:  MOVFF  01,C3F
0E182:  MOVWF  x40
0E184:  MOVFF  C3E,FEA
0E188:  MOVFF  C3D,FE9
0E18C:  MOVWF  FE2
0E18E:  MOVFF  01,FE1
0E192:  MOVLW  10
0E194:  MOVWF  01
0E196:  MOVFF  FE6,FEE
0E19A:  DECFSZ 01,F
0E19C:  BRA    E196
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
0E19E:  MOVLW  01
0E1A0:  ADDWF  x3C,W
0E1A2:  MOVWF  x3D
0E1A4:  MOVLW  C0
0E1A6:  MOVWF  FF6
0E1A8:  MOVLW  0A
0E1AA:  MOVWF  FF7
0E1AC:  MOVLW  00
0E1AE:  MOVWF  FF8
0E1B0:  MOVLW  18
0E1B2:  MOVWF  xC1
0E1B4:  MOVLB  0
0E1B6:  CALL   5290
0E1BA:  MOVFF  C3D,CBE
0E1BE:  MOVLW  18
0E1C0:  MOVLB  C
0E1C2:  MOVWF  xBF
0E1C4:  MOVLB  0
0E1C6:  CALL   73A8
0E1CA:  MOVLW  2E
0E1CC:  MOVLB  D
0E1CE:  MOVWF  x6A
0E1D0:  MOVLB  0
0E1D2:  CALL   44EE
0E1D6:  MOVLW  20
0E1D8:  MOVLB  D
0E1DA:  MOVWF  x6A
0E1DC:  MOVLB  0
0E1DE:  CALL   44EE
....................  
....................     if (part == 1) { 
0E1E2:  MOVLB  C
0E1E4:  DECFSZ x3C,W
0E1E6:  BRA    E214
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, true); 
0E1E8:  MOVLW  08
0E1EA:  MOVWF  x57
0E1EC:  MOVLW  58
0E1EE:  MOVWF  x56
0E1F0:  MOVLW  20
0E1F2:  MOVWF  x58
0E1F4:  MOVLW  01
0E1F6:  MOVWF  x59
0E1F8:  MOVLB  0
0E1FA:  CALL   CD30
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
0E1FE:  MOVLW  08
0E200:  MOVWF  FEA
0E202:  MOVLW  58
0E204:  MOVWF  FE9
0E206:  CLRF   00
0E208:  CLRF   02
0E20A:  MOVLW  20
0E20C:  MOVWF  01
0E20E:  CALL   5222
0E212:  MOVLB  C
....................     } 
....................  
....................     return 0; 
0E214:  MOVLW  00
0E216:  MOVWF  01
0E218:  MOVLB  5
0E21A:  MOVLB  0
0E21C:  RETURN 0
.................... } 
....................  
.................... // Receive ADCS telemetry 
.................... uint8_t command_adcs_telemetry(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
08078:  MOVLW  02
0807A:  MOVLB  C
0807C:  MOVWF  xBE
0807E:  MOVLB  0
08080:  CALL   52E8
08084:  MOVF   01,W
08086:  SUBLW  02
08088:  BZ    80AC
....................         if (verbose) { 
0808A:  MOVLB  5
0808C:  MOVF   x5A,F
0808E:  BZ    80A4
....................             fprintf(PC, "MUX change failed!"); 
08090:  MOVLW  DE
08092:  MOVWF  FF6
08094:  MOVLW  0A
08096:  MOVWF  FF7
08098:  MOVLW  00
0809A:  MOVWF  FF8
0809C:  MOVLB  0
0809E:  CALL   4534
080A2:  MOVLB  5
....................         } 
....................         return 1; 
080A4:  MOVLW  01
080A6:  MOVWF  01
080A8:  BRA    8164
080AA:  MOVLB  0
....................     } 
....................     response_rx = 1; // Received a reply 
080AC:  MOVLW  01
080AE:  MOVLB  7
080B0:  MOVWF  x50
....................  
....................     fprintf(PC, "ADCS: "); 
080B2:  MOVLW  F2
080B4:  MOVWF  FF6
080B6:  MOVLW  0A
080B8:  MOVWF  FF7
080BA:  MOVLW  00
080BC:  MOVWF  FF8
080BE:  MOVLB  0
080C0:  CALL   4534
....................     fprintf(PC, "Mode=%X | ", data[2]); 
080C4:  MOVLW  02
080C6:  MOVLB  C
080C8:  ADDWF  x38,W
080CA:  MOVWF  FE9
080CC:  MOVLW  00
080CE:  ADDWFC x39,W
080D0:  MOVWF  FEA
080D2:  MOVFF  FEF,C3A
080D6:  MOVLW  FA
080D8:  MOVWF  FF6
080DA:  MOVLW  0A
080DC:  MOVWF  FF7
080DE:  MOVLW  00
080E0:  MOVWF  FF8
080E2:  MOVLW  05
080E4:  MOVWF  xC1
080E6:  MOVLB  0
080E8:  CALL   5290
080EC:  MOVFF  C3A,CBF
080F0:  MOVLW  37
080F2:  MOVLB  C
080F4:  MOVWF  xC0
080F6:  MOVLB  0
080F8:  CALL   5A92
080FC:  MOVLW  01
080FE:  MOVWF  FF6
08100:  MOVLW  0B
08102:  MOVWF  FF7
08104:  MOVLW  00
08106:  MOVWF  FF8
08108:  MOVLW  03
0810A:  MOVLB  C
0810C:  MOVWF  xC1
0810E:  MOVLB  0
08110:  CALL   5290
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
08114:  MOVFF  C39,C90
08118:  MOVFF  C38,C8F
0811C:  MOVLW  2C
0811E:  MOVLB  C
08120:  MOVWF  x91
08122:  MOVLB  0
08124:  RCALL  7A5C
....................  
....................     telemetry_time.adcs_time = current_time; 
08126:  MOVFF  3E,EE
0812A:  MOVFF  3D,ED
0812E:  MOVFF  3C,EC
08132:  MOVFF  3B,EB
....................     memcpy(telemetry.adcs_message, data + 2, sizeof(telemetry.adcs_message)); 
08136:  MOVLW  02
08138:  MOVLB  C
0813A:  ADDWF  x38,W
0813C:  MOVWF  x3A
0813E:  MOVLW  00
08140:  ADDWFC x39,W
08142:  MOVWF  x3B
08144:  CLRF   FEA
08146:  MOVLW  AA
08148:  MOVWF  FE9
0814A:  MOVFF  C3B,FE2
0814E:  MOVFF  C3A,FE1
08152:  MOVLW  28
08154:  MOVWF  01
08156:  MOVFF  FE6,FEE
0815A:  DECFSZ 01,F
0815C:  BRA    8156
....................  
....................     return 0; 
0815E:  MOVLW  00
08160:  MOVWF  01
08162:  MOVLB  5
08164:  MOVLB  0
08166:  GOTO   18822 (RETURN)
.................... } 
....................  
.................... // Receive GPS time from ADCS 
.................... uint8_t command_adcs_gps_time(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
082C0:  MOVLW  02
082C2:  MOVLB  C
082C4:  MOVWF  xBE
082C6:  MOVLB  0
082C8:  CALL   52E8
082CC:  MOVF   01,W
082CE:  SUBLW  02
082D0:  BZ    82F4
....................         if (verbose) { 
082D2:  MOVLB  5
082D4:  MOVF   x5A,F
082D6:  BZ    82EC
....................             fprintf(PC, "MUX change failed!"); 
082D8:  MOVLW  06
082DA:  MOVWF  FF6
082DC:  MOVLW  0B
082DE:  MOVWF  FF7
082E0:  MOVLW  00
082E2:  MOVWF  FF8
082E4:  MOVLB  0
082E6:  CALL   4534
082EA:  MOVLB  5
....................         } 
....................         return 1; 
082EC:  MOVLW  01
082EE:  MOVWF  01
082F0:  BRA    858E
082F2:  MOVLB  0
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................         uint8_t day; 
....................         uint8_t month; 
....................         uint8_t year; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t valid_time = 0; 
082F4:  MOVFF  C39,C3B
082F8:  MOVFF  C38,C3A
082FC:  MOVLB  C
082FE:  CLRF   x3C
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
08300:  MOVFF  C39,C90
08304:  MOVFF  C38,C8F
08308:  MOVLW  2C
0830A:  MOVWF  x91
0830C:  MOVLB  0
0830E:  CALL   7A5C
....................  
....................     if (packet->year == 0x00 || packet->year >= 38) { 
08312:  MOVLW  07
08314:  MOVLB  C
08316:  ADDWF  x3A,W
08318:  MOVWF  FE9
0831A:  MOVLW  00
0831C:  ADDWFC x3B,W
0831E:  MOVWF  FEA
08320:  MOVF   FEF,F
08322:  BZ    8336
08324:  MOVLW  07
08326:  ADDWF  x3A,W
08328:  MOVWF  FE9
0832A:  MOVLW  00
0832C:  ADDWFC x3B,W
0832E:  MOVWF  FEA
08330:  MOVF   FEF,W
08332:  SUBLW  25
08334:  BC    833C
....................         valid_time = 2; 
08336:  MOVLW  02
08338:  MOVWF  x3C
....................     } else if (obc_flags.gps_time_sync_state == 1 && boot_flags.deployment_flag >= 5) { 
0833A:  BRA    8584
0833C:  MOVLB  1
0833E:  DECFSZ x03,W
08340:  BRA    8586
08342:  MOVLB  0
08344:  MOVF   xFF,W
08346:  SUBLW  04
08348:  BTFSS  FD8.0
0834A:  BRA    8350
0834C:  MOVLB  1
0834E:  BRA    8586
....................         struct_tm gps_time; 
....................         gps_time.tm_year = packet->year + 100; 
08350:  MOVLW  07
08352:  MOVLB  C
08354:  ADDWF  x3A,W
08356:  MOVWF  FE9
08358:  MOVLW  00
0835A:  ADDWFC x3B,W
0835C:  MOVWF  FEA
0835E:  MOVLW  64
08360:  ADDWF  FEF,W
08362:  MOVWF  x42
08364:  CLRF   x43
08366:  BTFSC  FD8.0
08368:  INCF   x42,F
....................         gps_time.tm_mon = packet->month - 1; 
0836A:  MOVLW  06
0836C:  ADDWF  x3A,W
0836E:  MOVWF  FE9
08370:  MOVLW  00
08372:  ADDWFC x3B,W
08374:  MOVWF  FEA
08376:  MOVLW  01
08378:  SUBWF  FEF,W
0837A:  MOVWF  x41
....................         gps_time.tm_mday = packet->day; 
0837C:  MOVLW  05
0837E:  ADDWF  x3A,W
08380:  MOVWF  FE9
08382:  MOVLW  00
08384:  ADDWFC x3B,W
08386:  MOVWF  FEA
08388:  MOVFF  FEF,C40
....................         gps_time.tm_hour = packet->hour; 
0838C:  MOVLW  02
0838E:  ADDWF  x3A,W
08390:  MOVWF  FE9
08392:  MOVLW  00
08394:  ADDWFC x3B,W
08396:  MOVWF  FEA
08398:  MOVFF  FEF,C3F
....................         gps_time.tm_min = packet->minute; 
0839C:  MOVLW  03
0839E:  ADDWF  x3A,W
083A0:  MOVWF  FE9
083A2:  MOVLW  00
083A4:  ADDWFC x3B,W
083A6:  MOVWF  FEA
083A8:  MOVFF  FEF,C3E
....................         gps_time.tm_sec = packet->second + obc_flags.leap_seconds; 
083AC:  MOVLW  04
083AE:  ADDWF  x3A,W
083B0:  MOVWF  FE9
083B2:  MOVLW  00
083B4:  ADDWFC x3B,W
083B6:  MOVWF  FEA
083B8:  MOVLB  1
083BA:  MOVF   x00,W
083BC:  ADDWF  FEF,W
083BE:  MOVLB  C
083C0:  MOVWF  x3D
....................  
....................         time_t unix_time = mktime(&gps_time); 
....................  
....................         time_t delta = unix_time - current_time; 
083C2:  MOVLW  0C
083C4:  MOVWF  x65
083C6:  MOVLW  3D
083C8:  MOVWF  x64
083CA:  MOVLB  0
083CC:  CALL   4810
083D0:  MOVFF  03,C4A
083D4:  MOVFF  02,C49
083D8:  MOVFF  01,C48
083DC:  MOVFF  00,C47
083E0:  MOVF   3B,W
083E2:  MOVLB  C
083E4:  SUBWF  x47,W
083E6:  MOVWF  x4B
083E8:  MOVF   3C,W
083EA:  SUBWFB x48,W
083EC:  MOVWF  x4C
083EE:  MOVF   3D,W
083F0:  SUBWFB x49,W
083F2:  MOVWF  x4D
083F4:  MOVF   3E,W
083F6:  SUBWFB x4A,W
083F8:  MOVWF  x4E
....................         if (delta < 0) 
083FA:  BTFSS  x4E.7
083FC:  BRA    8414
....................             delta = -delta; 
083FE:  COMF   x4B,F
08400:  COMF   x4C,F
08402:  COMF   x4D,F
08404:  COMF   x4E,F
08406:  INCF   x4B,F
08408:  BTFSC  FD8.2
0840A:  INCF   x4C,F
0840C:  BTFSC  FD8.2
0840E:  INCF   x4D,F
08410:  BTFSC  FD8.2
08412:  INCF   x4E,F
....................         if (delta > 30 * 60) { // Do not update time if the difference to the current time is larger than 30 minutes 
08414:  BTFSC  x4E.7
08416:  BRA    8436
08418:  MOVF   x4E,F
0841A:  BNZ   8430
0841C:  MOVF   x4D,F
0841E:  BNZ   8430
08420:  MOVF   x4C,W
08422:  SUBLW  06
08424:  BC    8436
08426:  XORLW  FF
08428:  BNZ   8430
0842A:  MOVF   x4B,W
0842C:  SUBLW  08
0842E:  BC    8436
....................             valid_time = 3; 
08430:  MOVLW  03
08432:  MOVWF  x3C
....................         } else { 
08434:  BRA    8584
....................             valid_time = 1; 
08436:  MOVLW  01
08438:  MOVWF  x3C
....................             SetTimeSec(unix_time); 
0843A:  MOVFF  C4A,C52
0843E:  MOVFF  C49,C51
08442:  MOVFF  C48,C50
08446:  MOVFF  C47,C4F
0844A:  MOVLB  0
0844C:  CALL   5140
....................             current_time = time(0); 
08450:  MOVLB  C
08452:  CLRF   x50
08454:  CLRF   x4F
08456:  MOVLB  0
08458:  CALL   4C60
0845C:  MOVFF  03,3E
08460:  MOVFF  02,3D
08464:  MOVFF  01,3C
08468:  MOVFF  00,3B
....................             reset_pic_update_clock(current_time); 
0846C:  MOVFF  3E,C52
08470:  MOVFF  3D,C51
08474:  MOVFF  3C,C50
08478:  MOVFF  3B,C4F
0847C:  RCALL  816A
....................             // Change memory location based on the new date 
....................             flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
0847E:  MOVLW  02
08480:  MOVLB  C
08482:  MOVWF  x4F
08484:  MOVFF  FF,C50
08488:  MOVFF  13C,C54
0848C:  MOVFF  13B,C53
08490:  MOVFF  13A,C52
08494:  MOVFF  139,C51
08498:  CLRF   x58
0849A:  MOVLW  11
0849C:  MOVWF  x57
0849E:  CLRF   x56
084A0:  CLRF   x55
084A2:  CLRF   x5C
084A4:  CLRF   x5B
084A6:  CLRF   x5A
084A8:  MOVLW  98
084AA:  MOVWF  x59
084AC:  MOVLW  01
084AE:  MOVWF  x5D
084B0:  MOVWF  x5F
084B2:  MOVLW  31
084B4:  MOVWF  x5E
084B6:  MOVLB  0
084B8:  CALL   5B62
....................             fprintf(PC, "\r\nNew time: %04ld/%02d/%02d %02d:%02d:%02d", gps_time.tm_year + 1900, 
....................                 (char)gps_time.tm_mon + 1, 
....................                 gps_time.tm_mday, 
....................                 gps_time.tm_hour, 
....................                 gps_time.tm_min, 
....................                 gps_time.tm_sec); 
084BC:  MOVLW  6C
084BE:  MOVLB  C
084C0:  ADDWF  x42,W
084C2:  MOVWF  x4F
084C4:  MOVLW  07
084C6:  ADDWFC x43,W
084C8:  MOVWF  x50
084CA:  MOVLW  01
084CC:  ADDWF  x41,W
084CE:  MOVWF  x51
084D0:  MOVLW  1A
084D2:  MOVWF  FF6
084D4:  MOVLW  0B
084D6:  MOVWF  FF7
084D8:  MOVLW  00
084DA:  MOVWF  FF8
084DC:  MOVLW  0C
084DE:  MOVWF  xC1
084E0:  MOVLB  0
084E2:  CALL   5290
084E6:  MOVLW  0A
084E8:  MOVWF  FE9
084EA:  MOVFF  C50,C66
084EE:  MOVFF  C4F,C65
084F2:  CALL   7894
084F6:  MOVLW  2F
084F8:  MOVLB  D
084FA:  MOVWF  x6A
084FC:  MOVLB  0
084FE:  CALL   44EE
08502:  MOVFF  C51,C65
08506:  MOVLW  01
08508:  MOVLB  C
0850A:  MOVWF  x66
0850C:  MOVLB  0
0850E:  CALL   7994
08512:  MOVLW  2F
08514:  MOVLB  D
08516:  MOVWF  x6A
08518:  MOVLB  0
0851A:  CALL   44EE
0851E:  MOVFF  C40,C65
08522:  MOVLW  01
08524:  MOVLB  C
08526:  MOVWF  x66
08528:  MOVLB  0
0852A:  CALL   7994
0852E:  MOVLW  20
08530:  MOVLB  D
08532:  MOVWF  x6A
08534:  MOVLB  0
08536:  CALL   44EE
0853A:  MOVFF  C3F,C65
0853E:  MOVLW  01
08540:  MOVLB  C
08542:  MOVWF  x66
08544:  MOVLB  0
08546:  CALL   7994
0854A:  MOVLW  3A
0854C:  MOVLB  D
0854E:  MOVWF  x6A
08550:  MOVLB  0
08552:  CALL   44EE
08556:  MOVFF  C3E,C65
0855A:  MOVLW  01
0855C:  MOVLB  C
0855E:  MOVWF  x66
08560:  MOVLB  0
08562:  CALL   7994
08566:  MOVLW  3A
08568:  MOVLB  D
0856A:  MOVWF  x6A
0856C:  MOVLB  0
0856E:  CALL   44EE
08572:  MOVFF  C3D,C65
08576:  MOVLW  01
08578:  MOVLB  C
0857A:  MOVWF  x66
0857C:  MOVLB  0
0857E:  CALL   7994
08582:  MOVLB  C
08584:  MOVLB  1
....................         } 
....................     } 
....................     return valid_time; 
08586:  MOVLB  C
08588:  MOVFF  C3C,01
0858C:  MOVLB  5
0858E:  MOVLB  0
08590:  GOTO   18836 (RETURN)
.................... } 
....................  
.................... // ============ COM Commands ============ 
....................  
.................... // Message from UHF 
.................... uint8_t command_uhf_message(uint8_t* data) 
*
0CA7A:  MOVFF  C39,C3B
0CA7E:  MOVFF  C38,C3A
.................... { 
....................     enum { length = 22 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t gs_message[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     static uint8_t last_upload[length] = { 0 }; // Stores the last uploaded command 
....................     static time_t last_upload_t = 0; 
....................  
....................     fprintf(PC, "Uplink: "); 
0CA82:  MOVLW  46
0CA84:  MOVWF  FF6
0CA86:  MOVLW  0B
0CA88:  MOVWF  FF7
0CA8A:  MOVLW  00
0CA8C:  MOVWF  FF8
0CA8E:  CALL   4534
....................     uint8_t new_length = packet->gs_message[2] != 0xCC ? 14 : length; // Don't pass CRC onwards for short commands 
0CA92:  MOVLW  03
0CA94:  MOVLB  C
0CA96:  ADDWF  x3A,W
0CA98:  MOVWF  FE9
0CA9A:  MOVLW  00
0CA9C:  ADDWFC x3B,W
0CA9E:  MOVWF  FEA
0CAA0:  MOVF   FEF,W
0CAA2:  SUBLW  CC
0CAA4:  BZ    CAAA
0CAA6:  MOVLW  0E
0CAA8:  BRA    CAAC
0CAAA:  MOVLW  16
0CAAC:  MOVWF  x3C
....................     uart_print_pc_hex(packet->gs_message, new_length); 
0CAAE:  MOVLW  01
0CAB0:  ADDWF  x3A,W
0CAB2:  MOVWF  01
0CAB4:  MOVLW  00
0CAB6:  ADDWFC x3B,W
0CAB8:  MOVWF  03
0CABA:  MOVFF  01,C5C
0CABE:  MOVWF  x5D
0CAC0:  MOVWF  x90
0CAC2:  MOVFF  01,C8F
0CAC6:  MOVFF  C3C,C91
0CACA:  MOVLB  0
0CACC:  CALL   7A5C
....................     uint8_t valid = uplink_valid(packet->gs_message); 
....................     uint8_t different = memcmp(last_upload, packet->gs_message, new_length) || (last_upload_t <= (current_time - 4 * 60)); // Commands are different within 4 min window 
0CAD0:  MOVLW  01
0CAD2:  MOVLB  C
0CAD4:  ADDWF  x3A,W
0CAD6:  MOVWF  01
0CAD8:  MOVLW  00
0CADA:  ADDWFC x3B,W
0CADC:  MOVWF  03
0CADE:  MOVFF  01,C5C
0CAE2:  MOVWF  x5D
0CAE4:  MOVWF  x5F
0CAE6:  MOVFF  01,C5E
0CAEA:  MOVLB  0
0CAEC:  BRA    C926
0CAEE:  MOVFF  01,C3D
0CAF2:  MOVLW  01
0CAF4:  MOVLB  C
0CAF6:  ADDWF  x3A,W
0CAF8:  MOVWF  01
0CAFA:  MOVLW  00
0CAFC:  ADDWFC x3B,W
0CAFE:  MOVWF  03
0CB00:  MOVFF  01,C5C
0CB04:  MOVWF  x5D
0CB06:  MOVLW  0A
0CB08:  MOVWF  x5F
0CB0A:  MOVLW  C1
0CB0C:  MOVWF  x5E
0CB0E:  MOVFF  03,C61
0CB12:  MOVFF  01,C60
0CB16:  CLRF   x63
0CB18:  MOVFF  C3C,C62
0CB1C:  MOVLB  0
0CB1E:  BRA    C9F4
0CB20:  MOVF   01,F
0CB22:  BNZ   CB8A
0CB24:  MOVLW  F0
0CB26:  SUBWF  3B,W
0CB28:  MOVWF  00
0CB2A:  MOVLW  00
0CB2C:  SUBWFB 3C,W
0CB2E:  MOVWF  01
0CB30:  MOVLW  00
0CB32:  SUBWFB 3D,W
0CB34:  MOVWF  02
0CB36:  MOVLW  00
0CB38:  SUBWFB 3E,W
0CB3A:  MOVWF  03
0CB3C:  MOVLB  A
0CB3E:  BTFSS  xDA.7
0CB40:  BRA    CB4C
0CB42:  BTFSC  03.7
0CB44:  BRA    CB4A
0CB46:  MOVLB  0
0CB48:  BRA    CB8A
0CB4A:  BRA    CB50
0CB4C:  BTFSC  03.7
0CB4E:  BRA    CB86
0CB50:  MOVF   xDA,W
0CB52:  SUBWF  03,W
0CB54:  BNC   CB86
0CB56:  BTFSC  FD8.2
0CB58:  BRA    CB5E
0CB5A:  MOVLB  0
0CB5C:  BRA    CB8A
0CB5E:  MOVF   xD9,W
0CB60:  SUBWF  02,W
0CB62:  BNC   CB86
0CB64:  BTFSC  FD8.2
0CB66:  BRA    CB6C
0CB68:  MOVLB  0
0CB6A:  BRA    CB8A
0CB6C:  MOVF   xD8,W
0CB6E:  SUBWF  01,W
0CB70:  BNC   CB86
0CB72:  BTFSC  FD8.2
0CB74:  BRA    CB7A
0CB76:  MOVLB  0
0CB78:  BRA    CB8A
0CB7A:  MOVF   xD7,W
0CB7C:  SUBWF  00,W
0CB7E:  BTFSS  FD8.0
0CB80:  BRA    CB86
0CB82:  MOVLB  0
0CB84:  BRA    CB8A
0CB86:  MOVLW  00
0CB88:  BRA    CB8C
0CB8A:  MOVLW  01
0CB8C:  MOVLB  C
0CB8E:  MOVWF  x3E
....................     memcpy(last_upload, packet->gs_message, new_length); 
0CB90:  MOVLW  01
0CB92:  ADDWF  x3A,W
0CB94:  MOVWF  01
0CB96:  MOVLW  00
0CB98:  ADDWFC x3B,W
0CB9A:  MOVWF  03
0CB9C:  MOVFF  01,C5C
0CBA0:  MOVWF  x5D
0CBA2:  MOVLW  0A
0CBA4:  MOVWF  FEA
0CBA6:  MOVLW  C1
0CBA8:  MOVWF  FE9
0CBAA:  MOVFF  03,FE2
0CBAE:  MOVFF  01,FE1
0CBB2:  MOVF   x3C,W
0CBB4:  MOVWF  01
0CBB6:  BZ    CBC0
0CBB8:  MOVFF  FE6,FEE
0CBBC:  DECFSZ 01,F
0CBBE:  BRA    CBB8
....................     last_upload_t = current_time; 
0CBC0:  MOVFF  3E,ADA
0CBC4:  MOVFF  3D,AD9
0CBC8:  MOVFF  3C,AD8
0CBCC:  MOVFF  3B,AD7
....................     if (valid && different) { 
0CBD0:  MOVF   x3D,F
0CBD2:  BZ    CC9A
0CBD4:  MOVF   x3E,F
0CBD6:  BZ    CC9A
....................         fprintf(PC, " Valid uplink"); 
0CBD8:  MOVLW  50
0CBDA:  MOVWF  FF6
0CBDC:  MOVLW  0B
0CBDE:  MOVWF  FF7
0CBE0:  MOVLW  00
0CBE2:  MOVWF  FF8
0CBE4:  MOVLB  0
0CBE6:  CALL   4534
....................         uint8_t cmd[BUFF_LENGTH] = { MSG_COMM }; 
0CBEA:  MOVLW  C0
0CBEC:  MOVLB  C
0CBEE:  MOVWF  x3F
0CBF0:  CLRF   x40
0CBF2:  CLRF   x41
0CBF4:  CLRF   x42
0CBF6:  CLRF   x43
0CBF8:  CLRF   x44
0CBFA:  CLRF   x45
0CBFC:  CLRF   x46
0CBFE:  CLRF   x47
0CC00:  CLRF   x48
0CC02:  CLRF   x49
0CC04:  CLRF   x4A
0CC06:  CLRF   x4B
0CC08:  CLRF   x4C
0CC0A:  CLRF   x4D
0CC0C:  CLRF   x4E
0CC0E:  CLRF   x4F
0CC10:  CLRF   x50
0CC12:  CLRF   x51
0CC14:  CLRF   x52
0CC16:  CLRF   x53
0CC18:  CLRF   x54
0CC1A:  CLRF   x55
0CC1C:  CLRF   x56
0CC1E:  CLRF   x57
0CC20:  CLRF   x58
0CC22:  CLRF   x59
0CC24:  CLRF   x5A
....................         uint8_t copy_size = packet->gs_message[2] != 0xCC ? 9 : new_length; // Don't pass CRC onwards for short commands 
0CC26:  MOVLW  03
0CC28:  ADDWF  x3A,W
0CC2A:  MOVWF  FE9
0CC2C:  MOVLW  00
0CC2E:  ADDWFC x3B,W
0CC30:  MOVWF  FEA
0CC32:  MOVF   FEF,W
0CC34:  SUBLW  CC
0CC36:  BZ    CC3C
0CC38:  MOVLW  09
0CC3A:  BRA    CC3E
0CC3C:  MOVF   x3C,W
0CC3E:  MOVWF  x5B
....................         memcpy(cmd + 1, packet->gs_message + 3, copy_size); 
0CC40:  MOVLW  01
0CC42:  ADDWF  x3A,W
0CC44:  MOVWF  01
0CC46:  MOVLW  00
0CC48:  ADDWFC x3B,W
0CC4A:  MOVWF  03
0CC4C:  MOVFF  01,C5C
0CC50:  MOVWF  x5D
0CC52:  MOVLW  03
0CC54:  ADDWF  x5C,F
0CC56:  MOVLW  00
0CC58:  ADDWFC x5D,F
0CC5A:  MOVLW  0C
0CC5C:  MOVWF  FEA
0CC5E:  MOVLW  40
0CC60:  MOVWF  FE9
0CC62:  MOVFF  C5D,FE2
0CC66:  MOVFF  C5C,FE1
0CC6A:  MOVF   x5B,W
0CC6C:  MOVWF  01
0CC6E:  BZ    CC78
0CC70:  MOVFF  FE6,FEE
0CC74:  DECFSZ 01,F
0CC76:  BRA    CC70
....................         vschedule(current_time, cmd); 
0CC78:  MOVFF  3E,C98
0CC7C:  MOVFF  3D,C97
0CC80:  MOVFF  3C,C96
0CC84:  MOVFF  3B,C95
0CC88:  MOVLW  0C
0CC8A:  MOVWF  x9A
0CC8C:  MOVLW  3F
0CC8E:  MOVWF  x99
0CC90:  MOVLB  0
0CC92:  CALL   704C
....................     } else { 
0CC96:  BRA    CD18
0CC98:  MOVLB  C
....................         fprintf(PC, " Invalid (%d) or identical (%d) uplink.", !valid, !different); 
0CC9A:  MOVF   x3D,F
0CC9C:  BZ    CCA2
0CC9E:  MOVLW  00
0CCA0:  BRA    CCA4
0CCA2:  MOVLW  01
0CCA4:  MOVWF  x5C
0CCA6:  MOVF   x3E,F
0CCA8:  BZ    CCAE
0CCAA:  MOVLW  00
0CCAC:  BRA    CCB0
0CCAE:  MOVLW  01
0CCB0:  MOVWF  x5D
0CCB2:  MOVLW  5E
0CCB4:  MOVWF  FF6
0CCB6:  MOVLW  0B
0CCB8:  MOVWF  FF7
0CCBA:  MOVLW  00
0CCBC:  MOVWF  FF8
0CCBE:  MOVLW  0A
0CCC0:  MOVWF  xC1
0CCC2:  MOVLB  0
0CCC4:  CALL   5290
0CCC8:  MOVFF  C5C,CBE
0CCCC:  MOVLW  18
0CCCE:  MOVLB  C
0CCD0:  MOVWF  xBF
0CCD2:  MOVLB  0
0CCD4:  CALL   73A8
0CCD8:  MOVLW  6A
0CCDA:  MOVWF  FF6
0CCDC:  MOVLW  0B
0CCDE:  MOVWF  FF7
0CCE0:  MOVLW  00
0CCE2:  MOVWF  FF8
0CCE4:  MOVLW  10
0CCE6:  MOVLB  C
0CCE8:  MOVWF  xC1
0CCEA:  MOVLB  0
0CCEC:  CALL   5290
0CCF0:  MOVFF  C5D,CBE
0CCF4:  MOVLW  18
0CCF6:  MOVLB  C
0CCF8:  MOVWF  xBF
0CCFA:  MOVLB  0
0CCFC:  CALL   73A8
0CD00:  MOVLW  7C
0CD02:  MOVWF  FF6
0CD04:  MOVLW  0B
0CD06:  MOVWF  FF7
0CD08:  MOVLW  00
0CD0A:  MOVWF  FF8
0CD0C:  MOVLW  09
0CD0E:  MOVLB  C
0CD10:  MOVWF  xC1
0CD12:  MOVLB  0
0CD14:  CALL   5290
....................     } 
....................     return !(valid && different); 
0CD18:  MOVLB  C
0CD1A:  MOVF   x3D,F
0CD1C:  BZ    CD26
0CD1E:  MOVF   x3E,F
0CD20:  BZ    CD26
0CD22:  MOVLW  00
0CD24:  BRA    CD28
0CD26:  MOVLW  01
0CD28:  MOVWF  01
0CD2A:  MOVLB  0
0CD2C:  GOTO   18A5E (RETURN)
.................... } 
....................  
.................... // Change CW mode flags 
.................... uint8_t command_change_cw_mode_flags(uint8_t* data) 
.................... { 
....................     obc_flags.cw_mode = data[2]; // data[2] is the new flag status 
*
0FF7C:  MOVLW  02
0FF7E:  MOVLB  C
0FF80:  ADDWF  x38,W
0FF82:  MOVWF  FE9
0FF84:  MOVLW  00
0FF86:  ADDWFC x39,W
0FF88:  MOVWF  FEA
0FF8A:  MOVFF  FEF,105
0FF8E:  MOVLB  1
....................     save_state(data[1]);         // data[1] is the current command ID 
0FF90:  MOVLW  01
0FF92:  MOVLB  C
0FF94:  ADDWF  x38,W
0FF96:  MOVWF  FE9
0FF98:  MOVLW  00
0FF9A:  ADDWFC x39,W
0FF9C:  MOVWF  FEA
0FF9E:  MOVFF  FEF,C3A
0FFA2:  MOVFF  C3A,C60
0FFA6:  MOVLB  0
0FFA8:  CALL   8CAE
....................     return obc_flags.cw_mode; 
0FFAC:  MOVLB  1
0FFAE:  MOVFF  105,01
0FFB2:  MOVLB  0
0FFB4:  GOTO   18D3A (RETURN)
.................... } 
....................  
.................... // Ask ADCS if satellite is over Japan 
.................... uint8_t over_japan_check() 
.................... { 
....................     uint8_t command[] = { 0xFC }; 
*
0CE18:  MOVLW  FC
0CE1A:  MOVLB  C
0CE1C:  MOVWF  x53
....................     stm32_raw_command(command, sizeof(command), false); // Send request to ADCS 
0CE1E:  MOVLW  0C
0CE20:  MOVWF  x57
0CE22:  MOVLW  53
0CE24:  MOVWF  x56
0CE26:  MOVLW  01
0CE28:  MOVWF  x58
0CE2A:  CLRF   x59
0CE2C:  MOVLB  0
0CE2E:  RCALL  CD30
....................  
....................     uint8_t response[2] = { 0 }; 
0CE30:  MOVLB  C
0CE32:  CLRF   x54
0CE34:  CLRF   x55
....................     uart_download_packet(&uart_port_MSN, response, sizeof(response), 100000); // Try to get a response 
0CE36:  MOVLW  0A
0CE38:  MOVLB  D
0CE3A:  MOVWF  x45
0CE3C:  MOVLW  97
0CE3E:  MOVWF  x44
0CE40:  MOVLW  0C
0CE42:  MOVWF  x47
0CE44:  MOVLW  54
0CE46:  MOVWF  x46
0CE48:  CLRF   x4B
0CE4A:  CLRF   x4A
0CE4C:  CLRF   x49
0CE4E:  MOVLW  02
0CE50:  MOVWF  x48
0CE52:  CLRF   x4F
0CE54:  MOVLW  01
0CE56:  MOVWF  x4E
0CE58:  MOVLW  86
0CE5A:  MOVWF  x4D
0CE5C:  MOVLW  A0
0CE5E:  MOVWF  x4C
0CE60:  MOVLB  0
0CE62:  CALL   97CE
....................  
....................     if (response[1] == 0xA5) { 
0CE66:  MOVLB  C
0CE68:  MOVF   x55,W
0CE6A:  SUBLW  A5
0CE6C:  BNZ   CE84
....................         return ((int8_t)response[0] > 0); // Elevation > 0 degrees 
0CE6E:  BTFSC  x54.7
0CE70:  BRA    CE78
0CE72:  MOVF   x54,W
0CE74:  SUBLW  00
0CE76:  BNC   CE7C
0CE78:  MOVLW  00
0CE7A:  BRA    CE7E
0CE7C:  MOVLW  01
0CE7E:  MOVWF  01
0CE80:  BRA    CE88
....................     } else { 
0CE82:  BRA    CE88
....................         return false; 
0CE84:  MOVLW  00
0CE86:  MOVWF  01
....................     } 
0CE88:  MOVLB  0
0CE8A:  GOTO   CEAA (RETURN)
.................... } 
....................  
.................... // Decides if it is OK to send CW or not based on flags and ADCS 
.................... uint8_t ok_to_send_cw() 
.................... { 
....................     switch (obc_flags.cw_mode) { 
0CE8E:  MOVLB  1
0CE90:  MOVF   x05,W
0CE92:  XORLW  00
0CE94:  MOVLB  0
0CE96:  BZ    CEA2
0CE98:  XORLW  01
0CE9A:  BZ    CEA8
0CE9C:  XORLW  03
0CE9E:  BZ    CEAE
0CEA0:  BRA    CEB4
....................     case 0: return false; 
0CEA2:  MOVLW  00
0CEA4:  MOVWF  01
0CEA6:  BRA    CEB8
....................     case 1: return over_japan_check(); 
0CEA8:  BRA    CE18
0CEAA:  MOVF   01,W
0CEAC:  BRA    CEB8
....................     case 2: return true; 
0CEAE:  MOVLW  01
0CEB0:  MOVWF  01
0CEB2:  BRA    CEB8
....................     default: return false; 
0CEB4:  MOVLW  00
0CEB6:  MOVWF  01
....................     } 
0CEB8:  GOTO   CF5C (RETURN)
.................... } 
....................  
.................... // COM CW request 
.................... uint8_t command_com_cw(uint8_t* data) 
.................... { 
....................     enum { com_to_main_size = 25 }; 
....................  
....................     static uint8_t current_cw = 0; 
....................     telemetry.com_rssi = *(uint16_t*)&data[2]; 
0CEBC:  MOVLW  02
0CEBE:  MOVLB  C
0CEC0:  ADDWF  x38,W
0CEC2:  MOVWF  01
0CEC4:  MOVLW  00
0CEC6:  ADDWFC x39,W
0CEC8:  MOVFF  01,FE9
0CECC:  MOVWF  FEA
0CECE:  MOVFF  FEC,D4
0CED2:  MOVF   FED,F
0CED4:  MOVFF  FEF,D3
....................     telemetry_time.com_time = current_time; 
0CED8:  MOVFF  3E,F2
0CEDC:  MOVFF  3D,F1
0CEE0:  MOVFF  3C,F0
0CEE4:  MOVFF  3B,EF
....................  
....................     // Generate CW reply 
....................     uint8_t cmd[24] = { 0 }; 
0CEE8:  CLRF   x3A
0CEEA:  CLRF   x3B
0CEEC:  CLRF   x3C
0CEEE:  CLRF   x3D
0CEF0:  CLRF   x3E
0CEF2:  CLRF   x3F
0CEF4:  CLRF   x40
0CEF6:  CLRF   x41
0CEF8:  CLRF   x42
0CEFA:  CLRF   x43
0CEFC:  CLRF   x44
0CEFE:  CLRF   x45
0CF00:  CLRF   x46
0CF02:  CLRF   x47
0CF04:  CLRF   x48
0CF06:  CLRF   x49
0CF08:  CLRF   x4A
0CF0A:  CLRF   x4B
0CF0C:  CLRF   x4C
0CF0E:  CLRF   x4D
0CF10:  CLRF   x4E
0CF12:  CLRF   x4F
0CF14:  CLRF   x50
0CF16:  CLRF   x51
....................     cmd[0] = 0x0B; 
0CF18:  MOVLW  0B
0CF1A:  MOVWF  x3A
....................     cmd[1] = 0x50; 
0CF1C:  MOVLW  50
0CF1E:  MOVWF  x3B
....................     memcpy(cmd + 2, cw[current_cw], sizeof(cw[0])); 
0CF20:  MOVLB  A
0CF22:  MOVF   xDB,W
0CF24:  MULLW  06
0CF26:  MOVF   FF3,W
0CF28:  CLRF   03
0CF2A:  ADDLW  F3
0CF2C:  MOVWF  01
0CF2E:  MOVLW  00
0CF30:  ADDWFC 03,F
0CF32:  MOVFF  01,C53
0CF36:  MOVLB  C
0CF38:  MOVFF  03,C54
0CF3C:  MOVLW  0C
0CF3E:  MOVWF  FEA
0CF40:  MOVLW  3C
0CF42:  MOVWF  FE9
0CF44:  MOVFF  03,FE2
0CF48:  MOVFF  01,FE1
0CF4C:  MOVLW  06
0CF4E:  MOVWF  01
0CF50:  MOVFF  FE6,FEE
0CF54:  DECFSZ 01,F
0CF56:  BRA    CF50
....................     cmd[sizeof(cw[0]) + 2] = ok_to_send_cw(); 
0CF58:  MOVLB  0
0CF5A:  BRA    CE8E
0CF5C:  MOVFF  01,C42
....................     cmd[23] = 0x0C; 
0CF60:  MOVLW  0C
0CF62:  MOVLB  C
0CF64:  MOVWF  x51
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
0CF66:  CLRF   x52
0CF68:  MOVF   x52,W
0CF6A:  SUBLW  17
0CF6C:  BNC   CF8E
....................         fputc(cmd[i], COMM); 
0CF6E:  CLRF   03
0CF70:  MOVF   x52,W
0CF72:  ADDLW  3A
0CF74:  MOVWF  FE9
0CF76:  MOVLW  0C
0CF78:  ADDWFC 03,W
0CF7A:  MOVWF  FEA
0CF7C:  MOVFF  FEF,C53
0CF80:  MOVF   x53,W
0CF82:  MOVLB  0
0CF84:  CALL   5422
0CF88:  MOVLB  C
0CF8A:  INCF   x52,F
0CF8C:  BRA    CF68
....................     } 
....................     current_cw++; 
0CF8E:  MOVLB  A
0CF90:  INCF   xDB,F
....................     if (current_cw >= sizeof(cw) / sizeof(cw[0])) 
0CF92:  MOVF   xDB,W
0CF94:  SUBLW  01
0CF96:  BC    CF9A
....................         current_cw = 0; 
0CF98:  CLRF   xDB
....................     fprintf(PC, "COM: "); 
0CF9A:  MOVLW  86
0CF9C:  MOVWF  FF6
0CF9E:  MOVLW  0B
0CFA0:  MOVWF  FF7
0CFA2:  MOVLW  00
0CFA4:  MOVWF  FF8
0CFA6:  MOVLB  0
0CFA8:  CALL   4534
....................     uart_print_pc_hex(data, com_to_main_size); 
0CFAC:  MOVFF  C39,C90
0CFB0:  MOVFF  C38,C8F
0CFB4:  MOVLW  19
0CFB6:  MOVLB  C
0CFB8:  MOVWF  x91
0CFBA:  MOVLB  0
0CFBC:  CALL   7A5C
....................     return 0; 
0CFC0:  MOVLW  00
0CFC2:  MOVWF  01
0CFC4:  GOTO   18A70 (RETURN)
.................... } 
....................  
.................... // COM Access request 
.................... uint8_t command_com_access_request(uint8_t* data) 
*
0D034:  MOVFF  C39,C3B
0D038:  MOVFF  C38,C3A
0D03C:  MOVLW  02
0D03E:  MOVLB  C
0D040:  ADDWF  x3A,W
0D042:  MOVWF  FE9
0D044:  MOVLW  00
0D046:  ADDWFC x3B,W
0D048:  MOVWF  FEA
0D04A:  MOVFF  FEF,00
0D04E:  CLRF   01
0D050:  CLRF   02
0D052:  CLRF   03
0D054:  MOVFF  03,C51
0D058:  MOVFF  02,C50
0D05C:  MOVFF  01,C4F
0D060:  MOVFF  00,C4E
0D064:  MOVFF  FEA,C53
0D068:  MOVFF  FE9,C52
0D06C:  CLRF   xB4
0D06E:  CLRF   xB3
0D070:  CLRF   xB2
0D072:  MOVLW  3C
0D074:  MOVWF  xB1
0D076:  MOVFF  03,CB8
0D07A:  MOVFF  02,CB7
0D07E:  MOVFF  01,CB6
0D082:  MOVFF  00,CB5
0D086:  MOVLB  0
0D088:  CALL   456E
0D08C:  MOVFF  C53,FEA
0D090:  MOVFF  C52,FE9
0D094:  MOVF   00,W
0D096:  ADDWF  3B,W
0D098:  MOVLB  C
0D09A:  MOVWF  x3C
0D09C:  MOVF   01,W
0D09E:  ADDWFC 3C,W
0D0A0:  MOVWF  x3D
0D0A2:  MOVF   02,W
0D0A4:  ADDWFC 3D,W
0D0A6:  MOVWF  x3E
0D0A8:  MOVF   03,W
0D0AA:  ADDWFC 3E,W
0D0AC:  MOVWF  x3F
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x59 
....................         uint8_t time;    // in minutes 
....................     }* packet = (struct packet*)data; 
....................  
....................     time_t disable_time = current_time + (60 * (time_t)packet->time); 
....................     scheduled_command_clear_specified_command(0xC0, 0x58); 
0D0AE:  MOVLW  C0
0D0B0:  MOVWF  xBE
0D0B2:  MOVLW  58
0D0B4:  MOVWF  xBF
0D0B6:  MOVLB  0
0D0B8:  CALL   7E00
....................     schedule(current_time, { 0xC0, 0x58, 0x01 }); 
0D0BC:  MOVLW  C0
0D0BE:  MOVLB  C
0D0C0:  MOVWF  x40
0D0C2:  MOVLW  58
0D0C4:  MOVWF  x41
0D0C6:  MOVLW  01
0D0C8:  MOVWF  x42
0D0CA:  MOVFF  3E,C98
0D0CE:  MOVFF  3D,C97
0D0D2:  MOVFF  3C,C96
0D0D6:  MOVFF  3B,C95
0D0DA:  MOVLW  0C
0D0DC:  MOVWF  x9A
0D0DE:  MOVLW  40
0D0E0:  MOVWF  x99
0D0E2:  MOVLB  0
0D0E4:  CALL   704C
....................     schedule(disable_time, { 0xC0, 0x58, 0x00 }); 
0D0E8:  MOVLW  C0
0D0EA:  MOVLB  C
0D0EC:  MOVWF  x43
0D0EE:  MOVLW  58
0D0F0:  MOVWF  x44
0D0F2:  CLRF   x45
0D0F4:  MOVFF  C3F,C98
0D0F8:  MOVFF  C3E,C97
0D0FC:  MOVFF  C3D,C96
0D100:  MOVFF  C3C,C95
0D104:  MOVLW  0C
0D106:  MOVWF  x9A
0D108:  MOVLW  43
0D10A:  MOVWF  x99
0D10C:  MOVLB  0
0D10E:  CALL   704C
....................  
....................     uint8_t reply[8] = { 0 }; 
0D112:  MOVLB  C
0D114:  CLRF   x46
0D116:  CLRF   x47
0D118:  CLRF   x48
0D11A:  CLRF   x49
0D11C:  CLRF   x4A
0D11E:  CLRF   x4B
0D120:  CLRF   x4C
0D122:  CLRF   x4D
....................     send_com_ack(reply); 
0D124:  MOVLW  0C
0D126:  MOVWF  x4F
0D128:  MOVLW  46
0D12A:  MOVWF  x4E
0D12C:  MOVLB  0
0D12E:  CALL   77A2
....................  
....................     return packet->time; 
0D132:  MOVLW  02
0D134:  MOVLB  C
0D136:  ADDWF  x3A,W
0D138:  MOVWF  FE9
0D13A:  MOVLW  00
0D13C:  ADDWFC x3B,W
0D13E:  MOVWF  FEA
0D140:  MOVFF  FEF,01
0D144:  MOVLB  0
0D146:  GOTO   18AA6 (RETURN)
.................... } 
....................  
.................... // Change COM access 
.................... uint8_t command_com_access_change(uint8_t* data) 
*
0CFEC:  MOVFF  C39,C3B
0CFF0:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x58 
....................         uint8_t state;   // 0: OBC side; 1: COM side 
....................     }* packet = (struct packet*)data; 
....................  
....................     output_bit(MUX_SEL_COM_SHARED_FM, packet->state); 
0CFF4:  MOVLW  02
0CFF6:  MOVLB  C
0CFF8:  ADDWF  x3A,W
0CFFA:  MOVWF  FE9
0CFFC:  MOVLW  00
0CFFE:  ADDWFC x3B,W
0D000:  MOVWF  FEA
0D002:  MOVF   FEF,F
0D004:  BNZ   D00A
0D006:  BCF    F8B.5
0D008:  BRA    D00C
0D00A:  BSF    F8B.5
0D00C:  BCF    F94.5
....................     memory_busy = packet->state; 
0D00E:  MOVLW  02
0D010:  ADDWF  x3A,W
0D012:  MOVWF  FE9
0D014:  MOVLW  00
0D016:  ADDWFC x3B,W
0D018:  MOVWF  FEA
0D01A:  MOVFF  FEF,55B
....................  
....................     return packet->state; 
0D01E:  MOVLW  02
0D020:  ADDWF  x3A,W
0D022:  MOVWF  FE9
0D024:  MOVLW  00
0D026:  ADDWFC x3B,W
0D028:  MOVWF  FEA
0D02A:  MOVFF  FEF,01
0D02E:  MOVLB  0
0D030:  GOTO   18A94 (RETURN)
.................... } 
....................  
.................... // ============ OBC/PCIB Commands ============ 
....................  
.................... // Schedule any command 
.................... uint8_t command_schedule_anything(uint8_t* data) 
*
14FB6:  MOVFF  C39,C3B
14FBA:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin;       // C0 
....................         uint8_t command;      // F6 
....................         time_t schedule_time; // Time_T 4 bytes 
....................         uint8_t schedule_command[12]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     vschedule(packet->schedule_time, packet->schedule_command); 
14FBE:  MOVLW  02
14FC0:  MOVLB  C
14FC2:  ADDWF  x3A,W
14FC4:  MOVWF  FE9
14FC6:  MOVLW  00
14FC8:  ADDWFC x3B,W
14FCA:  MOVWF  FEA
14FCC:  MOVFF  FEF,C95
14FD0:  MOVFF  FEC,C96
14FD4:  MOVFF  FEC,C97
14FD8:  MOVFF  FEC,C98
14FDC:  MOVLW  06
14FDE:  ADDWF  x3A,W
14FE0:  MOVWF  01
14FE2:  MOVLW  00
14FE4:  ADDWFC x3B,W
14FE6:  MOVWF  03
14FE8:  MOVFF  01,C40
14FEC:  MOVWF  x41
14FEE:  MOVWF  x9A
14FF0:  MOVFF  01,C99
14FF4:  MOVLB  0
14FF6:  CALL   704C
....................  
....................     return 0; 
14FFA:  MOVLW  00
14FFC:  MOVWF  01
14FFE:  GOTO   18EEA (RETURN)
.................... } 
....................  
.................... // Set the clock to a given value (UNIX time, seconds after Jan 1st 1970) 
.................... uint8_t command_set_clock(uint8_t* data) 
*
091CA:  MOVFF  C39,C3B
091CE:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t current_time; 
....................         int8_t leap_seconds; 
....................         uint8_t gps_time_sync_state; // Not set here, kept for backward compatibility 
....................         uint8_t skip_telemetry_config; 
....................     }* packet = (struct packet*)data; 
....................     obc_flags.leap_seconds = packet->leap_seconds; 
091D2:  MOVLW  06
091D4:  MOVLB  C
091D6:  ADDWF  x3A,W
091D8:  MOVWF  FE9
091DA:  MOVLW  00
091DC:  ADDWFC x3B,W
091DE:  MOVWF  FEA
091E0:  MOVFF  FEF,100
....................     // obc_flags.gps_time_sync_state = packet->gps_time_sync_state; 
....................  
....................     uint8_t time_updated = 0; 
091E4:  CLRF   x3C
....................  
....................     if (packet->current_time < T0) { 
091E6:  MOVLW  02
091E8:  ADDWF  x3A,W
091EA:  MOVWF  FE9
091EC:  MOVLW  00
091EE:  ADDWFC x3B,W
091F0:  MOVWF  FEA
091F2:  MOVFF  FEF,C3F
091F6:  MOVFF  FEC,C40
091FA:  MOVFF  FEC,C41
091FE:  MOVFF  FEC,C42
09202:  BTFSC  x42.7
09204:  BRA    9224
09206:  MOVF   x42,W
09208:  SUBLW  38
0920A:  BNC   925A
0920C:  BNZ   9224
0920E:  MOVF   x41,W
09210:  SUBLW  6D
09212:  BNC   925A
09214:  BNZ   9224
09216:  MOVF   x40,W
09218:  SUBLW  43
0921A:  BNC   925A
0921C:  BNZ   9224
0921E:  MOVF   x3F,W
09220:  SUBLW  7F
09222:  BNC   925A
....................         time_updated = 1; 
09224:  MOVLW  01
09226:  MOVWF  x3C
....................         SetTimeSec(T0); // Set clock to as early as possible (Jan 1st 2000, 00:00:00); 
09228:  MOVLW  38
0922A:  MOVWF  x52
0922C:  MOVLW  6D
0922E:  MOVWF  x51
09230:  MOVLW  43
09232:  MOVWF  x50
09234:  MOVLW  80
09236:  MOVWF  x4F
09238:  MOVLB  0
0923A:  CALL   5140
....................         // mai_400_update_clock(T0); 
....................         reset_pic_update_clock(T0); 
0923E:  MOVLW  38
09240:  MOVLB  C
09242:  MOVWF  x52
09244:  MOVLW  6D
09246:  MOVWF  x51
09248:  MOVLW  43
0924A:  MOVWF  x50
0924C:  MOVLW  80
0924E:  MOVWF  x4F
09250:  MOVLB  0
09252:  CALL   816A
....................     } else { 
09256:  BRA    9308
09258:  MOVLB  C
....................         SetTimeSec(packet->current_time + obc_flags.leap_seconds); 
0925A:  MOVLW  02
0925C:  ADDWF  x3A,W
0925E:  MOVWF  FE9
09260:  MOVLW  00
09262:  ADDWFC x3B,W
09264:  MOVWF  FEA
09266:  MOVFF  FEF,C3F
0926A:  MOVFF  FEC,C40
0926E:  MOVFF  FEC,C41
09272:  MOVFF  FEC,C42
09276:  MOVFF  100,00
0927A:  CLRF   01
0927C:  CLRF   02
0927E:  CLRF   03
09280:  BTFSS  00.7
09282:  BRA    928A
09284:  DECF   01,F
09286:  DECF   02,F
09288:  DECF   03,F
0928A:  MOVF   00,W
0928C:  ADDWF  x3F,F
0928E:  MOVF   01,W
09290:  ADDWFC x40,F
09292:  MOVF   02,W
09294:  ADDWFC x41,F
09296:  MOVF   03,W
09298:  ADDWFC x42,F
0929A:  MOVFF  C42,C52
0929E:  MOVFF  C41,C51
092A2:  MOVFF  C40,C50
092A6:  MOVFF  C3F,C4F
092AA:  MOVLB  0
092AC:  CALL   5140
....................         reset_pic_update_clock(packet->current_time + obc_flags.leap_seconds); 
092B0:  MOVLW  02
092B2:  MOVLB  C
092B4:  ADDWF  x3A,W
092B6:  MOVWF  FE9
092B8:  MOVLW  00
092BA:  ADDWFC x3B,W
092BC:  MOVWF  FEA
092BE:  MOVFF  FEF,C3F
092C2:  MOVFF  FEC,C40
092C6:  MOVFF  FEC,C41
092CA:  MOVFF  FEC,C42
092CE:  MOVFF  100,00
092D2:  CLRF   01
092D4:  CLRF   02
092D6:  CLRF   03
092D8:  BTFSS  00.7
092DA:  BRA    92E2
092DC:  DECF   01,F
092DE:  DECF   02,F
092E0:  DECF   03,F
092E2:  MOVF   00,W
092E4:  ADDWF  x3F,F
092E6:  MOVF   01,W
092E8:  ADDWFC x40,F
092EA:  MOVF   02,W
092EC:  ADDWFC x41,F
092EE:  MOVF   03,W
092F0:  ADDWFC x42,F
092F2:  MOVFF  C42,C52
092F6:  MOVFF  C41,C51
092FA:  MOVFF  C40,C50
092FE:  MOVFF  C3F,C4F
09302:  MOVLB  0
09304:  CALL   816A
....................     } 
....................     current_time = time(0); 
09308:  MOVLB  C
0930A:  CLRF   x50
0930C:  CLRF   x4F
0930E:  MOVLB  0
09310:  CALL   4C60
09314:  MOVFF  03,3E
09318:  MOVFF  02,3D
0931C:  MOVFF  01,3C
09320:  MOVFF  00,3B
....................  
....................     if(!packet->skip_telemetry_config) { // Useful for clock manipulation without disturbing telemetry collection 
09324:  MOVLW  08
09326:  MOVLB  C
09328:  ADDWF  x3A,W
0932A:  MOVWF  FE9
0932C:  MOVLW  00
0932E:  ADDWFC x3B,W
09330:  MOVWF  FEA
09332:  MOVF   FEF,F
09334:  BNZ   9374
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
09336:  MOVLW  02
09338:  MOVWF  x4F
0933A:  MOVFF  FF,C50
0933E:  MOVFF  13C,C54
09342:  MOVFF  13B,C53
09346:  MOVFF  13A,C52
0934A:  MOVFF  139,C51
0934E:  CLRF   x58
09350:  MOVLW  11
09352:  MOVWF  x57
09354:  CLRF   x56
09356:  CLRF   x55
09358:  CLRF   x5C
0935A:  CLRF   x5B
0935C:  CLRF   x5A
0935E:  MOVLW  98
09360:  MOVWF  x59
09362:  MOVLW  01
09364:  MOVWF  x5D
09366:  MOVWF  x5F
09368:  MOVLW  31
0936A:  MOVWF  x5E
0936C:  MOVLB  0
0936E:  CALL   5B62
09372:  MOVLB  C
....................     } 
....................  
....................     struct_tm* local_time = localtime(&current_time); 
09374:  CLRF   x84
09376:  MOVLW  3B
09378:  MOVWF  x83
0937A:  MOVLB  0
0937C:  CALL   4D28
09380:  MOVFF  02,C3E
09384:  MOVFF  01,C3D
....................  
....................     fprintf(PC, " New time: %04ld/%02d/%02d %02d:%02d:%02d(0x%08lX) ", 
....................         local_time->tm_year + 1900, 
....................         (uint8_t)local_time->tm_mon + 1, 
....................         local_time->tm_mday, 
....................         local_time->tm_hour, 
....................         local_time->tm_min, 
....................         local_time->tm_sec, 
....................         current_time); 
09388:  MOVLW  05
0938A:  MOVLB  C
0938C:  ADDWF  x3D,W
0938E:  MOVWF  FE9
09390:  MOVLW  00
09392:  ADDWFC x3E,W
09394:  MOVWF  FEA
09396:  MOVFF  FEC,C40
0939A:  MOVF   FED,F
0939C:  MOVFF  FEF,C3F
093A0:  MOVLW  6C
093A2:  ADDWF  x3F,F
093A4:  MOVLW  07
093A6:  ADDWFC x40,F
093A8:  MOVLW  04
093AA:  ADDWF  x3D,W
093AC:  MOVWF  FE9
093AE:  MOVLW  00
093B0:  ADDWFC x3E,W
093B2:  MOVWF  FEA
093B4:  MOVLW  01
093B6:  ADDWF  FEF,W
093B8:  MOVWF  x41
093BA:  MOVLW  03
093BC:  ADDWF  x3D,W
093BE:  MOVWF  FE9
093C0:  MOVLW  00
093C2:  ADDWFC x3E,W
093C4:  MOVWF  FEA
093C6:  MOVFF  FEF,C42
093CA:  MOVLW  02
093CC:  ADDWF  x3D,W
093CE:  MOVWF  FE9
093D0:  MOVLW  00
093D2:  ADDWFC x3E,W
093D4:  MOVWF  FEA
093D6:  MOVFF  FEF,C43
093DA:  MOVLW  01
093DC:  ADDWF  x3D,W
093DE:  MOVWF  FE9
093E0:  MOVLW  00
093E2:  ADDWFC x3E,W
093E4:  MOVWF  FEA
093E6:  MOVFF  FEF,C44
093EA:  MOVFF  C3D,FE9
093EE:  MOVFF  C3E,FEA
093F2:  MOVFF  FEF,C45
093F6:  MOVLW  8C
093F8:  MOVWF  FF6
093FA:  MOVLW  0B
093FC:  MOVWF  FF7
093FE:  MOVLW  00
09400:  MOVWF  FF8
09402:  MOVLW  0B
09404:  MOVWF  xC1
09406:  MOVLB  0
09408:  CALL   5290
0940C:  MOVLW  0A
0940E:  MOVWF  FE9
09410:  MOVFF  C40,C66
09414:  MOVFF  C3F,C65
09418:  CALL   7894
0941C:  MOVLW  2F
0941E:  MOVLB  D
09420:  MOVWF  x6A
09422:  MOVLB  0
09424:  CALL   44EE
09428:  MOVFF  C41,C65
0942C:  MOVLW  01
0942E:  MOVLB  C
09430:  MOVWF  x66
09432:  MOVLB  0
09434:  CALL   7994
09438:  MOVLW  2F
0943A:  MOVLB  D
0943C:  MOVWF  x6A
0943E:  MOVLB  0
09440:  CALL   44EE
09444:  MOVFF  C42,C65
09448:  MOVLW  01
0944A:  MOVLB  C
0944C:  MOVWF  x66
0944E:  MOVLB  0
09450:  CALL   7994
09454:  MOVLW  20
09456:  MOVLB  D
09458:  MOVWF  x6A
0945A:  MOVLB  0
0945C:  CALL   44EE
09460:  MOVFF  C43,C65
09464:  MOVLW  01
09466:  MOVLB  C
09468:  MOVWF  x66
0946A:  MOVLB  0
0946C:  CALL   7994
09470:  MOVLW  3A
09472:  MOVLB  D
09474:  MOVWF  x6A
09476:  MOVLB  0
09478:  CALL   44EE
0947C:  MOVFF  C44,C65
09480:  MOVLW  01
09482:  MOVLB  C
09484:  MOVWF  x66
09486:  MOVLB  0
09488:  CALL   7994
0948C:  MOVLW  3A
0948E:  MOVLB  D
09490:  MOVWF  x6A
09492:  MOVLB  0
09494:  CALL   44EE
09498:  MOVFF  C45,C65
0949C:  MOVLW  01
0949E:  MOVLB  C
094A0:  MOVWF  x66
094A2:  MOVLB  0
094A4:  CALL   7994
094A8:  MOVLW  B5
094AA:  MOVWF  FF6
094AC:  MOVLW  0B
094AE:  MOVWF  FF7
094B0:  MOVLW  00
094B2:  MOVWF  FF8
094B4:  MOVLW  03
094B6:  MOVLB  C
094B8:  MOVWF  xC1
094BA:  MOVLB  0
094BC:  CALL   5290
094C0:  MOVFF  3E,CBF
094C4:  MOVLW  37
094C6:  MOVLB  C
094C8:  MOVWF  xC0
094CA:  MOVLB  0
094CC:  CALL   5A92
094D0:  MOVFF  3D,CBF
094D4:  MOVLW  37
094D6:  MOVLB  C
094D8:  MOVWF  xC0
094DA:  MOVLB  0
094DC:  CALL   5A92
094E0:  MOVFF  3C,CBF
094E4:  MOVLW  37
094E6:  MOVLB  C
094E8:  MOVWF  xC0
094EA:  MOVLB  0
094EC:  CALL   5A92
094F0:  MOVFF  3B,CBF
094F4:  MOVLW  37
094F6:  MOVLB  C
094F8:  MOVWF  xC0
094FA:  MOVLB  0
094FC:  CALL   5A92
09500:  MOVLW  29
09502:  MOVLB  D
09504:  MOVWF  x6A
09506:  MOVLB  0
09508:  CALL   44EE
0950C:  MOVLW  20
0950E:  MOVLB  D
09510:  MOVWF  x6A
09512:  MOVLB  0
09514:  CALL   44EE
....................  
....................     fprintf(PC, "Leap: %d GPS sync: 0x%02X", obc_flags.leap_seconds, obc_flags.gps_time_sync_state); 
09518:  MOVLW  C0
0951A:  MOVWF  FF6
0951C:  MOVLW  0B
0951E:  MOVWF  FF7
09520:  MOVLW  00
09522:  MOVWF  FF8
09524:  MOVLW  06
09526:  MOVLB  C
09528:  MOVWF  xC1
0952A:  MOVLB  0
0952C:  CALL   5290
09530:  MOVFF  100,CBE
09534:  MOVLW  18
09536:  MOVLB  C
09538:  MOVWF  xBF
0953A:  MOVLB  0
0953C:  CALL   73A8
09540:  MOVLW  C8
09542:  MOVWF  FF6
09544:  MOVLW  0B
09546:  MOVWF  FF7
09548:  MOVLW  00
0954A:  MOVWF  FF8
0954C:  MOVLW  0D
0954E:  MOVLB  C
09550:  MOVWF  xC1
09552:  MOVLB  0
09554:  CALL   5290
09558:  MOVFF  103,CBF
0955C:  MOVLW  37
0955E:  MOVLB  C
09560:  MOVWF  xC0
09562:  MOVLB  0
09564:  CALL   5A92
....................     return time_updated; 
09568:  MOVLB  C
0956A:  MOVFF  C3C,01
0956E:  MOVLB  0
09570:  GOTO   18886 (RETURN)
.................... } 
....................  
.................... // Display the TRIS status to debug port 
.................... uint8_t command_get_tris(uint8_t* data) 
.................... { 
....................     fprintf(PC, "\r\n         fedcba9876543210"); 
*
12C44:  MOVLW  DA
12C46:  MOVWF  FF6
12C48:  MOVLW  0B
12C4A:  MOVWF  FF7
12C4C:  MOVLW  00
12C4E:  MOVWF  FF8
12C50:  CALL   4534
....................     fprintf(PC, "\r\ntris_a = "); 
12C54:  MOVLW  F6
12C56:  MOVWF  FF6
12C58:  MOVLW  0B
12C5A:  MOVWF  FF7
12C5C:  MOVLW  00
12C5E:  MOVWF  FF8
12C60:  CALL   4534
....................     print_binary16(get_tris_a()); 
12C64:  MOVFF  F92,C3A
12C68:  MOVLB  C
12C6A:  CLRF   x3C
12C6C:  MOVFF  F92,C3B
12C70:  MOVLB  0
12C72:  RCALL  12BF8
....................     fprintf(PC, "\r\ntris_b = "); 
12C74:  MOVLW  02
12C76:  MOVWF  FF6
12C78:  MOVLW  0C
12C7A:  MOVWF  FF7
12C7C:  MOVLW  00
12C7E:  MOVWF  FF8
12C80:  CALL   4534
....................     print_binary16(get_tris_b()); 
12C84:  MOVFF  F93,C3A
12C88:  MOVLB  C
12C8A:  CLRF   x3C
12C8C:  MOVFF  F93,C3B
12C90:  MOVLB  0
12C92:  RCALL  12BF8
....................     fprintf(PC, "\r\ntris_c = "); 
12C94:  MOVLW  0E
12C96:  MOVWF  FF6
12C98:  MOVLW  0C
12C9A:  MOVWF  FF7
12C9C:  MOVLW  00
12C9E:  MOVWF  FF8
12CA0:  CALL   4534
....................     print_binary16(get_tris_c()); 
12CA4:  MOVFF  F94,C3A
12CA8:  MOVLB  C
12CAA:  CLRF   x3C
12CAC:  MOVFF  F94,C3B
12CB0:  MOVLB  0
12CB2:  RCALL  12BF8
....................     fprintf(PC, "\r\ntris_d = "); 
12CB4:  MOVLW  1A
12CB6:  MOVWF  FF6
12CB8:  MOVLW  0C
12CBA:  MOVWF  FF7
12CBC:  MOVLW  00
12CBE:  MOVWF  FF8
12CC0:  CALL   4534
....................     print_binary16(get_tris_d()); 
12CC4:  MOVFF  F95,C3A
12CC8:  MOVLB  C
12CCA:  CLRF   x3C
12CCC:  MOVFF  F95,C3B
12CD0:  MOVLB  0
12CD2:  RCALL  12BF8
....................     fprintf(PC, "\r\ntris_e = "); 
12CD4:  MOVLW  26
12CD6:  MOVWF  FF6
12CD8:  MOVLW  0C
12CDA:  MOVWF  FF7
12CDC:  MOVLW  00
12CDE:  MOVWF  FF8
12CE0:  CALL   4534
....................     print_binary16(get_tris_e()); 
12CE4:  MOVFF  F96,C3A
12CE8:  MOVLB  C
12CEA:  CLRF   x3C
12CEC:  MOVFF  F96,C3B
12CF0:  MOVLB  0
12CF2:  RCALL  12BF8
....................     fprintf(PC, "\r\ntris_f = "); 
12CF4:  MOVLW  32
12CF6:  MOVWF  FF6
12CF8:  MOVLW  0C
12CFA:  MOVWF  FF7
12CFC:  MOVLW  00
12CFE:  MOVWF  FF8
12D00:  CALL   4534
....................     print_binary16(get_tris_f()); 
12D04:  MOVFF  F97,C3A
12D08:  MOVLB  C
12D0A:  CLRF   x3C
12D0C:  MOVFF  F97,C3B
12D10:  MOVLB  0
12D12:  RCALL  12BF8
....................     fprintf(PC, "\r\ntris_g = "); 
12D14:  MOVLW  3E
12D16:  MOVWF  FF6
12D18:  MOVLW  0C
12D1A:  MOVWF  FF7
12D1C:  MOVLW  00
12D1E:  MOVWF  FF8
12D20:  CALL   4534
....................     print_binary16(get_tris_g()); 
12D24:  MOVFF  F98,C3A
12D28:  MOVLB  C
12D2A:  CLRF   x3C
12D2C:  MOVFF  F98,C3B
12D30:  MOVLB  0
12D32:  RCALL  12BF8
....................     return 0xEE; 
12D34:  MOVLW  EE
12D36:  MOVWF  01
12D38:  RETURN 0
.................... } 
....................  
.................... // Prints a memory address relative to satellite time (if ptr = 0x0000, prints satellite time). 
.................... uint8_t command_print_memory_address(uint8_t* data) 
*
090F0:  MOVFF  C39,C3B
090F4:  MOVFF  C38,C3A
090F8:  MOVLW  02
090FA:  MOVLB  C
090FC:  ADDWF  x3A,W
090FE:  MOVWF  FE9
09100:  MOVLW  00
09102:  ADDWFC x3B,W
09104:  MOVWF  FEA
09106:  MOVFF  FEF,00
0910A:  MOVFF  FEC,01
0910E:  MOVFF  FEC,02
09112:  MOVFF  FEC,03
09116:  MOVLW  3B
09118:  ADDWF  00,W
0911A:  MOVWF  x3C
0911C:  MOVLW  00
0911E:  ADDWFC 01,W
09120:  MOVWF  x3D
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t ptr; 
....................     }* packet = (struct packet*)data; 
.................... #ifndef PC_SIM 
....................     uint32_t* addr = (uint32_t*)packet->ptr + &current_time; 
....................     fprintf(PC, "*%04lX = %08lX", addr, *addr); 
09122:  MOVFF  C3D,03
09126:  MOVFF  C3C,FE9
0912A:  MOVFF  C3D,FEA
0912E:  MOVFF  FEF,C3E
09132:  MOVFF  FEC,C3F
09136:  MOVFF  FEC,C40
0913A:  MOVFF  FEC,C41
0913E:  MOVLW  2A
09140:  MOVLB  D
09142:  MOVWF  x6A
09144:  MOVLB  0
09146:  CALL   44EE
0914A:  MOVFF  C3D,CBF
0914E:  MOVLW  37
09150:  MOVLB  C
09152:  MOVWF  xC0
09154:  MOVLB  0
09156:  CALL   5A92
0915A:  MOVFF  C3C,CBF
0915E:  MOVLW  37
09160:  MOVLB  C
09162:  MOVWF  xC0
09164:  MOVLB  0
09166:  CALL   5A92
0916A:  MOVLW  50
0916C:  MOVWF  FF6
0916E:  MOVLW  0C
09170:  MOVWF  FF7
09172:  MOVLW  00
09174:  MOVWF  FF8
09176:  MOVLW  03
09178:  MOVLB  C
0917A:  MOVWF  xC1
0917C:  MOVLB  0
0917E:  CALL   5290
09182:  MOVFF  C41,CBF
09186:  MOVLW  37
09188:  MOVLB  C
0918A:  MOVWF  xC0
0918C:  MOVLB  0
0918E:  CALL   5A92
09192:  MOVFF  C40,CBF
09196:  MOVLW  37
09198:  MOVLB  C
0919A:  MOVWF  xC0
0919C:  MOVLB  0
0919E:  CALL   5A92
091A2:  MOVFF  C3F,CBF
091A6:  MOVLW  37
091A8:  MOVLB  C
091AA:  MOVWF  xC0
091AC:  MOVLB  0
091AE:  CALL   5A92
091B2:  MOVFF  C3E,CBF
091B6:  MOVLW  37
091B8:  MOVLB  C
091BA:  MOVWF  xC0
091BC:  MOVLB  0
091BE:  CALL   5A92
.................... #endif 
....................     return 0; 
091C2:  MOVLW  00
091C4:  MOVWF  01
091C6:  GOTO   18872 (RETURN)
.................... } 
....................  
.................... // Sets the value of a memory address relative to satellite time 
.................... uint8_t command_set_obc_variable(uint8_t* data) 
*
0960A:  MOVFF  C39,C3B
0960E:  MOVFF  C38,C3A
09612:  MOVLB  C
09614:  CLRF   x42
09616:  MOVLW  3B
09618:  MOVWF  x41
0961A:  MOVLW  02
0961C:  ADDWF  x3A,W
0961E:  MOVWF  FE9
09620:  MOVLW  00
09622:  ADDWFC x3B,W
09624:  MOVWF  FEA
09626:  MOVFF  FEC,03
0962A:  MOVF   FED,F
0962C:  MOVF   FEF,W
0962E:  ADDWF  x41,W
09630:  MOVWF  x3C
09632:  MOVF   03,W
09634:  ADDWFC x42,W
09636:  MOVWF  x3D
09638:  MOVLW  05
0963A:  ADDWF  x3A,W
0963C:  MOVWF  01
0963E:  MOVLW  00
09640:  ADDWFC x3B,W
09642:  MOVFF  01,C3E
09646:  MOVWF  x3F
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t offset; 
....................         uint8_t size; 
....................         uint8_t data[sizeof(uint32_t)]; 
....................         uint8_t save_state; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t* dst = (uint8_t*)&current_time + packet->offset; 
....................     uint8_t* src = packet->data; 
....................  
....................     fprintf(PC, "Changing variable at 0x%04X, size %d to 0x%08LX", dst, packet->size, *(uint32_t*)&packet->data[0]); 
09648:  MOVLW  04
0964A:  ADDWF  x3A,W
0964C:  MOVWF  FE9
0964E:  MOVLW  00
09650:  ADDWFC x3B,W
09652:  MOVWF  FEA
09654:  MOVFF  FEF,C41
09658:  MOVLW  05
0965A:  ADDWF  x3A,W
0965C:  MOVWF  01
0965E:  MOVLW  00
09660:  ADDWFC x3B,W
09662:  MOVWF  03
09664:  MOVFF  01,FE9
09668:  MOVWF  FEA
0966A:  MOVFF  FEF,C42
0966E:  MOVFF  FEC,C43
09672:  MOVFF  FEC,C44
09676:  MOVFF  FEC,C45
0967A:  MOVLW  5A
0967C:  MOVWF  FF6
0967E:  MOVLW  0C
09680:  MOVWF  FF7
09682:  MOVLW  00
09684:  MOVWF  FF8
09686:  MOVLW  17
09688:  MOVWF  xC1
0968A:  MOVLB  0
0968C:  CALL   5290
09690:  MOVLW  02
09692:  MOVLB  C
09694:  MOVWF  x46
09696:  MOVLW  30
09698:  MOVLB  D
0969A:  MOVWF  x6A
0969C:  MOVLB  0
0969E:  CALL   44EE
096A2:  MOVLB  C
096A4:  DECFSZ x46,F
096A6:  BRA    9696
096A8:  MOVFF  C3C,CBF
096AC:  MOVLW  37
096AE:  MOVWF  xC0
096B0:  MOVLB  0
096B2:  CALL   5A92
096B6:  MOVLW  75
096B8:  MOVWF  FF6
096BA:  MOVLW  0C
096BC:  MOVWF  FF7
096BE:  MOVLW  00
096C0:  MOVWF  FF8
096C2:  MOVLW  07
096C4:  MOVLB  C
096C6:  MOVWF  xC1
096C8:  MOVLB  0
096CA:  CALL   5290
096CE:  MOVFF  C41,CBE
096D2:  MOVLW  18
096D4:  MOVLB  C
096D6:  MOVWF  xBF
096D8:  MOVLB  0
096DA:  CALL   73A8
096DE:  MOVLW  7E
096E0:  MOVWF  FF6
096E2:  MOVLW  0C
096E4:  MOVWF  FF7
096E6:  MOVLW  00
096E8:  MOVWF  FF8
096EA:  MOVLW  06
096EC:  MOVLB  C
096EE:  MOVWF  xC1
096F0:  MOVLB  0
096F2:  CALL   5290
096F6:  MOVFF  C45,CBF
096FA:  MOVLW  37
096FC:  MOVLB  C
096FE:  MOVWF  xC0
09700:  MOVLB  0
09702:  CALL   5A92
09706:  MOVFF  C44,CBF
0970A:  MOVLW  37
0970C:  MOVLB  C
0970E:  MOVWF  xC0
09710:  MOVLB  0
09712:  CALL   5A92
09716:  MOVFF  C43,CBF
0971A:  MOVLW  37
0971C:  MOVLB  C
0971E:  MOVWF  xC0
09720:  MOVLB  0
09722:  CALL   5A92
09726:  MOVFF  C42,CBF
0972A:  MOVLW  37
0972C:  MOVLB  C
0972E:  MOVWF  xC0
09730:  MOVLB  0
09732:  CALL   5A92
....................     for (uint8_t i = 0; i < packet->size; i++) { 
09736:  MOVLB  C
09738:  CLRF   x40
0973A:  MOVLW  04
0973C:  ADDWF  x3A,W
0973E:  MOVWF  FE9
09740:  MOVLW  00
09742:  ADDWFC x3B,W
09744:  MOVWF  FEA
09746:  MOVF   FEF,W
09748:  SUBWF  x40,W
0974A:  BC    9780
....................         *(dst + i) = *(src + i); 
0974C:  MOVF   x40,W
0974E:  ADDWF  x3C,W
09750:  MOVWF  01
09752:  MOVLW  00
09754:  ADDWFC x3D,W
09756:  MOVFF  01,C41
0975A:  MOVWF  x42
0975C:  MOVF   x40,W
0975E:  ADDWF  x3E,W
09760:  MOVWF  01
09762:  MOVLW  00
09764:  ADDWFC x3F,W
09766:  MOVFF  01,FE9
0976A:  MOVWF  FEA
0976C:  MOVFF  FEF,C43
09770:  MOVFF  C42,FEA
09774:  MOVFF  C41,FE9
09778:  MOVFF  C43,FEF
0977C:  INCF   x40,F
0977E:  BRA    973A
....................     } 
....................  
....................     if (packet->save_state == 1) { 
09780:  MOVLW  09
09782:  ADDWF  x3A,W
09784:  MOVWF  FE9
09786:  MOVLW  00
09788:  ADDWFC x3B,W
0978A:  MOVWF  FEA
0978C:  DECFSZ FEF,W
0978E:  BRA    97AA
....................         save_state(data[1]); // data[1] is the current command id 
09790:  MOVLW  01
09792:  ADDWF  x38,W
09794:  MOVWF  FE9
09796:  MOVLW  00
09798:  ADDWFC x39,W
0979A:  MOVWF  FEA
0979C:  MOVFF  FEF,C60
097A0:  MOVLB  0
097A2:  CALL   8CAE
....................     } else if (packet->save_state == 2) { 
097A6:  BRA    97C2
097A8:  MOVLB  C
097AA:  MOVLW  09
097AC:  ADDWF  x3A,W
097AE:  MOVWF  FE9
097B0:  MOVLW  00
097B2:  ADDWFC x3B,W
097B4:  MOVWF  FEA
097B6:  MOVF   FEF,W
097B8:  SUBLW  02
097BA:  BNZ   97C4
....................         save_flags(); 
097BC:  MOVLB  0
097BE:  RCALL  9574
....................         scheduled_command_clear_all(); 
097C0:  RCALL  95CE
097C2:  MOVLB  C
....................     } 
....................  
....................     return 0; 
097C4:  MOVLW  00
097C6:  MOVWF  01
097C8:  MOVLB  0
097CA:  GOTO   188AE (RETURN)
.................... } 
....................  
.................... // Sends the antenna deployment command to relay pic 
.................... uint8_t command_deploy_antenna(uint8_t* data) 
*
12630:  MOVFF  C39,C3B
12634:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
12638:  BTFSC  3E.7
1263A:  BRA    12758
1263C:  MOVF   3E,W
1263E:  SUBLW  37
12640:  BTFSC  FD8.0
12642:  BRA    12758
12644:  XORLW  FF
12646:  BNZ   12666
12648:  MOVF   3D,W
1264A:  SUBLW  6C
1264C:  BTFSC  FD8.0
1264E:  BRA    12758
12650:  XORLW  FF
12652:  BNZ   12666
12654:  MOVF   3C,W
12656:  SUBLW  49
12658:  BTFSC  FD8.0
1265A:  BRA    12758
1265C:  XORLW  FF
1265E:  BNZ   12666
12660:  MOVF   3B,W
12662:  SUBLW  A5
12664:  BC    12758
....................         // Increment deployment flag and save state 
....................         boot_flags.deployment_flag++; 
12666:  INCF   xFF,F
....................         get_com_shared_fm_access(); 
12668:  CALL   8672
....................         save_flags(); 
1266C:  CALL   9574
....................  
....................         uint8_t time = 30;    // in seconds 
12670:  MOVLW  1E
12672:  MOVLB  C
12674:  MOVWF  x3C
....................         if (packet->time_s) { // if specified time is not zero, then use specified value 
12676:  MOVLW  02
12678:  ADDWF  x3A,W
1267A:  MOVWF  FE9
1267C:  MOVLW  00
1267E:  ADDWFC x3B,W
12680:  MOVWF  FEA
12682:  MOVF   FEF,F
12684:  BZ    12696
....................             time = packet->time_s; 
12686:  MOVLW  02
12688:  ADDWF  x3A,W
1268A:  MOVWF  FE9
1268C:  MOVLW  00
1268E:  ADDWFC x3B,W
12690:  MOVWF  FEA
12692:  MOVFF  FEF,C3C
....................         } 
....................         fprintf(PC, "Deploying UHF Antenna for %ds... ", time); 
12696:  MOVLW  8A
12698:  MOVWF  FF6
1269A:  MOVLW  0C
1269C:  MOVWF  FF7
1269E:  MOVLW  00
126A0:  MOVWF  FF8
126A2:  MOVLW  1A
126A4:  MOVWF  xC1
126A6:  MOVLB  0
126A8:  CALL   5290
126AC:  MOVFF  C3C,CBE
126B0:  MOVLW  18
126B2:  MOVLB  C
126B4:  MOVWF  xBF
126B6:  MOVLB  0
126B8:  CALL   73A8
126BC:  MOVLW  A6
126BE:  MOVWF  FF6
126C0:  MOVLW  0C
126C2:  MOVWF  FF7
126C4:  MOVLW  00
126C6:  MOVWF  FF8
126C8:  MOVLW  05
126CA:  MOVLB  C
126CC:  MOVWF  xC1
126CE:  MOVLB  0
126D0:  CALL   5290
....................         output_high(DIO_BURNER_ANTENNA); 
126D4:  BCF    F98.4
126D6:  BSF    F8F.4
....................         delay_ms((uint32_t)time * 1000); 
126D8:  MOVLB  C
126DA:  CLRF   x40
126DC:  CLRF   x3F
126DE:  CLRF   x3E
126E0:  MOVFF  C3C,C3D
126E4:  MOVFF  C40,CB4
126E8:  MOVFF  C3F,CB3
126EC:  MOVFF  C3E,CB2
126F0:  MOVFF  C3C,CB1
126F4:  CLRF   xB8
126F6:  CLRF   xB7
126F8:  MOVLW  03
126FA:  MOVWF  xB6
126FC:  MOVLW  E8
126FE:  MOVWF  xB5
12700:  MOVLB  0
12702:  CALL   456E
12706:  MOVFF  03,C40
1270A:  MOVFF  02,C3F
1270E:  MOVFF  01,C3E
12712:  MOVFF  00,C3D
12716:  MOVFF  01,C41
1271A:  MOVLB  C
1271C:  INCF   x41,F
1271E:  DECF   x41,F
12720:  BTFSC  FD8.2
12722:  BRA    12732
12724:  MOVLB  D
12726:  SETF   x52
12728:  MOVLB  0
1272A:  CALL   5266
1272E:  MOVLB  C
12730:  BRA    1271E
12732:  MOVFF  C3D,D52
12736:  MOVLB  0
12738:  CALL   5266
....................         output_low(DIO_BURNER_ANTENNA); 
1273C:  BCF    F98.4
1273E:  BCF    F8F.4
....................         fprintf(PC, "Done!\r\n"); 
12740:  MOVLW  AC
12742:  MOVWF  FF6
12744:  MOVLW  0C
12746:  MOVWF  FF7
12748:  MOVLW  00
1274A:  MOVWF  FF8
1274C:  CALL   4534
....................         return 0; 
12750:  MOVLW  00
12752:  MOVWF  01
12754:  BRA    1275C
....................     } else { 
12756:  BRA    1275C
....................         return 1; 
12758:  MOVLW  01
1275A:  MOVWF  01
....................     } 
1275C:  GOTO   18E12 (RETURN)
.................... } 
....................  
.................... // Clear completely the main memory. 
.................... uint8_t command_clear_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
*
0EE80:  CALL   8672
....................     flash_erase(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, ERASE_SECTOR); 
0EE84:  MOVLW  0A
0EE86:  MOVLB  D
0EE88:  MOVWF  x49
0EE8A:  MOVLW  A3
0EE8C:  MOVWF  x48
0EE8E:  CLRF   x4D
0EE90:  CLRF   x4C
0EE92:  CLRF   x4B
0EE94:  CLRF   x4A
0EE96:  MOVLW  DC
0EE98:  MOVWF  x4E
0EE9A:  MOVLB  0
0EE9C:  CALL   604C
....................     fprintf(PC, "Waiting 10s for reset...\r\n"); 
0EEA0:  MOVLW  B4
0EEA2:  MOVWF  FF6
0EEA4:  MOVLW  0C
0EEA6:  MOVWF  FF7
0EEA8:  MOVLW  00
0EEAA:  MOVWF  FF8
0EEAC:  CALL   4534
....................     delay_ms(10000); 
0EEB0:  MOVLW  28
0EEB2:  MOVLB  C
0EEB4:  MOVWF  x3A
0EEB6:  MOVLW  FA
0EEB8:  MOVLB  D
0EEBA:  MOVWF  x52
0EEBC:  MOVLB  0
0EEBE:  CALL   5266
0EEC2:  MOVLB  C
0EEC4:  DECFSZ x3A,F
0EEC6:  BRA    EEB6
....................     reset_cpu(); 
0EEC8:  RESET
....................     return 0; 
0EECA:  MOVLW  00
0EECC:  MOVWF  01
0EECE:  MOVLB  0
0EED0:  GOTO   18CE6 (RETURN)
.................... } 
....................  
.................... // Save state to memory. 
.................... uint8_t command_save_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
*
0CFC8:  CALL   8672
....................     save_state(data[1]); // data[1] is the current command id 
0CFCC:  MOVLW  01
0CFCE:  MOVLB  C
0CFD0:  ADDWF  x38,W
0CFD2:  MOVWF  FE9
0CFD4:  MOVLW  00
0CFD6:  ADDWFC x39,W
0CFD8:  MOVWF  FEA
0CFDA:  MOVFF  FEF,C60
0CFDE:  MOVLB  0
0CFE0:  CALL   8CAE
....................     return 0; 
0CFE4:  MOVLW  00
0CFE6:  MOVWF  01
0CFE8:  GOTO   18A82 (RETURN)
.................... } 
....................  
.................... // Dump state. 
.................... uint8_t command_dump_memory(uint8_t* data) 
*
12864:  MOVFF  C39,C3B
12868:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t start; 
....................         uint32_t size; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................     fprintf(PC, "\r\nHex dump start"); 
1286C:  MOVLW  D0
1286E:  MOVWF  FF6
12870:  MOVLW  0C
12872:  MOVWF  FF7
12874:  MOVLW  00
12876:  MOVWF  FF8
12878:  CALL   4534
....................     switch (packet->source) { 
1287C:  MOVLW  0A
1287E:  MOVLB  C
12880:  ADDWF  x3A,W
12882:  MOVWF  FE9
12884:  MOVLW  00
12886:  ADDWFC x3B,W
12888:  MOVWF  FEA
1288A:  MOVF   FEF,W
1288C:  XORLW  00
1288E:  MOVLB  0
12890:  BZ    1289E
12892:  XORLW  01
12894:  BZ    12926
12896:  XORLW  03
12898:  BTFSC  FD8.2
1289A:  BRA    129AA
1289C:  BRA    12A36
....................     case 0: 
....................         get_com_shared_fm_access(); 
1289E:  CALL   8672
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
128A2:  MOVLW  02
128A4:  MOVLB  C
128A6:  ADDWF  x3A,W
128A8:  MOVWF  FE9
128AA:  MOVLW  00
128AC:  ADDWFC x3B,W
128AE:  MOVWF  FEA
128B0:  MOVFF  FEF,C46
128B4:  MOVFF  FEC,C47
128B8:  MOVFF  FEC,C48
128BC:  MOVFF  FEC,C49
128C0:  MOVLW  02
128C2:  ADDWF  x3A,W
128C4:  MOVWF  FE9
128C6:  MOVLW  00
128C8:  ADDWFC x3B,W
128CA:  MOVWF  FEA
128CC:  MOVFF  FEF,C40
128D0:  MOVFF  FEC,C41
128D4:  MOVFF  FEC,C42
128D8:  MOVFF  FEC,C43
128DC:  MOVLW  06
128DE:  ADDWF  x3A,W
128E0:  MOVWF  FE9
128E2:  MOVLW  00
128E4:  ADDWFC x3B,W
128E6:  MOVWF  FEA
128E8:  MOVFF  FEF,00
128EC:  MOVFF  FEC,01
128F0:  MOVFF  FEC,02
128F4:  MOVFF  FEC,03
128F8:  MOVF   00,W
128FA:  ADDWF  x40,F
128FC:  MOVF   01,W
128FE:  ADDWFC x41,F
12900:  MOVF   02,W
12902:  ADDWFC x42,F
12904:  MOVF   03,W
12906:  ADDWFC x43,F
12908:  MOVLW  0A
1290A:  MOVWF  x45
1290C:  MOVLW  A3
1290E:  MOVWF  x44
12910:  MOVFF  C43,C4D
12914:  MOVFF  C42,C4C
12918:  MOVFF  C41,C4B
1291C:  MOVFF  C40,C4A
12920:  MOVLB  0
12922:  RCALL  12760
....................         break; 
12924:  BRA    12ABC
....................     case 1: 
....................         flash_dump(&spi_port_MAIN_FM, packet->start, packet->start + packet->size); 
12926:  MOVLW  02
12928:  MOVLB  C
1292A:  ADDWF  x3A,W
1292C:  MOVWF  FE9
1292E:  MOVLW  00
12930:  ADDWFC x3B,W
12932:  MOVWF  FEA
12934:  MOVFF  FEF,C46
12938:  MOVFF  FEC,C47
1293C:  MOVFF  FEC,C48
12940:  MOVFF  FEC,C49
12944:  MOVLW  02
12946:  ADDWF  x3A,W
12948:  MOVWF  FE9
1294A:  MOVLW  00
1294C:  ADDWFC x3B,W
1294E:  MOVWF  FEA
12950:  MOVFF  FEF,C40
12954:  MOVFF  FEC,C41
12958:  MOVFF  FEC,C42
1295C:  MOVFF  FEC,C43
12960:  MOVLW  06
12962:  ADDWF  x3A,W
12964:  MOVWF  FE9
12966:  MOVLW  00
12968:  ADDWFC x3B,W
1296A:  MOVWF  FEA
1296C:  MOVFF  FEF,00
12970:  MOVFF  FEC,01
12974:  MOVFF  FEC,02
12978:  MOVFF  FEC,03
1297C:  MOVF   00,W
1297E:  ADDWF  x40,F
12980:  MOVF   01,W
12982:  ADDWFC x41,F
12984:  MOVF   02,W
12986:  ADDWFC x42,F
12988:  MOVF   03,W
1298A:  ADDWFC x43,F
1298C:  MOVLW  0A
1298E:  MOVWF  x45
12990:  MOVLW  AD
12992:  MOVWF  x44
12994:  MOVFF  C43,C4D
12998:  MOVFF  C42,C4C
1299C:  MOVFF  C41,C4B
129A0:  MOVFF  C40,C4A
129A4:  MOVLB  0
129A6:  RCALL  12760
....................         break; 
129A8:  BRA    12ABC
....................     case 2: 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
129AA:  BCF    F92.5
129AC:  BCF    F89.5
....................         flash_dump(&spi_port_MISSION_FM, packet->start, packet->start + packet->size); 
129AE:  MOVLW  02
129B0:  MOVLB  C
129B2:  ADDWF  x3A,W
129B4:  MOVWF  FE9
129B6:  MOVLW  00
129B8:  ADDWFC x3B,W
129BA:  MOVWF  FEA
129BC:  MOVFF  FEF,C46
129C0:  MOVFF  FEC,C47
129C4:  MOVFF  FEC,C48
129C8:  MOVFF  FEC,C49
129CC:  MOVLW  02
129CE:  ADDWF  x3A,W
129D0:  MOVWF  FE9
129D2:  MOVLW  00
129D4:  ADDWFC x3B,W
129D6:  MOVWF  FEA
129D8:  MOVFF  FEF,C40
129DC:  MOVFF  FEC,C41
129E0:  MOVFF  FEC,C42
129E4:  MOVFF  FEC,C43
129E8:  MOVLW  06
129EA:  ADDWF  x3A,W
129EC:  MOVWF  FE9
129EE:  MOVLW  00
129F0:  ADDWFC x3B,W
129F2:  MOVWF  FEA
129F4:  MOVFF  FEF,00
129F8:  MOVFF  FEC,01
129FC:  MOVFF  FEC,02
12A00:  MOVFF  FEC,03
12A04:  MOVF   00,W
12A06:  ADDWF  x40,F
12A08:  MOVF   01,W
12A0A:  ADDWFC x41,F
12A0C:  MOVF   02,W
12A0E:  ADDWFC x42,F
12A10:  MOVF   03,W
12A12:  ADDWFC x43,F
12A14:  MOVLW  0A
12A16:  MOVWF  x45
12A18:  MOVLW  B7
12A1A:  MOVWF  x44
12A1C:  MOVFF  C43,C4D
12A20:  MOVFF  C42,C4C
12A24:  MOVFF  C41,C4B
12A28:  MOVFF  C40,C4A
12A2C:  MOVLB  0
12A2E:  RCALL  12760
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
12A30:  BCF    F92.5
12A32:  BSF    F89.5
....................         break; 
12A34:  BRA    12ABC
....................     default: 
....................         get_com_shared_fm_access(); 
12A36:  CALL   8672
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
12A3A:  MOVLW  02
12A3C:  MOVLB  C
12A3E:  ADDWF  x3A,W
12A40:  MOVWF  FE9
12A42:  MOVLW  00
12A44:  ADDWFC x3B,W
12A46:  MOVWF  FEA
12A48:  MOVFF  FEF,C46
12A4C:  MOVFF  FEC,C47
12A50:  MOVFF  FEC,C48
12A54:  MOVFF  FEC,C49
12A58:  MOVLW  02
12A5A:  ADDWF  x3A,W
12A5C:  MOVWF  FE9
12A5E:  MOVLW  00
12A60:  ADDWFC x3B,W
12A62:  MOVWF  FEA
12A64:  MOVFF  FEF,C40
12A68:  MOVFF  FEC,C41
12A6C:  MOVFF  FEC,C42
12A70:  MOVFF  FEC,C43
12A74:  MOVLW  06
12A76:  ADDWF  x3A,W
12A78:  MOVWF  FE9
12A7A:  MOVLW  00
12A7C:  ADDWFC x3B,W
12A7E:  MOVWF  FEA
12A80:  MOVFF  FEF,00
12A84:  MOVFF  FEC,01
12A88:  MOVFF  FEC,02
12A8C:  MOVFF  FEC,03
12A90:  MOVF   00,W
12A92:  ADDWF  x40,F
12A94:  MOVF   01,W
12A96:  ADDWFC x41,F
12A98:  MOVF   02,W
12A9A:  ADDWFC x42,F
12A9C:  MOVF   03,W
12A9E:  ADDWFC x43,F
12AA0:  MOVLW  0A
12AA2:  MOVWF  x45
12AA4:  MOVLW  A3
12AA6:  MOVWF  x44
12AA8:  MOVFF  C43,C4D
12AAC:  MOVFF  C42,C4C
12AB0:  MOVFF  C41,C4B
12AB4:  MOVFF  C40,C4A
12AB8:  MOVLB  0
12ABA:  RCALL  12760
....................         break; 
....................     } 
....................     fprintf(PC, "\r\nHex dump end\r\n"); 
12ABC:  MOVLW  E2
12ABE:  MOVWF  FF6
12AC0:  MOVLW  0C
12AC2:  MOVWF  FF7
12AC4:  MOVLW  00
12AC6:  MOVWF  FF8
12AC8:  CALL   4534
....................     return packet->source; 
12ACC:  MOVLW  0A
12ACE:  MOVLB  C
12AD0:  ADDWF  x3A,W
12AD2:  MOVWF  FE9
12AD4:  MOVLW  00
12AD6:  ADDWFC x3B,W
12AD8:  MOVWF  FEA
12ADA:  MOVFF  FEF,01
12ADE:  MOVLB  0
12AE0:  GOTO   18E36 (RETURN)
.................... } 
....................  
.................... // Helper function to copy data from flash memory to flash memory 
.................... uint8_t copy( 
....................     uint8_t origin, // 0:COM, 1:MAIN, 2:MISSION 
....................     uint8_t dest,   // 0:COM, 1:MAIN, 2:MISSION 
....................     uint32_t to_page_or_sector_or_address, 
....................     uint32_t from_page_or_sector_or_address, 
....................     uint32_t size, // in page or sectors or sectors 
....................     uint8_t mode   // mode: 0 = pages, 1 = sectors, 2 = addressed by byte, size as pages 
.................... ) 
.................... { 
....................     get_com_shared_fm_access(); 
*
0AB50:  CALL   8672
....................  
....................     uint8_t erase_mode; 
....................     uint32_t increment; 
....................  
....................     if (mode == 0 || mode == 2) { 
0AB54:  MOVLB  C
0AB56:  MOVF   x97,F
0AB58:  BZ    AB60
0AB5A:  MOVF   x97,W
0AB5C:  SUBLW  02
0AB5E:  BNZ   AB70
....................         erase_mode = ERASE_PAGE; 
0AB60:  MOVLW  21
0AB62:  MOVWF  x98
....................         increment = MEMORY_PAGE_SIZE; 
0AB64:  CLRF   x9C
0AB66:  CLRF   x9B
0AB68:  MOVLW  10
0AB6A:  MOVWF  x9A
0AB6C:  CLRF   x99
....................     } else { 
0AB6E:  BRA    AB7E
....................         erase_mode = ERASE_SECTOR; 
0AB70:  MOVLW  DC
0AB72:  MOVWF  x98
....................         increment = MEMORY_SECTOR_SIZE; 
0AB74:  CLRF   x9C
0AB76:  MOVLW  01
0AB78:  MOVWF  x9B
0AB7A:  CLRF   x9A
0AB7C:  CLRF   x99
....................     } 
....................  
....................     uint32_t to_address = 0; 
....................     uint32_t from_address = 0; 
0AB7E:  CLRF   xA0
0AB80:  CLRF   x9F
0AB82:  CLRF   x9E
0AB84:  CLRF   x9D
0AB86:  CLRF   xA4
0AB88:  CLRF   xA3
0AB8A:  CLRF   xA2
0AB8C:  CLRF   xA1
....................     if (mode == 2) { 
0AB8E:  MOVF   x97,W
0AB90:  SUBLW  02
0AB92:  BNZ   ABB6
....................         to_address = to_page_or_sector_or_address; 
0AB94:  MOVFF  C8E,CA0
0AB98:  MOVFF  C8D,C9F
0AB9C:  MOVFF  C8C,C9E
0ABA0:  MOVFF  C8B,C9D
....................         from_address = from_page_or_sector_or_address; 
0ABA4:  MOVFF  C92,CA4
0ABA8:  MOVFF  C91,CA3
0ABAC:  MOVFF  C90,CA2
0ABB0:  MOVFF  C8F,CA1
....................     } else { 
0ABB4:  BRA    AC22
....................         to_address = to_page_or_sector_or_address * increment; 
0ABB6:  MOVFF  C8E,CB4
0ABBA:  MOVFF  C8D,CB3
0ABBE:  MOVFF  C8C,CB2
0ABC2:  MOVFF  C8B,CB1
0ABC6:  MOVFF  C9C,CB8
0ABCA:  MOVFF  C9B,CB7
0ABCE:  MOVFF  C9A,CB6
0ABD2:  MOVFF  C99,CB5
0ABD6:  MOVLB  0
0ABD8:  CALL   456E
0ABDC:  MOVFF  03,CA0
0ABE0:  MOVFF  02,C9F
0ABE4:  MOVFF  01,C9E
0ABE8:  MOVFF  00,C9D
....................         from_address = from_page_or_sector_or_address * increment; 
0ABEC:  MOVFF  C92,CB4
0ABF0:  MOVFF  C91,CB3
0ABF4:  MOVFF  C90,CB2
0ABF8:  MOVFF  C8F,CB1
0ABFC:  MOVFF  C9C,CB8
0AC00:  MOVFF  C9B,CB7
0AC04:  MOVFF  C9A,CB6
0AC08:  MOVFF  C99,CB5
0AC0C:  CALL   456E
0AC10:  MOVFF  03,CA4
0AC14:  MOVFF  02,CA3
0AC18:  MOVFF  01,CA2
0AC1C:  MOVFF  00,CA1
0AC20:  MOVLB  C
....................     } 
....................  
....................     size *= increment; 
0AC22:  MOVFF  C96,CB4
0AC26:  MOVFF  C95,CB3
0AC2A:  MOVFF  C94,CB2
0AC2E:  MOVFF  C93,CB1
0AC32:  MOVFF  C9C,CB8
0AC36:  MOVFF  C9B,CB7
0AC3A:  MOVFF  C9A,CB6
0AC3E:  MOVFF  C99,CB5
0AC42:  MOVLB  0
0AC44:  CALL   456E
0AC48:  MOVFF  03,C96
0AC4C:  MOVFF  02,C95
0AC50:  MOVFF  01,C94
0AC54:  MOVFF  00,C93
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX,mode=%d", origin, dest, to_address, from_address, size, mode); 
0AC58:  MOVLW  F4
0AC5A:  MOVWF  FF6
0AC5C:  MOVLW  0C
0AC5E:  MOVWF  FF7
0AC60:  MOVLW  00
0AC62:  MOVWF  FF8
0AC64:  MOVLW  0C
0AC66:  MOVLB  C
0AC68:  MOVWF  xC1
0AC6A:  MOVLB  0
0AC6C:  CALL   5290
0AC70:  MOVFF  C89,CBE
0AC74:  MOVLW  18
0AC76:  MOVLB  C
0AC78:  MOVWF  xBF
0AC7A:  MOVLB  0
0AC7C:  CALL   73A8
0AC80:  MOVLW  02
0AC82:  MOVWF  FF6
0AC84:  MOVLW  0D
0AC86:  MOVWF  FF7
0AC88:  MOVLW  00
0AC8A:  MOVWF  FF8
0AC8C:  MOVLW  06
0AC8E:  MOVLB  C
0AC90:  MOVWF  xC1
0AC92:  MOVLB  0
0AC94:  CALL   5290
0AC98:  MOVFF  C8A,CBE
0AC9C:  MOVLW  18
0AC9E:  MOVLB  C
0ACA0:  MOVWF  xBF
0ACA2:  MOVLB  0
0ACA4:  CALL   73A8
0ACA8:  MOVLW  0A
0ACAA:  MOVWF  FF6
0ACAC:  MOVLW  0D
0ACAE:  MOVWF  FF7
0ACB0:  MOVLW  00
0ACB2:  MOVWF  FF8
0ACB4:  MOVLW  09
0ACB6:  MOVLB  C
0ACB8:  MOVWF  xC1
0ACBA:  MOVLB  0
0ACBC:  CALL   5290
0ACC0:  MOVFF  CA0,CBF
0ACC4:  MOVLW  37
0ACC6:  MOVLB  C
0ACC8:  MOVWF  xC0
0ACCA:  MOVLB  0
0ACCC:  CALL   5A92
0ACD0:  MOVFF  C9F,CBF
0ACD4:  MOVLW  37
0ACD6:  MOVLB  C
0ACD8:  MOVWF  xC0
0ACDA:  MOVLB  0
0ACDC:  CALL   5A92
0ACE0:  MOVFF  C9E,CBF
0ACE4:  MOVLW  37
0ACE6:  MOVLB  C
0ACE8:  MOVWF  xC0
0ACEA:  MOVLB  0
0ACEC:  CALL   5A92
0ACF0:  MOVFF  C9D,CBF
0ACF4:  MOVLW  37
0ACF6:  MOVLB  C
0ACF8:  MOVWF  xC0
0ACFA:  MOVLB  0
0ACFC:  CALL   5A92
0AD00:  MOVLW  16
0AD02:  MOVWF  FF6
0AD04:  MOVLW  0D
0AD06:  MOVWF  FF7
0AD08:  MOVLW  00
0AD0A:  MOVWF  FF8
0AD0C:  MOVLW  0B
0AD0E:  MOVLB  C
0AD10:  MOVWF  xC1
0AD12:  MOVLB  0
0AD14:  CALL   5290
0AD18:  MOVFF  CA4,CBF
0AD1C:  MOVLW  37
0AD1E:  MOVLB  C
0AD20:  MOVWF  xC0
0AD22:  MOVLB  0
0AD24:  CALL   5A92
0AD28:  MOVFF  CA3,CBF
0AD2C:  MOVLW  37
0AD2E:  MOVLB  C
0AD30:  MOVWF  xC0
0AD32:  MOVLB  0
0AD34:  CALL   5A92
0AD38:  MOVFF  CA2,CBF
0AD3C:  MOVLW  37
0AD3E:  MOVLB  C
0AD40:  MOVWF  xC0
0AD42:  MOVLB  0
0AD44:  CALL   5A92
0AD48:  MOVFF  CA1,CBF
0AD4C:  MOVLW  37
0AD4E:  MOVLB  C
0AD50:  MOVWF  xC0
0AD52:  MOVLB  0
0AD54:  CALL   5A92
0AD58:  MOVLW  24
0AD5A:  MOVWF  FF6
0AD5C:  MOVLW  0D
0AD5E:  MOVWF  FF7
0AD60:  MOVLW  00
0AD62:  MOVWF  FF8
0AD64:  MOVLW  06
0AD66:  MOVLB  C
0AD68:  MOVWF  xC1
0AD6A:  MOVLB  0
0AD6C:  CALL   5290
0AD70:  MOVFF  C96,CBF
0AD74:  MOVLW  37
0AD76:  MOVLB  C
0AD78:  MOVWF  xC0
0AD7A:  MOVLB  0
0AD7C:  CALL   5A92
0AD80:  MOVFF  C95,CBF
0AD84:  MOVLW  37
0AD86:  MOVLB  C
0AD88:  MOVWF  xC0
0AD8A:  MOVLB  0
0AD8C:  CALL   5A92
0AD90:  MOVFF  C94,CBF
0AD94:  MOVLW  37
0AD96:  MOVLB  C
0AD98:  MOVWF  xC0
0AD9A:  MOVLB  0
0AD9C:  CALL   5A92
0ADA0:  MOVFF  C93,CBF
0ADA4:  MOVLW  37
0ADA6:  MOVLB  C
0ADA8:  MOVWF  xC0
0ADAA:  MOVLB  0
0ADAC:  CALL   5A92
0ADB0:  MOVLW  2D
0ADB2:  MOVWF  FF6
0ADB4:  MOVLW  0D
0ADB6:  MOVWF  FF7
0ADB8:  MOVLW  00
0ADBA:  MOVWF  FF8
0ADBC:  MOVLW  06
0ADBE:  MOVLB  C
0ADC0:  MOVWF  xC1
0ADC2:  MOVLB  0
0ADC4:  CALL   5290
0ADC8:  MOVFF  C97,CBE
0ADCC:  MOVLW  18
0ADCE:  MOVLB  C
0ADD0:  MOVWF  xBF
0ADD2:  MOVLB  0
0ADD4:  CALL   73A8
....................  
....................     // Erase the pages before copying 
....................     if (dest == 0x00) { 
0ADD8:  MOVLB  C
0ADDA:  MOVF   x8A,F
0ADDC:  BNZ   AE56
....................         for (uint32_t i = 0; i < size; i += increment) { 
0ADDE:  CLRF   xA8
0ADE0:  CLRF   xA7
0ADE2:  CLRF   xA6
0ADE4:  CLRF   xA5
0ADE6:  MOVF   xA8,W
0ADE8:  SUBWF  x96,W
0ADEA:  BNC   AE54
0ADEC:  BNZ   AE04
0ADEE:  MOVF   xA7,W
0ADF0:  SUBWF  x95,W
0ADF2:  BNC   AE54
0ADF4:  BNZ   AE04
0ADF6:  MOVF   xA6,W
0ADF8:  SUBWF  x94,W
0ADFA:  BNC   AE54
0ADFC:  BNZ   AE04
0ADFE:  MOVF   x93,W
0AE00:  SUBWF  xA5,W
0AE02:  BC    AE54
....................             flash_erase(&spi_port_COM_FM, to_address + i, erase_mode); 
0AE04:  MOVF   xA5,W
0AE06:  ADDWF  x9D,W
0AE08:  MOVWF  xB1
0AE0A:  MOVF   xA6,W
0AE0C:  ADDWFC x9E,W
0AE0E:  MOVWF  xB2
0AE10:  MOVF   xA7,W
0AE12:  ADDWFC x9F,W
0AE14:  MOVWF  xB3
0AE16:  MOVF   xA8,W
0AE18:  ADDWFC xA0,W
0AE1A:  MOVWF  xB4
0AE1C:  MOVLW  0A
0AE1E:  MOVLB  D
0AE20:  MOVWF  x49
0AE22:  MOVLW  A3
0AE24:  MOVWF  x48
0AE26:  MOVFF  CB4,D4D
0AE2A:  MOVFF  CB3,D4C
0AE2E:  MOVFF  CB2,D4B
0AE32:  MOVFF  CB1,D4A
0AE36:  MOVFF  C98,D4E
0AE3A:  MOVLB  0
0AE3C:  CALL   604C
0AE40:  MOVLB  C
0AE42:  MOVF   x99,W
0AE44:  ADDWF  xA5,F
0AE46:  MOVF   x9A,W
0AE48:  ADDWFC xA6,F
0AE4A:  MOVF   x9B,W
0AE4C:  ADDWFC xA7,F
0AE4E:  MOVF   x9C,W
0AE50:  ADDWFC xA8,F
0AE52:  BRA    ADE6
....................         } 
....................     } else if (dest == 0x01) { 
0AE54:  BRA    AF56
0AE56:  DECFSZ x8A,W
0AE58:  BRA    AED2
....................         for (uint32_t i = 0; i < size; i += increment) { 
0AE5A:  CLRF   xAC
0AE5C:  CLRF   xAB
0AE5E:  CLRF   xAA
0AE60:  CLRF   xA9
0AE62:  MOVF   xAC,W
0AE64:  SUBWF  x96,W
0AE66:  BNC   AED0
0AE68:  BNZ   AE80
0AE6A:  MOVF   xAB,W
0AE6C:  SUBWF  x95,W
0AE6E:  BNC   AED0
0AE70:  BNZ   AE80
0AE72:  MOVF   xAA,W
0AE74:  SUBWF  x94,W
0AE76:  BNC   AED0
0AE78:  BNZ   AE80
0AE7A:  MOVF   x93,W
0AE7C:  SUBWF  xA9,W
0AE7E:  BC    AED0
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, erase_mode); 
0AE80:  MOVF   xA9,W
0AE82:  ADDWF  x9D,W
0AE84:  MOVWF  xB1
0AE86:  MOVF   xAA,W
0AE88:  ADDWFC x9E,W
0AE8A:  MOVWF  xB2
0AE8C:  MOVF   xAB,W
0AE8E:  ADDWFC x9F,W
0AE90:  MOVWF  xB3
0AE92:  MOVF   xAC,W
0AE94:  ADDWFC xA0,W
0AE96:  MOVWF  xB4
0AE98:  MOVLW  0A
0AE9A:  MOVLB  D
0AE9C:  MOVWF  x49
0AE9E:  MOVLW  AD
0AEA0:  MOVWF  x48
0AEA2:  MOVFF  CB4,D4D
0AEA6:  MOVFF  CB3,D4C
0AEAA:  MOVFF  CB2,D4B
0AEAE:  MOVFF  CB1,D4A
0AEB2:  MOVFF  C98,D4E
0AEB6:  MOVLB  0
0AEB8:  CALL   604C
0AEBC:  MOVLB  C
0AEBE:  MOVF   x99,W
0AEC0:  ADDWF  xA9,F
0AEC2:  MOVF   x9A,W
0AEC4:  ADDWFC xAA,F
0AEC6:  MOVF   x9B,W
0AEC8:  ADDWFC xAB,F
0AECA:  MOVF   x9C,W
0AECC:  ADDWFC xAC,F
0AECE:  BRA    AE62
....................         } 
....................     } else if (dest == 0x02) { 
0AED0:  BRA    AF56
0AED2:  MOVF   x8A,W
0AED4:  SUBLW  02
0AED6:  BNZ   AF56
....................         for (uint32_t i = 0; i < size; i += increment) { 
0AED8:  CLRF   xB0
0AEDA:  CLRF   xAF
0AEDC:  CLRF   xAE
0AEDE:  CLRF   xAD
0AEE0:  MOVF   xB0,W
0AEE2:  SUBWF  x96,W
0AEE4:  BNC   AF56
0AEE6:  BNZ   AEFE
0AEE8:  MOVF   xAF,W
0AEEA:  SUBWF  x95,W
0AEEC:  BNC   AF56
0AEEE:  BNZ   AEFE
0AEF0:  MOVF   xAE,W
0AEF2:  SUBWF  x94,W
0AEF4:  BNC   AF56
0AEF6:  BNZ   AEFE
0AEF8:  MOVF   x93,W
0AEFA:  SUBWF  xAD,W
0AEFC:  BC    AF56
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
0AEFE:  BCF    F92.5
0AF00:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, erase_mode); 
0AF02:  MOVF   xAD,W
0AF04:  ADDWF  x9D,W
0AF06:  MOVWF  xB1
0AF08:  MOVF   xAE,W
0AF0A:  ADDWFC x9E,W
0AF0C:  MOVWF  xB2
0AF0E:  MOVF   xAF,W
0AF10:  ADDWFC x9F,W
0AF12:  MOVWF  xB3
0AF14:  MOVF   xB0,W
0AF16:  ADDWFC xA0,W
0AF18:  MOVWF  xB4
0AF1A:  MOVLW  0A
0AF1C:  MOVLB  D
0AF1E:  MOVWF  x49
0AF20:  MOVLW  B7
0AF22:  MOVWF  x48
0AF24:  MOVFF  CB4,D4D
0AF28:  MOVFF  CB3,D4C
0AF2C:  MOVFF  CB2,D4B
0AF30:  MOVFF  CB1,D4A
0AF34:  MOVFF  C98,D4E
0AF38:  MOVLB  0
0AF3A:  CALL   604C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
0AF3E:  BCF    F92.5
0AF40:  BSF    F89.5
0AF42:  MOVLB  C
0AF44:  MOVF   x99,W
0AF46:  ADDWF  xAD,F
0AF48:  MOVF   x9A,W
0AF4A:  ADDWFC xAE,F
0AF4C:  MOVF   x9B,W
0AF4E:  ADDWFC xAF,F
0AF50:  MOVF   x9C,W
0AF52:  ADDWFC xB0,F
0AF54:  BRA    AEE0
....................         } 
....................     } 
....................  
....................     if (origin == 0x00 && dest == 0x00) { 
0AF56:  MOVF   x89,F
0AF58:  BNZ   AFA6
0AF5A:  MOVF   x8A,F
0AF5C:  BNZ   AFA6
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address, &spi_port_COM_FM, to_address, size); 
0AF5E:  MOVLW  0A
0AF60:  MOVWF  xB2
0AF62:  MOVLW  A3
0AF64:  MOVWF  xB1
0AF66:  MOVFF  CA4,CB6
0AF6A:  MOVFF  CA3,CB5
0AF6E:  MOVFF  CA2,CB4
0AF72:  MOVFF  CA1,CB3
0AF76:  MOVLW  0A
0AF78:  MOVWF  xB8
0AF7A:  MOVLW  A3
0AF7C:  MOVWF  xB7
0AF7E:  MOVFF  CA0,CBC
0AF82:  MOVFF  C9F,CBB
0AF86:  MOVFF  C9E,CBA
0AF8A:  MOVFF  C9D,CB9
0AF8E:  MOVFF  C96,CC0
0AF92:  MOVFF  C95,CBF
0AF96:  MOVFF  C94,CBE
0AF9A:  MOVFF  C93,CBD
0AF9E:  MOVLB  0
0AFA0:  RCALL  AAAE
....................  
....................     } else if (origin == 0x00 && dest == 0x01) { 
0AFA2:  BRA    B262
0AFA4:  MOVLB  C
0AFA6:  MOVF   x89,F
0AFA8:  BNZ   AFF6
0AFAA:  DECFSZ x8A,W
0AFAC:  BRA    AFF6
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address, &spi_port_MAIN_FM, to_address, size); 
0AFAE:  MOVLW  0A
0AFB0:  MOVWF  xB2
0AFB2:  MOVLW  A3
0AFB4:  MOVWF  xB1
0AFB6:  MOVFF  CA4,CB6
0AFBA:  MOVFF  CA3,CB5
0AFBE:  MOVFF  CA2,CB4
0AFC2:  MOVFF  CA1,CB3
0AFC6:  MOVLW  0A
0AFC8:  MOVWF  xB8
0AFCA:  MOVLW  AD
0AFCC:  MOVWF  xB7
0AFCE:  MOVFF  CA0,CBC
0AFD2:  MOVFF  C9F,CBB
0AFD6:  MOVFF  C9E,CBA
0AFDA:  MOVFF  C9D,CB9
0AFDE:  MOVFF  C96,CC0
0AFE2:  MOVFF  C95,CBF
0AFE6:  MOVFF  C94,CBE
0AFEA:  MOVFF  C93,CBD
0AFEE:  MOVLB  0
0AFF0:  RCALL  AAAE
....................  
....................     } else if (origin == 0x00 && dest == 0x02) { 
0AFF2:  BRA    B262
0AFF4:  MOVLB  C
0AFF6:  MOVF   x89,F
0AFF8:  BNZ   B050
0AFFA:  MOVF   x8A,W
0AFFC:  SUBLW  02
0AFFE:  BNZ   B050
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0B000:  BCF    F92.5
0B002:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address, &spi_port_MISSION_FM, to_address, size); 
0B004:  MOVLW  0A
0B006:  MOVWF  xB2
0B008:  MOVLW  A3
0B00A:  MOVWF  xB1
0B00C:  MOVFF  CA4,CB6
0B010:  MOVFF  CA3,CB5
0B014:  MOVFF  CA2,CB4
0B018:  MOVFF  CA1,CB3
0B01C:  MOVLW  0A
0B01E:  MOVWF  xB8
0B020:  MOVLW  B7
0B022:  MOVWF  xB7
0B024:  MOVFF  CA0,CBC
0B028:  MOVFF  C9F,CBB
0B02C:  MOVFF  C9E,CBA
0B030:  MOVFF  C9D,CB9
0B034:  MOVFF  C96,CC0
0B038:  MOVFF  C95,CBF
0B03C:  MOVFF  C94,CBE
0B040:  MOVFF  C93,CBD
0B044:  MOVLB  0
0B046:  RCALL  AAAE
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0B048:  BCF    F92.5
0B04A:  BSF    F89.5
....................  
....................     } else if (origin == 0x01 && dest == 0x00) { 
0B04C:  BRA    B262
0B04E:  MOVLB  C
0B050:  DECFSZ x89,W
0B052:  BRA    B0A0
0B054:  MOVF   x8A,F
0B056:  BNZ   B0A0
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address, &spi_port_COM_FM, to_address, size); 
0B058:  MOVLW  0A
0B05A:  MOVWF  xB2
0B05C:  MOVLW  AD
0B05E:  MOVWF  xB1
0B060:  MOVFF  CA4,CB6
0B064:  MOVFF  CA3,CB5
0B068:  MOVFF  CA2,CB4
0B06C:  MOVFF  CA1,CB3
0B070:  MOVLW  0A
0B072:  MOVWF  xB8
0B074:  MOVLW  A3
0B076:  MOVWF  xB7
0B078:  MOVFF  CA0,CBC
0B07C:  MOVFF  C9F,CBB
0B080:  MOVFF  C9E,CBA
0B084:  MOVFF  C9D,CB9
0B088:  MOVFF  C96,CC0
0B08C:  MOVFF  C95,CBF
0B090:  MOVFF  C94,CBE
0B094:  MOVFF  C93,CBD
0B098:  MOVLB  0
0B09A:  RCALL  AAAE
....................  
....................     } else if (origin == 0x01 && dest == 0x01) { 
0B09C:  BRA    B262
0B09E:  MOVLB  C
0B0A0:  DECFSZ x89,W
0B0A2:  BRA    B0F0
0B0A4:  DECFSZ x8A,W
0B0A6:  BRA    B0F0
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address, &spi_port_MAIN_FM, to_address, size); 
0B0A8:  MOVLW  0A
0B0AA:  MOVWF  xB2
0B0AC:  MOVLW  AD
0B0AE:  MOVWF  xB1
0B0B0:  MOVFF  CA4,CB6
0B0B4:  MOVFF  CA3,CB5
0B0B8:  MOVFF  CA2,CB4
0B0BC:  MOVFF  CA1,CB3
0B0C0:  MOVLW  0A
0B0C2:  MOVWF  xB8
0B0C4:  MOVLW  AD
0B0C6:  MOVWF  xB7
0B0C8:  MOVFF  CA0,CBC
0B0CC:  MOVFF  C9F,CBB
0B0D0:  MOVFF  C9E,CBA
0B0D4:  MOVFF  C9D,CB9
0B0D8:  MOVFF  C96,CC0
0B0DC:  MOVFF  C95,CBF
0B0E0:  MOVFF  C94,CBE
0B0E4:  MOVFF  C93,CBD
0B0E8:  MOVLB  0
0B0EA:  RCALL  AAAE
....................  
....................     } else if (origin == 0x01 && dest == 0x02) { 
0B0EC:  BRA    B262
0B0EE:  MOVLB  C
0B0F0:  DECFSZ x89,W
0B0F2:  BRA    B14A
0B0F4:  MOVF   x8A,W
0B0F6:  SUBLW  02
0B0F8:  BNZ   B14A
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0B0FA:  BCF    F92.5
0B0FC:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address, &spi_port_MISSION_FM, to_address, size); 
0B0FE:  MOVLW  0A
0B100:  MOVWF  xB2
0B102:  MOVLW  AD
0B104:  MOVWF  xB1
0B106:  MOVFF  CA4,CB6
0B10A:  MOVFF  CA3,CB5
0B10E:  MOVFF  CA2,CB4
0B112:  MOVFF  CA1,CB3
0B116:  MOVLW  0A
0B118:  MOVWF  xB8
0B11A:  MOVLW  B7
0B11C:  MOVWF  xB7
0B11E:  MOVFF  CA0,CBC
0B122:  MOVFF  C9F,CBB
0B126:  MOVFF  C9E,CBA
0B12A:  MOVFF  C9D,CB9
0B12E:  MOVFF  C96,CC0
0B132:  MOVFF  C95,CBF
0B136:  MOVFF  C94,CBE
0B13A:  MOVFF  C93,CBD
0B13E:  MOVLB  0
0B140:  RCALL  AAAE
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0B142:  BCF    F92.5
0B144:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x00) { 
0B146:  BRA    B262
0B148:  MOVLB  C
0B14A:  MOVF   x89,W
0B14C:  SUBLW  02
0B14E:  BNZ   B1A4
0B150:  MOVF   x8A,F
0B152:  BNZ   B1A4
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0B154:  BCF    F92.5
0B156:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address, &spi_port_COM_FM, to_address, size); 
0B158:  MOVLW  0A
0B15A:  MOVWF  xB2
0B15C:  MOVLW  B7
0B15E:  MOVWF  xB1
0B160:  MOVFF  CA4,CB6
0B164:  MOVFF  CA3,CB5
0B168:  MOVFF  CA2,CB4
0B16C:  MOVFF  CA1,CB3
0B170:  MOVLW  0A
0B172:  MOVWF  xB8
0B174:  MOVLW  A3
0B176:  MOVWF  xB7
0B178:  MOVFF  CA0,CBC
0B17C:  MOVFF  C9F,CBB
0B180:  MOVFF  C9E,CBA
0B184:  MOVFF  C9D,CB9
0B188:  MOVFF  C96,CC0
0B18C:  MOVFF  C95,CBF
0B190:  MOVFF  C94,CBE
0B194:  MOVFF  C93,CBD
0B198:  MOVLB  0
0B19A:  RCALL  AAAE
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0B19C:  BCF    F92.5
0B19E:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x01) { 
0B1A0:  BRA    B262
0B1A2:  MOVLB  C
0B1A4:  MOVF   x89,W
0B1A6:  SUBLW  02
0B1A8:  BNZ   B1FE
0B1AA:  DECFSZ x8A,W
0B1AC:  BRA    B1FE
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0B1AE:  BCF    F92.5
0B1B0:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address, &spi_port_MAIN_FM, to_address, size); 
0B1B2:  MOVLW  0A
0B1B4:  MOVWF  xB2
0B1B6:  MOVLW  B7
0B1B8:  MOVWF  xB1
0B1BA:  MOVFF  CA4,CB6
0B1BE:  MOVFF  CA3,CB5
0B1C2:  MOVFF  CA2,CB4
0B1C6:  MOVFF  CA1,CB3
0B1CA:  MOVLW  0A
0B1CC:  MOVWF  xB8
0B1CE:  MOVLW  AD
0B1D0:  MOVWF  xB7
0B1D2:  MOVFF  CA0,CBC
0B1D6:  MOVFF  C9F,CBB
0B1DA:  MOVFF  C9E,CBA
0B1DE:  MOVFF  C9D,CB9
0B1E2:  MOVFF  C96,CC0
0B1E6:  MOVFF  C95,CBF
0B1EA:  MOVFF  C94,CBE
0B1EE:  MOVFF  C93,CBD
0B1F2:  MOVLB  0
0B1F4:  RCALL  AAAE
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0B1F6:  BCF    F92.5
0B1F8:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x02) { 
0B1FA:  BRA    B262
0B1FC:  MOVLB  C
0B1FE:  MOVF   x89,W
0B200:  SUBLW  02
0B202:  BNZ   B25A
0B204:  MOVF   x8A,W
0B206:  SUBLW  02
0B208:  BNZ   B25A
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0B20A:  BCF    F92.5
0B20C:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address, &spi_port_MISSION_FM, to_address, size); 
0B20E:  MOVLW  0A
0B210:  MOVWF  xB2
0B212:  MOVLW  B7
0B214:  MOVWF  xB1
0B216:  MOVFF  CA4,CB6
0B21A:  MOVFF  CA3,CB5
0B21E:  MOVFF  CA2,CB4
0B222:  MOVFF  CA1,CB3
0B226:  MOVLW  0A
0B228:  MOVWF  xB8
0B22A:  MOVLW  B7
0B22C:  MOVWF  xB7
0B22E:  MOVFF  CA0,CBC
0B232:  MOVFF  C9F,CBB
0B236:  MOVFF  C9E,CBA
0B23A:  MOVFF  C9D,CB9
0B23E:  MOVFF  C96,CC0
0B242:  MOVFF  C95,CBF
0B246:  MOVFF  C94,CBE
0B24A:  MOVFF  C93,CBD
0B24E:  MOVLB  0
0B250:  RCALL  AAAE
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0B252:  BCF    F92.5
0B254:  BSF    F89.5
....................  
....................     } else { 
0B256:  BRA    B262
0B258:  MOVLB  C
....................         return 1; 
0B25A:  MOVLW  01
0B25C:  MOVWF  01
0B25E:  BRA    B268
0B260:  MOVLB  0
....................     } 
....................  
....................     return 0; 
0B262:  MOVLW  00
0B264:  MOVWF  01
0B266:  MOVLB  C
0B268:  MOVLB  0
0B26A:  RETURN 0
.................... } 
....................  
.................... // Copy data sectors between flash memories 
.................... uint8_t command_copy_memory_sector(uint8_t* data) 
*
0B2F0:  MOVFF  C39,C3B
0B2F4:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     return copy(packet->origin_port, packet->destination_port, packet->destination_sector, packet->source_sector, packet->n_sectors, 1); // 1 -> sector copy 
0B2F8:  MOVLW  09
0B2FA:  MOVLB  C
0B2FC:  ADDWF  x3A,W
0B2FE:  MOVWF  FE9
0B300:  MOVLW  00
0B302:  ADDWFC x3B,W
0B304:  MOVWF  FEA
0B306:  MOVFF  FEF,C89
0B30A:  MOVLW  08
0B30C:  ADDWF  x3A,W
0B30E:  MOVWF  FE9
0B310:  MOVLW  00
0B312:  ADDWFC x3B,W
0B314:  MOVWF  FEA
0B316:  MOVFF  FEF,C8A
0B31A:  MOVLW  02
0B31C:  ADDWF  x3A,W
0B31E:  MOVWF  FE9
0B320:  MOVLW  00
0B322:  ADDWFC x3B,W
0B324:  MOVWF  FEA
0B326:  MOVFF  FEC,C8C
0B32A:  MOVF   FED,F
0B32C:  MOVFF  FEF,C8B
0B330:  MOVLW  04
0B332:  ADDWF  x3A,W
0B334:  MOVWF  FE9
0B336:  MOVLW  00
0B338:  ADDWFC x3B,W
0B33A:  MOVWF  FEA
0B33C:  MOVFF  FEC,C90
0B340:  MOVF   FED,F
0B342:  MOVFF  FEF,C8F
0B346:  MOVLW  06
0B348:  ADDWF  x3A,W
0B34A:  MOVWF  FE9
0B34C:  MOVLW  00
0B34E:  ADDWFC x3B,W
0B350:  MOVWF  FEA
0B352:  MOVFF  FEC,C94
0B356:  MOVF   FED,F
0B358:  MOVFF  FEF,C93
0B35C:  CLRF   x8E
0B35E:  CLRF   x8D
0B360:  CLRF   x92
0B362:  CLRF   x91
0B364:  CLRF   x96
0B366:  CLRF   x95
0B368:  MOVLW  01
0B36A:  MOVWF  x97
0B36C:  MOVLB  0
0B36E:  CALL   AB50
0B372:  MOVF   01,W
0B374:  GOTO   188F6 (RETURN)
.................... } 
....................  
.................... // Copy data pages between flash memories 
.................... uint8_t command_copy_memory_page(uint8_t* data) 
*
0B26C:  MOVFF  C39,C3B
0B270:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t source_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     return copy(packet->origin_port, packet->destination_port, packet->destination_page, packet->source_page, packet->n_pages, 0); // 0 -> page copy 
0B274:  MOVLW  09
0B276:  MOVLB  C
0B278:  ADDWF  x3A,W
0B27A:  MOVWF  FE9
0B27C:  MOVLW  00
0B27E:  ADDWFC x3B,W
0B280:  MOVWF  FEA
0B282:  MOVFF  FEF,C89
0B286:  MOVLW  08
0B288:  ADDWF  x3A,W
0B28A:  MOVWF  FE9
0B28C:  MOVLW  00
0B28E:  ADDWFC x3B,W
0B290:  MOVWF  FEA
0B292:  MOVFF  FEF,C8A
0B296:  MOVLW  02
0B298:  ADDWF  x3A,W
0B29A:  MOVWF  FE9
0B29C:  MOVLW  00
0B29E:  ADDWFC x3B,W
0B2A0:  MOVWF  FEA
0B2A2:  MOVFF  FEC,C8C
0B2A6:  MOVF   FED,F
0B2A8:  MOVFF  FEF,C8B
0B2AC:  MOVLW  04
0B2AE:  ADDWF  x3A,W
0B2B0:  MOVWF  FE9
0B2B2:  MOVLW  00
0B2B4:  ADDWFC x3B,W
0B2B6:  MOVWF  FEA
0B2B8:  MOVFF  FEC,C90
0B2BC:  MOVF   FED,F
0B2BE:  MOVFF  FEF,C8F
0B2C2:  MOVLW  06
0B2C4:  ADDWF  x3A,W
0B2C6:  MOVWF  FE9
0B2C8:  MOVLW  00
0B2CA:  ADDWFC x3B,W
0B2CC:  MOVWF  FEA
0B2CE:  MOVFF  FEC,C94
0B2D2:  MOVF   FED,F
0B2D4:  MOVFF  FEF,C93
0B2D8:  CLRF   x8E
0B2DA:  CLRF   x8D
0B2DC:  CLRF   x92
0B2DE:  CLRF   x91
0B2E0:  CLRF   x96
0B2E2:  CLRF   x95
0B2E4:  CLRF   x97
0B2E6:  MOVLB  0
0B2E8:  RCALL  AB50
0B2EA:  MOVF   01,W
0B2EC:  GOTO   188E4 (RETURN)
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_page(uint8_t* data) 
*
0B378:  MOVFF  C39,C3B
0B37C:  MOVFF  C38,C3A
0B380:  MOVLW  06
0B382:  MOVLB  C
0B384:  ADDWF  x3A,W
0B386:  MOVWF  FE9
0B388:  MOVLW  00
0B38A:  ADDWFC x3B,W
0B38C:  MOVWF  FEA
0B38E:  MOVFF  FEF,C3C
0B392:  MOVLW  02
0B394:  ADDWF  x3A,W
0B396:  MOVWF  FE9
0B398:  MOVLW  00
0B39A:  ADDWFC x3B,W
0B39C:  MOVWF  FEA
0B39E:  MOVFF  FEC,C52
0B3A2:  MOVF   FED,F
0B3A4:  MOVFF  FEF,C51
0B3A8:  CLRF   x53
0B3AA:  CLRF   x54
0B3AC:  CLRF   x3D
0B3AE:  RLCF   x51,W
0B3B0:  MOVWF  x3E
0B3B2:  RLCF   x52,W
0B3B4:  MOVWF  x3F
0B3B6:  RLCF   x53,W
0B3B8:  MOVWF  x40
0B3BA:  RLCF   x3E,F
0B3BC:  RLCF   x3F,F
0B3BE:  RLCF   x40,F
0B3C0:  RLCF   x3E,F
0B3C2:  RLCF   x3F,F
0B3C4:  RLCF   x40,F
0B3C6:  RLCF   x3E,F
0B3C8:  RLCF   x3F,F
0B3CA:  RLCF   x40,F
0B3CC:  MOVLW  F0
0B3CE:  ANDWF  x3E,F
0B3D0:  MOVLW  04
0B3D2:  ADDWF  x3A,W
0B3D4:  MOVWF  FE9
0B3D6:  MOVLW  00
0B3D8:  ADDWFC x3B,W
0B3DA:  MOVWF  FEA
0B3DC:  MOVFF  FEC,03
0B3E0:  MOVF   FED,F
0B3E2:  MOVFF  FEF,C51
0B3E6:  CLRF   x53
0B3E8:  CLRF   x41
0B3EA:  RLCF   x51,W
0B3EC:  MOVWF  x42
0B3EE:  RLCF   03,W
0B3F0:  MOVWF  x43
0B3F2:  RLCF   x53,W
0B3F4:  MOVWF  x44
0B3F6:  RLCF   x42,F
0B3F8:  RLCF   x43,F
0B3FA:  RLCF   x44,F
0B3FC:  RLCF   x42,F
0B3FE:  RLCF   x43,F
0B400:  RLCF   x44,F
0B402:  RLCF   x42,F
0B404:  RLCF   x43,F
0B406:  RLCF   x44,F
0B408:  MOVLW  F0
0B40A:  ANDWF  x42,F
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_page * MEMORY_PAGE_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_pages * MEMORY_PAGE_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
0B40C:  MOVLB  0
0B40E:  CALL   8672
....................  
....................     if (dest == 0x00) { 
0B412:  MOVLB  C
0B414:  MOVF   x3C,F
0B416:  BNZ   B48A
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
0B418:  CLRF   x48
0B41A:  CLRF   x47
0B41C:  CLRF   x46
0B41E:  CLRF   x45
0B420:  MOVF   x48,W
0B422:  SUBWF  x44,W
0B424:  BNC   B488
0B426:  BNZ   B43E
0B428:  MOVF   x47,W
0B42A:  SUBWF  x43,W
0B42C:  BNC   B488
0B42E:  BNZ   B43E
0B430:  MOVF   x46,W
0B432:  SUBWF  x42,W
0B434:  BNC   B488
0B436:  BNZ   B43E
0B438:  MOVF   x41,W
0B43A:  SUBWF  x45,W
0B43C:  BC    B488
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_PAGE); 
0B43E:  MOVF   x45,W
0B440:  ADDWF  x3D,W
0B442:  MOVWF  x51
0B444:  MOVF   x46,W
0B446:  ADDWFC x3E,W
0B448:  MOVWF  x52
0B44A:  MOVF   x47,W
0B44C:  ADDWFC x3F,W
0B44E:  MOVWF  x53
0B450:  MOVF   x48,W
0B452:  ADDWFC x40,W
0B454:  MOVWF  x54
0B456:  MOVLW  0A
0B458:  MOVLB  D
0B45A:  MOVWF  x49
0B45C:  MOVLW  A3
0B45E:  MOVWF  x48
0B460:  MOVFF  C54,D4D
0B464:  MOVFF  C53,D4C
0B468:  MOVFF  C52,D4B
0B46C:  MOVFF  C51,D4A
0B470:  MOVLW  21
0B472:  MOVWF  x4E
0B474:  MOVLB  0
0B476:  CALL   604C
0B47A:  MOVLW  10
0B47C:  MOVLB  C
0B47E:  ADDWF  x46,F
0B480:  MOVLW  00
0B482:  ADDWFC x47,F
0B484:  ADDWFC x48,F
0B486:  BRA    B420
....................         } 
....................     } else if (dest == 0x01) { 
0B488:  BRA    B57E
0B48A:  DECFSZ x3C,W
0B48C:  BRA    B500
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
0B48E:  CLRF   x4C
0B490:  CLRF   x4B
0B492:  CLRF   x4A
0B494:  CLRF   x49
0B496:  MOVF   x4C,W
0B498:  SUBWF  x44,W
0B49A:  BNC   B4FE
0B49C:  BNZ   B4B4
0B49E:  MOVF   x4B,W
0B4A0:  SUBWF  x43,W
0B4A2:  BNC   B4FE
0B4A4:  BNZ   B4B4
0B4A6:  MOVF   x4A,W
0B4A8:  SUBWF  x42,W
0B4AA:  BNC   B4FE
0B4AC:  BNZ   B4B4
0B4AE:  MOVF   x41,W
0B4B0:  SUBWF  x49,W
0B4B2:  BC    B4FE
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_PAGE); 
0B4B4:  MOVF   x49,W
0B4B6:  ADDWF  x3D,W
0B4B8:  MOVWF  x51
0B4BA:  MOVF   x4A,W
0B4BC:  ADDWFC x3E,W
0B4BE:  MOVWF  x52
0B4C0:  MOVF   x4B,W
0B4C2:  ADDWFC x3F,W
0B4C4:  MOVWF  x53
0B4C6:  MOVF   x4C,W
0B4C8:  ADDWFC x40,W
0B4CA:  MOVWF  x54
0B4CC:  MOVLW  0A
0B4CE:  MOVLB  D
0B4D0:  MOVWF  x49
0B4D2:  MOVLW  AD
0B4D4:  MOVWF  x48
0B4D6:  MOVFF  C54,D4D
0B4DA:  MOVFF  C53,D4C
0B4DE:  MOVFF  C52,D4B
0B4E2:  MOVFF  C51,D4A
0B4E6:  MOVLW  21
0B4E8:  MOVWF  x4E
0B4EA:  MOVLB  0
0B4EC:  CALL   604C
0B4F0:  MOVLW  10
0B4F2:  MOVLB  C
0B4F4:  ADDWF  x4A,F
0B4F6:  MOVLW  00
0B4F8:  ADDWFC x4B,F
0B4FA:  ADDWFC x4C,F
0B4FC:  BRA    B496
....................         } 
....................     } else if (dest == 0x02) { 
0B4FE:  BRA    B57E
0B500:  MOVF   x3C,W
0B502:  SUBLW  02
0B504:  BNZ   B57E
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
0B506:  CLRF   x50
0B508:  CLRF   x4F
0B50A:  CLRF   x4E
0B50C:  CLRF   x4D
0B50E:  MOVF   x50,W
0B510:  SUBWF  x44,W
0B512:  BNC   B57E
0B514:  BNZ   B52C
0B516:  MOVF   x4F,W
0B518:  SUBWF  x43,W
0B51A:  BNC   B57E
0B51C:  BNZ   B52C
0B51E:  MOVF   x4E,W
0B520:  SUBWF  x42,W
0B522:  BNC   B57E
0B524:  BNZ   B52C
0B526:  MOVF   x41,W
0B528:  SUBWF  x4D,W
0B52A:  BC    B57E
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
0B52C:  BCF    F92.5
0B52E:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_PAGE); 
0B530:  MOVF   x4D,W
0B532:  ADDWF  x3D,W
0B534:  MOVWF  x51
0B536:  MOVF   x4E,W
0B538:  ADDWFC x3E,W
0B53A:  MOVWF  x52
0B53C:  MOVF   x4F,W
0B53E:  ADDWFC x3F,W
0B540:  MOVWF  x53
0B542:  MOVF   x50,W
0B544:  ADDWFC x40,W
0B546:  MOVWF  x54
0B548:  MOVLW  0A
0B54A:  MOVLB  D
0B54C:  MOVWF  x49
0B54E:  MOVLW  B7
0B550:  MOVWF  x48
0B552:  MOVFF  C54,D4D
0B556:  MOVFF  C53,D4C
0B55A:  MOVFF  C52,D4B
0B55E:  MOVFF  C51,D4A
0B562:  MOVLW  21
0B564:  MOVWF  x4E
0B566:  MOVLB  0
0B568:  CALL   604C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
0B56C:  BCF    F92.5
0B56E:  BSF    F89.5
0B570:  MOVLW  10
0B572:  MOVLB  C
0B574:  ADDWF  x4E,F
0B576:  MOVLW  00
0B578:  ADDWFC x4F,F
0B57A:  ADDWFC x50,F
0B57C:  BRA    B50E
....................         } 
....................     } 
....................  
....................     return 0; 
0B57E:  MOVLW  00
0B580:  MOVWF  01
0B582:  MOVLB  0
0B584:  GOTO   18908 (RETURN)
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_sector(uint8_t* data) 
0B588:  MOVFF  C39,C3B
0B58C:  MOVFF  C38,C3A
0B590:  MOVLW  06
0B592:  MOVLB  C
0B594:  ADDWF  x3A,W
0B596:  MOVWF  FE9
0B598:  MOVLW  00
0B59A:  ADDWFC x3B,W
0B59C:  MOVWF  FEA
0B59E:  MOVFF  FEF,C3C
0B5A2:  MOVLW  02
0B5A4:  ADDWF  x3A,W
0B5A6:  MOVWF  FE9
0B5A8:  MOVLW  00
0B5AA:  ADDWFC x3B,W
0B5AC:  MOVWF  FEA
0B5AE:  MOVFF  FEC,03
0B5B2:  MOVF   FED,F
0B5B4:  MOVFF  FEF,C3F
0B5B8:  MOVFF  03,C52
0B5BC:  CLRF   x53
0B5BE:  CLRF   x54
0B5C0:  MOVFF  03,C40
0B5C4:  CLRF   x3D
0B5C6:  CLRF   x3E
0B5C8:  MOVLW  04
0B5CA:  ADDWF  x3A,W
0B5CC:  MOVWF  FE9
0B5CE:  MOVLW  00
0B5D0:  ADDWFC x3B,W
0B5D2:  MOVWF  FEA
0B5D4:  MOVFF  FEC,C44
0B5D8:  MOVF   FED,F
0B5DA:  MOVFF  FEF,C43
0B5DE:  CLRF   x41
0B5E0:  CLRF   x42
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_sectors * MEMORY_SECTOR_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
0B5E2:  MOVLB  0
0B5E4:  CALL   8672
....................  
....................     if (dest == 0x00) { 
0B5E8:  MOVLB  C
0B5EA:  MOVF   x3C,F
0B5EC:  BNZ   B65E
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
0B5EE:  CLRF   x48
0B5F0:  CLRF   x47
0B5F2:  CLRF   x46
0B5F4:  CLRF   x45
0B5F6:  MOVF   x48,W
0B5F8:  SUBWF  x44,W
0B5FA:  BNC   B65C
0B5FC:  BNZ   B614
0B5FE:  MOVF   x47,W
0B600:  SUBWF  x43,W
0B602:  BNC   B65C
0B604:  BNZ   B614
0B606:  MOVF   x46,W
0B608:  SUBWF  x42,W
0B60A:  BNC   B65C
0B60C:  BNZ   B614
0B60E:  MOVF   x41,W
0B610:  SUBWF  x45,W
0B612:  BC    B65C
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_SECTOR); 
0B614:  MOVF   x45,W
0B616:  ADDWF  x3D,W
0B618:  MOVWF  x51
0B61A:  MOVF   x46,W
0B61C:  ADDWFC x3E,W
0B61E:  MOVWF  x52
0B620:  MOVF   x47,W
0B622:  ADDWFC x3F,W
0B624:  MOVWF  x53
0B626:  MOVF   x48,W
0B628:  ADDWFC x40,W
0B62A:  MOVWF  x54
0B62C:  MOVLW  0A
0B62E:  MOVLB  D
0B630:  MOVWF  x49
0B632:  MOVLW  A3
0B634:  MOVWF  x48
0B636:  MOVFF  C54,D4D
0B63A:  MOVFF  C53,D4C
0B63E:  MOVFF  C52,D4B
0B642:  MOVFF  C51,D4A
0B646:  MOVLW  DC
0B648:  MOVWF  x4E
0B64A:  MOVLB  0
0B64C:  CALL   604C
0B650:  MOVLW  01
0B652:  MOVLB  C
0B654:  ADDWF  x47,F
0B656:  MOVLW  00
0B658:  ADDWFC x48,F
0B65A:  BRA    B5F6
....................         } 
....................     } else if (dest == 0x01) { 
0B65C:  BRA    B74E
0B65E:  DECFSZ x3C,W
0B660:  BRA    B6D2
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
0B662:  CLRF   x4C
0B664:  CLRF   x4B
0B666:  CLRF   x4A
0B668:  CLRF   x49
0B66A:  MOVF   x4C,W
0B66C:  SUBWF  x44,W
0B66E:  BNC   B6D0
0B670:  BNZ   B688
0B672:  MOVF   x4B,W
0B674:  SUBWF  x43,W
0B676:  BNC   B6D0
0B678:  BNZ   B688
0B67A:  MOVF   x4A,W
0B67C:  SUBWF  x42,W
0B67E:  BNC   B6D0
0B680:  BNZ   B688
0B682:  MOVF   x41,W
0B684:  SUBWF  x49,W
0B686:  BC    B6D0
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_SECTOR); 
0B688:  MOVF   x49,W
0B68A:  ADDWF  x3D,W
0B68C:  MOVWF  x51
0B68E:  MOVF   x4A,W
0B690:  ADDWFC x3E,W
0B692:  MOVWF  x52
0B694:  MOVF   x4B,W
0B696:  ADDWFC x3F,W
0B698:  MOVWF  x53
0B69A:  MOVF   x4C,W
0B69C:  ADDWFC x40,W
0B69E:  MOVWF  x54
0B6A0:  MOVLW  0A
0B6A2:  MOVLB  D
0B6A4:  MOVWF  x49
0B6A6:  MOVLW  AD
0B6A8:  MOVWF  x48
0B6AA:  MOVFF  C54,D4D
0B6AE:  MOVFF  C53,D4C
0B6B2:  MOVFF  C52,D4B
0B6B6:  MOVFF  C51,D4A
0B6BA:  MOVLW  DC
0B6BC:  MOVWF  x4E
0B6BE:  MOVLB  0
0B6C0:  CALL   604C
0B6C4:  MOVLW  01
0B6C6:  MOVLB  C
0B6C8:  ADDWF  x4B,F
0B6CA:  MOVLW  00
0B6CC:  ADDWFC x4C,F
0B6CE:  BRA    B66A
....................         } 
....................     } else if (dest == 0x02) { 
0B6D0:  BRA    B74E
0B6D2:  MOVF   x3C,W
0B6D4:  SUBLW  02
0B6D6:  BNZ   B74E
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
0B6D8:  CLRF   x50
0B6DA:  CLRF   x4F
0B6DC:  CLRF   x4E
0B6DE:  CLRF   x4D
0B6E0:  MOVF   x50,W
0B6E2:  SUBWF  x44,W
0B6E4:  BNC   B74E
0B6E6:  BNZ   B6FE
0B6E8:  MOVF   x4F,W
0B6EA:  SUBWF  x43,W
0B6EC:  BNC   B74E
0B6EE:  BNZ   B6FE
0B6F0:  MOVF   x4E,W
0B6F2:  SUBWF  x42,W
0B6F4:  BNC   B74E
0B6F6:  BNZ   B6FE
0B6F8:  MOVF   x41,W
0B6FA:  SUBWF  x4D,W
0B6FC:  BC    B74E
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
0B6FE:  BCF    F92.5
0B700:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_SECTOR); 
0B702:  MOVF   x4D,W
0B704:  ADDWF  x3D,W
0B706:  MOVWF  x51
0B708:  MOVF   x4E,W
0B70A:  ADDWFC x3E,W
0B70C:  MOVWF  x52
0B70E:  MOVF   x4F,W
0B710:  ADDWFC x3F,W
0B712:  MOVWF  x53
0B714:  MOVF   x50,W
0B716:  ADDWFC x40,W
0B718:  MOVWF  x54
0B71A:  MOVLW  0A
0B71C:  MOVLB  D
0B71E:  MOVWF  x49
0B720:  MOVLW  B7
0B722:  MOVWF  x48
0B724:  MOVFF  C54,D4D
0B728:  MOVFF  C53,D4C
0B72C:  MOVFF  C52,D4B
0B730:  MOVFF  C51,D4A
0B734:  MOVLW  DC
0B736:  MOVWF  x4E
0B738:  MOVLB  0
0B73A:  CALL   604C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
0B73E:  BCF    F92.5
0B740:  BSF    F89.5
0B742:  MOVLW  01
0B744:  MOVLB  C
0B746:  ADDWF  x4F,F
0B748:  MOVLW  00
0B74A:  ADDWFC x50,F
0B74C:  BRA    B6E0
....................         } 
....................     } 
....................  
....................     return 0; 
0B74E:  MOVLW  00
0B750:  MOVWF  01
0B752:  MOVLB  0
0B754:  GOTO   1891A (RETURN)
.................... } 
....................  
.................... uint8_t xmodem_send_fn( 
....................     uint32_t source_address, 
....................     uint32_t n_packets, 
....................     uint8_t source, 
....................     uint8_t destination, 
....................     uint32_t destination_address) 
.................... { 
....................     fprintf(PC, "Waiting for xmodem transfer..."); 
*
0A63E:  MOVLW  36
0A640:  MOVWF  FF6
0A642:  MOVLW  0D
0A644:  MOVWF  FF7
0A646:  MOVLW  00
0A648:  MOVWF  FF8
0A64A:  CALL   4534
....................     uart_fn* destination_uart = NULL; 
....................  
....................     const uint8_t max_tries = 5; 
....................     uint8_t current_try = 0; 
....................     int8_t error = 0; 
0A64E:  MOVLB  C
0A650:  CLRF   x59
0A652:  CLRF   x58
0A654:  CLRF   x5A
0A656:  CLRF   x5B
....................  
....................     while (current_try < max_tries) { 
0A658:  MOVF   x5A,W
0A65A:  SUBLW  04
0A65C:  BTFSS  FD8.0
0A65E:  BRA    A98E
....................         switch (destination) { 
0A660:  MOVF   x53,W
0A662:  XORLW  00
0A664:  MOVLB  0
0A666:  BZ    A672
0A668:  XORLW  01
0A66A:  BZ    A67E
0A66C:  XORLW  03
0A66E:  BZ    A6BE
0A670:  BRA    A6FE
....................         case 0: 
....................             destination_uart = &uart_port_PC; 
0A672:  MOVLW  0A
0A674:  MOVLB  C
0A676:  MOVWF  x59
0A678:  MOVLW  67
0A67A:  MOVWF  x58
....................             break; // For PC 
0A67C:  BRA    A708
....................         case 1: 
....................             if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
0A67E:  MOVLW  06
0A680:  MOVLB  C
0A682:  MOVWF  xBE
0A684:  MOVLB  0
0A686:  CALL   52E8
0A68A:  MOVF   01,W
0A68C:  SUBLW  06
0A68E:  BZ    A6B2
....................                 if (verbose) { 
0A690:  MOVLB  5
0A692:  MOVF   x5A,F
0A694:  BZ    A6AA
....................                     fprintf(PC, "MUX change failed!"); 
0A696:  MOVLW  56
0A698:  MOVWF  FF6
0A69A:  MOVLW  0D
0A69C:  MOVWF  FF7
0A69E:  MOVLW  00
0A6A0:  MOVWF  FF8
0A6A2:  MOVLB  0
0A6A4:  CALL   4534
0A6A8:  MOVLB  5
....................                 } 
....................                 return 1; 
0A6AA:  MOVLW  01
0A6AC:  MOVWF  01
0A6AE:  BRA    A994
0A6B0:  MOVLB  0
....................             } 
....................             destination_uart = &uart_port_MSN; 
0A6B2:  MOVLW  0A
0A6B4:  MOVLB  C
0A6B6:  MOVWF  x59
0A6B8:  MOVLW  97
0A6BA:  MOVWF  x58
....................             break; // For PCIB 
0A6BC:  BRA    A708
....................         case 2: 
....................             if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
0A6BE:  MOVLW  06
0A6C0:  MOVLB  C
0A6C2:  MOVWF  xBE
0A6C4:  MOVLB  0
0A6C6:  CALL   52E8
0A6CA:  MOVF   01,W
0A6CC:  SUBLW  06
0A6CE:  BZ    A6F2
....................                 if (verbose) { 
0A6D0:  MOVLB  5
0A6D2:  MOVF   x5A,F
0A6D4:  BZ    A6EA
....................                     fprintf(PC, "MUX change failed!"); 
0A6D6:  MOVLW  6A
0A6D8:  MOVWF  FF6
0A6DA:  MOVLW  0D
0A6DC:  MOVWF  FF7
0A6DE:  MOVLW  00
0A6E0:  MOVWF  FF8
0A6E2:  MOVLB  0
0A6E4:  CALL   4534
0A6E8:  MOVLB  5
....................                 } 
....................                 return 1; 
0A6EA:  MOVLW  01
0A6EC:  MOVWF  01
0A6EE:  BRA    A994
0A6F0:  MOVLB  0
....................             } 
....................             destination_uart = &uart_port_MSN; 
0A6F2:  MOVLW  0A
0A6F4:  MOVLB  C
0A6F6:  MOVWF  x59
0A6F8:  MOVLW  97
0A6FA:  MOVWF  x58
....................             break; // For Rpi 
0A6FC:  BRA    A708
....................         default: destination_uart = &uart_port_PC; break; 
0A6FE:  MOVLW  0A
0A700:  MOVLB  C
0A702:  MOVWF  x59
0A704:  MOVLW  67
0A706:  MOVWF  x58
....................         } 
....................  
....................         if (destination == 2) {                                                            // Rpi 
0A708:  MOVF   x53,W
0A70A:  SUBLW  02
0A70C:  BNZ   A7E8
....................             uint8_t message_pcib[MSG_LENGTH_PCIB] = { 0x0B, 0xCD };                        // Array with request for direct copy relay -> rpi = 0xCD 
0A70E:  MOVLW  0B
0A710:  MOVWF  x5C
0A712:  MOVLW  CD
0A714:  MOVWF  x5D
0A716:  CLRF   x5E
0A718:  CLRF   x5F
0A71A:  CLRF   x60
0A71C:  CLRF   x61
0A71E:  CLRF   x62
0A720:  CLRF   x63
0A722:  CLRF   x64
0A724:  CLRF   x65
0A726:  CLRF   x66
0A728:  CLRF   x67
0A72A:  CLRF   x68
0A72C:  CLRF   x69
0A72E:  CLRF   x6A
0A730:  CLRF   x6B
0A732:  CLRF   x6C
0A734:  CLRF   x6D
0A736:  CLRF   x6E
0A738:  CLRF   x6F
0A73A:  CLRF   x70
0A73C:  CLRF   x71
0A73E:  CLRF   x72
0A740:  CLRF   x73
0A742:  CLRF   x74
0A744:  CLRF   x75
0A746:  CLRF   x76
0A748:  CLRF   x77
0A74A:  CLRF   x78
0A74C:  CLRF   x79
0A74E:  CLRF   x7A
0A750:  CLRF   x7B
0A752:  CLRF   x7C
0A754:  CLRF   x7D
0A756:  CLRF   x7E
0A758:  CLRF   x7F
....................             checksum_obc(message_pcib, MSG_LENGTH_PCIB);                                   // Add checksum 
0A75A:  MOVLW  0C
0A75C:  MOVWF  xAF
0A75E:  MOVLW  5C
0A760:  MOVWF  xAE
0A762:  MOVLW  24
0A764:  MOVWF  xB0
0A766:  MOVLB  0
0A768:  CALL   8E80
....................             uart_send_packet_repeat(&uart_port_MSN, message_pcib, MSG_LENGTH_PCIB, 5, 10); // Send request 5 times, 100ms spaced 
0A76C:  MOVLW  0A
0A76E:  MOVLB  C
0A770:  MOVWF  xAF
0A772:  MOVLW  97
0A774:  MOVWF  xAE
0A776:  MOVLW  0C
0A778:  MOVWF  xB1
0A77A:  MOVLW  5C
0A77C:  MOVWF  xB0
0A77E:  CLRF   xB5
0A780:  CLRF   xB4
0A782:  CLRF   xB3
0A784:  MOVLW  24
0A786:  MOVWF  xB2
0A788:  MOVLW  05
0A78A:  MOVWF  xB6
0A78C:  CLRF   xBA
0A78E:  CLRF   xB9
0A790:  CLRF   xB8
0A792:  MOVLW  0A
0A794:  MOVWF  xB7
0A796:  MOVLB  0
0A798:  CALL   8F3C
....................             delay_ms(1000); 
0A79C:  MOVLW  04
0A79E:  MOVLB  C
0A7A0:  MOVWF  xA4
0A7A2:  MOVLW  FA
0A7A4:  MOVLB  D
0A7A6:  MOVWF  x52
0A7A8:  MOVLB  0
0A7AA:  CALL   5266
0A7AE:  MOVLB  C
0A7B0:  DECFSZ xA4,F
0A7B2:  BRA    A7A2
....................             fprintf(PCIB, "\nrx,%05lu\n", destination_address); 
0A7B4:  MOVLW  7E
0A7B6:  MOVWF  FF6
0A7B8:  MOVLW  0D
0A7BA:  MOVWF  FF7
0A7BC:  MOVLW  00
0A7BE:  MOVWF  FF8
0A7C0:  MOVLW  04
0A7C2:  MOVWF  xA4
0A7C4:  MOVLB  0
0A7C6:  BRA    A320
0A7C8:  MOVLW  45
0A7CA:  MOVWF  FE9
0A7CC:  MOVFF  C57,CA7
0A7D0:  MOVFF  C56,CA6
0A7D4:  MOVFF  C55,CA5
0A7D8:  MOVFF  C54,CA4
0A7DC:  BRA    A354
0A7DE:  MOVLW  0A
0A7E0:  BTFSS  F9E.4
0A7E2:  BRA    A7E0
0A7E4:  MOVWF  FAD
0A7E6:  MOVLB  C
....................         } 
....................  
....................         if (destination == 1) { // PCIB 
0A7E8:  DECFSZ x53,W
0A7EA:  BRA    A85A
....................             struct req { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint8_t source; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 9]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req; 
....................             req.origin = MSG_OBC; 
0A7EC:  MOVLW  0B
0A7EE:  MOVWF  x80
....................             req.command = 0xD1; // X-modem receive; 
0A7F0:  MOVLW  D1
0A7F2:  MOVWF  x81
....................             req.address = destination_address; 
0A7F4:  MOVFF  C57,C85
0A7F8:  MOVFF  C56,C84
0A7FC:  MOVFF  C55,C83
0A800:  MOVFF  C54,C82
....................             req.source = 1; // OBC 
0A804:  MOVLW  01
0A806:  MOVWF  x86
....................             checksum_obc((uint8_t*)&req, sizeof(req)); 
0A808:  MOVLW  0C
0A80A:  MOVWF  xA5
0A80C:  MOVLW  80
0A80E:  MOVWF  xA4
0A810:  MOVFF  CA5,CAF
0A814:  MOVWF  xAE
0A816:  MOVLW  24
0A818:  MOVWF  xB0
0A81A:  MOVLB  0
0A81C:  CALL   8E80
....................             uart_send_packet_repeat(&uart_port_MSN, (uint8_t*)&req, sizeof(req), 5, 10); 
0A820:  MOVLW  0C
0A822:  MOVLB  C
0A824:  MOVWF  xA5
0A826:  MOVLW  80
0A828:  MOVWF  xA4
0A82A:  MOVLW  0A
0A82C:  MOVWF  xAF
0A82E:  MOVLW  97
0A830:  MOVWF  xAE
0A832:  MOVFF  CA5,CB1
0A836:  MOVFF  CA4,CB0
0A83A:  CLRF   xB5
0A83C:  CLRF   xB4
0A83E:  CLRF   xB3
0A840:  MOVLW  24
0A842:  MOVWF  xB2
0A844:  MOVLW  05
0A846:  MOVWF  xB6
0A848:  CLRF   xBA
0A84A:  CLRF   xB9
0A84C:  CLRF   xB8
0A84E:  MOVLW  0A
0A850:  MOVWF  xB7
0A852:  MOVLB  0
0A854:  CALL   8F3C
0A858:  MOVLB  C
....................         } 
....................  
....................         switch (source) { 
0A85A:  MOVF   x52,W
0A85C:  XORLW  00
0A85E:  MOVLB  0
0A860:  BZ    A86C
0A862:  XORLW  01
0A864:  BZ    A8AC
0A866:  XORLW  03
0A868:  BZ    A8E8
0A86A:  BRA    A92C
....................         case 0: 
....................             get_com_shared_fm_access(); 
0A86C:  CALL   8672
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, source_address, n_packets); 
0A870:  MOVFF  C4F,CA5
0A874:  MOVFF  C4E,CA4
0A878:  MOVFF  C59,CA7
0A87C:  MOVFF  C58,CA6
0A880:  MOVLW  0A
0A882:  MOVLB  C
0A884:  MOVWF  xA9
0A886:  MOVLW  A3
0A888:  MOVWF  xA8
0A88A:  MOVFF  C4D,CAD
0A88E:  MOVFF  C4C,CAC
0A892:  MOVFF  C4B,CAB
0A896:  MOVFF  C4A,CAA
0A89A:  MOVFF  C4F,CAF
0A89E:  MOVFF  C4E,CAE
0A8A2:  MOVLB  0
0A8A4:  RCALL  A4E6
0A8A6:  MOVFF  01,C5B
....................             break; 
0A8AA:  BRA    A96A
....................         case 1: 
....................             error = xmodem_send(destination_uart, &spi_port_MAIN_FM, source_address, n_packets); 
0A8AC:  MOVFF  C4F,CA5
0A8B0:  MOVFF  C4E,CA4
0A8B4:  MOVFF  C59,CA7
0A8B8:  MOVFF  C58,CA6
0A8BC:  MOVLW  0A
0A8BE:  MOVLB  C
0A8C0:  MOVWF  xA9
0A8C2:  MOVLW  AD
0A8C4:  MOVWF  xA8
0A8C6:  MOVFF  C4D,CAD
0A8CA:  MOVFF  C4C,CAC
0A8CE:  MOVFF  C4B,CAB
0A8D2:  MOVFF  C4A,CAA
0A8D6:  MOVFF  C4F,CAF
0A8DA:  MOVFF  C4E,CAE
0A8DE:  MOVLB  0
0A8E0:  RCALL  A4E6
0A8E2:  MOVFF  01,C5B
....................             break; 
0A8E6:  BRA    A96A
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
0A8E8:  BCF    F92.5
0A8EA:  BCF    F89.5
....................             error = xmodem_send(destination_uart, &spi_port_MISSION_FM, source_address, n_packets); 
0A8EC:  MOVFF  C4F,CA5
0A8F0:  MOVFF  C4E,CA4
0A8F4:  MOVFF  C59,CA7
0A8F8:  MOVFF  C58,CA6
0A8FC:  MOVLW  0A
0A8FE:  MOVLB  C
0A900:  MOVWF  xA9
0A902:  MOVLW  B7
0A904:  MOVWF  xA8
0A906:  MOVFF  C4D,CAD
0A90A:  MOVFF  C4C,CAC
0A90E:  MOVFF  C4B,CAB
0A912:  MOVFF  C4A,CAA
0A916:  MOVFF  C4F,CAF
0A91A:  MOVFF  C4E,CAE
0A91E:  MOVLB  0
0A920:  RCALL  A4E6
0A922:  MOVFF  01,C5B
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
0A926:  BCF    F92.5
0A928:  BSF    F89.5
....................             break; 
0A92A:  BRA    A96A
....................         default: 
....................             get_com_shared_fm_access(); 
0A92C:  CALL   8672
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, source_address, n_packets); 
0A930:  MOVFF  C4F,CA5
0A934:  MOVFF  C4E,CA4
0A938:  MOVFF  C59,CA7
0A93C:  MOVFF  C58,CA6
0A940:  MOVLW  0A
0A942:  MOVLB  C
0A944:  MOVWF  xA9
0A946:  MOVLW  A3
0A948:  MOVWF  xA8
0A94A:  MOVFF  C4D,CAD
0A94E:  MOVFF  C4C,CAC
0A952:  MOVFF  C4B,CAB
0A956:  MOVFF  C4A,CAA
0A95A:  MOVFF  C4F,CAF
0A95E:  MOVFF  C4E,CAE
0A962:  MOVLB  0
0A964:  RCALL  A4E6
0A966:  MOVFF  01,C5B
....................             break; 
....................         } 
....................         current_try++; 
0A96A:  MOVLB  C
0A96C:  INCF   x5A,F
....................         delay_ms(1000); 
0A96E:  MOVLW  04
0A970:  MOVWF  xA4
0A972:  MOVLW  FA
0A974:  MOVLB  D
0A976:  MOVWF  x52
0A978:  MOVLB  0
0A97A:  CALL   5266
0A97E:  MOVLB  C
0A980:  DECFSZ xA4,F
0A982:  BRA    A972
....................         if (error != -1) 
0A984:  MOVF   x5B,W
0A986:  SUBLW  FF
0A988:  BZ    A98C
....................             break; 
0A98A:  BRA    A98E
0A98C:  BRA    A658
....................     } 
....................     return error; 
0A98E:  MOVFF  C5B,01
0A992:  MOVLB  5
0A994:  MOVLB  0
0A996:  RETURN 0
.................... } 
....................  
.................... // Send data through xmodem protocol 
.................... uint8_t command_xmodem_send(uint8_t* data) 
*
1221A:  MOVFF  C39,C3B
1221E:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D0 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t destination_address; 
....................     }* packet = (struct packet*)data; 
....................  
....................     return xmodem_send_fn(packet->source_address, packet->n_packets, packet->source, packet->destination, packet->destination_address); 
12222:  MOVLW  02
12224:  MOVLB  C
12226:  ADDWF  x3A,W
12228:  MOVWF  FE9
1222A:  MOVLW  00
1222C:  ADDWFC x3B,W
1222E:  MOVWF  FEA
12230:  MOVFF  FEF,C4A
12234:  MOVFF  FEC,C4B
12238:  MOVFF  FEC,C4C
1223C:  MOVFF  FEC,C4D
12240:  MOVLW  06
12242:  ADDWF  x3A,W
12244:  MOVWF  FE9
12246:  MOVLW  00
12248:  ADDWFC x3B,W
1224A:  MOVWF  FEA
1224C:  MOVFF  FEF,C4E
12250:  MOVFF  FEC,C4F
12254:  MOVFF  FEC,C50
12258:  MOVFF  FEC,C51
1225C:  MOVLW  0A
1225E:  ADDWF  x3A,W
12260:  MOVWF  FE9
12262:  MOVLW  00
12264:  ADDWFC x3B,W
12266:  MOVWF  FEA
12268:  MOVFF  FEF,C52
1226C:  MOVLW  0B
1226E:  ADDWF  x3A,W
12270:  MOVWF  FE9
12272:  MOVLW  00
12274:  ADDWFC x3B,W
12276:  MOVWF  FEA
12278:  MOVFF  FEF,C53
1227C:  MOVLW  0C
1227E:  ADDWF  x3A,W
12280:  MOVWF  FE9
12282:  MOVLW  00
12284:  ADDWFC x3B,W
12286:  MOVWF  FEA
12288:  MOVFF  FEF,C54
1228C:  MOVFF  FEC,C55
12290:  MOVFF  FEC,C56
12294:  MOVFF  FEC,C57
12298:  MOVLB  0
1229A:  CALL   A63E
1229E:  MOVF   01,W
122A0:  GOTO   18D70 (RETURN)
.................... } 
....................  
.................... // Short version of XMODEM send command, similar to flash copy command 
.................... uint8_t command_xmodem_send_sector(uint8_t* data) 
*
0A998:  MOVFF  C39,C3B
0A99C:  MOVFF  C38,C3A
0A9A0:  MOVLW  02
0A9A2:  MOVLB  C
0A9A4:  ADDWF  x3A,W
0A9A6:  MOVWF  FE9
0A9A8:  MOVLW  00
0A9AA:  ADDWFC x3B,W
0A9AC:  MOVWF  FEA
0A9AE:  MOVFF  FEC,C49
0A9B2:  MOVF   FED,F
0A9B4:  MOVFF  FEF,C48
*
0A9C4:  MOVLW  04
0A9C6:  ADDWF  x3A,W
0A9C8:  MOVWF  FE9
0A9CA:  MOVLW  00
0A9CC:  ADDWFC x3B,W
0A9CE:  MOVWF  FEA
0A9D0:  MOVFF  FEC,C49
0A9D4:  MOVF   FED,F
0A9D6:  MOVFF  FEF,C48
*
0A9E6:  MOVLW  06
0A9E8:  ADDWF  x3A,W
0A9EA:  MOVWF  FE9
0A9EC:  MOVLW  00
0A9EE:  ADDWFC x3B,W
0A9F0:  MOVWF  FEA
0A9F2:  MOVFF  FEC,C49
0A9F6:  MOVF   FED,F
0A9F8:  MOVFF  FEF,C48
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t destination_address = packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t source_address = packet->source_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t n_packets = packet->n_sectors * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     return xmodem_send_fn(source_address, n_packets, packet->source, packet->destination, destination_address); 
*
0AA54:  MOVLW  09
0AA56:  ADDWF  x3A,W
0AA58:  MOVWF  FE9
0AA5A:  MOVLW  00
0AA5C:  ADDWFC x3B,W
0AA5E:  MOVWF  FEA
0AA60:  MOVFF  FEF,C52
0AA64:  MOVLW  08
0AA66:  ADDWF  x3A,W
0AA68:  MOVWF  FE9
0AA6A:  MOVLW  00
0AA6C:  ADDWFC x3B,W
0AA6E:  MOVWF  FEA
0AA70:  MOVFF  FEF,C53
0AA74:  MOVFF  C43,C4D
0AA78:  MOVFF  C42,C4C
0AA7C:  MOVFF  C41,C4B
0AA80:  MOVFF  C40,C4A
0AA84:  MOVFF  C47,C51
0AA88:  MOVFF  C46,C50
0AA8C:  MOVFF  C45,C4F
0AA90:  MOVFF  C44,C4E
0AA94:  MOVFF  C3F,C57
0AA98:  MOVFF  C3E,C56
0AA9C:  MOVFF  C3D,C55
0AAA0:  MOVFF  C3C,C54
0AAA4:  MOVLB  0
0AAA6:  RCALL  A63E
0AAA8:  MOVF   01,W
0AAAA:  GOTO   188D2 (RETURN)
.................... } 
....................  
.................... uint8_t xmodem_receive_fn( 
....................     uint32_t destination_address, 
....................     uint8_t source, 
....................     uint8_t destination, 
....................     uint32_t source_address, 
....................     uint32_t n_packets) 
*
09CD4:  MOVLB  C
09CD6:  CLRF   x58
.................... { 
....................     int8_t total_packets = 0; 
....................     fprintf(PC, "Receiving xmodem data..."); 
09CD8:  MOVLW  8A
09CDA:  MOVWF  FF6
09CDC:  MOVLW  0D
09CDE:  MOVWF  FF7
09CE0:  MOVLW  00
09CE2:  MOVWF  FF8
09CE4:  MOVLB  0
09CE6:  CALL   4534
....................  
....................     uart_fn* source_uart = NULL; 
....................     const uint8_t max_tries = 5; 
....................  
....................     uint8_t current_try = 0; 
09CEA:  MOVLB  C
09CEC:  CLRF   x5A
09CEE:  CLRF   x59
09CF0:  CLRF   x5B
....................  
....................     switch (source) { 
09CF2:  MOVF   x4E,W
09CF4:  XORLW  00
09CF6:  MOVLB  0
09CF8:  BZ    9D0C
09CFA:  XORLW  01
09CFC:  BZ    9D18
09CFE:  XORLW  02
09D00:  BZ    9D58
09D02:  XORLW  07
09D04:  BZ    9D98
09D06:  XORLW  01
09D08:  BZ    9DD8
09D0A:  BRA    9E18
....................     case 0: source_uart = &uart_port_PC; break; 
09D0C:  MOVLW  0A
09D0E:  MOVLB  C
09D10:  MOVWF  x5A
09D12:  MOVLW  67
09D14:  MOVWF  x59
09D16:  BRA    9E22
....................     case 1: 
....................         if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
09D18:  MOVLW  06
09D1A:  MOVLB  C
09D1C:  MOVWF  xBE
09D1E:  MOVLB  0
09D20:  CALL   52E8
09D24:  MOVF   01,W
09D26:  SUBLW  06
09D28:  BZ    9D4C
....................             if (verbose) { 
09D2A:  MOVLB  5
09D2C:  MOVF   x5A,F
09D2E:  BZ    9D44
....................                 fprintf(PC, "MUX change failed!"); 
09D30:  MOVLW  A4
09D32:  MOVWF  FF6
09D34:  MOVLW  0D
09D36:  MOVWF  FF7
09D38:  MOVLW  00
09D3A:  MOVWF  FF8
09D3C:  MOVLB  0
09D3E:  CALL   4534
09D42:  MOVLB  5
....................             } 
....................             return 1; 
09D44:  MOVLW  01
09D46:  MOVWF  01
09D48:  BRA    A076
09D4A:  MOVLB  0
....................         } 
....................         source_uart = &uart_port_MSN; 
09D4C:  MOVLW  0A
09D4E:  MOVLB  C
09D50:  MOVWF  x5A
09D52:  MOVLW  97
09D54:  MOVWF  x59
....................         break; 
09D56:  BRA    9E22
....................     // case 2: reserved (thermal mission) 
....................     case 3: 
....................         if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
09D58:  MOVLW  02
09D5A:  MOVLB  C
09D5C:  MOVWF  xBE
09D5E:  MOVLB  0
09D60:  CALL   52E8
09D64:  MOVF   01,W
09D66:  SUBLW  02
09D68:  BZ    9D8C
....................             if (verbose) { 
09D6A:  MOVLB  5
09D6C:  MOVF   x5A,F
09D6E:  BZ    9D84
....................                 fprintf(PC, "MUX change failed!"); 
09D70:  MOVLW  B8
09D72:  MOVWF  FF6
09D74:  MOVLW  0D
09D76:  MOVWF  FF7
09D78:  MOVLW  00
09D7A:  MOVWF  FF8
09D7C:  MOVLB  0
09D7E:  CALL   4534
09D82:  MOVLB  5
....................             } 
....................             return 1; 
09D84:  MOVLW  01
09D86:  MOVWF  01
09D88:  BRA    A076
09D8A:  MOVLB  0
....................         } 
....................         source_uart = &uart_port_MSN; 
09D8C:  MOVLW  0A
09D8E:  MOVLB  C
09D90:  MOVWF  x5A
09D92:  MOVLW  97
09D94:  MOVWF  x59
....................         break; 
09D96:  BRA    9E22
....................     case 4: 
....................         if (mux_sel(mux_tmcr1) != mux_tmcr1) { // If MUX did not change 
09D98:  MOVLW  01
09D9A:  MOVLB  C
09D9C:  MOVWF  xBE
09D9E:  MOVLB  0
09DA0:  CALL   52E8
09DA4:  DECFSZ 01,W
09DA6:  BRA    9DAA
09DA8:  BRA    9DCC
....................             if (verbose) { 
09DAA:  MOVLB  5
09DAC:  MOVF   x5A,F
09DAE:  BZ    9DC4
....................                 fprintf(PC, "MUX change failed!"); 
09DB0:  MOVLW  CC
09DB2:  MOVWF  FF6
09DB4:  MOVLW  0D
09DB6:  MOVWF  FF7
09DB8:  MOVLW  00
09DBA:  MOVWF  FF8
09DBC:  MOVLB  0
09DBE:  CALL   4534
09DC2:  MOVLB  5
....................             } 
....................             return 1; 
09DC4:  MOVLW  01
09DC6:  MOVWF  01
09DC8:  BRA    A076
09DCA:  MOVLB  0
....................         } 
....................         source_uart = &uart_port_MSN; 
09DCC:  MOVLW  0A
09DCE:  MOVLB  C
09DD0:  MOVWF  x5A
09DD2:  MOVLW  97
09DD4:  MOVWF  x59
....................         break; 
09DD6:  BRA    9E22
....................     case 5: 
....................         if (mux_sel(mux_tmcr2) != mux_tmcr2) { // If MUX did not change 
09DD8:  MOVLW  03
09DDA:  MOVLB  C
09DDC:  MOVWF  xBE
09DDE:  MOVLB  0
09DE0:  CALL   52E8
09DE4:  MOVF   01,W
09DE6:  SUBLW  03
09DE8:  BZ    9E0C
....................             if (verbose) { 
09DEA:  MOVLB  5
09DEC:  MOVF   x5A,F
09DEE:  BZ    9E04
....................                 fprintf(PC, "MUX change failed!"); 
09DF0:  MOVLW  E0
09DF2:  MOVWF  FF6
09DF4:  MOVLW  0D
09DF6:  MOVWF  FF7
09DF8:  MOVLW  00
09DFA:  MOVWF  FF8
09DFC:  MOVLB  0
09DFE:  CALL   4534
09E02:  MOVLB  5
....................             } 
....................             return 1; 
09E04:  MOVLW  01
09E06:  MOVWF  01
09E08:  BRA    A076
09E0A:  MOVLB  0
....................         } 
....................         source_uart = &uart_port_MSN; 
09E0C:  MOVLW  0A
09E0E:  MOVLB  C
09E10:  MOVWF  x5A
09E12:  MOVLW  97
09E14:  MOVWF  x59
....................         break; 
09E16:  BRA    9E22
....................     default: source_uart = &uart_port_PC; break; 
09E18:  MOVLW  0A
09E1A:  MOVLB  C
09E1C:  MOVWF  x5A
09E1E:  MOVLW  67
09E20:  MOVWF  x59
....................     } 
....................  
....................     while (current_try < max_tries) { 
09E22:  MOVF   x5B,W
09E24:  SUBLW  04
09E26:  BTFSS  FD8.0
09E28:  BRA    A070
....................         if (source == 1 || source == 4 || source == 5) { // PCIB, TMCR1 or TMCR2 
09E2A:  DECFSZ x4E,W
09E2C:  BRA    9E30
09E2E:  BRA    9E3C
09E30:  MOVF   x4E,W
09E32:  SUBLW  04
09E34:  BZ    9E3C
09E36:  MOVF   x4E,W
09E38:  SUBLW  05
09E3A:  BNZ   9EC6
....................             struct req_pcib { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint32_t n_packets; 
....................                 uint8_t destination; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 13]; // the lenght is the same for the 3 subsystems 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req_pcib; 
....................             req_pcib.origin = MSG_OBC; 
09E3C:  MOVLW  0B
09E3E:  MOVWF  x5C
....................             req_pcib.command = 0xD0; // X-modem send; 
09E40:  MOVLW  D0
09E42:  MOVWF  x5D
....................             req_pcib.address = source_address; 
09E44:  MOVFF  C53,C61
09E48:  MOVFF  C52,C60
09E4C:  MOVFF  C51,C5F
09E50:  MOVFF  C50,C5E
....................             req_pcib.n_packets = n_packets; 
09E54:  MOVFF  C57,C65
09E58:  MOVFF  C56,C64
09E5C:  MOVFF  C55,C63
09E60:  MOVFF  C54,C62
....................             req_pcib.destination = 1; // OBC 
09E64:  MOVLW  01
09E66:  MOVWF  x66
....................             checksum_obc((uint8_t*)&req_pcib, sizeof(req_pcib)); 
09E68:  MOVLW  0C
09E6A:  MOVWF  xAD
09E6C:  MOVLW  5C
09E6E:  MOVWF  xAC
09E70:  MOVFF  CAD,CAF
09E74:  MOVWF  xAE
09E76:  MOVLW  24
09E78:  MOVWF  xB0
09E7A:  MOVLB  0
09E7C:  CALL   8E80
....................             uart_send_packet_repeat(source_uart, (uint8_t*)&req_pcib, sizeof(req_pcib), 1, 10); 
09E80:  MOVLW  0C
09E82:  MOVLB  C
09E84:  MOVWF  xAD
09E86:  MOVLW  5C
09E88:  MOVWF  xAC
09E8A:  MOVFF  C5A,CAF
09E8E:  MOVFF  C59,CAE
09E92:  MOVFF  CAD,CB1
09E96:  MOVWF  xB0
09E98:  CLRF   xB5
09E9A:  CLRF   xB4
09E9C:  CLRF   xB3
09E9E:  MOVLW  24
09EA0:  MOVWF  xB2
09EA2:  MOVLW  01
09EA4:  MOVWF  xB6
09EA6:  CLRF   xBA
09EA8:  CLRF   xB9
09EAA:  CLRF   xB8
09EAC:  MOVLW  0A
09EAE:  MOVWF  xB7
09EB0:  MOVLB  0
09EB2:  CALL   8F3C
....................             delay_ms(100); 
09EB6:  MOVLW  64
09EB8:  MOVLB  D
09EBA:  MOVWF  x52
09EBC:  MOVLB  0
09EBE:  CALL   5266
....................         } else if (source == 2 || source == 3) { // Thermal or ADCS 
09EC2:  BRA    9F58
09EC4:  MOVLB  C
09EC6:  MOVF   x4E,W
09EC8:  SUBLW  02
09ECA:  BZ    9ED2
09ECC:  MOVF   x4E,W
09ECE:  SUBLW  03
09ED0:  BNZ   9F5A
....................             struct req_adcs { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint32_t n_packets; 
....................                 uint8_t destination; 
....................                 uint8_t padding[MSG_LENGTH_ADCS - 13]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req_adcs; 
....................             req_adcs.origin = MSG_OBC; 
09ED2:  MOVLW  0B
09ED4:  MOVWF  x80
....................             req_adcs.command = 0xD0; // X-modem send; 
09ED6:  MOVLW  D0
09ED8:  MOVWF  x81
....................             req_adcs.address = source_address; 
09EDA:  MOVFF  C53,C85
09EDE:  MOVFF  C52,C84
09EE2:  MOVFF  C51,C83
09EE6:  MOVFF  C50,C82
....................             req_adcs.n_packets = n_packets; 
09EEA:  MOVFF  C57,C89
09EEE:  MOVFF  C56,C88
09EF2:  MOVFF  C55,C87
09EF6:  MOVFF  C54,C86
....................             req_adcs.destination = 1; // OBC 
09EFA:  MOVLW  01
09EFC:  MOVWF  x8A
....................             checksum_obc((uint8_t*)&req_adcs, sizeof(req_adcs)); 
09EFE:  MOVLW  0C
09F00:  MOVWF  xAD
09F02:  MOVLW  80
09F04:  MOVWF  xAC
09F06:  MOVFF  CAD,CAF
09F0A:  MOVWF  xAE
09F0C:  MOVLW  2C
09F0E:  MOVWF  xB0
09F10:  MOVLB  0
09F12:  CALL   8E80
....................             uart_send_packet_repeat(source_uart, (uint8_t*)&req_adcs, sizeof(req_adcs), 1, 10); 
09F16:  MOVLW  0C
09F18:  MOVLB  C
09F1A:  MOVWF  xAD
09F1C:  MOVLW  80
09F1E:  MOVWF  xAC
09F20:  MOVFF  C5A,CAF
09F24:  MOVFF  C59,CAE
09F28:  MOVFF  CAD,CB1
09F2C:  MOVWF  xB0
09F2E:  CLRF   xB5
09F30:  CLRF   xB4
09F32:  CLRF   xB3
09F34:  MOVLW  2C
09F36:  MOVWF  xB2
09F38:  MOVLW  01
09F3A:  MOVWF  xB6
09F3C:  CLRF   xBA
09F3E:  CLRF   xB9
09F40:  CLRF   xB8
09F42:  MOVLW  0A
09F44:  MOVWF  xB7
09F46:  MOVLB  0
09F48:  CALL   8F3C
....................             delay_ms(100); 
09F4C:  MOVLW  64
09F4E:  MOVLB  D
09F50:  MOVWF  x52
09F52:  MOVLB  0
09F54:  CALL   5266
09F58:  MOVLB  C
....................         } 
....................         if (source == 2 || source == 3) { 
09F5A:  MOVF   x4E,W
09F5C:  SUBLW  02
09F5E:  BZ    9F66
09F60:  MOVF   x4E,W
09F62:  SUBLW  03
09F64:  BNZ   9F7C
....................             delay_ms(5000); 
09F66:  MOVLW  14
09F68:  MOVWF  xAC
09F6A:  MOVLW  FA
09F6C:  MOVLB  D
09F6E:  MOVWF  x52
09F70:  MOVLB  0
09F72:  CALL   5266
09F76:  MOVLB  C
09F78:  DECFSZ xAC,F
09F7A:  BRA    9F6A
....................         } 
....................  
....................         switch (destination) { 
09F7C:  MOVF   x4F,W
09F7E:  XORLW  00
09F80:  MOVLB  0
09F82:  BZ    9F8E
09F84:  XORLW  01
09F86:  BZ    9FBE
09F88:  XORLW  03
09F8A:  BZ    9FEA
09F8C:  BRA    A01E
....................         case 0: 
....................             get_com_shared_fm_access(); 
09F8E:  CALL   8672
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, destination_address); 
09F92:  MOVFF  C5A,CAD
09F96:  MOVFF  C59,CAC
09F9A:  MOVLW  0A
09F9C:  MOVLB  C
09F9E:  MOVWF  xAF
09FA0:  MOVLW  A3
09FA2:  MOVWF  xAE
09FA4:  MOVFF  C4D,CB3
09FA8:  MOVFF  C4C,CB2
09FAC:  MOVFF  C4B,CB1
09FB0:  MOVFF  C4A,CB0
09FB4:  MOVLB  0
09FB6:  RCALL  99A4
09FB8:  MOVFF  01,C58
....................             break; 
09FBC:  BRA    A04C
....................         case 1: 
....................             total_packets = xmodem_receive(source_uart, &spi_port_MAIN_FM, destination_address); 
09FBE:  MOVFF  C5A,CAD
09FC2:  MOVFF  C59,CAC
09FC6:  MOVLW  0A
09FC8:  MOVLB  C
09FCA:  MOVWF  xAF
09FCC:  MOVLW  AD
09FCE:  MOVWF  xAE
09FD0:  MOVFF  C4D,CB3
09FD4:  MOVFF  C4C,CB2
09FD8:  MOVFF  C4B,CB1
09FDC:  MOVFF  C4A,CB0
09FE0:  MOVLB  0
09FE2:  RCALL  99A4
09FE4:  MOVFF  01,C58
....................             break; 
09FE8:  BRA    A04C
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
09FEA:  BCF    F92.5
09FEC:  BCF    F89.5
....................             total_packets = xmodem_receive(source_uart, &spi_port_MISSION_FM, destination_address); 
09FEE:  MOVFF  C5A,CAD
09FF2:  MOVFF  C59,CAC
09FF6:  MOVLW  0A
09FF8:  MOVLB  C
09FFA:  MOVWF  xAF
09FFC:  MOVLW  B7
09FFE:  MOVWF  xAE
0A000:  MOVFF  C4D,CB3
0A004:  MOVFF  C4C,CB2
0A008:  MOVFF  C4B,CB1
0A00C:  MOVFF  C4A,CB0
0A010:  MOVLB  0
0A012:  RCALL  99A4
0A014:  MOVFF  01,C58
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
0A018:  BCF    F92.5
0A01A:  BSF    F89.5
....................             break; 
0A01C:  BRA    A04C
....................         default: 
....................             get_com_shared_fm_access(); 
0A01E:  CALL   8672
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, destination_address); 
0A022:  MOVFF  C5A,CAD
0A026:  MOVFF  C59,CAC
0A02A:  MOVLW  0A
0A02C:  MOVLB  C
0A02E:  MOVWF  xAF
0A030:  MOVLW  A3
0A032:  MOVWF  xAE
0A034:  MOVFF  C4D,CB3
0A038:  MOVFF  C4C,CB2
0A03C:  MOVFF  C4B,CB1
0A040:  MOVFF  C4A,CB0
0A044:  MOVLB  0
0A046:  RCALL  99A4
0A048:  MOVFF  01,C58
....................             break; 
....................         } 
....................         current_try++; 
0A04C:  MOVLB  C
0A04E:  INCF   x5B,F
....................         delay_ms(1000); 
0A050:  MOVLW  04
0A052:  MOVWF  xAC
0A054:  MOVLW  FA
0A056:  MOVLB  D
0A058:  MOVWF  x52
0A05A:  MOVLB  0
0A05C:  CALL   5266
0A060:  MOVLB  C
0A062:  DECFSZ xAC,F
0A064:  BRA    A054
....................         if (total_packets != -1) 
0A066:  MOVF   x58,W
0A068:  SUBLW  FF
0A06A:  BZ    A06E
....................             break; 
0A06C:  BRA    A070
0A06E:  BRA    9E22
....................     } 
....................     return total_packets; 
0A070:  MOVFF  C58,01
0A074:  MOVLB  5
0A076:  MOVLB  0
0A078:  RETURN 0
.................... } 
....................  
.................... // Receive data through xmodem protocol 
.................... uint8_t command_xmodem_receive(uint8_t* data) 
*
122A4:  MOVFF  C39,C3B
122A8:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     }* packet = (struct packet*)data; 
....................     return (xmodem_receive_fn(packet->destination_address, packet->source, packet->destination, packet->source_address, packet->n_packets)); 
122AC:  MOVLW  02
122AE:  MOVLB  C
122B0:  ADDWF  x3A,W
122B2:  MOVWF  FE9
122B4:  MOVLW  00
122B6:  ADDWFC x3B,W
122B8:  MOVWF  FEA
122BA:  MOVFF  FEF,C4A
122BE:  MOVFF  FEC,C4B
122C2:  MOVFF  FEC,C4C
122C6:  MOVFF  FEC,C4D
122CA:  MOVLW  06
122CC:  ADDWF  x3A,W
122CE:  MOVWF  FE9
122D0:  MOVLW  00
122D2:  ADDWFC x3B,W
122D4:  MOVWF  FEA
122D6:  MOVFF  FEF,C4E
122DA:  MOVLW  07
122DC:  ADDWF  x3A,W
122DE:  MOVWF  FE9
122E0:  MOVLW  00
122E2:  ADDWFC x3B,W
122E4:  MOVWF  FEA
122E6:  MOVFF  FEF,C4F
122EA:  MOVLW  08
122EC:  ADDWF  x3A,W
122EE:  MOVWF  FE9
122F0:  MOVLW  00
122F2:  ADDWFC x3B,W
122F4:  MOVWF  FEA
122F6:  MOVFF  FEF,C50
122FA:  MOVFF  FEC,C51
122FE:  MOVFF  FEC,C52
12302:  MOVFF  FEC,C53
12306:  MOVLW  0C
12308:  ADDWF  x3A,W
1230A:  MOVWF  FE9
1230C:  MOVLW  00
1230E:  ADDWFC x3B,W
12310:  MOVWF  FEA
12312:  MOVFF  FEF,C54
12316:  MOVFF  FEC,C55
1231A:  MOVFF  FEC,C56
1231E:  MOVFF  FEC,C57
12322:  MOVLB  0
12324:  CALL   9CD4
12328:  MOVF   01,W
1232A:  GOTO   18D82 (RETURN)
.................... } 
....................  
.................... // Short version of XMODEM receive command, similar to flash copy command 
.................... uint8_t command_xmodem_receive_sector(uint8_t* data) 
*
0A07A:  MOVFF  C39,C3B
0A07E:  MOVFF  C38,C3A
0A082:  MOVLW  02
0A084:  MOVLB  C
0A086:  ADDWF  x3A,W
0A088:  MOVWF  FE9
0A08A:  MOVLW  00
0A08C:  ADDWFC x3B,W
0A08E:  MOVWF  FEA
0A090:  MOVFF  FEC,C49
0A094:  MOVF   FED,F
0A096:  MOVFF  FEF,C48
*
0A0A6:  MOVLW  04
0A0A8:  ADDWF  x3A,W
0A0AA:  MOVWF  FE9
0A0AC:  MOVLW  00
0A0AE:  ADDWFC x3B,W
0A0B0:  MOVWF  FEA
0A0B2:  MOVFF  FEC,C49
0A0B6:  MOVF   FED,F
0A0B8:  MOVFF  FEF,C48
*
0A0C8:  MOVLW  06
0A0CA:  ADDWF  x3A,W
0A0CC:  MOVWF  FE9
0A0CE:  MOVLW  00
0A0D0:  ADDWFC x3B,W
0A0D2:  MOVWF  FEA
0A0D4:  MOVFF  FEC,C49
0A0D8:  MOVF   FED,F
0A0DA:  MOVFF  FEF,C48
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t destination_address = packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t source_address = packet->source_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t n_packets = packet->n_sectors * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX\r\n", packet->source, packet->destination, destination_address, source_address, n_packets); 
*
0A136:  MOVLW  09
0A138:  ADDWF  x3A,W
0A13A:  MOVWF  FE9
0A13C:  MOVLW  00
0A13E:  ADDWFC x3B,W
0A140:  MOVWF  FEA
0A142:  MOVFF  FEF,C48
0A146:  MOVLW  08
0A148:  ADDWF  x3A,W
0A14A:  MOVWF  FE9
0A14C:  MOVLW  00
0A14E:  ADDWFC x3B,W
0A150:  MOVWF  FEA
0A152:  MOVFF  FEF,C49
0A156:  MOVLW  F4
0A158:  MOVWF  FF6
0A15A:  MOVLW  0D
0A15C:  MOVWF  FF7
0A15E:  MOVLW  00
0A160:  MOVWF  FF8
0A162:  MOVLW  0C
0A164:  MOVWF  xC1
0A166:  MOVLB  0
0A168:  CALL   5290
0A16C:  MOVFF  C48,CBE
0A170:  MOVLW  18
0A172:  MOVLB  C
0A174:  MOVWF  xBF
0A176:  MOVLB  0
0A178:  CALL   73A8
0A17C:  MOVLW  02
0A17E:  MOVWF  FF6
0A180:  MOVLW  0E
0A182:  MOVWF  FF7
0A184:  MOVLW  00
0A186:  MOVWF  FF8
0A188:  MOVLW  06
0A18A:  MOVLB  C
0A18C:  MOVWF  xC1
0A18E:  MOVLB  0
0A190:  CALL   5290
0A194:  MOVFF  C49,CBE
0A198:  MOVLW  18
0A19A:  MOVLB  C
0A19C:  MOVWF  xBF
0A19E:  MOVLB  0
0A1A0:  CALL   73A8
0A1A4:  MOVLW  0A
0A1A6:  MOVWF  FF6
0A1A8:  MOVLW  0E
0A1AA:  MOVWF  FF7
0A1AC:  MOVLW  00
0A1AE:  MOVWF  FF8
0A1B0:  MOVLW  09
0A1B2:  MOVLB  C
0A1B4:  MOVWF  xC1
0A1B6:  MOVLB  0
0A1B8:  CALL   5290
0A1BC:  MOVFF  C3F,CBF
0A1C0:  MOVLW  37
0A1C2:  MOVLB  C
0A1C4:  MOVWF  xC0
0A1C6:  MOVLB  0
0A1C8:  CALL   5A92
0A1CC:  MOVFF  C3E,CBF
0A1D0:  MOVLW  37
0A1D2:  MOVLB  C
0A1D4:  MOVWF  xC0
0A1D6:  MOVLB  0
0A1D8:  CALL   5A92
0A1DC:  MOVFF  C3D,CBF
0A1E0:  MOVLW  37
0A1E2:  MOVLB  C
0A1E4:  MOVWF  xC0
0A1E6:  MOVLB  0
0A1E8:  CALL   5A92
0A1EC:  MOVFF  C3C,CBF
0A1F0:  MOVLW  37
0A1F2:  MOVLB  C
0A1F4:  MOVWF  xC0
0A1F6:  MOVLB  0
0A1F8:  CALL   5A92
0A1FC:  MOVLW  16
0A1FE:  MOVWF  FF6
0A200:  MOVLW  0E
0A202:  MOVWF  FF7
0A204:  MOVLW  00
0A206:  MOVWF  FF8
0A208:  MOVLW  0B
0A20A:  MOVLB  C
0A20C:  MOVWF  xC1
0A20E:  MOVLB  0
0A210:  CALL   5290
0A214:  MOVFF  C43,CBF
0A218:  MOVLW  37
0A21A:  MOVLB  C
0A21C:  MOVWF  xC0
0A21E:  MOVLB  0
0A220:  CALL   5A92
0A224:  MOVFF  C42,CBF
0A228:  MOVLW  37
0A22A:  MOVLB  C
0A22C:  MOVWF  xC0
0A22E:  MOVLB  0
0A230:  CALL   5A92
0A234:  MOVFF  C41,CBF
0A238:  MOVLW  37
0A23A:  MOVLB  C
0A23C:  MOVWF  xC0
0A23E:  MOVLB  0
0A240:  CALL   5A92
0A244:  MOVFF  C40,CBF
0A248:  MOVLW  37
0A24A:  MOVLB  C
0A24C:  MOVWF  xC0
0A24E:  MOVLB  0
0A250:  CALL   5A92
0A254:  MOVLW  24
0A256:  MOVWF  FF6
0A258:  MOVLW  0E
0A25A:  MOVWF  FF7
0A25C:  MOVLW  00
0A25E:  MOVWF  FF8
0A260:  MOVLW  06
0A262:  MOVLB  C
0A264:  MOVWF  xC1
0A266:  MOVLB  0
0A268:  CALL   5290
0A26C:  MOVFF  C47,CBF
0A270:  MOVLW  37
0A272:  MOVLB  C
0A274:  MOVWF  xC0
0A276:  MOVLB  0
0A278:  CALL   5A92
0A27C:  MOVFF  C46,CBF
0A280:  MOVLW  37
0A282:  MOVLB  C
0A284:  MOVWF  xC0
0A286:  MOVLB  0
0A288:  CALL   5A92
0A28C:  MOVFF  C45,CBF
0A290:  MOVLW  37
0A292:  MOVLB  C
0A294:  MOVWF  xC0
0A296:  MOVLB  0
0A298:  CALL   5A92
0A29C:  MOVFF  C44,CBF
0A2A0:  MOVLW  37
0A2A2:  MOVLB  C
0A2A4:  MOVWF  xC0
0A2A6:  MOVLB  0
0A2A8:  CALL   5A92
0A2AC:  MOVLW  0D
0A2AE:  MOVLB  D
0A2B0:  MOVWF  x6A
0A2B2:  MOVLB  0
0A2B4:  CALL   44EE
0A2B8:  MOVLW  0A
0A2BA:  MOVLB  D
0A2BC:  MOVWF  x6A
0A2BE:  MOVLB  0
0A2C0:  CALL   44EE
....................  
....................     return xmodem_receive_fn(destination_address, packet->source, packet->destination, source_address, n_packets); 
0A2C4:  MOVLW  09
0A2C6:  MOVLB  C
0A2C8:  ADDWF  x3A,W
0A2CA:  MOVWF  FE9
0A2CC:  MOVLW  00
0A2CE:  ADDWFC x3B,W
0A2D0:  MOVWF  FEA
0A2D2:  MOVFF  FEF,C4E
0A2D6:  MOVLW  08
0A2D8:  ADDWF  x3A,W
0A2DA:  MOVWF  FE9
0A2DC:  MOVLW  00
0A2DE:  ADDWFC x3B,W
0A2E0:  MOVWF  FEA
0A2E2:  MOVFF  FEF,C4F
0A2E6:  MOVFF  C3F,C4D
0A2EA:  MOVFF  C3E,C4C
0A2EE:  MOVFF  C3D,C4B
0A2F2:  MOVFF  C3C,C4A
0A2F6:  MOVFF  C43,C53
0A2FA:  MOVFF  C42,C52
0A2FE:  MOVFF  C41,C51
0A302:  MOVFF  C40,C50
0A306:  MOVFF  C47,C57
0A30A:  MOVFF  C46,C56
0A30E:  MOVFF  C45,C55
0A312:  MOVFF  C44,C54
0A316:  MOVLB  0
0A318:  RCALL  9CD4
0A31A:  MOVF   01,W
0A31C:  GOTO   188C0 (RETURN)
.................... } 
....................  
.................... uint8_t command_clear_all_schedule_commands(uint8_t* data) 
.................... { 
....................     scheduled_command_clear_all(); 
*
0FFD0:  CALL   95CE
....................     return 0; 
0FFD4:  MOVLW  00
0FFD6:  MOVWF  01
0FFD8:  GOTO   18F20 (RETURN)
.................... } 
....................  
.................... uint8_t command_boot_flag_set(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
*
16F70:  CALL   8672
....................     uint8_t value = data[2]; 
16F74:  MOVLW  02
16F76:  MOVLB  C
16F78:  ADDWF  x38,W
16F7A:  MOVWF  FE9
16F7C:  MOVLW  00
16F7E:  ADDWFC x39,W
16F80:  MOVWF  FEA
16F82:  MOVFF  FEF,C3A
....................     boot_flags.deployment_flag = value; 
16F86:  MOVFF  C3A,FF
....................     save_flags(); 
16F8A:  MOVLB  0
16F8C:  CALL   9574
....................     scheduled_command_clear_all(); 
16F90:  CALL   95CE
....................     return value; 
16F94:  MOVLB  C
16F96:  MOVFF  C3A,01
16F9A:  MOVLB  0
16F9C:  GOTO   18F7A (RETURN)
.................... } 
....................  
.................... // Reset log command 
.................... uint8_t command_reset_log(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Main PIC reset detected."); 
*
0FFE8:  MOVLW  30
0FFEA:  MOVWF  FF6
0FFEC:  MOVLW  0E
0FFEE:  MOVWF  FF7
0FFF0:  MOVLW  00
0FFF2:  MOVWF  FF8
0FFF4:  CALL   4534
....................     return boot_flags.deployment_flag; 
0FFF8:  MOVFF  FF,01
0FFFC:  GOTO   18FB0 (RETURN)
.................... } 
....................  
.................... // Telemetry keeping function 
.................... uint8_t command_save_telemetry(uint8_t* data) 
.................... { 
....................     if (!memory_busy) { 
*
165B8:  MOVLB  5
165BA:  MOVF   x5B,F
165BC:  BTFSS  FD8.2
165BE:  BRA    16952
....................         // Write the obc timestamp to telemetry and relative collection times 
....................         telemetry.obc_time = current_time; 
165C0:  MOVFF  3E,D8
165C4:  MOVFF  3D,D7
165C8:  MOVFF  3C,D6
165CC:  MOVFF  3B,D5
....................         telemetry.reset_time = current_time - telemetry_time.reset_time > 255 ? 255 : current_time - telemetry_time.reset_time; 
165D0:  MOVLB  0
165D2:  MOVF   xDB,W
165D4:  SUBWF  3B,W
165D6:  MOVLB  C
165D8:  MOVWF  x4E
165DA:  MOVLB  0
165DC:  MOVF   xDC,W
165DE:  SUBWFB 3C,W
165E0:  MOVLB  C
165E2:  MOVWF  x4F
165E4:  MOVLB  0
165E6:  MOVF   xDD,W
165E8:  SUBWFB 3D,W
165EA:  MOVLB  C
165EC:  MOVWF  x50
165EE:  MOVLB  0
165F0:  MOVF   xDE,W
165F2:  SUBWFB 3E,W
165F4:  MOVLB  C
165F6:  MOVWF  x51
165F8:  BTFSC  FE8.7
165FA:  BRA    1660E
165FC:  MOVF   x51,F
165FE:  BNZ   1660A
16600:  MOVF   x50,F
16602:  BNZ   1660A
16604:  MOVF   x4F,W
16606:  SUBLW  00
16608:  BC    1660E
1660A:  MOVLW  FF
1660C:  BRA    1662C
1660E:  MOVLB  0
16610:  MOVF   xDB,W
16612:  SUBWF  3B,W
16614:  MOVWF  00
16616:  MOVF   xDC,W
16618:  SUBWFB 3C,W
1661A:  MOVWF  01
1661C:  MOVF   xDD,W
1661E:  SUBWFB 3D,W
16620:  MOVWF  02
16622:  MOVF   xDE,W
16624:  SUBWFB 3E,W
16626:  MOVWF  03
16628:  MOVF   00,W
1662A:  MOVLB  C
1662C:  MOVWF  43
....................         telemetry.fab_time = current_time - telemetry_time.fab_time > 255 ? 255 : current_time - telemetry_time.fab_time; 
1662E:  MOVLB  0
16630:  MOVF   xDF,W
16632:  SUBWF  3B,W
16634:  MOVLB  C
16636:  MOVWF  x4E
16638:  MOVLB  0
1663A:  MOVF   xE0,W
1663C:  SUBWFB 3C,W
1663E:  MOVLB  C
16640:  MOVWF  x4F
16642:  MOVLB  0
16644:  MOVF   xE1,W
16646:  SUBWFB 3D,W
16648:  MOVLB  C
1664A:  MOVWF  x50
1664C:  MOVLB  0
1664E:  MOVF   xE2,W
16650:  SUBWFB 3E,W
16652:  MOVLB  C
16654:  MOVWF  x51
16656:  BTFSC  FE8.7
16658:  BRA    1666C
1665A:  MOVF   x51,F
1665C:  BNZ   16668
1665E:  MOVF   x50,F
16660:  BNZ   16668
16662:  MOVF   x4F,W
16664:  SUBLW  00
16666:  BC    1666C
16668:  MOVLW  FF
1666A:  BRA    1668A
1666C:  MOVLB  0
1666E:  MOVF   xDF,W
16670:  SUBWF  3B,W
16672:  MOVWF  00
16674:  MOVF   xE0,W
16676:  SUBWFB 3C,W
16678:  MOVWF  01
1667A:  MOVF   xE1,W
1667C:  SUBWFB 3D,W
1667E:  MOVWF  02
16680:  MOVF   xE2,W
16682:  SUBWFB 3E,W
16684:  MOVWF  03
16686:  MOVF   00,W
16688:  MOVLB  C
1668A:  MOVWF  5C
....................         telemetry.msn_time = current_time - telemetry_time.msn_time > 255 ? 255 : current_time - telemetry_time.msn_time; 
1668C:  MOVLB  0
1668E:  MOVF   xE7,W
16690:  SUBWF  3B,W
16692:  MOVLB  C
16694:  MOVWF  x4E
16696:  MOVLB  0
16698:  MOVF   xE8,W
1669A:  SUBWFB 3C,W
1669C:  MOVLB  C
1669E:  MOVWF  x4F
166A0:  MOVLB  0
166A2:  MOVF   xE9,W
166A4:  SUBWFB 3D,W
166A6:  MOVLB  C
166A8:  MOVWF  x50
166AA:  MOVLB  0
166AC:  MOVF   xEA,W
166AE:  SUBWFB 3E,W
166B0:  MOVLB  C
166B2:  MOVWF  x51
166B4:  BTFSC  FE8.7
166B6:  BRA    166CA
166B8:  MOVF   x51,F
166BA:  BNZ   166C6
166BC:  MOVF   x50,F
166BE:  BNZ   166C6
166C0:  MOVF   x4F,W
166C2:  SUBLW  00
166C4:  BC    166CA
166C6:  MOVLW  FF
166C8:  BRA    166E6
166CA:  MOVLB  0
166CC:  MOVF   xE7,W
166CE:  SUBWF  3B,W
166D0:  MOVWF  00
166D2:  MOVF   xE8,W
166D4:  SUBWFB 3C,W
166D6:  MOVWF  01
166D8:  MOVF   xE9,W
166DA:  SUBWFB 3D,W
166DC:  MOVWF  02
166DE:  MOVF   xEA,W
166E0:  SUBWFB 3E,W
166E2:  MOVWF  03
166E4:  MOVF   00,W
166E6:  MOVLB  0
166E8:  MOVWF  x9B
....................         telemetry.pcib_time = current_time - telemetry_time.pcib_time > 255 ? 255 : current_time - telemetry_time.pcib_time; 
166EA:  MOVF   xE3,W
166EC:  SUBWF  3B,W
166EE:  MOVLB  C
166F0:  MOVWF  x4E
166F2:  MOVLB  0
166F4:  MOVF   xE4,W
166F6:  SUBWFB 3C,W
166F8:  MOVLB  C
166FA:  MOVWF  x4F
166FC:  MOVLB  0
166FE:  MOVF   xE5,W
16700:  SUBWFB 3D,W
16702:  MOVLB  C
16704:  MOVWF  x50
16706:  MOVLB  0
16708:  MOVF   xE6,W
1670A:  SUBWFB 3E,W
1670C:  MOVLB  C
1670E:  MOVWF  x51
16710:  BTFSC  FE8.7
16712:  BRA    16726
16714:  MOVF   x51,F
16716:  BNZ   16722
16718:  MOVF   x50,F
1671A:  BNZ   16722
1671C:  MOVF   x4F,W
1671E:  SUBLW  00
16720:  BC    16726
16722:  MOVLW  FF
16724:  BRA    16742
16726:  MOVLB  0
16728:  MOVF   xE3,W
1672A:  SUBWF  3B,W
1672C:  MOVWF  00
1672E:  MOVF   xE4,W
16730:  SUBWFB 3C,W
16732:  MOVWF  01
16734:  MOVF   xE5,W
16736:  SUBWFB 3D,W
16738:  MOVWF  02
1673A:  MOVF   xE6,W
1673C:  SUBWFB 3E,W
1673E:  MOVWF  03
16740:  MOVF   00,W
16742:  MOVLB  0
16744:  MOVWF  x9E
....................         telemetry.adcs_time = current_time - telemetry_time.adcs_time > 255 ? 255 : current_time - telemetry_time.adcs_time; 
16746:  MOVF   xEB,W
16748:  SUBWF  3B,W
1674A:  MOVLB  C
1674C:  MOVWF  x4E
1674E:  MOVLB  0
16750:  MOVF   xEC,W
16752:  SUBWFB 3C,W
16754:  MOVLB  C
16756:  MOVWF  x4F
16758:  MOVLB  0
1675A:  MOVF   xED,W
1675C:  SUBWFB 3D,W
1675E:  MOVLB  C
16760:  MOVWF  x50
16762:  MOVLB  0
16764:  MOVF   xEE,W
16766:  SUBWFB 3E,W
16768:  MOVLB  C
1676A:  MOVWF  x51
1676C:  BTFSC  FE8.7
1676E:  BRA    16782
16770:  MOVF   x51,F
16772:  BNZ   1677E
16774:  MOVF   x50,F
16776:  BNZ   1677E
16778:  MOVF   x4F,W
1677A:  SUBLW  00
1677C:  BC    16782
1677E:  MOVLW  FF
16780:  BRA    1679E
16782:  MOVLB  0
16784:  MOVF   xEB,W
16786:  SUBWF  3B,W
16788:  MOVWF  00
1678A:  MOVF   xEC,W
1678C:  SUBWFB 3C,W
1678E:  MOVWF  01
16790:  MOVF   xED,W
16792:  SUBWFB 3D,W
16794:  MOVWF  02
16796:  MOVF   xEE,W
16798:  SUBWFB 3E,W
1679A:  MOVWF  03
1679C:  MOVF   00,W
1679E:  MOVLB  0
167A0:  MOVWF  xA9
....................         telemetry.com_time = current_time - telemetry_time.com_time > 255 ? 255 : current_time - telemetry_time.com_time; 
167A2:  MOVF   xEF,W
167A4:  SUBWF  3B,W
167A6:  MOVLB  C
167A8:  MOVWF  x4E
167AA:  MOVLB  0
167AC:  MOVF   xF0,W
167AE:  SUBWFB 3C,W
167B0:  MOVLB  C
167B2:  MOVWF  x4F
167B4:  MOVLB  0
167B6:  MOVF   xF1,W
167B8:  SUBWFB 3D,W
167BA:  MOVLB  C
167BC:  MOVWF  x50
167BE:  MOVLB  0
167C0:  MOVF   xF2,W
167C2:  SUBWFB 3E,W
167C4:  MOVLB  C
167C6:  MOVWF  x51
167C8:  BTFSC  FE8.7
167CA:  BRA    167DE
167CC:  MOVF   x51,F
167CE:  BNZ   167DA
167D0:  MOVF   x50,F
167D2:  BNZ   167DA
167D4:  MOVF   x4F,W
167D6:  SUBLW  00
167D8:  BC    167DE
167DA:  MOVLW  FF
167DC:  BRA    167FA
167DE:  MOVLB  0
167E0:  MOVF   xEF,W
167E2:  SUBWF  3B,W
167E4:  MOVWF  00
167E6:  MOVF   xF0,W
167E8:  SUBWFB 3C,W
167EA:  MOVWF  01
167EC:  MOVF   xF1,W
167EE:  SUBWFB 3D,W
167F0:  MOVWF  02
167F2:  MOVF   xF2,W
167F4:  SUBWFB 3E,W
167F6:  MOVWF  03
167F8:  MOVF   00,W
167FA:  MOVLB  0
167FC:  MOVWF  xD2
....................  
....................         // Save telemetry to flash 
....................         uint8_t* telemetry_data = (uint8_t*)&telemetry; 
167FE:  MOVLB  C
16800:  CLRF   x4F
16802:  MOVLW  43
16804:  MOVFF  C4F,C3B
16808:  MOVWF  x3A
....................         flash_cycle_write(&spi_port_COM_FM, telemetry_data, &addr_flags.flash_telemetry); 
1680A:  MOVLW  0A
1680C:  MOVWF  xBF
1680E:  MOVLW  A3
16810:  MOVWF  xBE
16812:  MOVFF  C3B,CC1
16816:  MOVFF  C3A,CC0
1681A:  MOVLW  01
1681C:  MOVWF  xC3
1681E:  MOVLW  31
16820:  MOVWF  xC2
16822:  MOVLB  0
16824:  CALL   6658
....................         fprintf(PC, "Saving telemetry data: "); 
16828:  MOVLW  4A
1682A:  MOVWF  FF6
1682C:  MOVLW  0E
1682E:  MOVWF  FF7
16830:  MOVLW  00
16832:  MOVWF  FF8
16834:  CALL   4534
....................         fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_telemetry.current - sizeof(telemetry)); 
16838:  MOVLW  98
1683A:  MOVLB  1
1683C:  SUBWF  x39,W
1683E:  MOVLB  C
16840:  MOVWF  x4E
16842:  MOVLW  00
16844:  MOVLB  1
16846:  SUBWFB x3A,W
16848:  MOVLB  C
1684A:  MOVWF  x4F
1684C:  MOVLW  00
1684E:  MOVLB  1
16850:  SUBWFB x3B,W
16852:  MOVLB  C
16854:  MOVWF  x50
16856:  MOVLW  00
16858:  MOVLB  1
1685A:  SUBWFB x3C,W
1685C:  MOVLB  C
1685E:  MOVWF  x51
16860:  MOVLW  62
16862:  MOVWF  FF6
16864:  MOVLW  0E
16866:  MOVWF  FF7
16868:  MOVLW  00
1686A:  MOVWF  FF8
1686C:  MOVLW  08
1686E:  MOVWF  xC1
16870:  MOVLB  0
16872:  CALL   5290
16876:  MOVFF  C51,CBF
1687A:  MOVLW  37
1687C:  MOVLB  C
1687E:  MOVWF  xC0
16880:  MOVLB  0
16882:  CALL   5A92
16886:  MOVFF  C50,CBF
1688A:  MOVLW  37
1688C:  MOVLB  C
1688E:  MOVWF  xC0
16890:  MOVLB  0
16892:  CALL   5A92
16896:  MOVFF  C4F,CBF
1689A:  MOVLW  37
1689C:  MOVLB  C
1689E:  MOVWF  xC0
168A0:  MOVLB  0
168A2:  CALL   5A92
168A6:  MOVFF  C4E,CBF
168AA:  MOVLW  37
168AC:  MOVLB  C
168AE:  MOVWF  xC0
168B0:  MOVLB  0
168B2:  CALL   5A92
168B6:  MOVLW  20
168B8:  MOVLB  D
168BA:  MOVWF  x6A
168BC:  MOVLB  0
168BE:  CALL   44EE
....................  
....................         build_cw(); // Prepare CW strings 
168C2:  GOTO   15434
....................         if (verbose) 
168C6:  MOVLB  5
168C8:  MOVF   x5A,F
168CA:  BZ    168D4
....................             deserialize_cw();   // For debug only 
168CC:  MOVLB  0
168CE:  GOTO   15B1C
168D2:  MOVLB  5
....................         initialize_telemetry(); // Reset for next iteration 
168D4:  MOVLB  0
168D6:  CALL   523C
....................  
....................         // Save satellite log to flash 
....................         log_flush(); 
168DA:  BRA    16476
....................  
....................         // Save addresses to flash 
....................         address_rotation addr; 
....................  
....................         uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
168DC:  MOVLW  0C
168DE:  MOVLB  C
168E0:  MOVWF  x4F
168E2:  MOVLW  3C
168E4:  MOVFF  C4F,C4D
168E8:  MOVWF  x4C
....................  
....................         addr.flash_log_current = addr_flags.flash_log.current; 
168EA:  MOVFF  12F,C3F
168EE:  MOVFF  12E,C3E
168F2:  MOVFF  12D,C3D
168F6:  MOVFF  12C,C3C
....................         addr.flash_telemetry_current = addr_flags.flash_telemetry.current; 
168FA:  MOVFF  13C,C43
168FE:  MOVFF  13B,C42
16902:  MOVFF  13A,C41
16906:  MOVFF  139,C40
....................         addr.flash_sel_zes_current = addr_flags.flash_sel_zes.current; 
1690A:  MOVFF  149,C47
1690E:  MOVFF  148,C46
16912:  MOVFF  147,C45
16916:  MOVFF  146,C44
....................         addr.flash_sel_ref_current = addr_flags.flash_sel_ref.current; 
1691A:  MOVFF  156,C4B
1691E:  MOVFF  155,C4A
16922:  MOVFF  154,C49
16926:  MOVFF  153,C48
....................  
....................         flash_cycle_write(&spi_port_COM_FM, addr_flag_ptr, &addr_flags.flash_addr); 
1692A:  MOVLW  0A
1692C:  MOVWF  xBF
1692E:  MOVLW  A3
16930:  MOVWF  xBE
16932:  MOVFF  C4D,CC1
16936:  MOVFF  C4C,CC0
1693A:  MOVLW  01
1693C:  MOVWF  xC3
1693E:  MOVLW  17
16940:  MOVWF  xC2
16942:  MOVLB  0
16944:  CALL   6658
....................         return 0; 
16948:  MOVLW  00
1694A:  MOVWF  01
1694C:  BRA    16968
....................     } else { 
1694E:  BRA    16968
16950:  MOVLB  5
....................         fprintf(PC, "Skipping saving telemetry data."); 
16952:  MOVLW  72
16954:  MOVWF  FF6
16956:  MOVLW  0E
16958:  MOVWF  FF7
1695A:  MOVLW  00
1695C:  MOVWF  FF8
1695E:  MOVLB  0
16960:  CALL   4534
....................         return 1; 
16964:  MOVLW  01
16966:  MOVWF  01
....................     } 
16968:  GOTO   18F0E (RETURN)
.................... } 
....................  
.................... // Change OCP's default state 
.................... uint8_t command_ocp_state(uint8_t* data) 
*
0E7AC:  MOVFF  C39,C3B
0E7B0:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin;     // 0xC0 
....................         uint8_t command;    // 0xAE 
....................         uint8_t on_off;     // 0: off; 1: on 
....................         uint8_t ocp_number; // 0: adcs; 1: MCP; 2: pcib 
....................     }* packet = (struct packet*)data; 
....................  
....................     enum { 
....................         ocp_adcs = 0, 
....................         ocp_MCP = 1, 
....................         ocp_relay = 2 
....................     }; 
....................  
....................     switch (packet->ocp_number) { 
0E7B4:  MOVLW  03
0E7B6:  MOVLB  C
0E7B8:  ADDWF  x3A,W
0E7BA:  MOVWF  FE9
0E7BC:  MOVLW  00
0E7BE:  ADDWFC x3B,W
0E7C0:  MOVWF  FEA
0E7C2:  MOVF   FEF,W
0E7C4:  XORLW  00
0E7C6:  MOVLB  0
0E7C8:  BZ    E7D4
0E7CA:  XORLW  01
0E7CC:  BZ    E81E
0E7CE:  XORLW  03
0E7D0:  BZ    E868
0E7D2:  BRA    E8B2
....................     case ocp_adcs: 
....................         output_bit(OCP_EN_ADCS, packet->on_off); 
0E7D4:  MOVLW  02
0E7D6:  MOVLB  C
0E7D8:  ADDWF  x3A,W
0E7DA:  MOVWF  FE9
0E7DC:  MOVLW  00
0E7DE:  ADDWFC x3B,W
0E7E0:  MOVWF  FEA
0E7E2:  MOVF   FEF,F
0E7E4:  BNZ   E7EA
0E7E6:  BCF    F8E.7
0E7E8:  BRA    E7EC
0E7EA:  BSF    F8E.7
0E7EC:  BCF    F97.7
....................         obc_flags.adcs_on_off = packet->on_off; 
0E7EE:  MOVLW  02
0E7F0:  ADDWF  x3A,W
0E7F2:  MOVWF  FE9
0E7F4:  MOVLW  00
0E7F6:  ADDWFC x3B,W
0E7F8:  MOVWF  FEA
0E7FA:  MOVFF  FEF,101
....................         save_state(data[1]); // data[1] is the current command id 
0E7FE:  MOVLW  01
0E800:  ADDWF  x38,W
0E802:  MOVWF  FE9
0E804:  MOVLW  00
0E806:  ADDWFC x39,W
0E808:  MOVWF  FEA
0E80A:  MOVFF  FEF,C60
0E80E:  MOVLB  0
0E810:  CALL   8CAE
....................         return obc_flags.adcs_on_off; 
0E814:  MOVLB  1
0E816:  MOVFF  101,01
0E81A:  BRA    E8B8
0E81C:  MOVLB  0
....................     case ocp_MCP: 
....................         output_bit(OCP_EN_MCP, packet->on_off); 
0E81E:  MOVLW  02
0E820:  MOVLB  C
0E822:  ADDWF  x3A,W
0E824:  MOVWF  FE9
0E826:  MOVLW  00
0E828:  ADDWFC x3B,W
0E82A:  MOVWF  FEA
0E82C:  MOVF   FEF,F
0E82E:  BNZ   E834
0E830:  BCF    F8C.6
0E832:  BRA    E836
0E834:  BSF    F8C.6
0E836:  BCF    F95.6
....................         obc_flags.MCP_on_off = packet->on_off; 
0E838:  MOVLW  02
0E83A:  ADDWF  x3A,W
0E83C:  MOVWF  FE9
0E83E:  MOVLW  00
0E840:  ADDWFC x3B,W
0E842:  MOVWF  FEA
0E844:  MOVFF  FEF,102
....................         save_state(data[1]); // data[1] is the current command id 
0E848:  MOVLW  01
0E84A:  ADDWF  x38,W
0E84C:  MOVWF  FE9
0E84E:  MOVLW  00
0E850:  ADDWFC x39,W
0E852:  MOVWF  FEA
0E854:  MOVFF  FEF,C60
0E858:  MOVLB  0
0E85A:  CALL   8CAE
....................         return obc_flags.MCP_on_off; 
0E85E:  MOVLB  1
0E860:  MOVFF  102,01
0E864:  BRA    E8B8
0E866:  MOVLB  0
....................     case ocp_relay: 
....................         output_bit(OCP_EN_RELAY, packet->on_off); 
0E868:  MOVLW  02
0E86A:  MOVLB  C
0E86C:  ADDWF  x3A,W
0E86E:  MOVWF  FE9
0E870:  MOVLW  00
0E872:  ADDWFC x3B,W
0E874:  MOVWF  FEA
0E876:  MOVF   FEF,F
0E878:  BNZ   E87E
0E87A:  BCF    F8F.0
0E87C:  BRA    E880
0E87E:  BSF    F8F.0
0E880:  BCF    F98.0
....................         obc_flags.relay_on_off = packet->on_off; 
0E882:  MOVLW  02
0E884:  ADDWF  x3A,W
0E886:  MOVWF  FE9
0E888:  MOVLW  00
0E88A:  ADDWFC x3B,W
0E88C:  MOVWF  FEA
0E88E:  MOVFF  FEF,10B
....................         save_state(data[1]); // data[1] is the current command id 
0E892:  MOVLW  01
0E894:  ADDWF  x38,W
0E896:  MOVWF  FE9
0E898:  MOVLW  00
0E89A:  ADDWFC x39,W
0E89C:  MOVWF  FEA
0E89E:  MOVFF  FEF,C60
0E8A2:  MOVLB  0
0E8A4:  CALL   8CAE
....................         return obc_flags.relay_on_off; 
0E8A8:  MOVLB  1
0E8AA:  MOVFF  10B,01
0E8AE:  BRA    E8B8
0E8B0:  MOVLB  0
....................     } 
....................  
....................     return -1; 
0E8B2:  MOVLW  FF
0E8B4:  MOVWF  01
0E8B6:  MOVLB  1
0E8B8:  MOVLB  0
0E8BA:  GOTO   18C7A (RETURN)
.................... } 
....................  
.................... // void boot_commands_clear_nth(uint8_t n) 
.................... uint8_t command_boot_cmd_clear_nth(uint8_t* data) 
*
0C0F0:  MOVFF  C39,C3B
0C0F4:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t n; 
....................     }* packet = (struct packet*)data; 
....................     boot_commands_clear_nth(packet->n); 
0C0F8:  MOVLW  02
0C0FA:  MOVLB  C
0C0FC:  ADDWF  x3A,W
0C0FE:  MOVWF  FE9
0C100:  MOVLW  00
0C102:  ADDWFC x3B,W
0C104:  MOVWF  FEA
0C106:  MOVFF  FEF,C3D
0C10A:  MOVLB  0
0C10C:  CALL   65BA
....................     boot_commands_write(); 
0C110:  CALL   6602
....................     return 0; 
0C114:  MOVLW  00
0C116:  MOVWF  01
0C118:  GOTO   189BC (RETURN)
.................... } 
....................  
.................... // void boot_commands_clear_all() 
.................... uint8_t command_boot_cmd_clear_all(uint8_t* data) 
.................... { 
....................     boot_commands_clear_all(); 
0C11C:  CALL   65E6
....................     boot_commands_write(); 
0C120:  CALL   6602
....................     return 0; 
0C124:  MOVLW  00
0C126:  MOVWF  01
0C128:  GOTO   189CE (RETURN)
.................... } 
....................  
.................... // Add a boot command 
.................... uint8_t command_boot_cmd_add(uint8_t* data) 
*
0C1B6:  MOVFF  C39,C3B
0C1BA:  MOVFF  C38,C3A
.................... { 
....................     enum { length = MSG_LENGTH_COMM - 13 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t delay_from_boot; 
....................         uint8_t new_boot_cmd[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     boot_command bc; 
....................     bc.time = packet->delay_from_boot; 
0C1BE:  MOVLW  02
0C1C0:  MOVLB  C
0C1C2:  ADDWF  x3A,W
0C1C4:  MOVWF  FE9
0C1C6:  MOVLW  00
0C1C8:  ADDWFC x3B,W
0C1CA:  MOVWF  FEA
0C1CC:  MOVFF  FEF,C3C
0C1D0:  MOVFF  FEC,C3D
0C1D4:  MOVFF  FEC,C3E
0C1D8:  MOVFF  FEC,C3F
....................     memcpy(bc.command, packet->new_boot_cmd, length); 
0C1DC:  MOVLW  06
0C1DE:  ADDWF  x3A,W
0C1E0:  MOVWF  01
0C1E2:  MOVLW  00
0C1E4:  ADDWFC x3B,W
0C1E6:  MOVWF  03
0C1E8:  MOVFF  01,C5C
0C1EC:  MOVWF  x5D
0C1EE:  MOVLW  0C
0C1F0:  MOVWF  FEA
0C1F2:  MOVLW  40
0C1F4:  MOVWF  FE9
0C1F6:  MOVFF  03,FE2
0C1FA:  MOVFF  01,FE1
0C1FE:  MOVLW  0C
0C200:  MOVWF  01
0C202:  MOVFF  FE6,FEE
0C206:  DECFSZ 01,F
0C208:  BRA    C202
....................     boot_commands_add(bc); 
0C20A:  MOVFF  C3C,C5C
0C20E:  MOVFF  C3D,C5D
0C212:  MOVFF  C3E,C5E
0C216:  MOVFF  C3F,C5F
0C21A:  MOVFF  C40,C60
0C21E:  MOVFF  C41,C61
0C222:  MOVFF  C42,C62
0C226:  MOVFF  C43,C63
0C22A:  MOVFF  C44,C64
0C22E:  MOVFF  C45,C65
0C232:  MOVFF  C46,C66
0C236:  MOVFF  C47,C67
0C23A:  MOVFF  C48,C68
0C23E:  MOVFF  C49,C69
0C242:  MOVFF  C4A,C6A
0C246:  MOVFF  C4B,C6B
0C24A:  MOVFF  C4C,C6C
0C24E:  MOVFF  C4D,C6D
0C252:  MOVFF  C4E,C6E
0C256:  MOVFF  C4F,C6F
0C25A:  MOVFF  C50,C70
0C25E:  MOVFF  C51,C71
0C262:  MOVFF  C52,C72
0C266:  MOVFF  C53,C73
0C26A:  MOVFF  C54,C74
0C26E:  MOVFF  C55,C75
0C272:  MOVFF  C56,C76
0C276:  MOVFF  C57,C77
0C27A:  MOVFF  C58,C78
0C27E:  MOVFF  C59,C79
0C282:  MOVFF  C5A,C7A
0C286:  MOVFF  C5B,C7B
0C28A:  MOVLB  0
0C28C:  BRA    C12C
....................     boot_commands_write(); 
0C28E:  CALL   6602
....................  
....................     return 0; 
0C292:  MOVLW  00
0C294:  MOVWF  01
0C296:  GOTO   189E0 (RETURN)
.................... } 
....................  
.................... // ============ Reset Commands ============ 
....................  
.................... // Reset pic telemetry data 
.................... uint8_t command_reset_telemetry(uint8_t* data) 
.................... { 
....................     response_rx = 1; // Received a reply 
*
087A4:  MOVLW  01
087A6:  MOVLB  7
087A8:  MOVWF  x50
....................     struct packet { 
....................         uint8_t message[MSG_LENGTH_RST - 10]; 
....................         uint8_t padding[9]; // empty part 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
087AA:  MOVFF  C39,C3B
087AE:  MOVFF  C38,C3A
....................  
....................     fprintf(PC, "RESET: "); 
087B2:  MOVLW  92
087B4:  MOVWF  FF6
087B6:  MOVLW  0E
087B8:  MOVWF  FF7
087BA:  MOVLW  00
087BC:  MOVWF  FF8
087BE:  MOVLB  0
087C0:  CALL   4534
....................     uart_print_pc_hex(data, MSG_LENGTH_RST); 
087C4:  MOVFF  C39,C90
087C8:  MOVFF  C38,C8F
087CC:  MOVLW  24
087CE:  MOVLB  C
087D0:  MOVWF  x91
087D2:  MOVLB  0
087D4:  CALL   7A5C
....................  
....................     if (rst_clock_update) { 
087D8:  MOVLB  7
087DA:  MOVF   x55,F
087DC:  BTFSC  FD8.2
087DE:  BRA    8C64
....................         rst_clock_updated = 1; 
087E0:  MOVLW  01
087E2:  MOVWF  x56
....................         rst_clock_update = 0; 
087E4:  CLRF   x55
....................         struct_tm rst_time; 
....................         rst_time.tm_year = (unsigned long)packet->message[2] + 100; 
087E6:  MOVLW  02
087E8:  MOVLB  C
087EA:  ADDWF  x3A,W
087EC:  MOVWF  FE9
087EE:  MOVLW  00
087F0:  ADDWFC x3B,W
087F2:  MOVWF  FEA
087F4:  MOVF   FEF,W
087F6:  CLRF   x50
087F8:  MOVWF  x4F
087FA:  MOVLW  64
087FC:  ADDWF  x4F,W
087FE:  MOVWF  x41
08800:  MOVLW  00
08802:  ADDWFC x50,W
08804:  MOVWF  x42
....................         rst_time.tm_mon = (unsigned long)packet->message[3] - 1; 
08806:  MOVLW  03
08808:  ADDWF  x3A,W
0880A:  MOVWF  FE9
0880C:  MOVLW  00
0880E:  ADDWFC x3B,W
08810:  MOVWF  FEA
08812:  MOVF   FEF,W
08814:  MOVWF  x4F
08816:  MOVLW  01
08818:  SUBWF  x4F,W
0881A:  MOVWF  x40
....................         rst_time.tm_mday = (unsigned long)packet->message[4]; 
0881C:  MOVLW  04
0881E:  ADDWF  x3A,W
08820:  MOVWF  FE9
08822:  MOVLW  00
08824:  ADDWFC x3B,W
08826:  MOVWF  FEA
08828:  MOVFF  FEF,C3F
....................         rst_time.tm_hour = (unsigned long)packet->message[5]; 
0882C:  MOVLW  05
0882E:  ADDWF  x3A,W
08830:  MOVWF  FE9
08832:  MOVLW  00
08834:  ADDWFC x3B,W
08836:  MOVWF  FEA
08838:  MOVFF  FEF,C3E
....................         rst_time.tm_min = (unsigned long)packet->message[6]; 
0883C:  MOVLW  06
0883E:  ADDWF  x3A,W
08840:  MOVWF  FE9
08842:  MOVLW  00
08844:  ADDWFC x3B,W
08846:  MOVWF  FEA
08848:  MOVFF  FEF,C3D
....................         rst_time.tm_sec = (unsigned long)packet->message[7] + 1; 
0884C:  MOVLW  07
0884E:  ADDWF  x3A,W
08850:  MOVWF  FE9
08852:  MOVLW  00
08854:  ADDWFC x3B,W
08856:  MOVWF  FEA
08858:  MOVF   FEF,W
0885A:  MOVWF  x4F
0885C:  MOVLW  01
0885E:  ADDWF  x4F,W
08860:  MOVWF  x3C
....................         SetTime(&rst_time); 
08862:  MOVLW  0C
08864:  MOVWF  x50
08866:  MOVLW  3C
08868:  MOVWF  x4F
0886A:  MOVLB  0
0886C:  BRA    8594
....................         time_t new_time = mktime(&rst_time); 
0886E:  MOVLW  0C
08870:  MOVLB  C
08872:  MOVWF  x65
08874:  MOVLW  3C
08876:  MOVWF  x64
08878:  MOVLB  0
0887A:  CALL   4810
0887E:  MOVFF  03,C49
08882:  MOVFF  02,C48
08886:  MOVFF  01,C47
0888A:  MOVFF  00,C46
....................         // mai_400_update_clock(new_time); 
....................         current_time = new_time; 
0888E:  MOVFF  C49,3E
08892:  MOVFF  C48,3D
08896:  MOVFF  C47,3C
0889A:  MOVFF  C46,3B
....................         previous_time = new_time; 
0889E:  MOVFF  C49,42
088A2:  MOVFF  C48,41
088A6:  MOVFF  C47,40
088AA:  MOVFF  C46,3F
....................         reset_time = new_time; 
088AE:  MOVFF  C49,754
088B2:  MOVFF  C48,753
088B6:  MOVFF  C47,752
088BA:  MOVFF  C46,751
....................         // Read stored commands from memory 
....................         get_com_shared_fm_access(); 
088BE:  RCALL  8672
....................         uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
088C0:  MOVLW  01
088C2:  MOVLB  C
088C4:  MOVWF  x50
088C6:  MOVLW  5A
088C8:  MOVFF  C50,C4B
088CC:  MOVWF  x4A
....................         flash_transfer_data_to_ram( 
....................             &spi_port_COM_FM, 
....................             SCHEDULED_CMD_ADDRESS, 
....................             cmd_ptr, 
....................             sizeof(scheduled_commands)); 
088CE:  MOVLW  0A
088D0:  MOVLB  D
088D2:  MOVWF  x4C
088D4:  MOVLW  A3
088D6:  MOVWF  x4B
088D8:  CLRF   x50
088DA:  CLRF   x4F
088DC:  MOVLW  30
088DE:  MOVWF  x4E
088E0:  CLRF   x4D
088E2:  MOVFF  C4B,D52
088E6:  MOVFF  C4A,D51
088EA:  CLRF   x56
088EC:  CLRF   x55
088EE:  MOVLW  04
088F0:  MOVWF  x54
088F2:  CLRF   x53
088F4:  MOVLB  0
088F6:  CALL   57C8
....................         // Remove scheduled commads that are scheduled to run in the past 
....................         for(uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
088FA:  MOVLB  C
088FC:  CLRF   x4C
088FE:  MOVF   x4C,W
08900:  SUBLW  1F
08902:  BTFSS  FD8.0
08904:  BRA    8A86
....................             if(scheduled_commands[i].time < current_time + 1800L) { 
08906:  CLRF   xC4
08908:  MOVFF  C4C,CC3
0890C:  CLRF   xC6
0890E:  MOVLW  20
08910:  MOVWF  xC5
08912:  MOVLB  0
08914:  CALL   4D06
08918:  MOVFF  02,C50
0891C:  MOVFF  01,C4F
08920:  MOVLW  5A
08922:  MOVLB  C
08924:  ADDWF  01,W
08926:  MOVWF  FE9
08928:  MOVLW  01
0892A:  ADDWFC 02,W
0892C:  MOVWF  FEA
0892E:  MOVFF  FEF,C51
08932:  MOVFF  FEC,C52
08936:  MOVFF  FEC,C53
0893A:  MOVFF  FEC,C54
0893E:  MOVLW  08
08940:  ADDWF  3B,W
08942:  MOVWF  00
08944:  MOVLW  07
08946:  ADDWFC 3C,W
08948:  MOVWF  01
0894A:  MOVLW  00
0894C:  ADDWFC 3D,W
0894E:  MOVWF  02
08950:  MOVLW  00
08952:  ADDWFC 3E,W
08954:  MOVWF  03
08956:  BTFSS  x54.7
08958:  BRA    8960
0895A:  BTFSS  03.7
0895C:  BRA    8988
0895E:  BRA    8964
08960:  BTFSC  03.7
08962:  BRA    8A82
08964:  MOVF   x54,W
08966:  SUBWF  03,W
08968:  BTFSS  FD8.0
0896A:  BRA    8A82
0896C:  BNZ   8988
0896E:  MOVF   x53,W
08970:  SUBWF  02,W
08972:  BTFSS  FD8.0
08974:  BRA    8A82
08976:  BNZ   8988
08978:  MOVF   x52,W
0897A:  SUBWF  01,W
0897C:  BTFSS  FD8.0
0897E:  BRA    8A82
08980:  BNZ   8988
08982:  MOVF   00,W
08984:  SUBWF  x51,W
08986:  BC    8A82
....................                 scheduled_commands[i].time = TIME_T_MAX; 
08988:  CLRF   xC4
0898A:  MOVFF  C4C,CC3
0898E:  CLRF   xC6
08990:  MOVLW  20
08992:  MOVWF  xC5
08994:  MOVLB  0
08996:  CALL   4D06
0899A:  MOVLW  5A
0899C:  MOVLB  C
0899E:  ADDWF  01,W
089A0:  MOVWF  FE9
089A2:  MOVLW  01
089A4:  ADDWFC 02,W
089A6:  MOVWF  FEA
089A8:  SETF   FEF
089AA:  SETF   FEC
089AC:  SETF   FEC
089AE:  MOVLW  7F
089B0:  MOVWF  FEC
....................                 fprintf(PC, "\r\nWarning: a scheduled command (%02X %02X) in flash memory was scheduled to run in a past date/time and was marked as complete.\r\n", scheduled_commands[i].command[0], scheduled_commands[i].command[1]); 
089B2:  CLRF   xC4
089B4:  MOVFF  C4C,CC3
089B8:  CLRF   xC6
089BA:  MOVLW  20
089BC:  MOVWF  xC5
089BE:  MOVLB  0
089C0:  CALL   4D06
089C4:  MOVFF  02,C50
089C8:  MOVFF  01,C4F
089CC:  MOVLW  04
089CE:  MOVLB  C
089D0:  ADDWF  x4F,F
089D2:  MOVLW  00
089D4:  ADDWFC x50,F
089D6:  MOVLW  5A
089D8:  ADDWF  x4F,W
089DA:  MOVWF  FE9
089DC:  MOVLW  01
089DE:  ADDWFC x50,W
089E0:  MOVWF  FEA
089E2:  MOVFF  FEF,C51
089E6:  CLRF   xC4
089E8:  MOVFF  C4C,CC3
089EC:  CLRF   xC6
089EE:  MOVLW  20
089F0:  MOVWF  xC5
089F2:  MOVLB  0
089F4:  CALL   4D06
089F8:  MOVFF  02,C53
089FC:  MOVFF  01,C52
08A00:  MOVLW  04
08A02:  MOVLB  C
08A04:  ADDWF  x52,F
08A06:  MOVLW  00
08A08:  ADDWFC x53,F
08A0A:  MOVLW  01
08A0C:  ADDWF  x52,W
08A0E:  MOVWF  01
08A10:  MOVLW  00
08A12:  ADDWFC x53,W
08A14:  MOVWF  03
08A16:  MOVF   01,W
08A18:  ADDLW  5A
08A1A:  MOVWF  FE9
08A1C:  MOVLW  01
08A1E:  ADDWFC 03,W
08A20:  MOVWF  FEA
08A22:  MOVFF  FEF,C52
08A26:  MOVLW  9A
08A28:  MOVWF  FF6
08A2A:  MOVLW  0E
08A2C:  MOVWF  FF7
08A2E:  MOVLW  00
08A30:  MOVWF  FF8
08A32:  MOVLW  20
08A34:  MOVWF  xC1
08A36:  MOVLB  0
08A38:  CALL   5290
08A3C:  MOVFF  C51,CBF
08A40:  MOVLW  37
08A42:  MOVLB  C
08A44:  MOVWF  xC0
08A46:  MOVLB  0
08A48:  CALL   5A92
08A4C:  MOVLW  20
08A4E:  MOVLB  D
08A50:  MOVWF  x6A
08A52:  MOVLB  0
08A54:  CALL   44EE
08A58:  MOVFF  C52,CBF
08A5C:  MOVLW  37
08A5E:  MOVLB  C
08A60:  MOVWF  xC0
08A62:  MOVLB  0
08A64:  CALL   5A92
08A68:  MOVLW  C3
08A6A:  MOVWF  FF6
08A6C:  MOVLW  0E
08A6E:  MOVWF  FF7
08A70:  MOVLW  00
08A72:  MOVWF  FF8
08A74:  MOVLW  58
08A76:  MOVLB  C
08A78:  MOVWF  xC1
08A7A:  MOVLB  0
08A7C:  CALL   5290
08A80:  MOVLB  C
....................             } 
08A82:  INCF   x4C,F
08A84:  BRA    88FE
....................         } 
....................         // Read and schedule boot commands 
....................         boot_commands_schedule(); 
08A86:  MOVLB  0
08A88:  BRA    8694
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
08A8A:  MOVLW  02
08A8C:  MOVLB  C
08A8E:  MOVWF  x4F
08A90:  MOVFF  FF,C50
08A94:  MOVFF  13C,C54
08A98:  MOVFF  13B,C53
08A9C:  MOVFF  13A,C52
08AA0:  MOVFF  139,C51
08AA4:  CLRF   x58
08AA6:  MOVLW  11
08AA8:  MOVWF  x57
08AAA:  CLRF   x56
08AAC:  CLRF   x55
08AAE:  CLRF   x5C
08AB0:  CLRF   x5B
08AB2:  CLRF   x5A
08AB4:  MOVLW  98
08AB6:  MOVWF  x59
08AB8:  MOVLW  01
08ABA:  MOVWF  x5D
08ABC:  MOVWF  x5F
08ABE:  MOVLW  31
08AC0:  MOVWF  x5E
08AC2:  MOVLB  0
08AC4:  CALL   5B62
....................  
....................         struct_tm* local_time = localtime(&current_time); 
08AC8:  MOVLB  C
08ACA:  CLRF   x84
08ACC:  MOVLW  3B
08ACE:  MOVWF  x83
08AD0:  MOVLB  0
08AD2:  CALL   4D28
08AD6:  MOVFF  02,C4E
08ADA:  MOVFF  01,C4D
....................         fprintf(PC, " New time: %04ld/%02d/%02d %02d:%02d:%02d (0x%08lX)", 
....................             local_time->tm_year + 1900, 
....................             (uint8_t)local_time->tm_mon + 1, 
....................             local_time->tm_mday, 
....................             local_time->tm_hour, 
....................             local_time->tm_min, 
....................             local_time->tm_sec, 
....................             current_time); 
08ADE:  MOVLW  05
08AE0:  MOVLB  C
08AE2:  ADDWF  x4D,W
08AE4:  MOVWF  FE9
08AE6:  MOVLW  00
08AE8:  ADDWFC x4E,W
08AEA:  MOVWF  FEA
08AEC:  MOVFF  FEC,C50
08AF0:  MOVF   FED,F
08AF2:  MOVFF  FEF,C4F
08AF6:  MOVLW  6C
08AF8:  ADDWF  x4F,F
08AFA:  MOVLW  07
08AFC:  ADDWFC x50,F
08AFE:  MOVLW  04
08B00:  ADDWF  x4D,W
08B02:  MOVWF  FE9
08B04:  MOVLW  00
08B06:  ADDWFC x4E,W
08B08:  MOVWF  FEA
08B0A:  MOVLW  01
08B0C:  ADDWF  FEF,W
08B0E:  MOVWF  x51
08B10:  MOVLW  03
08B12:  ADDWF  x4D,W
08B14:  MOVWF  FE9
08B16:  MOVLW  00
08B18:  ADDWFC x4E,W
08B1A:  MOVWF  FEA
08B1C:  MOVFF  FEF,C52
08B20:  MOVLW  02
08B22:  ADDWF  x4D,W
08B24:  MOVWF  FE9
08B26:  MOVLW  00
08B28:  ADDWFC x4E,W
08B2A:  MOVWF  FEA
08B2C:  MOVFF  FEF,C53
08B30:  MOVLW  01
08B32:  ADDWF  x4D,W
08B34:  MOVWF  FE9
08B36:  MOVLW  00
08B38:  ADDWFC x4E,W
08B3A:  MOVWF  FEA
08B3C:  MOVFF  FEF,C54
08B40:  MOVFF  C4D,FE9
08B44:  MOVFF  C4E,FEA
08B48:  MOVFF  FEF,C55
08B4C:  MOVLW  1C
08B4E:  MOVWF  FF6
08B50:  MOVLW  0F
08B52:  MOVWF  FF7
08B54:  MOVLW  00
08B56:  MOVWF  FF8
08B58:  MOVLW  0B
08B5A:  MOVWF  xC1
08B5C:  MOVLB  0
08B5E:  CALL   5290
08B62:  MOVLW  0A
08B64:  MOVWF  FE9
08B66:  MOVFF  C50,C66
08B6A:  MOVFF  C4F,C65
08B6E:  CALL   7894
08B72:  MOVLW  2F
08B74:  MOVLB  D
08B76:  MOVWF  x6A
08B78:  MOVLB  0
08B7A:  CALL   44EE
08B7E:  MOVFF  C51,C65
08B82:  MOVLW  01
08B84:  MOVLB  C
08B86:  MOVWF  x66
08B88:  MOVLB  0
08B8A:  CALL   7994
08B8E:  MOVLW  2F
08B90:  MOVLB  D
08B92:  MOVWF  x6A
08B94:  MOVLB  0
08B96:  CALL   44EE
08B9A:  MOVFF  C52,C65
08B9E:  MOVLW  01
08BA0:  MOVLB  C
08BA2:  MOVWF  x66
08BA4:  MOVLB  0
08BA6:  CALL   7994
08BAA:  MOVLW  20
08BAC:  MOVLB  D
08BAE:  MOVWF  x6A
08BB0:  MOVLB  0
08BB2:  CALL   44EE
08BB6:  MOVFF  C53,C65
08BBA:  MOVLW  01
08BBC:  MOVLB  C
08BBE:  MOVWF  x66
08BC0:  MOVLB  0
08BC2:  CALL   7994
08BC6:  MOVLW  3A
08BC8:  MOVLB  D
08BCA:  MOVWF  x6A
08BCC:  MOVLB  0
08BCE:  CALL   44EE
08BD2:  MOVFF  C54,C65
08BD6:  MOVLW  01
08BD8:  MOVLB  C
08BDA:  MOVWF  x66
08BDC:  MOVLB  0
08BDE:  CALL   7994
08BE2:  MOVLW  3A
08BE4:  MOVLB  D
08BE6:  MOVWF  x6A
08BE8:  MOVLB  0
08BEA:  CALL   44EE
08BEE:  MOVFF  C55,C65
08BF2:  MOVLW  01
08BF4:  MOVLB  C
08BF6:  MOVWF  x66
08BF8:  MOVLB  0
08BFA:  CALL   7994
08BFE:  MOVLW  45
08C00:  MOVWF  FF6
08C02:  MOVLW  0F
08C04:  MOVWF  FF7
08C06:  MOVLW  00
08C08:  MOVWF  FF8
08C0A:  MOVLW  04
08C0C:  MOVLB  C
08C0E:  MOVWF  xC1
08C10:  MOVLB  0
08C12:  CALL   5290
08C16:  MOVFF  3E,CBF
08C1A:  MOVLW  37
08C1C:  MOVLB  C
08C1E:  MOVWF  xC0
08C20:  MOVLB  0
08C22:  CALL   5A92
08C26:  MOVFF  3D,CBF
08C2A:  MOVLW  37
08C2C:  MOVLB  C
08C2E:  MOVWF  xC0
08C30:  MOVLB  0
08C32:  CALL   5A92
08C36:  MOVFF  3C,CBF
08C3A:  MOVLW  37
08C3C:  MOVLB  C
08C3E:  MOVWF  xC0
08C40:  MOVLB  0
08C42:  CALL   5A92
08C46:  MOVFF  3B,CBF
08C4A:  MOVLW  37
08C4C:  MOVLB  C
08C4E:  MOVWF  xC0
08C50:  MOVLB  0
08C52:  CALL   5A92
08C56:  MOVLW  29
08C58:  MOVLB  D
08C5A:  MOVWF  x6A
08C5C:  MOVLB  0
08C5E:  CALL   44EE
08C62:  MOVLB  7
....................     } 
....................  
....................     telemetry_time.reset_time = current_time; 
08C64:  MOVFF  3E,DE
08C68:  MOVFF  3D,DD
08C6C:  MOVFF  3C,DC
08C70:  MOVFF  3B,DB
....................     memcpy(telemetry.reset_message, packet->message + 2, sizeof(telemetry.reset_message)); 
08C74:  MOVLB  C
08C76:  MOVFF  C3B,03
08C7A:  MOVFF  C3A,C4F
08C7E:  MOVFF  C3B,C50
08C82:  MOVLW  02
08C84:  ADDWF  x4F,F
08C86:  MOVLW  00
08C88:  ADDWFC x50,F
08C8A:  CLRF   FEA
08C8C:  MOVLW  44
08C8E:  MOVWF  FE9
08C90:  MOVFF  C50,FE2
08C94:  MOVFF  C4F,FE1
08C98:  MOVLW  18
08C9A:  MOVWF  01
08C9C:  MOVFF  FE6,FEE
08CA0:  DECFSZ 01,F
08CA2:  BRA    8C9C
....................     return rst_clock_updated; 
08CA4:  MOVLB  7
08CA6:  MOVF   x56,W
08CA8:  MOVWF  01
08CAA:  MOVLB  0
08CAC:  RETURN 0
.................... } 
....................  
.................... // Warn that 24-hour reset is about to happen 
.................... uint8_t command_reset_warning(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................  
....................     // uint8_t adcs_cmd[] = { 0x22 }; 
....................     // mai_400_command(adcs_cmd, sizeof(adcs_cmd)); 
....................  
....................     save_state(data[1]); // data[1] is the current command id 
*
08F9A:  MOVLW  01
08F9C:  MOVLB  C
08F9E:  ADDWF  x38,W
08FA0:  MOVWF  FE9
08FA2:  MOVLW  00
08FA4:  ADDWFC x39,W
08FA6:  MOVWF  FEA
08FA8:  MOVFF  FEF,C60
08FAC:  MOVLB  0
08FAE:  RCALL  8CAE
....................  
....................     // Reply: 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
08FB0:  MOVLB  C
08FB2:  CLRF   x3A
08FB4:  MOVF   x3A,W
08FB6:  SUBLW  23
08FB8:  BNC   8FCE
....................         fputc(cmd[i], RST); 
08FBA:  CLRF   03
08FBC:  MOVF   x3A,W
08FBE:  MOVLB  0
08FC0:  CALL   01CC
08FC4:  CALL   544E
08FC8:  MOVLB  C
08FCA:  INCF   x3A,F
08FCC:  BRA    8FB4
....................     } 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
08FCE:  MOVLW  06
08FD0:  MOVWF  xBE
08FD2:  MOVLB  0
08FD4:  CALL   52E8
08FD8:  MOVF   01,W
08FDA:  SUBLW  06
08FDC:  BZ    9000
....................         if (verbose) { 
08FDE:  MOVLB  5
08FE0:  MOVF   x5A,F
08FE2:  BZ    8FF8
....................             fprintf(PC, "MUX change failed!"); 
08FE4:  MOVLW  50
08FE6:  MOVWF  FF6
08FE8:  MOVLW  0F
08FEA:  MOVWF  FF7
08FEC:  MOVLW  00
08FEE:  MOVWF  FF8
08FF0:  MOVLB  0
08FF2:  CALL   4534
08FF6:  MOVLB  5
....................         } 
....................         return 1; 
08FF8:  MOVLW  01
08FFA:  MOVWF  01
08FFC:  BRA    90EA
08FFE:  MOVLB  0
....................     } 
....................  
....................     uint8_t relay_warning[MSG_LENGTH_PCIB] = { 0 }; 
09000:  MOVLB  C
09002:  CLRF   x3B
09004:  CLRF   x3C
09006:  CLRF   x3D
09008:  CLRF   x3E
0900A:  CLRF   x3F
0900C:  CLRF   x40
0900E:  CLRF   x41
09010:  CLRF   x42
09012:  CLRF   x43
09014:  CLRF   x44
09016:  CLRF   x45
09018:  CLRF   x46
0901A:  CLRF   x47
0901C:  CLRF   x48
0901E:  CLRF   x49
09020:  CLRF   x4A
09022:  CLRF   x4B
09024:  CLRF   x4C
09026:  CLRF   x4D
09028:  CLRF   x4E
0902A:  CLRF   x4F
0902C:  CLRF   x50
0902E:  CLRF   x51
09030:  CLRF   x52
09032:  CLRF   x53
09034:  CLRF   x54
09036:  CLRF   x55
09038:  CLRF   x56
0903A:  CLRF   x57
0903C:  CLRF   x58
0903E:  CLRF   x59
09040:  CLRF   x5A
09042:  CLRF   x5B
09044:  CLRF   x5C
09046:  CLRF   x5D
09048:  CLRF   x5E
....................     relay_warning[0] = MSG_OBC; 
0904A:  MOVLW  0B
0904C:  MOVWF  x3B
....................     relay_warning[1] = 0xFF; // Reset warning 
0904E:  SETF   x3C
....................     checksum_obc(relay_warning, sizeof(relay_warning)); 
09050:  MOVLW  0C
09052:  MOVWF  xAF
09054:  MOVLW  3B
09056:  MOVWF  xAE
09058:  MOVLW  24
0905A:  MOVWF  xB0
0905C:  MOVLB  0
0905E:  RCALL  8E80
....................     uart_send_packet_repeat(&uart_port_MSN, relay_warning, sizeof(relay_warning), 5, 100000); 
09060:  MOVLW  0A
09062:  MOVLB  C
09064:  MOVWF  xAF
09066:  MOVLW  97
09068:  MOVWF  xAE
0906A:  MOVLW  0C
0906C:  MOVWF  xB1
0906E:  MOVLW  3B
09070:  MOVWF  xB0
09072:  CLRF   xB5
09074:  CLRF   xB4
09076:  CLRF   xB3
09078:  MOVLW  24
0907A:  MOVWF  xB2
0907C:  MOVLW  05
0907E:  MOVWF  xB6
09080:  CLRF   xBA
09082:  MOVLW  01
09084:  MOVWF  xB9
09086:  MOVLW  86
09088:  MOVWF  xB8
0908A:  MOVLW  A0
0908C:  MOVWF  xB7
0908E:  MOVLB  0
09090:  RCALL  8F3C
....................  
....................     fprintf(PC, "Waiting for 24h reset...\r\n"); 
09092:  MOVLW  64
09094:  MOVWF  FF6
09096:  MOVLW  0F
09098:  MOVWF  FF7
0909A:  MOVLW  00
0909C:  MOVWF  FF8
0909E:  CALL   4534
....................     delay_ms(60000); 
090A2:  MOVLW  F0
090A4:  MOVLB  C
090A6:  MOVWF  x5F
090A8:  MOVLW  FA
090AA:  MOVLB  D
090AC:  MOVWF  x52
090AE:  MOVLB  0
090B0:  CALL   5266
090B4:  MOVLB  C
090B6:  DECFSZ x5F,F
090B8:  BRA    90A8
....................     delay_ms(60000); 
090BA:  MOVLW  F0
090BC:  MOVWF  x5F
090BE:  MOVLW  FA
090C0:  MOVLB  D
090C2:  MOVWF  x52
090C4:  MOVLB  0
090C6:  CALL   5266
090CA:  MOVLB  C
090CC:  DECFSZ x5F,F
090CE:  BRA    90BE
....................  
....................     fprintf(PC, "No 24h reset happened, doing soft reset instead.\r\n"); 
090D0:  MOVLW  80
090D2:  MOVWF  FF6
090D4:  MOVLW  0F
090D6:  MOVWF  FF7
090D8:  MOVLW  00
090DA:  MOVWF  FF8
090DC:  MOVLB  0
090DE:  CALL   4534
....................     reset_cpu(); 
090E2:  RESET
....................  
....................     return 0; 
090E4:  MOVLW  00
090E6:  MOVWF  01
090E8:  MOVLB  5
090EA:  MOVLB  0
090EC:  GOTO   1885E (RETURN)
.................... } 
....................  
.................... // Reset pic acknowledge of time change 
.................... uint8_t command_time_change_ack(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Reset PIC time change ACK."); 
....................     return 0; 
.................... } 
....................  
.................... // Passes a command from ground-station to reset pic 
.................... uint8_t command_send_data_to_reset(uint8_t* data) 
*
14ECC:  MOVFF  C39,C3C
14ED0:  MOVFF  C38,C3B
.................... { 
....................     uint8_t i; 
....................     struct packet { 
....................         uint8_t command;     // C0: comm pic message 
....................         uint8_t reset_cmd;   // F5: reset message 
....................         uint8_t data[8];     // data to be passed to reset pic 
....................         uint8_t silent_mode; // if equals to 1, do not print debug message 
....................     }* packet = (struct packet*)data; 
....................     uint8_t cmd[36] = { 0 }; 
14ED4:  MOVLB  C
14ED6:  CLRF   x3D
14ED8:  CLRF   x3E
14EDA:  CLRF   x3F
14EDC:  CLRF   x40
14EDE:  CLRF   x41
14EE0:  CLRF   x42
14EE2:  CLRF   x43
14EE4:  CLRF   x44
14EE6:  CLRF   x45
14EE8:  CLRF   x46
14EEA:  CLRF   x47
14EEC:  CLRF   x48
14EEE:  CLRF   x49
14EF0:  CLRF   x4A
14EF2:  CLRF   x4B
14EF4:  CLRF   x4C
14EF6:  CLRF   x4D
14EF8:  CLRF   x4E
14EFA:  CLRF   x4F
14EFC:  CLRF   x50
14EFE:  CLRF   x51
14F00:  CLRF   x52
14F02:  CLRF   x53
14F04:  CLRF   x54
14F06:  CLRF   x55
14F08:  CLRF   x56
14F0A:  CLRF   x57
14F0C:  CLRF   x58
14F0E:  CLRF   x59
14F10:  CLRF   x5A
14F12:  CLRF   x5B
14F14:  CLRF   x5C
14F16:  CLRF   x5D
14F18:  CLRF   x5E
14F1A:  CLRF   x5F
14F1C:  CLRF   x60
....................     cmd[0] = 0xB0; 
14F1E:  MOVLW  B0
14F20:  MOVWF  x3D
....................     for (i = 0; i < 8; i++) { 
14F22:  CLRF   x3A
14F24:  MOVF   x3A,W
14F26:  SUBLW  07
14F28:  BNC   14F5A
....................         cmd[i + 1] = packet->data[i]; 
14F2A:  MOVLW  01
14F2C:  ADDWF  x3A,W
14F2E:  CLRF   03
14F30:  ADDLW  3D
14F32:  MOVWF  01
14F34:  MOVLW  0C
14F36:  ADDWFC 03,F
14F38:  MOVLW  02
14F3A:  ADDWF  x3A,W
14F3C:  ADDWF  x3B,W
14F3E:  MOVWF  FE9
14F40:  MOVLW  00
14F42:  ADDWFC x3C,W
14F44:  MOVWF  FEA
14F46:  MOVFF  FEF,C63
14F4A:  MOVFF  03,FEA
14F4E:  MOVFF  01,FE9
14F52:  MOVFF  C63,FEF
14F56:  INCF   x3A,F
14F58:  BRA    14F24
....................     } 
....................     cmd[35] = 0xB1; 
14F5A:  MOVLW  B1
14F5C:  MOVWF  x60
....................     for (i = 0; i < sizeof(cmd); i++) { 
14F5E:  CLRF   x3A
14F60:  MOVF   x3A,W
14F62:  SUBLW  23
14F64:  BNC   14F86
....................         fputc(cmd[i], RST); 
14F66:  CLRF   03
14F68:  MOVF   x3A,W
14F6A:  ADDLW  3D
14F6C:  MOVWF  FE9
14F6E:  MOVLW  0C
14F70:  ADDWFC 03,W
14F72:  MOVWF  FEA
14F74:  MOVFF  FEF,C61
14F78:  MOVF   x61,W
14F7A:  MOVLB  0
14F7C:  CALL   544E
14F80:  MOVLB  C
14F82:  INCF   x3A,F
14F84:  BRA    14F60
....................     } 
....................     if (packet->silent_mode != 1) 
14F86:  MOVLW  0A
14F88:  ADDWF  x3B,W
14F8A:  MOVWF  FE9
14F8C:  MOVLW  00
14F8E:  ADDWFC x3C,W
14F90:  MOVWF  FEA
14F92:  DECFSZ FEF,W
14F94:  BRA    14F98
14F96:  BRA    14FAC
....................         uart_print_pc_hex(cmd, sizeof(cmd)); 
14F98:  MOVLW  0C
14F9A:  MOVWF  x90
14F9C:  MOVLW  3D
14F9E:  MOVWF  x8F
14FA0:  MOVLW  24
14FA2:  MOVWF  x91
14FA4:  MOVLB  0
14FA6:  CALL   7A5C
14FAA:  MOVLB  C
....................     return 0; 
14FAC:  MOVLW  00
14FAE:  MOVWF  01
14FB0:  MOVLB  0
14FB2:  GOTO   18ED8 (RETURN)
.................... } 
....................  
.................... // ============ EPS Commands ============ 
....................  
.................... uint8_t command_eps_telemetry(uint8_t* data) 
.................... { 
....................     enum { cmd_len = 7 }; 
....................     response_rx = 1; // Received a reply 
*
1768C:  MOVLW  01
1768E:  MOVLB  7
17690:  MOVWF  x50
....................     fprintf(PC, "EPS: "); 
17692:  MOVLW  D0
17694:  MOVWF  FF6
17696:  MOVLW  0F
17698:  MOVWF  FF7
1769A:  MOVLW  00
1769C:  MOVWF  FF8
1769E:  MOVLB  0
176A0:  CALL   4534
....................  
....................     uint16_t voltage_hex = make16(data[50], data[51]); 
....................     uint16_t current_hex = make16(data[54], data[55]); 
....................     uint16_t temperature_hex = make16(data[56], data[57]); 
....................  
....................     float voltage = voltage_hex * 3.3 * 3 / 4096; 
....................     float current = (3952.5 * current_hex * 3.28 / 4096) - 6479.5; 
....................     float temperature = 75 - temperature_hex * 3.256 * 30 / 4096; 
176A4:  MOVLW  32
176A6:  MOVLB  C
176A8:  ADDWF  x38,W
176AA:  MOVWF  FE9
176AC:  MOVLW  00
176AE:  ADDWFC x39,W
176B0:  MOVWF  FEA
176B2:  MOVFF  FEF,C3B
176B6:  MOVLW  33
176B8:  ADDWF  x38,W
176BA:  MOVWF  FE9
176BC:  MOVLW  00
176BE:  ADDWFC x39,W
176C0:  MOVWF  FEA
176C2:  MOVFF  FEF,C3A
176C6:  MOVLW  36
176C8:  ADDWF  x38,W
176CA:  MOVWF  FE9
176CC:  MOVLW  00
176CE:  ADDWFC x39,W
176D0:  MOVWF  FEA
176D2:  MOVFF  FEF,C3D
176D6:  MOVLW  37
176D8:  ADDWF  x38,W
176DA:  MOVWF  FE9
176DC:  MOVLW  00
176DE:  ADDWFC x39,W
176E0:  MOVWF  FEA
176E2:  MOVFF  FEF,C3C
176E6:  MOVLW  38
176E8:  ADDWF  x38,W
176EA:  MOVWF  FE9
176EC:  MOVLW  00
176EE:  ADDWFC x39,W
176F0:  MOVWF  FEA
176F2:  MOVFF  FEF,C3F
176F6:  MOVLW  39
176F8:  ADDWF  x38,W
176FA:  MOVWF  FE9
176FC:  MOVLW  00
176FE:  ADDWFC x39,W
17700:  MOVWF  FEA
17702:  MOVFF  FEF,C3E
17706:  MOVFF  C3B,CA8
1770A:  MOVFF  C3A,CA7
1770E:  MOVLB  0
17710:  CALL   EFF2
17714:  MOVFF  03,CA6
17718:  MOVFF  02,CA5
1771C:  MOVFF  01,CA4
17720:  MOVFF  00,CA3
17724:  MOVLW  33
17726:  MOVLB  C
17728:  MOVWF  xAA
1772A:  MOVWF  xA9
1772C:  MOVLW  53
1772E:  MOVWF  xA8
17730:  MOVLW  80
17732:  MOVWF  xA7
17734:  MOVLB  0
17736:  CALL   F23C
1773A:  MOVFF  03,C60
1773E:  MOVFF  02,C5F
17742:  MOVFF  01,C5E
17746:  MOVFF  00,C5D
1774A:  MOVFF  03,CA6
1774E:  MOVFF  02,CA5
17752:  MOVFF  01,CA4
17756:  MOVFF  00,CA3
1775A:  MOVLB  C
1775C:  CLRF   xAA
1775E:  CLRF   xA9
17760:  MOVLW  40
17762:  MOVWF  xA8
17764:  MOVLW  80
17766:  MOVWF  xA7
17768:  MOVLB  0
1776A:  CALL   F23C
1776E:  MOVFF  03,C60
17772:  MOVFF  02,C5F
17776:  MOVFF  01,C5E
1777A:  MOVFF  00,C5D
1777E:  MOVFF  03,C9F
17782:  MOVFF  02,C9E
17786:  MOVFF  01,C9D
1778A:  MOVFF  00,C9C
1778E:  MOVLB  C
17790:  CLRF   xA3
17792:  CLRF   xA2
17794:  CLRF   xA1
17796:  MOVLW  8B
17798:  MOVWF  xA0
1779A:  MOVLB  0
1779C:  CALL   F0A2
177A0:  MOVFF  03,C43
177A4:  MOVFF  02,C42
177A8:  MOVFF  01,C41
177AC:  MOVFF  00,C40
177B0:  MOVFF  C3D,CA8
177B4:  MOVFF  C3C,CA7
177B8:  CALL   EFF2
177BC:  MOVLB  C
177BE:  CLRF   xA6
177C0:  MOVLW  08
177C2:  MOVWF  xA5
177C4:  MOVLW  77
177C6:  MOVWF  xA4
177C8:  MOVLW  8A
177CA:  MOVWF  xA3
177CC:  MOVFF  03,CAA
177D0:  MOVFF  02,CA9
177D4:  MOVFF  01,CA8
177D8:  MOVFF  00,CA7
177DC:  MOVLB  0
177DE:  CALL   F23C
177E2:  MOVFF  03,C60
177E6:  MOVFF  02,C5F
177EA:  MOVFF  01,C5E
177EE:  MOVFF  00,C5D
177F2:  MOVFF  03,CA6
177F6:  MOVFF  02,CA5
177FA:  MOVFF  01,CA4
177FE:  MOVFF  00,CA3
17802:  MOVLW  85
17804:  MOVLB  C
17806:  MOVWF  xAA
17808:  MOVLW  EB
1780A:  MOVWF  xA9
1780C:  MOVLW  51
1780E:  MOVWF  xA8
17810:  MOVLW  80
17812:  MOVWF  xA7
17814:  MOVLB  0
17816:  CALL   F23C
1781A:  MOVFF  03,C60
1781E:  MOVFF  02,C5F
17822:  MOVFF  01,C5E
17826:  MOVFF  00,C5D
1782A:  MOVFF  03,C9F
1782E:  MOVFF  02,C9E
17832:  MOVFF  01,C9D
17836:  MOVFF  00,C9C
1783A:  MOVLB  C
1783C:  CLRF   xA3
1783E:  CLRF   xA2
17840:  CLRF   xA1
17842:  MOVLW  8B
17844:  MOVWF  xA0
17846:  MOVLB  0
17848:  CALL   F0A2
1784C:  MOVFF  03,C60
17850:  MOVFF  02,C5F
17854:  MOVFF  01,C5E
17858:  MOVFF  00,C5D
1785C:  MOVFF  FEA,C62
17860:  MOVFF  FE9,C61
17864:  BSF    FD8.1
17866:  MOVFF  03,CAA
1786A:  MOVFF  02,CA9
1786E:  MOVFF  01,CA8
17872:  MOVFF  00,CA7
17876:  MOVLB  C
17878:  CLRF   xAE
1787A:  MOVLW  7C
1787C:  MOVWF  xAD
1787E:  MOVLW  4A
17880:  MOVWF  xAC
17882:  MOVLW  8B
17884:  MOVWF  xAB
17886:  MOVLB  0
17888:  CALL   F332
1788C:  MOVFF  C62,FEA
17890:  MOVFF  C61,FE9
17894:  MOVFF  03,C47
17898:  MOVFF  02,C46
1789C:  MOVFF  01,C45
178A0:  MOVFF  00,C44
178A4:  MOVFF  C3F,CA8
178A8:  MOVFF  C3E,CA7
178AC:  CALL   EFF2
178B0:  MOVFF  03,CA6
178B4:  MOVFF  02,CA5
178B8:  MOVFF  01,CA4
178BC:  MOVFF  00,CA3
178C0:  MOVLW  4E
178C2:  MOVLB  C
178C4:  MOVWF  xAA
178C6:  MOVLW  62
178C8:  MOVWF  xA9
178CA:  MOVLW  50
178CC:  MOVWF  xA8
178CE:  MOVLW  80
178D0:  MOVWF  xA7
178D2:  MOVLB  0
178D4:  CALL   F23C
178D8:  MOVFF  03,C60
178DC:  MOVFF  02,C5F
178E0:  MOVFF  01,C5E
178E4:  MOVFF  00,C5D
178E8:  MOVFF  03,CA6
178EC:  MOVFF  02,CA5
178F0:  MOVFF  01,CA4
178F4:  MOVFF  00,CA3
178F8:  MOVLB  C
178FA:  CLRF   xAA
178FC:  CLRF   xA9
178FE:  MOVLW  70
17900:  MOVWF  xA8
17902:  MOVLW  83
17904:  MOVWF  xA7
17906:  MOVLB  0
17908:  CALL   F23C
1790C:  MOVFF  03,C60
17910:  MOVFF  02,C5F
17914:  MOVFF  01,C5E
17918:  MOVFF  00,C5D
1791C:  MOVFF  03,C9F
17920:  MOVFF  02,C9E
17924:  MOVFF  01,C9D
17928:  MOVFF  00,C9C
1792C:  MOVLB  C
1792E:  CLRF   xA3
17930:  CLRF   xA2
17932:  CLRF   xA1
17934:  MOVLW  8B
17936:  MOVWF  xA0
17938:  MOVLB  0
1793A:  CALL   F0A2
1793E:  MOVFF  FEA,C5E
17942:  MOVFF  FE9,C5D
17946:  BSF    FD8.1
17948:  MOVLB  C
1794A:  CLRF   xAA
1794C:  CLRF   xA9
1794E:  MOVLW  16
17950:  MOVWF  xA8
17952:  MOVLW  85
17954:  MOVWF  xA7
17956:  MOVFF  03,CAE
1795A:  MOVFF  02,CAD
1795E:  MOVFF  01,CAC
17962:  MOVFF  00,CAB
17966:  MOVLB  0
17968:  CALL   F332
1796C:  MOVFF  C5E,FEA
17970:  MOVFF  C5D,FE9
17974:  MOVFF  03,C4B
17978:  MOVFF  02,C4A
1797C:  MOVFF  01,C49
17980:  MOVFF  00,C48
....................     fprintf(PC, "V=%f, C=%f, T=%f | ", voltage, current, temperature); 
17984:  MOVLW  56
17986:  MOVLB  D
17988:  MOVWF  x6A
1798A:  MOVLB  0
1798C:  CALL   44EE
17990:  MOVLW  3D
17992:  MOVLB  D
17994:  MOVWF  x6A
17996:  MOVLB  0
17998:  CALL   44EE
1799C:  MOVLW  89
1799E:  MOVWF  FE9
179A0:  MOVFF  C43,C5A
179A4:  MOVFF  C42,C59
179A8:  MOVFF  C41,C58
179AC:  MOVFF  C40,C57
179B0:  MOVLW  02
179B2:  MOVLB  C
179B4:  MOVWF  x5B
179B6:  MOVLB  0
179B8:  RCALL  174D0
179BA:  MOVLW  DA
179BC:  MOVWF  FF6
179BE:  MOVLW  0F
179C0:  MOVWF  FF7
179C2:  MOVLW  00
179C4:  MOVWF  FF8
179C6:  MOVLW  04
179C8:  MOVLB  C
179CA:  MOVWF  xC1
179CC:  MOVLB  0
179CE:  CALL   5290
179D2:  MOVLW  89
179D4:  MOVWF  FE9
179D6:  MOVFF  C47,C5A
179DA:  MOVFF  C46,C59
179DE:  MOVFF  C45,C58
179E2:  MOVFF  C44,C57
179E6:  MOVLW  02
179E8:  MOVLB  C
179EA:  MOVWF  x5B
179EC:  MOVLB  0
179EE:  RCALL  174D0
179F0:  MOVLW  E0
179F2:  MOVWF  FF6
179F4:  MOVLW  0F
179F6:  MOVWF  FF7
179F8:  MOVLW  00
179FA:  MOVWF  FF8
179FC:  MOVLW  04
179FE:  MOVLB  C
17A00:  MOVWF  xC1
17A02:  MOVLB  0
17A04:  CALL   5290
17A08:  MOVLW  89
17A0A:  MOVWF  FE9
17A0C:  MOVFF  C4B,C5A
17A10:  MOVFF  C4A,C59
17A14:  MOVFF  C49,C58
17A18:  MOVFF  C48,C57
17A1C:  MOVLW  02
17A1E:  MOVLB  C
17A20:  MOVWF  x5B
17A22:  MOVLB  0
17A24:  RCALL  174D0
17A26:  MOVLW  E6
17A28:  MOVWF  FF6
17A2A:  MOVLW  0F
17A2C:  MOVWF  FF7
17A2E:  MOVLW  00
17A30:  MOVWF  FF8
17A32:  MOVLW  03
17A34:  MOVLB  C
17A36:  MOVWF  xC1
17A38:  MOVLB  0
17A3A:  CALL   5290
....................  
....................     uint16_t heater_ref_temperature = make16(data[60], data[61]); 
....................     uint16_t heater_ref_voltage = make16(data[62], data[63]); 
17A3E:  MOVLW  3C
17A40:  MOVLB  C
17A42:  ADDWF  x38,W
17A44:  MOVWF  FE9
17A46:  MOVLW  00
17A48:  ADDWFC x39,W
17A4A:  MOVWF  FEA
17A4C:  MOVFF  FEF,C4D
17A50:  MOVLW  3D
17A52:  ADDWF  x38,W
17A54:  MOVWF  FE9
17A56:  MOVLW  00
17A58:  ADDWFC x39,W
17A5A:  MOVWF  FEA
17A5C:  MOVFF  FEF,C4C
17A60:  MOVLW  3E
17A62:  ADDWF  x38,W
17A64:  MOVWF  FE9
17A66:  MOVLW  00
17A68:  ADDWFC x39,W
17A6A:  MOVWF  FEA
17A6C:  MOVFF  FEF,C4F
17A70:  MOVLW  3F
17A72:  ADDWF  x38,W
17A74:  MOVWF  FE9
17A76:  MOVLW  00
17A78:  ADDWFC x39,W
17A7A:  MOVWF  FEA
17A7C:  MOVFF  FEF,C4E
....................  
....................     if ((heater_ref_temperature != obc_flags.heater_ref_temperature) || (heater_ref_voltage != obc_flags.heater_ref_voltage)) { 
17A80:  MOVLB  1
17A82:  MOVF   x06,W
17A84:  MOVLB  C
17A86:  SUBWF  x4C,W
17A88:  BNZ   17AA8
17A8A:  MOVLB  1
17A8C:  MOVF   x07,W
17A8E:  MOVLB  C
17A90:  SUBWF  x4D,W
17A92:  BNZ   17AA8
17A94:  MOVLB  1
17A96:  MOVF   x08,W
17A98:  MOVLB  C
17A9A:  SUBWF  x4E,W
17A9C:  BNZ   17AA8
17A9E:  MOVLB  1
17AA0:  MOVF   x09,W
17AA2:  MOVLB  C
17AA4:  SUBWF  x4F,W
17AA6:  BZ    17B86
....................         // E0 66 TH TL VH VL 
....................         fprintf(PC, " New T=0x%04lX, V=0x%04lX | ", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
17AA8:  MOVLW  EA
17AAA:  MOVWF  FF6
17AAC:  MOVLW  0F
17AAE:  MOVWF  FF7
17AB0:  MOVLW  00
17AB2:  MOVWF  FF8
17AB4:  MOVLW  09
17AB6:  MOVWF  xC1
17AB8:  MOVLB  0
17ABA:  CALL   5290
17ABE:  MOVFF  107,CBF
17AC2:  MOVLW  37
17AC4:  MOVLB  C
17AC6:  MOVWF  xC0
17AC8:  MOVLB  0
17ACA:  CALL   5A92
17ACE:  MOVFF  106,CBF
17AD2:  MOVLW  37
17AD4:  MOVLB  C
17AD6:  MOVWF  xC0
17AD8:  MOVLB  0
17ADA:  CALL   5A92
17ADE:  MOVLW  F8
17AE0:  MOVWF  FF6
17AE2:  MOVLW  0F
17AE4:  MOVWF  FF7
17AE6:  MOVLW  00
17AE8:  MOVWF  FF8
17AEA:  MOVLW  06
17AEC:  MOVLB  C
17AEE:  MOVWF  xC1
17AF0:  MOVLB  0
17AF2:  CALL   5290
17AF6:  MOVFF  109,CBF
17AFA:  MOVLW  37
17AFC:  MOVLB  C
17AFE:  MOVWF  xC0
17B00:  MOVLB  0
17B02:  CALL   5A92
17B06:  MOVFF  108,CBF
17B0A:  MOVLW  37
17B0C:  MOVLB  C
17B0E:  MOVWF  xC0
17B10:  MOVLB  0
17B12:  CALL   5A92
17B16:  MOVLW  03
17B18:  MOVWF  FF6
17B1A:  MOVLW  10
17B1C:  MOVWF  FF7
17B1E:  MOVLW  00
17B20:  MOVWF  FF8
17B22:  MOVLW  03
17B24:  MOVLB  C
17B26:  MOVWF  xC1
17B28:  MOVLB  0
17B2A:  CALL   5290
....................         uint8_t cmd_temp[cmd_len]; 
....................         cmd_temp[0] = 0xC0;                                      // COM_MSG 
17B2E:  MOVLW  C0
17B30:  MOVLB  C
17B32:  MOVWF  x50
....................         cmd_temp[1] = 0x6C;                                      // OBC_CMD 
17B34:  MOVLW  6C
17B36:  MOVWF  x51
....................         cmd_temp[2] = 0x66;                                      // EPS_CMD 
17B38:  MOVLW  66
17B3A:  MOVWF  x52
....................         cmd_temp[3] = (obc_flags.heater_ref_temperature >> 8);   // TEMP_HIGH 
17B3C:  MOVFF  107,C53
....................         cmd_temp[4] = (obc_flags.heater_ref_temperature & 0xFF); // TEMP_LOW 
17B40:  MOVFF  106,C54
17B44:  MOVLB  C
....................         cmd_temp[5] = (obc_flags.heater_ref_voltage >> 8);       // V_HIGH 
17B46:  MOVFF  109,C55
....................         cmd_temp[6] = (obc_flags.heater_ref_voltage & 0xFF);     // V_LOW 
17B4A:  MOVFF  108,C56
17B4E:  MOVLB  C
....................         vschedule(current_time + 5, cmd_temp); 
17B50:  MOVLW  05
17B52:  ADDWF  3B,W
17B54:  MOVWF  x57
17B56:  MOVLW  00
17B58:  ADDWFC 3C,W
17B5A:  MOVWF  x58
17B5C:  MOVLW  00
17B5E:  ADDWFC 3D,W
17B60:  MOVWF  x59
17B62:  MOVLW  00
17B64:  ADDWFC 3E,W
17B66:  MOVWF  x5A
17B68:  MOVWF  x98
17B6A:  MOVFF  C59,C97
17B6E:  MOVFF  C58,C96
17B72:  MOVFF  C57,C95
17B76:  MOVLW  0C
17B78:  MOVWF  x9A
17B7A:  MOVLW  50
17B7C:  MOVWF  x99
17B7E:  MOVLB  0
17B80:  CALL   704C
17B84:  MOVLB  C
....................     } 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_FAB); 
17B86:  MOVFF  C39,C90
17B8A:  MOVFF  C38,C8F
17B8E:  MOVLW  40
17B90:  MOVWF  x91
17B92:  MOVLB  0
17B94:  CALL   7A5C
....................     telemetry_time.fab_time = current_time; 
17B98:  MOVFF  3E,E2
17B9C:  MOVFF  3D,E1
17BA0:  MOVFF  3C,E0
17BA4:  MOVFF  3B,DF
....................     memcpy(telemetry.fab_message, data + 2, sizeof(telemetry.fab_message)); 
17BA8:  MOVLW  02
17BAA:  MOVLB  C
17BAC:  ADDWF  x38,W
17BAE:  MOVWF  x57
17BB0:  MOVLW  00
17BB2:  ADDWFC x39,W
17BB4:  MOVWF  x58
17BB6:  CLRF   FEA
17BB8:  MOVLW  5D
17BBA:  MOVWF  FE9
17BBC:  MOVFF  C58,FE2
17BC0:  MOVFF  C57,FE1
17BC4:  MOVLW  3E
17BC6:  MOVWF  01
17BC8:  MOVFF  FE6,FEE
17BCC:  DECFSZ 01,F
17BCE:  BRA    17BC8
....................     return 0; 
17BD0:  MOVLW  00
17BD2:  MOVWF  01
17BD4:  MOVLB  0
17BD6:  GOTO   18FC2 (RETURN)
.................... } 
....................  
.................... // Passes a command from ground-station to eps pic 
.................... uint8_t command_send_data_to_eps(uint8_t* data) 
*
0D322:  MOVFF  C39,C3C
0D326:  MOVFF  C38,C3B
.................... { 
....................     uint8_t i; 
....................     enum { data_size = 5 }; 
....................     struct packet { 
....................         uint8_t command;         // C0: com pic message 
....................         uint8_t eps_cmd;         // 6C: eps message 
....................         uint8_t data[data_size]; // data to be passed to reset pic 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t cmd[data_size + 1] = { 0 }; 
0D32A:  MOVLB  C
0D32C:  CLRF   x3D
0D32E:  CLRF   x3E
0D330:  CLRF   x3F
0D332:  CLRF   x40
0D334:  CLRF   x41
0D336:  CLRF   x42
....................     cmd[0] = 0xE0; 
0D338:  MOVLW  E0
0D33A:  MOVWF  x3D
....................     for (i = 0; i < data_size; i++) { 
0D33C:  CLRF   x3A
0D33E:  MOVF   x3A,W
0D340:  SUBLW  04
0D342:  BNC   D374
....................         cmd[i + 1] = packet->data[i]; 
0D344:  MOVLW  01
0D346:  ADDWF  x3A,W
0D348:  CLRF   03
0D34A:  ADDLW  3D
0D34C:  MOVWF  01
0D34E:  MOVLW  0C
0D350:  ADDWFC 03,F
0D352:  MOVLW  02
0D354:  ADDWF  x3A,W
0D356:  ADDWF  x3B,W
0D358:  MOVWF  FE9
0D35A:  MOVLW  00
0D35C:  ADDWFC x3C,W
0D35E:  MOVWF  FEA
0D360:  MOVFF  FEF,C45
0D364:  MOVFF  03,FEA
0D368:  MOVFF  01,FE9
0D36C:  MOVFF  C45,FEF
0D370:  INCF   x3A,F
0D372:  BRA    D33E
....................     } 
....................     for (i = 0; i < sizeof(cmd); i++) { 
0D374:  CLRF   x3A
0D376:  MOVF   x3A,W
0D378:  SUBLW  05
0D37A:  BNC   D39C
....................         fputc(cmd[i], FAB); 
0D37C:  CLRF   03
0D37E:  MOVF   x3A,W
0D380:  ADDLW  3D
0D382:  MOVWF  FE9
0D384:  MOVLW  0C
0D386:  ADDWFC 03,W
0D388:  MOVWF  FEA
0D38A:  MOVFF  FEF,C43
0D38E:  MOVF   x43,W
0D390:  MOVLB  0
0D392:  CALL   5438
0D396:  MOVLB  C
0D398:  INCF   x3A,F
0D39A:  BRA    D376
....................     } 
....................  
....................     fprintf(PC, "EPS cmd: "); 
0D39C:  MOVLW  08
0D39E:  MOVWF  FF6
0D3A0:  MOVLW  10
0D3A2:  MOVWF  FF7
0D3A4:  MOVLW  00
0D3A6:  MOVWF  FF8
0D3A8:  MOVLB  0
0D3AA:  CALL   4534
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
0D3AE:  MOVLW  0C
0D3B0:  MOVLB  C
0D3B2:  MOVWF  x90
0D3B4:  MOVLW  3D
0D3B6:  MOVWF  x8F
0D3B8:  MOVLW  06
0D3BA:  MOVWF  x91
0D3BC:  MOVLB  0
0D3BE:  CALL   7A5C
....................  
....................     return 0; 
0D3C2:  MOVLW  00
0D3C4:  MOVWF  01
0D3C6:  GOTO   18AEE (RETURN)
.................... } 
....................  
.................... typedef enum { 
....................     mcp_cmd_telemetry_req = 0x10, 
....................     mcp_cmd_opera_on = 0x20, 
....................     mcp_cmd_opera_off = 0x2F, 
....................     mcp_cmd_zes_reset = 0x30, 
....................     mcp_cmd_ref_status = 0x35, 
....................     mcp_cmd_tmcr1_on = 0x40, 
....................     mcp_cmd_tmcr1_off = 0x4F, 
....................     mcp_cmd_tmcr2_on = 0x50, 
....................     mcp_cmd_tmcr2_off = 0x5F 
.................... } mcp_command; 
....................  
.................... // Turn on/off OCPs in MCP 
.................... uint8_t command_mcp(uint8_t* data) 
*
0C0B2:  MOVFF  C39,C3B
0C0B6:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // 2A for MCP OCP control 
....................         uint8_t mcp_command; 
....................         uint16_t data; 
....................     }* packet = (struct packet*)data; 
....................  
....................     send_mcp_command(packet->mcp_command, packet->data, false); 
0C0BA:  MOVLW  02
0C0BC:  MOVLB  C
0C0BE:  ADDWF  x3A,W
0C0C0:  MOVWF  FE9
0C0C2:  MOVLW  00
0C0C4:  ADDWFC x3B,W
0C0C6:  MOVWF  FEA
0C0C8:  MOVFF  FEF,C80
0C0CC:  MOVLW  03
0C0CE:  ADDWF  x3A,W
0C0D0:  MOVWF  FE9
0C0D2:  MOVLW  00
0C0D4:  ADDWFC x3B,W
0C0D6:  MOVWF  FEA
0C0D8:  MOVFF  FEC,C82
0C0DC:  MOVF   FED,F
0C0DE:  MOVFF  FEF,C81
0C0E2:  CLRF   x83
0C0E4:  MOVLB  0
0C0E6:  RCALL  BAD6
....................  
....................     return 0; 
0C0E8:  MOVLW  00
0C0EA:  MOVWF  01
0C0EC:  GOTO   189AA (RETURN)
.................... } 
....................  
.................... uint8_t command_eps_set_heater_ref(uint8_t* data) 
*
0D3CA:  MOVFF  C39,C3B
0D3CE:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t command;   // C0: com pic message 
....................         uint8_t eps_cmd;   // 6D: heater ref settings 
....................         uint16_t temp_ref; // temperature reference 
....................         uint16_t v_ref;    // voltage reference 
....................     }* packet = (struct packet*)data; 
....................  
....................     obc_flags.heater_ref_temperature = packet->temp_ref; 
0D3D2:  MOVLW  02
0D3D4:  MOVLB  C
0D3D6:  ADDWF  x3A,W
0D3D8:  MOVWF  FE9
0D3DA:  MOVLW  00
0D3DC:  ADDWFC x3B,W
0D3DE:  MOVWF  FEA
0D3E0:  MOVFF  FEC,107
0D3E4:  MOVF   FED,F
0D3E6:  MOVFF  FEF,106
....................     obc_flags.heater_ref_voltage = packet->v_ref; 
0D3EA:  MOVLW  04
0D3EC:  ADDWF  x3A,W
0D3EE:  MOVWF  FE9
0D3F0:  MOVLW  00
0D3F2:  ADDWFC x3B,W
0D3F4:  MOVWF  FEA
0D3F6:  MOVFF  FEC,109
0D3FA:  MOVF   FED,F
0D3FC:  MOVFF  FEF,108
....................     save_state(packet->eps_cmd); 
0D400:  MOVLW  01
0D402:  ADDWF  x3A,W
0D404:  MOVWF  FE9
0D406:  MOVLW  00
0D408:  ADDWFC x3B,W
0D40A:  MOVWF  FEA
0D40C:  MOVFF  FEF,C60
0D410:  MOVLB  0
0D412:  CALL   8CAE
....................  
....................     fprintf(PC, "New T=0x%04lX, V=0x%04lX", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
0D416:  MOVLW  12
0D418:  MOVWF  FF6
0D41A:  MOVLW  10
0D41C:  MOVWF  FF7
0D41E:  MOVLW  00
0D420:  MOVWF  FF8
0D422:  MOVLW  08
0D424:  MOVLB  C
0D426:  MOVWF  xC1
0D428:  MOVLB  0
0D42A:  CALL   5290
0D42E:  MOVFF  107,CBF
0D432:  MOVLW  37
0D434:  MOVLB  C
0D436:  MOVWF  xC0
0D438:  MOVLB  0
0D43A:  CALL   5A92
0D43E:  MOVFF  106,CBF
0D442:  MOVLW  37
0D444:  MOVLB  C
0D446:  MOVWF  xC0
0D448:  MOVLB  0
0D44A:  CALL   5A92
0D44E:  MOVLW  1F
0D450:  MOVWF  FF6
0D452:  MOVLW  10
0D454:  MOVWF  FF7
0D456:  MOVLW  00
0D458:  MOVWF  FF8
0D45A:  MOVLW  06
0D45C:  MOVLB  C
0D45E:  MOVWF  xC1
0D460:  MOVLB  0
0D462:  CALL   5290
0D466:  MOVFF  109,CBF
0D46A:  MOVLW  37
0D46C:  MOVLB  C
0D46E:  MOVWF  xC0
0D470:  MOVLB  0
0D472:  CALL   5A92
0D476:  MOVFF  108,CBF
0D47A:  MOVLW  37
0D47C:  MOVLB  C
0D47E:  MOVWF  xC0
0D480:  MOVLB  0
0D482:  CALL   5A92
....................  
....................     return 0; 
0D486:  MOVLW  00
0D488:  MOVWF  01
0D48A:  GOTO   18B00 (RETURN)
.................... } 
....................  
.................... uint8_t command_obc_kill_on(uint8_t* data) 
*
0D270:  MOVLB  C
0D272:  CLRF   x3A
.................... { 
....................     uint8_t kill_sw_status = 0; 
....................     if (data[2] == 0x55 && data[4] == 0x55 && data[6] == 0x55 && data[8] == 0x55 && data[3] == 0xAA && data[5] == 0xAA && data[7] == 0xAA && data[9] == 0xAA) { 
0D274:  MOVLW  02
0D276:  ADDWF  x38,W
0D278:  MOVWF  FE9
0D27A:  MOVLW  00
0D27C:  ADDWFC x39,W
0D27E:  MOVWF  FEA
0D280:  MOVF   FEF,W
0D282:  SUBLW  55
0D284:  BNZ   D30C
0D286:  MOVLW  04
0D288:  ADDWF  x38,W
0D28A:  MOVWF  FE9
0D28C:  MOVLW  00
0D28E:  ADDWFC x39,W
0D290:  MOVWF  FEA
0D292:  MOVF   FEF,W
0D294:  SUBLW  55
0D296:  BNZ   D30C
0D298:  MOVLW  06
0D29A:  ADDWF  x38,W
0D29C:  MOVWF  FE9
0D29E:  MOVLW  00
0D2A0:  ADDWFC x39,W
0D2A2:  MOVWF  FEA
0D2A4:  MOVF   FEF,W
0D2A6:  SUBLW  55
0D2A8:  BNZ   D30C
0D2AA:  MOVLW  08
0D2AC:  ADDWF  x38,W
0D2AE:  MOVWF  FE9
0D2B0:  MOVLW  00
0D2B2:  ADDWFC x39,W
0D2B4:  MOVWF  FEA
0D2B6:  MOVF   FEF,W
0D2B8:  SUBLW  55
0D2BA:  BNZ   D30C
0D2BC:  MOVLW  03
0D2BE:  ADDWF  x38,W
0D2C0:  MOVWF  FE9
0D2C2:  MOVLW  00
0D2C4:  ADDWFC x39,W
0D2C6:  MOVWF  FEA
0D2C8:  MOVF   FEF,W
0D2CA:  SUBLW  AA
0D2CC:  BNZ   D30C
0D2CE:  MOVLW  05
0D2D0:  ADDWF  x38,W
0D2D2:  MOVWF  FE9
0D2D4:  MOVLW  00
0D2D6:  ADDWFC x39,W
0D2D8:  MOVWF  FEA
0D2DA:  MOVF   FEF,W
0D2DC:  SUBLW  AA
0D2DE:  BNZ   D30C
0D2E0:  MOVLW  07
0D2E2:  ADDWF  x38,W
0D2E4:  MOVWF  FE9
0D2E6:  MOVLW  00
0D2E8:  ADDWFC x39,W
0D2EA:  MOVWF  FEA
0D2EC:  MOVF   FEF,W
0D2EE:  SUBLW  AA
0D2F0:  BNZ   D30C
0D2F2:  MOVLW  09
0D2F4:  ADDWF  x38,W
0D2F6:  MOVWF  FE9
0D2F8:  MOVLW  00
0D2FA:  ADDWFC x39,W
0D2FC:  MOVWF  FEA
0D2FE:  MOVF   FEF,W
0D300:  SUBLW  AA
0D302:  BNZ   D30C
....................         kill_sw_status = 1; 
0D304:  MOVLW  01
0D306:  MOVWF  x3A
....................         output_high(OBC_KILL_DIO); 
0D308:  BCF    F92.4
0D30A:  BSF    F89.4
....................     } 
....................     return kill_sw_status; 
0D30C:  MOVFF  C3A,01
0D310:  MOVLB  0
0D312:  GOTO   18ACA (RETURN)
.................... } 
....................  
.................... uint8_t command_obc_kill_off(uint8_t* data) 
.................... { 
....................     output_low(OBC_KILL_DIO); 
0D316:  BCF    F92.4
0D318:  BCF    F89.4
....................     return 0; 
0D31A:  MOVLW  00
0D31C:  MOVWF  01
0D31E:  GOTO   18ADC (RETURN)
.................... } 
....................  
.................... // ADCS RAW command part a 
.................... uint8_t command_adcs_raw_part_a(uint8_t* data) 
*
0C48A:  MOVFF  C39,C3B
0C48E:  MOVFF  C38,C3A
.................... { 
....................     enum { raw_a_size = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_a[raw_a_size]; 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memcpy(adcs_raw_part_a, packet->part_a, raw_a_size); 
0C492:  MOVLW  02
0C494:  MOVLB  C
0C496:  ADDWF  x3A,W
0C498:  MOVWF  01
0C49A:  MOVLW  00
0C49C:  ADDWFC x3B,W
0C49E:  MOVWF  03
0C4A0:  MOVFF  01,C3C
0C4A4:  MOVWF  x3D
0C4A6:  MOVLW  08
0C4A8:  MOVWF  FEA
0C4AA:  MOVLW  78
0C4AC:  MOVWF  FE9
0C4AE:  MOVFF  03,FE2
0C4B2:  MOVFF  01,FE1
0C4B6:  MOVLW  10
0C4B8:  MOVWF  01
0C4BA:  MOVFF  FE6,FEE
0C4BE:  DECFSZ 01,F
0C4C0:  BRA    C4BA
....................     adcs_raw_part_a_crc0 = packet->crc0; 
0C4C2:  MOVLW  12
0C4C4:  ADDWF  x3A,W
0C4C6:  MOVWF  FE9
0C4C8:  MOVLW  00
0C4CA:  ADDWFC x3B,W
0C4CC:  MOVWF  FEA
0C4CE:  MOVFF  FEF,898
....................  
....................     uart_print_pc_hex(adcs_raw_part_a, sizeof(adcs_raw_part_a)); 
0C4D2:  MOVLW  08
0C4D4:  MOVWF  x90
0C4D6:  MOVLW  78
0C4D8:  MOVWF  x8F
0C4DA:  MOVLW  10
0C4DC:  MOVWF  x91
0C4DE:  MOVLB  0
0C4E0:  CALL   7A5C
....................     fprintf(PC, "Received adcs raw command part a."); 
0C4E4:  MOVLW  2C
0C4E6:  MOVWF  FF6
0C4E8:  MOVLW  10
0C4EA:  MOVWF  FF7
0C4EC:  MOVLW  00
0C4EE:  MOVWF  FF8
0C4F0:  CALL   4534
....................  
....................     return 0; 
0C4F4:  MOVLW  00
0C4F6:  MOVWF  01
0C4F8:  GOTO   18A28 (RETURN)
.................... } 
....................  
.................... // ADCS RAW command part b 
.................... uint8_t command_adcs_raw_part_b(uint8_t* data) 
0C4FC:  MOVFF  C39,C3B
0C500:  MOVFF  C38,C3A
.................... { 
....................     enum { raw_b_size = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_b[raw_b_size]; 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memcpy(adcs_raw_part_b, packet->part_b, raw_b_size); 
0C504:  MOVLW  02
0C506:  MOVLB  C
0C508:  ADDWF  x3A,W
0C50A:  MOVWF  01
0C50C:  MOVLW  00
0C50E:  ADDWFC x3B,W
0C510:  MOVWF  03
0C512:  MOVFF  01,C3C
0C516:  MOVWF  x3D
0C518:  MOVLW  08
0C51A:  MOVWF  FEA
0C51C:  MOVLW  88
0C51E:  MOVWF  FE9
0C520:  MOVFF  03,FE2
0C524:  MOVFF  01,FE1
0C528:  MOVLW  10
0C52A:  MOVWF  01
0C52C:  MOVFF  FE6,FEE
0C530:  DECFSZ 01,F
0C532:  BRA    C52C
....................     adcs_raw_part_b_crc0 = packet->crc0; 
0C534:  MOVLW  12
0C536:  ADDWF  x3A,W
0C538:  MOVWF  FE9
0C53A:  MOVLW  00
0C53C:  ADDWFC x3B,W
0C53E:  MOVWF  FEA
0C540:  MOVFF  FEF,899
....................  
....................     uart_print_pc_hex(adcs_raw_part_b, sizeof(adcs_raw_part_b)); 
0C544:  MOVLW  08
0C546:  MOVWF  x90
0C548:  MOVLW  88
0C54A:  MOVWF  x8F
0C54C:  MOVLW  10
0C54E:  MOVWF  x91
0C550:  MOVLB  0
0C552:  CALL   7A5C
....................     fprintf(PC, "Received adcs raw command part b."); 
0C556:  MOVLW  4E
0C558:  MOVWF  FF6
0C55A:  MOVLW  10
0C55C:  MOVWF  FF7
0C55E:  MOVLW  00
0C560:  MOVWF  FF8
0C562:  CALL   4534
....................  
....................     return 0; 
0C566:  MOVLW  00
0C568:  MOVWF  01
0C56A:  GOTO   18A3A (RETURN)
.................... } 
....................  
.................... // Helper function to calculate ADCS checksum 
.................... void checksum_adcs(uint8_t* data, int size) 
0C56E:  MOVLB  C
0C570:  CLRF   x98
0C572:  CLRF   x97
.................... { 
....................     uint16_t result = 0; 
....................     for (int i = 0; i < (size - 2); i++) { 
0C574:  CLRF   x99
0C576:  MOVLW  02
0C578:  SUBWF  x96,W
0C57A:  SUBWF  x99,W
0C57C:  BC    C596
....................         result += data[i]; 
0C57E:  MOVF   x99,W
0C580:  ADDWF  x94,W
0C582:  MOVWF  FE9
0C584:  MOVLW  00
0C586:  ADDWFC x95,W
0C588:  MOVWF  FEA
0C58A:  MOVF   FEF,W
0C58C:  ADDWF  x97,F
0C58E:  MOVLW  00
0C590:  ADDWFC x98,F
0C592:  INCF   x99,F
0C594:  BRA    C576
....................     } 
....................     unsigned char* ptr = (unsigned char*)&result; 
0C596:  MOVLW  0C
0C598:  MOVWF  x9D
0C59A:  MOVLW  97
0C59C:  MOVFF  C9D,C9B
0C5A0:  MOVWF  x9A
....................     data[size - 1] = ptr[1]; 
0C5A2:  MOVLW  01
0C5A4:  SUBWF  x96,W
0C5A6:  ADDWF  x94,W
0C5A8:  MOVWF  01
0C5AA:  MOVLW  00
0C5AC:  ADDWFC x95,W
0C5AE:  MOVWF  03
0C5B0:  MOVLW  01
0C5B2:  ADDWF  x9A,W
0C5B4:  MOVWF  FE9
0C5B6:  MOVLW  00
0C5B8:  ADDWFC x9B,W
0C5BA:  MOVWF  FEA
0C5BC:  MOVFF  FEF,C9E
0C5C0:  MOVFF  03,FEA
0C5C4:  MOVFF  01,FE9
0C5C8:  MOVFF  C9E,FEF
....................     data[size - 2] = ptr[0]; 
0C5CC:  MOVLW  02
0C5CE:  SUBWF  x96,W
0C5D0:  ADDWF  x94,W
0C5D2:  MOVWF  01
0C5D4:  MOVLW  00
0C5D6:  ADDWFC x95,W
0C5D8:  MOVFF  C9A,FE9
0C5DC:  MOVFF  C9B,FEA
0C5E0:  MOVFF  FEF,C9E
0C5E4:  MOVWF  FEA
0C5E6:  MOVFF  01,FE9
0C5EA:  MOVFF  C9E,FEF
0C5EE:  MOVLB  0
0C5F0:  GOTO   C67E (RETURN)
.................... } 
....................  
.................... // Send MAI-400 command (max 40-bytes) 
.................... void mai_400_command(uint8_t* data, int length) 
.................... { 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B }; 
0C5F4:  MOVLW  0B
0C5F6:  MOVLB  C
0C5F8:  MOVWF  x67
0C5FA:  CLRF   x68
0C5FC:  CLRF   x69
0C5FE:  CLRF   x6A
0C600:  CLRF   x6B
0C602:  CLRF   x6C
0C604:  CLRF   x6D
0C606:  CLRF   x6E
0C608:  CLRF   x6F
0C60A:  CLRF   x70
0C60C:  CLRF   x71
0C60E:  CLRF   x72
0C610:  CLRF   x73
0C612:  CLRF   x74
0C614:  CLRF   x75
0C616:  CLRF   x76
0C618:  CLRF   x77
0C61A:  CLRF   x78
0C61C:  CLRF   x79
0C61E:  CLRF   x7A
0C620:  CLRF   x7B
0C622:  CLRF   x7C
0C624:  CLRF   x7D
0C626:  CLRF   x7E
0C628:  CLRF   x7F
0C62A:  CLRF   x80
0C62C:  CLRF   x81
0C62E:  CLRF   x82
0C630:  CLRF   x83
0C632:  CLRF   x84
0C634:  CLRF   x85
0C636:  CLRF   x86
0C638:  CLRF   x87
0C63A:  CLRF   x88
0C63C:  CLRF   x89
0C63E:  CLRF   x8A
0C640:  CLRF   x8B
0C642:  CLRF   x8C
0C644:  CLRF   x8D
0C646:  CLRF   x8E
0C648:  CLRF   x8F
0C64A:  CLRF   x90
0C64C:  CLRF   x91
0C64E:  CLRF   x92
....................     memcpy(adcs_command + 1, data, length); 
0C650:  MOVLW  0C
0C652:  MOVWF  FEA
0C654:  MOVLW  68
0C656:  MOVWF  FE9
0C658:  MOVFF  C65,FE2
0C65C:  MOVFF  C64,FE1
0C660:  MOVF   x66,W
0C662:  MOVWF  01
0C664:  BZ    C66E
0C666:  MOVFF  FE6,FEE
0C66A:  DECFSZ 01,F
0C66C:  BRA    C666
....................     checksum_adcs(adcs_command + 1, 40); 
0C66E:  MOVLW  0C
0C670:  MOVWF  x95
0C672:  MOVLW  68
0C674:  MOVWF  x94
0C676:  MOVLW  28
0C678:  MOVWF  x96
0C67A:  MOVLB  0
0C67C:  BRA    C56E
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
0C67E:  MOVLW  0C
0C680:  MOVLB  C
0C682:  MOVWF  xAF
0C684:  MOVLW  67
0C686:  MOVWF  xAE
0C688:  MOVLW  2C
0C68A:  MOVWF  xB0
0C68C:  MOVLB  0
0C68E:  CALL   8E80
....................     for (int i = 0; i < sizeof(adcs_command); i++) { 
0C692:  MOVLB  C
0C694:  CLRF   x93
0C696:  MOVF   x93,W
0C698:  SUBLW  2B
0C69A:  BNC   C6BC
....................         fputc(adcs_command[i], ADCS); 
0C69C:  CLRF   03
0C69E:  MOVF   x93,W
0C6A0:  ADDLW  67
0C6A2:  MOVWF  FE9
0C6A4:  MOVLW  0C
0C6A6:  ADDWFC 03,W
0C6A8:  MOVWF  FEA
0C6AA:  MOVFF  FEF,C94
0C6AE:  MOVF   x94,W
0C6B0:  MOVLB  0
0C6B2:  CALL   5464
0C6B6:  MOVLB  C
0C6B8:  INCF   x93,F
0C6BA:  BRA    C696
....................     } 
0C6BC:  MOVLB  0
0C6BE:  GOTO   C810 (RETURN)
.................... } 
....................  
.................... // ADCS RAW command part c 
.................... uint8_t command_adcs_raw_part_c(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
0C6C2:  MOVLW  02
0C6C4:  MOVLB  C
0C6C6:  MOVWF  xBE
0C6C8:  MOVLB  0
0C6CA:  CALL   52E8
0C6CE:  MOVF   01,W
0C6D0:  SUBLW  02
0C6D2:  BZ    C6F6
....................         if (verbose) { 
0C6D4:  MOVLB  5
0C6D6:  MOVF   x5A,F
0C6D8:  BZ    C6EE
....................             fprintf(PC, "MUX change failed!"); 
0C6DA:  MOVLW  70
0C6DC:  MOVWF  FF6
0C6DE:  MOVLW  10
0C6E0:  MOVWF  FF7
0C6E2:  MOVLW  00
0C6E4:  MOVWF  FF8
0C6E6:  MOVLB  0
0C6E8:  CALL   4534
0C6EC:  MOVLB  5
....................         } 
....................         return 1; 
0C6EE:  MOVLW  01
0C6F0:  MOVWF  01
0C6F2:  BRA    C862
0C6F4:  MOVLB  0
....................     } 
....................     enum { raw_c_size = 6, 
....................         padding_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_c[raw_c_size]; 
....................         uint8_t padding[padding_size]; 
....................         uint8_t crc0_part_a; 
....................         uint8_t crc0_part_b; 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
0C6F6:  MOVFF  C39,C3B
0C6FA:  MOVFF  C38,C3A
....................  
....................     if (adcs_raw_part_a_crc0 != packet->crc0_part_a) { 
0C6FE:  MOVLW  10
0C700:  MOVLB  C
0C702:  ADDWF  x3A,W
0C704:  MOVWF  FE9
0C706:  MOVLW  00
0C708:  ADDWFC x3B,W
0C70A:  MOVWF  FEA
0C70C:  MOVF   FEF,W
0C70E:  MOVLB  8
0C710:  SUBWF  x98,W
0C712:  BZ    C74A
....................         uart_print_pc_hex(packet->part_c, raw_c_size); 
0C714:  MOVLW  02
0C716:  MOVLB  C
0C718:  ADDWF  x3A,W
0C71A:  MOVWF  01
0C71C:  MOVLW  00
0C71E:  ADDWFC x3B,W
0C720:  MOVWF  03
0C722:  MOVFF  01,C64
0C726:  MOVWF  x65
0C728:  MOVWF  x90
0C72A:  MOVFF  01,C8F
0C72E:  MOVLW  06
0C730:  MOVWF  x91
0C732:  MOVLB  0
0C734:  CALL   7A5C
....................         fprintf(PC, "Received adcs raw part c. Part a pairing error."); 
0C738:  MOVLW  84
0C73A:  MOVWF  FF6
0C73C:  MOVLW  10
0C73E:  MOVWF  FF7
0C740:  MOVLW  00
0C742:  MOVWF  FF8
0C744:  CALL   4534
....................     } else if (adcs_raw_part_b_crc0 != packet->crc0_part_b) { 
0C748:  BRA    C834
0C74A:  MOVLW  11
0C74C:  MOVLB  C
0C74E:  ADDWF  x3A,W
0C750:  MOVWF  FE9
0C752:  MOVLW  00
0C754:  ADDWFC x3B,W
0C756:  MOVWF  FEA
0C758:  MOVF   FEF,W
0C75A:  MOVLB  8
0C75C:  SUBWF  x99,W
0C75E:  BZ    C798
....................         uart_print_pc_hex(packet->part_c, raw_c_size); 
0C760:  MOVLW  02
0C762:  MOVLB  C
0C764:  ADDWF  x3A,W
0C766:  MOVWF  01
0C768:  MOVLW  00
0C76A:  ADDWFC x3B,W
0C76C:  MOVWF  03
0C76E:  MOVFF  01,C64
0C772:  MOVWF  x65
0C774:  MOVWF  x90
0C776:  MOVFF  01,C8F
0C77A:  MOVLW  06
0C77C:  MOVWF  x91
0C77E:  MOVLB  0
0C780:  CALL   7A5C
....................         fprintf(PC, "Received adcs raw part c. Part b pairing error."); 
0C784:  MOVLW  B4
0C786:  MOVWF  FF6
0C788:  MOVLW  10
0C78A:  MOVWF  FF7
0C78C:  MOVLW  00
0C78E:  MOVWF  FF8
0C790:  CALL   4534
....................     } else { 
0C794:  BRA    C834
0C796:  MOVLB  8
....................         uint8_t adcs_cmd[40]; 
....................         memcpy(adcs_cmd, adcs_raw_part_a, sizeof(adcs_raw_part_a)); 
0C798:  MOVLW  0C
0C79A:  MOVWF  FEA
0C79C:  MOVLW  3C
0C79E:  MOVWF  FE9
0C7A0:  MOVLW  08
0C7A2:  MOVWF  FE2
0C7A4:  MOVLW  78
0C7A6:  MOVWF  FE1
0C7A8:  MOVLW  10
0C7AA:  MOVWF  01
0C7AC:  MOVFF  FE6,FEE
0C7B0:  DECFSZ 01,F
0C7B2:  BRA    C7AC
....................         memcpy(adcs_cmd + sizeof(adcs_raw_part_a), adcs_raw_part_b, sizeof(adcs_raw_part_b)); 
0C7B4:  MOVLW  0C
0C7B6:  MOVWF  FEA
0C7B8:  MOVLW  4C
0C7BA:  MOVWF  FE9
0C7BC:  MOVLW  08
0C7BE:  MOVWF  FE2
0C7C0:  MOVLW  88
0C7C2:  MOVWF  FE1
0C7C4:  MOVLW  10
0C7C6:  MOVWF  01
0C7C8:  MOVFF  FE6,FEE
0C7CC:  DECFSZ 01,F
0C7CE:  BRA    C7C8
....................         memcpy(adcs_cmd + sizeof(adcs_raw_part_a) + sizeof(adcs_raw_part_b), packet->part_c, raw_c_size); 
0C7D0:  MOVLW  02
0C7D2:  MOVLB  C
0C7D4:  ADDWF  x3A,W
0C7D6:  MOVWF  01
0C7D8:  MOVLW  00
0C7DA:  ADDWFC x3B,W
0C7DC:  MOVWF  03
0C7DE:  MOVFF  01,C64
0C7E2:  MOVWF  x65
0C7E4:  MOVLW  0C
0C7E6:  MOVWF  FEA
0C7E8:  MOVLW  5C
0C7EA:  MOVWF  FE9
0C7EC:  MOVFF  03,FE2
0C7F0:  MOVFF  01,FE1
0C7F4:  MOVLW  06
0C7F6:  MOVWF  01
0C7F8:  MOVFF  FE6,FEE
0C7FC:  DECFSZ 01,F
0C7FE:  BRA    C7F8
....................         mai_400_command(adcs_cmd, sizeof(adcs_cmd)); 
0C800:  MOVLW  0C
0C802:  MOVWF  x65
0C804:  MOVLW  3C
0C806:  MOVWF  x64
0C808:  MOVLW  28
0C80A:  MOVWF  x66
0C80C:  MOVLB  0
0C80E:  BRA    C5F4
....................         uart_print_pc_hex(adcs_cmd, sizeof(adcs_cmd)); 
0C810:  MOVLW  0C
0C812:  MOVLB  C
0C814:  MOVWF  x90
0C816:  MOVLW  3C
0C818:  MOVWF  x8F
0C81A:  MOVLW  28
0C81C:  MOVWF  x91
0C81E:  MOVLB  0
0C820:  CALL   7A5C
....................         fprintf(PC, "Received adcs raw part c. Pairing ok."); 
0C824:  MOVLW  E4
0C826:  MOVWF  FF6
0C828:  MOVLW  10
0C82A:  MOVWF  FF7
0C82C:  MOVLW  00
0C82E:  MOVWF  FF8
0C830:  CALL   4534
....................     } 
....................     memset(&adcs_raw_part_a, 0, sizeof(adcs_raw_part_a)); // Erase old data. 
0C834:  MOVLW  08
0C836:  MOVWF  FEA
0C838:  MOVLW  78
0C83A:  MOVWF  FE9
0C83C:  CLRF   00
0C83E:  CLRF   02
0C840:  MOVLW  10
0C842:  MOVWF  01
0C844:  CALL   5222
....................     memset(&adcs_raw_part_b, 0, sizeof(adcs_raw_part_b)); // Erase old data. 
0C848:  MOVLW  08
0C84A:  MOVWF  FEA
0C84C:  MOVLW  88
0C84E:  MOVWF  FE9
0C850:  CLRF   00
0C852:  CLRF   02
0C854:  MOVLW  10
0C856:  MOVWF  01
0C858:  CALL   5222
....................     return 0; 
0C85C:  MOVLW  00
0C85E:  MOVWF  01
0C860:  MOVLB  5
0C862:  MOVLB  0
0C864:  GOTO   18A4C (RETURN)
.................... } 
....................  
.................... uint8_t command_to_deploy_SAP(uint8_t* data) 
*
0E2DA:  MOVFF  C39,C3B
0E2DE:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
0E2E2:  BTFSC  3E.7
0E2E4:  BRA    E3F8
0E2E6:  MOVF   3E,W
0E2E8:  SUBLW  37
0E2EA:  BTFSC  FD8.0
0E2EC:  BRA    E3F8
0E2EE:  XORLW  FF
0E2F0:  BNZ   E310
0E2F2:  MOVF   3D,W
0E2F4:  SUBLW  6C
0E2F6:  BTFSC  FD8.0
0E2F8:  BRA    E3F8
0E2FA:  XORLW  FF
0E2FC:  BNZ   E310
0E2FE:  MOVF   3C,W
0E300:  SUBLW  49
0E302:  BTFSC  FD8.0
0E304:  BRA    E3F8
0E306:  XORLW  FF
0E308:  BNZ   E310
0E30A:  MOVF   3B,W
0E30C:  SUBLW  A5
0E30E:  BC    E3F8
....................         uint8_t time = 30;           // in seconds 
0E310:  MOVLW  1E
0E312:  MOVLB  C
0E314:  MOVWF  x3C
....................         if (packet->time_s) {        // if specified time is not zero, then use specified value 
0E316:  MOVLW  02
0E318:  ADDWF  x3A,W
0E31A:  MOVWF  FE9
0E31C:  MOVLW  00
0E31E:  ADDWFC x3B,W
0E320:  MOVWF  FEA
0E322:  MOVF   FEF,F
0E324:  BZ    E336
....................             time = packet->time_s; 
0E326:  MOVLW  02
0E328:  ADDWF  x3A,W
0E32A:  MOVWF  FE9
0E32C:  MOVLW  00
0E32E:  ADDWFC x3B,W
0E330:  MOVWF  FEA
0E332:  MOVFF  FEF,C3C
....................         } 
....................         fprintf(PC, "Deploying SAP for %ds... ", time); 
0E336:  MOVLW  0A
0E338:  MOVWF  FF6
0E33A:  MOVLW  11
0E33C:  MOVWF  FF7
0E33E:  MOVLW  00
0E340:  MOVWF  FF8
0E342:  MOVLW  12
0E344:  MOVWF  xC1
0E346:  MOVLB  0
0E348:  CALL   5290
0E34C:  MOVFF  C3C,CBE
0E350:  MOVLW  18
0E352:  MOVLB  C
0E354:  MOVWF  xBF
0E356:  MOVLB  0
0E358:  CALL   73A8
0E35C:  MOVLW  1E
0E35E:  MOVWF  FF6
0E360:  MOVLW  11
0E362:  MOVWF  FF7
0E364:  MOVLW  00
0E366:  MOVWF  FF8
0E368:  MOVLW  05
0E36A:  MOVLB  C
0E36C:  MOVWF  xC1
0E36E:  MOVLB  0
0E370:  CALL   5290
....................         output_high(DIO_BURNER_SAP); 
0E374:  BCF    F94.2
0E376:  BSF    F8B.2
....................         delay_ms((uint32_t)time * 1000); 
0E378:  MOVLB  C
0E37A:  CLRF   x40
0E37C:  CLRF   x3F
0E37E:  CLRF   x3E
0E380:  MOVFF  C3C,C3D
0E384:  MOVFF  C40,CB4
0E388:  MOVFF  C3F,CB3
0E38C:  MOVFF  C3E,CB2
0E390:  MOVFF  C3C,CB1
0E394:  CLRF   xB8
0E396:  CLRF   xB7
0E398:  MOVLW  03
0E39A:  MOVWF  xB6
0E39C:  MOVLW  E8
0E39E:  MOVWF  xB5
0E3A0:  MOVLB  0
0E3A2:  CALL   456E
0E3A6:  MOVFF  03,C40
0E3AA:  MOVFF  02,C3F
0E3AE:  MOVFF  01,C3E
0E3B2:  MOVFF  00,C3D
0E3B6:  MOVFF  01,C41
0E3BA:  MOVLB  C
0E3BC:  INCF   x41,F
0E3BE:  DECF   x41,F
0E3C0:  BTFSC  FD8.2
0E3C2:  BRA    E3D2
0E3C4:  MOVLB  D
0E3C6:  SETF   x52
0E3C8:  MOVLB  0
0E3CA:  CALL   5266
0E3CE:  MOVLB  C
0E3D0:  BRA    E3BE
0E3D2:  MOVFF  C3D,D52
0E3D6:  MOVLB  0
0E3D8:  CALL   5266
....................         output_low(DIO_BURNER_SAP); 
0E3DC:  BCF    F94.2
0E3DE:  BCF    F8B.2
....................         fprintf(PC, "Done!\r\n"); 
0E3E0:  MOVLW  24
0E3E2:  MOVWF  FF6
0E3E4:  MOVLW  11
0E3E6:  MOVWF  FF7
0E3E8:  MOVLW  00
0E3EA:  MOVWF  FF8
0E3EC:  CALL   4534
....................         return 0; 
0E3F0:  MOVLW  00
0E3F2:  MOVWF  01
0E3F4:  BRA    E3FC
....................     } else { 
0E3F6:  BRA    E3FC
....................         return 1; 
0E3F8:  MOVLW  01
0E3FA:  MOVWF  01
....................     } 
0E3FC:  GOTO   18C32 (RETURN)
.................... } 
....................  
.................... uint8_t command_to_deploy_SMA(uint8_t* data) 
0E400:  MOVFF  C39,C3B
0E404:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
0E408:  BTFSC  3E.7
0E40A:  BRA    E51E
0E40C:  MOVF   3E,W
0E40E:  SUBLW  37
0E410:  BTFSC  FD8.0
0E412:  BRA    E51E
0E414:  XORLW  FF
0E416:  BNZ   E436
0E418:  MOVF   3D,W
0E41A:  SUBLW  6C
0E41C:  BTFSC  FD8.0
0E41E:  BRA    E51E
0E420:  XORLW  FF
0E422:  BNZ   E436
0E424:  MOVF   3C,W
0E426:  SUBLW  49
0E428:  BTFSC  FD8.0
0E42A:  BRA    E51E
0E42C:  XORLW  FF
0E42E:  BNZ   E436
0E430:  MOVF   3B,W
0E432:  SUBLW  A5
0E434:  BC    E51E
....................         uint8_t time = 60;           // in seconds 
0E436:  MOVLW  3C
0E438:  MOVLB  C
0E43A:  MOVWF  x3C
....................         if (packet->time_s) {        // if specified time is not zero, then use specified value 
0E43C:  MOVLW  02
0E43E:  ADDWF  x3A,W
0E440:  MOVWF  FE9
0E442:  MOVLW  00
0E444:  ADDWFC x3B,W
0E446:  MOVWF  FEA
0E448:  MOVF   FEF,F
0E44A:  BZ    E45C
....................             time = packet->time_s; 
0E44C:  MOVLW  02
0E44E:  ADDWF  x3A,W
0E450:  MOVWF  FE9
0E452:  MOVLW  00
0E454:  ADDWFC x3B,W
0E456:  MOVWF  FEA
0E458:  MOVFF  FEF,C3C
....................         } 
....................         fprintf(PC, "Deploying SMA for %ds... ", time); 
0E45C:  MOVLW  2C
0E45E:  MOVWF  FF6
0E460:  MOVLW  11
0E462:  MOVWF  FF7
0E464:  MOVLW  00
0E466:  MOVWF  FF8
0E468:  MOVLW  12
0E46A:  MOVWF  xC1
0E46C:  MOVLB  0
0E46E:  CALL   5290
0E472:  MOVFF  C3C,CBE
0E476:  MOVLW  18
0E478:  MOVLB  C
0E47A:  MOVWF  xBF
0E47C:  MOVLB  0
0E47E:  CALL   73A8
0E482:  MOVLW  40
0E484:  MOVWF  FF6
0E486:  MOVLW  11
0E488:  MOVWF  FF7
0E48A:  MOVLW  00
0E48C:  MOVWF  FF8
0E48E:  MOVLW  05
0E490:  MOVLB  C
0E492:  MOVWF  xC1
0E494:  MOVLB  0
0E496:  CALL   5290
....................         output_high(DIO_BURNER_SMA); 
0E49A:  BCF    F97.5
0E49C:  BSF    F8E.5
....................         delay_ms((uint32_t)time * 1000); 
0E49E:  MOVLB  C
0E4A0:  CLRF   x40
0E4A2:  CLRF   x3F
0E4A4:  CLRF   x3E
0E4A6:  MOVFF  C3C,C3D
0E4AA:  MOVFF  C40,CB4
0E4AE:  MOVFF  C3F,CB3
0E4B2:  MOVFF  C3E,CB2
0E4B6:  MOVFF  C3C,CB1
0E4BA:  CLRF   xB8
0E4BC:  CLRF   xB7
0E4BE:  MOVLW  03
0E4C0:  MOVWF  xB6
0E4C2:  MOVLW  E8
0E4C4:  MOVWF  xB5
0E4C6:  MOVLB  0
0E4C8:  CALL   456E
0E4CC:  MOVFF  03,C40
0E4D0:  MOVFF  02,C3F
0E4D4:  MOVFF  01,C3E
0E4D8:  MOVFF  00,C3D
0E4DC:  MOVFF  01,C41
0E4E0:  MOVLB  C
0E4E2:  INCF   x41,F
0E4E4:  DECF   x41,F
0E4E6:  BTFSC  FD8.2
0E4E8:  BRA    E4F8
0E4EA:  MOVLB  D
0E4EC:  SETF   x52
0E4EE:  MOVLB  0
0E4F0:  CALL   5266
0E4F4:  MOVLB  C
0E4F6:  BRA    E4E4
0E4F8:  MOVFF  C3D,D52
0E4FC:  MOVLB  0
0E4FE:  CALL   5266
....................         output_low(DIO_BURNER_SMA); 
0E502:  BCF    F97.5
0E504:  BCF    F8E.5
....................         fprintf(PC, "Done!\r\n"); 
0E506:  MOVLW  46
0E508:  MOVWF  FF6
0E50A:  MOVLW  11
0E50C:  MOVWF  FF7
0E50E:  MOVLW  00
0E510:  MOVWF  FF8
0E512:  CALL   4534
....................         return 0; 
0E516:  MOVLW  00
0E518:  MOVWF  01
0E51A:  BRA    E528
....................     } else { 
0E51C:  BRA    E524
....................         return 1; 
0E51E:  MOVLW  01
0E520:  MOVWF  01
0E522:  BRA    E528
....................     } 
....................     return 0; 
0E524:  MOVLW  00
0E526:  MOVWF  01
0E528:  GOTO   18C44 (RETURN)
.................... } 
....................  
.................... // General command for ZES SEL mission (sub-function 1) 
.................... uint8_t command_sel1_zes(uint8_t* data) 
*
0BD4E:  MOVFF  C39,C3B
0BD52:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     schedule(current_time, { 0xC0, 0x0F });      // Check UART 
0BD56:  MOVLW  C0
0BD58:  MOVLB  C
0BD5A:  MOVWF  x3C
0BD5C:  MOVLW  0F
0BD5E:  MOVWF  x3D
0BD60:  MOVFF  3E,C98
0BD64:  MOVFF  3D,C97
0BD68:  MOVFF  3C,C96
0BD6C:  MOVFF  3B,C95
0BD70:  MOVLW  0C
0BD72:  MOVWF  x9A
0BD74:  MOVLW  3C
0BD76:  MOVWF  x99
0BD78:  MOVLB  0
0BD7A:  CALL   704C
....................     schedule(current_time + 15, { 0xC0, 0x19 }); // Data initialization 
0BD7E:  MOVLW  C0
0BD80:  MOVLB  C
0BD82:  MOVWF  x3E
0BD84:  MOVLW  19
0BD86:  MOVWF  x3F
0BD88:  MOVLW  0F
0BD8A:  ADDWF  3B,W
0BD8C:  MOVWF  x47
0BD8E:  MOVLW  00
0BD90:  ADDWFC 3C,W
0BD92:  MOVWF  x48
0BD94:  MOVLW  00
0BD96:  ADDWFC 3D,W
0BD98:  MOVWF  x49
0BD9A:  MOVLW  00
0BD9C:  ADDWFC 3E,W
0BD9E:  MOVWF  x4A
0BDA0:  MOVWF  x98
0BDA2:  MOVFF  C49,C97
0BDA6:  MOVFF  C48,C96
0BDAA:  MOVFF  C47,C95
0BDAE:  MOVLW  0C
0BDB0:  MOVWF  x9A
0BDB2:  MOVLW  3E
0BDB4:  MOVWF  x99
0BDB6:  MOVLB  0
0BDB8:  CALL   704C
....................  
....................     struct new_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     } new_packet; 
....................  
....................     new_packet.origin = MSG_COMM; 
0BDBC:  MOVLW  C0
0BDBE:  MOVLB  C
0BDC0:  MOVWF  x40
....................     new_packet.command = 0x12; 
0BDC2:  MOVLW  12
0BDC4:  MOVWF  x41
....................     new_packet.repetitions = packet->repetitions;                             // Number of times to do the copy command to main bus 
0BDC6:  MOVLW  02
0BDC8:  ADDWF  x3A,W
0BDCA:  MOVWF  FE9
0BDCC:  MOVLW  00
0BDCE:  ADDWFC x3B,W
0BDD0:  MOVWF  FEA
0BDD2:  MOVFF  FEF,C42
....................     new_packet.delay_between_repetitions = packet->delay_between_repetitions; // time between copies 
0BDD6:  MOVLW  03
0BDD8:  ADDWF  x3A,W
0BDDA:  MOVWF  FE9
0BDDC:  MOVLW  00
0BDDE:  ADDWFC x3B,W
0BDE0:  MOVWF  FEA
0BDE2:  MOVFF  FEF,C43
0BDE6:  MOVFF  FEC,C44
0BDEA:  MOVFF  FEC,C45
0BDEE:  MOVFF  FEC,C46
....................  
....................     vschedule(current_time + 30, (uint8_t*)&new_packet); // Data copy 
0BDF2:  MOVLW  1E
0BDF4:  ADDWF  3B,W
0BDF6:  MOVWF  x47
0BDF8:  MOVLW  00
0BDFA:  ADDWFC 3C,W
0BDFC:  MOVWF  x48
0BDFE:  MOVLW  00
0BE00:  ADDWFC 3D,W
0BE02:  MOVWF  x49
0BE04:  MOVLW  00
0BE06:  ADDWFC 3E,W
0BE08:  MOVWF  x4A
0BE0A:  MOVLW  0C
0BE0C:  MOVWF  x4C
0BE0E:  MOVLW  40
0BE10:  MOVWF  x4B
0BE12:  MOVFF  C4A,C98
0BE16:  MOVFF  C49,C97
0BE1A:  MOVFF  C48,C96
0BE1E:  MOVFF  C47,C95
0BE22:  MOVFF  C4C,C9A
0BE26:  MOVWF  x99
0BE28:  MOVLB  0
0BE2A:  CALL   704C
....................     return 0; 
0BE2E:  MOVLW  00
0BE30:  MOVWF  01
0BE32:  GOTO   18974 (RETURN)
.................... } 
....................  
.................... // General command for REF SEL mission (sub-function 2) 
.................... uint8_t command_sel2_ref(uint8_t* data) 
0BE36:  MOVFF  C39,C3B
0BE3A:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     schedule(current_time, { 0xC0, 0x1F });      // Check UART 
0BE3E:  MOVLW  C0
0BE40:  MOVLB  C
0BE42:  MOVWF  x3C
0BE44:  MOVLW  1F
0BE46:  MOVWF  x3D
0BE48:  MOVFF  3E,C98
0BE4C:  MOVFF  3D,C97
0BE50:  MOVFF  3C,C96
0BE54:  MOVFF  3B,C95
0BE58:  MOVLW  0C
0BE5A:  MOVWF  x9A
0BE5C:  MOVLW  3C
0BE5E:  MOVWF  x99
0BE60:  MOVLB  0
0BE62:  CALL   704C
....................     schedule(current_time + 15, { 0xC0, 0x80 }); // Data initialization 
0BE66:  MOVLW  C0
0BE68:  MOVLB  C
0BE6A:  MOVWF  x3E
0BE6C:  MOVLW  80
0BE6E:  MOVWF  x3F
0BE70:  MOVLW  0F
0BE72:  ADDWF  3B,W
0BE74:  MOVWF  x47
0BE76:  MOVLW  00
0BE78:  ADDWFC 3C,W
0BE7A:  MOVWF  x48
0BE7C:  MOVLW  00
0BE7E:  ADDWFC 3D,W
0BE80:  MOVWF  x49
0BE82:  MOVLW  00
0BE84:  ADDWFC 3E,W
0BE86:  MOVWF  x4A
0BE88:  MOVWF  x98
0BE8A:  MOVFF  C49,C97
0BE8E:  MOVFF  C48,C96
0BE92:  MOVFF  C47,C95
0BE96:  MOVLW  0C
0BE98:  MOVWF  x9A
0BE9A:  MOVLW  3E
0BE9C:  MOVWF  x99
0BE9E:  MOVLB  0
0BEA0:  CALL   704C
....................  
....................     struct new_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     } new_packet; 
....................  
....................     new_packet.origin = MSG_COMM; 
0BEA4:  MOVLW  C0
0BEA6:  MOVLB  C
0BEA8:  MOVWF  x40
....................     new_packet.command = 0x81; 
0BEAA:  MOVLW  81
0BEAC:  MOVWF  x41
....................     new_packet.repetitions = packet->repetitions;                             // Number of times to do the copy command to main bus 
0BEAE:  MOVLW  02
0BEB0:  ADDWF  x3A,W
0BEB2:  MOVWF  FE9
0BEB4:  MOVLW  00
0BEB6:  ADDWFC x3B,W
0BEB8:  MOVWF  FEA
0BEBA:  MOVFF  FEF,C42
....................     new_packet.delay_between_repetitions = packet->delay_between_repetitions; // time between copies 
0BEBE:  MOVLW  03
0BEC0:  ADDWF  x3A,W
0BEC2:  MOVWF  FE9
0BEC4:  MOVLW  00
0BEC6:  ADDWFC x3B,W
0BEC8:  MOVWF  FEA
0BECA:  MOVFF  FEF,C43
0BECE:  MOVFF  FEC,C44
0BED2:  MOVFF  FEC,C45
0BED6:  MOVFF  FEC,C46
....................  
....................     vschedule(current_time + 30, (uint8_t*)&new_packet); // Data copy 
0BEDA:  MOVLW  1E
0BEDC:  ADDWF  3B,W
0BEDE:  MOVWF  x47
0BEE0:  MOVLW  00
0BEE2:  ADDWFC 3C,W
0BEE4:  MOVWF  x48
0BEE6:  MOVLW  00
0BEE8:  ADDWFC 3D,W
0BEEA:  MOVWF  x49
0BEEC:  MOVLW  00
0BEEE:  ADDWFC 3E,W
0BEF0:  MOVWF  x4A
0BEF2:  MOVLW  0C
0BEF4:  MOVWF  x4C
0BEF6:  MOVLW  40
0BEF8:  MOVWF  x4B
0BEFA:  MOVFF  C4A,C98
0BEFE:  MOVFF  C49,C97
0BF02:  MOVFF  C48,C96
0BF06:  MOVFF  C47,C95
0BF0A:  MOVFF  C4C,C9A
0BF0E:  MOVWF  x99
0BF10:  MOVLB  0
0BF12:  CALL   704C
....................     return 0; 
0BF16:  MOVLW  00
0BF18:  MOVWF  01
0BF1A:  GOTO   18986 (RETURN)
.................... } 
....................  
.................... // Send 0x3A to ZES 
.................... // Send CMD 1 of SEL 1 ZES (0x3A) to ZES_RX, and ZES_TX will send back hex number 5A (0x5A) as acknowledgement. 
.................... uint8_t command_sel1_a(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_zes) != mux_sel_zes) { // If MUX did not change 
*
0B758:  MOVLB  C
0B75A:  CLRF   xBE
0B75C:  MOVLB  0
0B75E:  CALL   52E8
0B762:  MOVF   01,F
0B764:  BZ    B788
....................         if (verbose) { 
0B766:  MOVLB  5
0B768:  MOVF   x5A,F
0B76A:  BZ    B780
....................             fprintf(PC, "MUX change failed!"); 
0B76C:  MOVLW  4E
0B76E:  MOVWF  FF6
0B770:  MOVLW  11
0B772:  MOVWF  FF7
0B774:  MOVLW  00
0B776:  MOVWF  FF8
0B778:  MOVLB  0
0B77A:  CALL   4534
0B77E:  MOVLB  5
....................         } 
....................         return 1; 
0B780:  MOVLW  01
0B782:  MOVWF  01
0B784:  BRA    B8C8
0B786:  MOVLB  0
....................     } 
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
0B788:  MOVLB  C
0B78A:  CLRF   x3A
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
0B78C:  CLRF   x3B
0B78E:  MOVF   x3B,W
0B790:  SUBLW  02
0B792:  BTFSS  FD8.0
0B794:  BRA    B884
....................         fprintf(PC, "\r\nAttempt %d\r\n", attempt); 
0B796:  MOVLW  62
0B798:  MOVWF  FF6
0B79A:  MOVLW  11
0B79C:  MOVWF  FF7
0B79E:  MOVLW  00
0B7A0:  MOVWF  FF8
0B7A2:  MOVLW  0A
0B7A4:  MOVWF  xC1
0B7A6:  MOVLB  0
0B7A8:  CALL   5290
0B7AC:  MOVFF  C3B,CBE
0B7B0:  MOVLW  18
0B7B2:  MOVLB  C
0B7B4:  MOVWF  xBF
0B7B6:  MOVLB  0
0B7B8:  CALL   73A8
0B7BC:  MOVLW  0D
0B7BE:  MOVLB  D
0B7C0:  MOVWF  x6A
0B7C2:  MOVLB  0
0B7C4:  CALL   44EE
0B7C8:  MOVLW  0A
0B7CA:  MOVLB  D
0B7CC:  MOVWF  x6A
0B7CE:  MOVLB  0
0B7D0:  CALL   44EE
....................         fputc(0x3A, SEL_ZES); 
0B7D4:  MOVLW  3A
0B7D6:  CALL   5464
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
0B7DA:  MOVLW  72
0B7DC:  MOVWF  FF6
0B7DE:  MOVLW  11
0B7E0:  MOVWF  FF7
0B7E2:  MOVLW  00
0B7E4:  MOVWF  FF8
0B7E6:  CALL   4534
....................         while (++timeout < 5) { 
0B7EA:  MOVLB  C
0B7EC:  INCF   x3A,F
0B7EE:  MOVF   x3A,W
0B7F0:  SUBLW  04
0B7F2:  BNC   B87E
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
0B7F4:  MOVLW  A2
0B7F6:  MOVWF  FF6
0B7F8:  MOVLW  11
0B7FA:  MOVWF  FF7
0B7FC:  MOVLW  00
0B7FE:  MOVWF  FF8
0B800:  MOVLB  0
0B802:  CALL   4534
....................             if (kbhit(SEL_ZES)) { 
0B806:  BTFSS  F9E.5
0B808:  BRA    B864
....................                 uint8_t r = fgetc(SEL_ZES); 
0B80A:  CALL   213C
0B80E:  MOVFF  01,C3C
....................                 if (r == 0x5A) { 
0B812:  MOVLB  C
0B814:  MOVF   x3C,W
0B816:  SUBLW  5A
0B818:  BNZ   B862
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
0B81A:  MOVLW  C4
0B81C:  MOVWF  FF6
0B81E:  MOVLW  11
0B820:  MOVWF  FF7
0B822:  MOVLW  00
0B824:  MOVWF  FF8
0B826:  MOVLW  06
0B828:  MOVWF  xC1
0B82A:  MOVLB  0
0B82C:  CALL   5290
0B830:  MOVFF  C3C,CBF
0B834:  MOVLW  37
0B836:  MOVLB  C
0B838:  MOVWF  xC0
0B83A:  MOVLB  0
0B83C:  CALL   5A92
0B840:  MOVLW  CC
0B842:  MOVWF  FF6
0B844:  MOVLW  11
0B846:  MOVWF  FF7
0B848:  MOVLW  00
0B84A:  MOVWF  FF8
0B84C:  MOVLW  05
0B84E:  MOVLB  C
0B850:  MOVWF  xC1
0B852:  MOVLB  0
0B854:  CALL   5290
....................                     return r; 
0B858:  MOVFF  C3C,01
0B85C:  MOVLB  5
0B85E:  BRA    B8C8
0B860:  MOVLB  C
0B862:  MOVLB  0
....................                 } 
....................             } 
....................             delay_ms(1000); 
0B864:  MOVLW  04
0B866:  MOVLB  C
0B868:  MOVWF  x3D
0B86A:  MOVLW  FA
0B86C:  MOVLB  D
0B86E:  MOVWF  x52
0B870:  MOVLB  0
0B872:  CALL   5266
0B876:  MOVLB  C
0B878:  DECFSZ x3D,F
0B87A:  BRA    B86A
0B87C:  BRA    B7EC
....................         } 
....................         timeout = 0; 
0B87E:  CLRF   x3A
0B880:  INCF   x3B,F
0B882:  BRA    B78E
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
0B884:  MOVLW  D2
0B886:  MOVWF  FF6
0B888:  MOVLW  11
0B88A:  MOVWF  FF7
0B88C:  MOVLW  00
0B88E:  MOVWF  FF8
0B890:  MOVLW  1B
0B892:  MOVWF  xC1
0B894:  MOVLB  0
0B896:  CALL   5290
0B89A:  MOVLW  03
0B89C:  MOVLB  C
0B89E:  MOVWF  xBE
0B8A0:  MOVLW  18
0B8A2:  MOVWF  xBF
0B8A4:  MOVLB  0
0B8A6:  CALL   73A8
0B8AA:  MOVLW  EF
0B8AC:  MOVWF  FF6
0B8AE:  MOVLW  11
0B8B0:  MOVWF  FF7
0B8B2:  MOVLW  00
0B8B4:  MOVWF  FF8
0B8B6:  MOVLW  09
0B8B8:  MOVLB  C
0B8BA:  MOVWF  xC1
0B8BC:  MOVLB  0
0B8BE:  CALL   5290
....................     return 0xFF; 
0B8C2:  MOVLW  FF
0B8C4:  MOVWF  01
0B8C6:  MOVLB  5
0B8C8:  MOVLB  0
0B8CA:  GOTO   1892C (RETURN)
.................... } 
....................  
.................... // Send reset function (Initialization of SEL Board) 
.................... uint8_t command_sel1_b(uint8_t* data) 
.................... { 
....................     send_mcp_command(mcp_cmd_zes_reset, 0, 0); 
*
0BBC0:  MOVLW  30
0BBC2:  MOVLB  C
0BBC4:  MOVWF  x80
0BBC6:  CLRF   x82
0BBC8:  CLRF   x81
0BBCA:  CLRF   x83
0BBCC:  MOVLB  0
0BBCE:  RCALL  BAD6
....................     return 0; 
0BBD0:  MOVLW  00
0BBD2:  MOVWF  01
0BBD4:  GOTO   18950 (RETURN)
.................... } 
....................  
.................... // Send 0x2A to ZES 
.................... // Send CMD 3 of SEL 1 ZES (0x2A) to ZES_RX, and ZES_TX will send back hex number A2 (0xA2) as data initialization. 
.................... uint8_t command_sel1_c(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_zes) != mux_sel_zes) { // If MUX did not change 
0BBD8:  MOVLB  C
0BBDA:  CLRF   xBE
0BBDC:  MOVLB  0
0BBDE:  CALL   52E8
0BBE2:  MOVF   01,F
0BBE4:  BZ    BC08
....................         if (verbose) { 
0BBE6:  MOVLB  5
0BBE8:  MOVF   x5A,F
0BBEA:  BZ    BC00
....................             fprintf(PC, "MUX change failed!"); 
0BBEC:  MOVLW  FA
0BBEE:  MOVWF  FF6
0BBF0:  MOVLW  11
0BBF2:  MOVWF  FF7
0BBF4:  MOVLW  00
0BBF6:  MOVWF  FF8
0BBF8:  MOVLB  0
0BBFA:  CALL   4534
0BBFE:  MOVLB  5
....................         } 
....................         return 1; 
0BC00:  MOVLW  01
0BC02:  MOVWF  01
0BC04:  BRA    BD48
0BC06:  MOVLB  0
....................     } 
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
0BC08:  MOVLB  C
0BC0A:  CLRF   x3A
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
0BC0C:  CLRF   x3B
0BC0E:  MOVF   x3B,W
0BC10:  SUBLW  02
0BC12:  BTFSS  FD8.0
0BC14:  BRA    BD04
....................         fprintf(PC, "\r\n\r\nAttempt %d\r\n", attempt); 
0BC16:  MOVLW  0E
0BC18:  MOVWF  FF6
0BC1A:  MOVLW  12
0BC1C:  MOVWF  FF7
0BC1E:  MOVLW  00
0BC20:  MOVWF  FF8
0BC22:  MOVLW  0C
0BC24:  MOVWF  xC1
0BC26:  MOVLB  0
0BC28:  CALL   5290
0BC2C:  MOVFF  C3B,CBE
0BC30:  MOVLW  18
0BC32:  MOVLB  C
0BC34:  MOVWF  xBF
0BC36:  MOVLB  0
0BC38:  CALL   73A8
0BC3C:  MOVLW  0D
0BC3E:  MOVLB  D
0BC40:  MOVWF  x6A
0BC42:  MOVLB  0
0BC44:  CALL   44EE
0BC48:  MOVLW  0A
0BC4A:  MOVLB  D
0BC4C:  MOVWF  x6A
0BC4E:  MOVLB  0
0BC50:  CALL   44EE
....................         fputc(0x2A, SEL_ZES); // Prepare Data from ZES board 
0BC54:  MOVLW  2A
0BC56:  CALL   5464
....................  
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
0BC5A:  MOVLW  20
0BC5C:  MOVWF  FF6
0BC5E:  MOVLW  12
0BC60:  MOVWF  FF7
0BC62:  MOVLW  00
0BC64:  MOVWF  FF8
0BC66:  CALL   4534
....................         while (++timeout < 5) { 
0BC6A:  MOVLB  C
0BC6C:  INCF   x3A,F
0BC6E:  MOVF   x3A,W
0BC70:  SUBLW  04
0BC72:  BNC   BCFE
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
0BC74:  MOVLW  50
0BC76:  MOVWF  FF6
0BC78:  MOVLW  12
0BC7A:  MOVWF  FF7
0BC7C:  MOVLW  00
0BC7E:  MOVWF  FF8
0BC80:  MOVLB  0
0BC82:  CALL   4534
....................             if (kbhit(SEL_ZES)) { 
0BC86:  BTFSS  F9E.5
0BC88:  BRA    BCE4
....................                 uint8_t r = fgetc(SEL_ZES); 
0BC8A:  CALL   213C
0BC8E:  MOVFF  01,C3C
....................                 if (r == 0xA2) { 
0BC92:  MOVLB  C
0BC94:  MOVF   x3C,W
0BC96:  SUBLW  A2
0BC98:  BNZ   BCE2
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
0BC9A:  MOVLW  72
0BC9C:  MOVWF  FF6
0BC9E:  MOVLW  12
0BCA0:  MOVWF  FF7
0BCA2:  MOVLW  00
0BCA4:  MOVWF  FF8
0BCA6:  MOVLW  06
0BCA8:  MOVWF  xC1
0BCAA:  MOVLB  0
0BCAC:  CALL   5290
0BCB0:  MOVFF  C3C,CBF
0BCB4:  MOVLW  37
0BCB6:  MOVLB  C
0BCB8:  MOVWF  xC0
0BCBA:  MOVLB  0
0BCBC:  CALL   5A92
0BCC0:  MOVLW  7A
0BCC2:  MOVWF  FF6
0BCC4:  MOVLW  12
0BCC6:  MOVWF  FF7
0BCC8:  MOVLW  00
0BCCA:  MOVWF  FF8
0BCCC:  MOVLW  05
0BCCE:  MOVLB  C
0BCD0:  MOVWF  xC1
0BCD2:  MOVLB  0
0BCD4:  CALL   5290
....................                     return r; 
0BCD8:  MOVFF  C3C,01
0BCDC:  MOVLB  5
0BCDE:  BRA    BD48
0BCE0:  MOVLB  C
0BCE2:  MOVLB  0
....................                 } 
....................             } 
....................             delay_ms(1000); 
0BCE4:  MOVLW  04
0BCE6:  MOVLB  C
0BCE8:  MOVWF  x3D
0BCEA:  MOVLW  FA
0BCEC:  MOVLB  D
0BCEE:  MOVWF  x52
0BCF0:  MOVLB  0
0BCF2:  CALL   5266
0BCF6:  MOVLB  C
0BCF8:  DECFSZ x3D,F
0BCFA:  BRA    BCEA
0BCFC:  BRA    BC6C
....................         } 
....................         timeout = 0; 
0BCFE:  CLRF   x3A
0BD00:  INCF   x3B,F
0BD02:  BRA    BC0E
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
0BD04:  MOVLW  80
0BD06:  MOVWF  FF6
0BD08:  MOVLW  12
0BD0A:  MOVWF  FF7
0BD0C:  MOVLW  00
0BD0E:  MOVWF  FF8
0BD10:  MOVLW  1B
0BD12:  MOVWF  xC1
0BD14:  MOVLB  0
0BD16:  CALL   5290
0BD1A:  MOVLW  03
0BD1C:  MOVLB  C
0BD1E:  MOVWF  xBE
0BD20:  MOVLW  18
0BD22:  MOVWF  xBF
0BD24:  MOVLB  0
0BD26:  CALL   73A8
0BD2A:  MOVLW  9D
0BD2C:  MOVWF  FF6
0BD2E:  MOVLW  12
0BD30:  MOVWF  FF7
0BD32:  MOVLW  00
0BD34:  MOVWF  FF8
0BD36:  MOVLW  09
0BD38:  MOVLB  C
0BD3A:  MOVWF  xC1
0BD3C:  MOVLB  0
0BD3E:  CALL   5290
....................     return 0xFF; 
0BD42:  MOVLW  FF
0BD44:  MOVWF  01
0BD46:  MOVLB  5
0BD48:  MOVLB  0
0BD4A:  GOTO   18962 (RETURN)
.................... } 
....................  
.................... // Send 0x2E to ZES (revised) 
.................... // Send CMD 4 of (0x2E) to ZES_RX, and ZES_TX will send back a first data stream. 
.................... uint8_t command_sel1_d(uint8_t* data) 
*
0B8CE:  MOVFF  C39,C3B
0B8D2:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (mux_sel(mux_sel_zes) != mux_sel_zes) { // If MUX did not change 
0B8D6:  MOVLB  C
0B8D8:  CLRF   xBE
0B8DA:  MOVLB  0
0B8DC:  CALL   52E8
0B8E0:  MOVF   01,F
0B8E2:  BZ    B906
....................         if (verbose) { 
0B8E4:  MOVLB  5
0B8E6:  MOVF   x5A,F
0B8E8:  BZ    B8FE
....................             fprintf(PC, "MUX change failed!"); 
0B8EA:  MOVLW  A8
0B8EC:  MOVWF  FF6
0B8EE:  MOVLW  12
0B8F0:  MOVWF  FF7
0B8F2:  MOVLW  00
0B8F4:  MOVWF  FF8
0B8F6:  MOVLB  0
0B8F8:  CALL   4534
0B8FC:  MOVLB  5
....................         } 
....................         return 1; 
0B8FE:  MOVLW  01
0B900:  MOVWF  01
0B902:  BRA    BAD0
0B904:  MOVLB  0
....................     } 
....................  
....................     uint8_t sel1_d_buffer[128]; 
....................  
....................     for (uint8_t i = 0; i < packet->repetitions; i++) { 
0B906:  MOVLB  C
0B908:  CLRF   xBC
0B90A:  MOVLW  02
0B90C:  ADDWF  x3A,W
0B90E:  MOVWF  FE9
0B910:  MOVLW  00
0B912:  ADDWFC x3B,W
0B914:  MOVWF  FEA
0B916:  MOVF   FEF,W
0B918:  SUBWF  xBC,W
0B91A:  BTFSC  FD8.0
0B91C:  BRA    BACA
....................         fprintf(PC, "Part no. %d: ", i); 
0B91E:  MOVLW  BC
0B920:  MOVWF  FF6
0B922:  MOVLW  12
0B924:  MOVWF  FF7
0B926:  MOVLW  00
0B928:  MOVWF  FF8
0B92A:  MOVLW  09
0B92C:  MOVWF  xC1
0B92E:  MOVLB  0
0B930:  CALL   5290
0B934:  MOVFF  CBC,CBE
0B938:  MOVLW  18
0B93A:  MOVLB  C
0B93C:  MOVWF  xBF
0B93E:  MOVLB  0
0B940:  CALL   73A8
0B944:  MOVLW  3A
0B946:  MOVLB  D
0B948:  MOVWF  x6A
0B94A:  MOVLB  0
0B94C:  CALL   44EE
0B950:  MOVLW  20
0B952:  MOVLB  D
0B954:  MOVWF  x6A
0B956:  MOVLB  0
0B958:  CALL   44EE
....................         fputc(0x2E, SEL_ZES); 
0B95C:  MOVLW  2E
0B95E:  CALL   5464
....................  
....................         uart_download_packet(&uart_port_MSN, sel1_d_buffer, sizeof(sel1_d_buffer), 100000); 
0B962:  MOVLW  0A
0B964:  MOVLB  D
0B966:  MOVWF  x45
0B968:  MOVLW  97
0B96A:  MOVWF  x44
0B96C:  MOVLW  0C
0B96E:  MOVWF  x47
0B970:  MOVLW  3C
0B972:  MOVWF  x46
0B974:  CLRF   x4B
0B976:  CLRF   x4A
0B978:  CLRF   x49
0B97A:  MOVLW  80
0B97C:  MOVWF  x48
0B97E:  CLRF   x4F
0B980:  MOVLW  01
0B982:  MOVWF  x4E
0B984:  MOVLW  86
0B986:  MOVWF  x4D
0B988:  MOVLW  A0
0B98A:  MOVWF  x4C
0B98C:  MOVLB  0
0B98E:  CALL   97CE
....................  
....................         if (sel1_d_buffer[0] == 0x2A && sel1_d_buffer[127] == 0x89) { 
0B992:  MOVLB  C
0B994:  MOVF   x3C,W
0B996:  SUBLW  2A
0B998:  BNZ   BA74
0B99A:  MOVF   xBB,W
0B99C:  SUBLW  89
0B99E:  BNZ   BA74
....................             for (uint8_t k = 0; k < 128; k++) { 
0B9A0:  CLRF   xBD
0B9A2:  MOVF   xBD,W
0B9A4:  SUBLW  7F
0B9A6:  BNC   B9D6
....................                 fprintf(PC, "%X ", sel1_d_buffer[k]); 
0B9A8:  CLRF   03
0B9AA:  MOVF   xBD,W
0B9AC:  ADDLW  3C
0B9AE:  MOVWF  FE9
0B9B0:  MOVLW  0C
0B9B2:  ADDWFC 03,W
0B9B4:  MOVWF  FEA
0B9B6:  MOVFF  FEF,CBF
0B9BA:  MOVLW  37
0B9BC:  MOVWF  xC0
0B9BE:  MOVLB  0
0B9C0:  CALL   5A92
0B9C4:  MOVLW  20
0B9C6:  MOVLB  D
0B9C8:  MOVWF  x6A
0B9CA:  MOVLB  0
0B9CC:  CALL   44EE
0B9D0:  MOVLB  C
0B9D2:  INCF   xBD,F
0B9D4:  BRA    B9A2
....................             } 
....................             get_com_shared_fm_access(); 
0B9D6:  MOVLB  0
0B9D8:  CALL   8672
....................             fprintf(PC, "\r\nSaving SEL ZES data: "); 
0B9DC:  MOVLW  CA
0B9DE:  MOVWF  FF6
0B9E0:  MOVLW  12
0B9E2:  MOVWF  FF7
0B9E4:  MOVLW  00
0B9E6:  MOVWF  FF8
0B9E8:  CALL   4534
....................             fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_sel_zes.current); 
0B9EC:  MOVLW  E2
0B9EE:  MOVWF  FF6
0B9F0:  MOVLW  12
0B9F2:  MOVWF  FF7
0B9F4:  MOVLW  00
0B9F6:  MOVWF  FF8
0B9F8:  MOVLW  08
0B9FA:  MOVLB  C
0B9FC:  MOVWF  xC1
0B9FE:  MOVLB  0
0BA00:  CALL   5290
0BA04:  MOVFF  149,CBF
0BA08:  MOVLW  37
0BA0A:  MOVLB  C
0BA0C:  MOVWF  xC0
0BA0E:  MOVLB  0
0BA10:  CALL   5A92
0BA14:  MOVFF  148,CBF
0BA18:  MOVLW  37
0BA1A:  MOVLB  C
0BA1C:  MOVWF  xC0
0BA1E:  MOVLB  0
0BA20:  CALL   5A92
0BA24:  MOVFF  147,CBF
0BA28:  MOVLW  37
0BA2A:  MOVLB  C
0BA2C:  MOVWF  xC0
0BA2E:  MOVLB  0
0BA30:  CALL   5A92
0BA34:  MOVFF  146,CBF
0BA38:  MOVLW  37
0BA3A:  MOVLB  C
0BA3C:  MOVWF  xC0
0BA3E:  MOVLB  0
0BA40:  CALL   5A92
0BA44:  MOVLW  20
0BA46:  MOVLB  D
0BA48:  MOVWF  x6A
0BA4A:  MOVLB  0
0BA4C:  CALL   44EE
....................             flash_cycle_write(&spi_port_COM_FM, sel1_d_buffer, &addr_flags.flash_sel_zes); 
0BA50:  MOVLW  0A
0BA52:  MOVLB  C
0BA54:  MOVWF  xBF
0BA56:  MOVLW  A3
0BA58:  MOVWF  xBE
0BA5A:  MOVLW  0C
0BA5C:  MOVWF  xC1
0BA5E:  MOVLW  3C
0BA60:  MOVWF  xC0
0BA62:  MOVLW  01
0BA64:  MOVWF  xC3
0BA66:  MOVLW  3E
0BA68:  MOVWF  xC2
0BA6A:  MOVLB  0
0BA6C:  CALL   6658
....................         } else { 
0BA70:  BRA    BA86
0BA72:  MOVLB  C
....................             fprintf(PC, "Failed to get data from SEL.\r\n"); 
0BA74:  MOVLW  F2
0BA76:  MOVWF  FF6
0BA78:  MOVLW  12
0BA7A:  MOVWF  FF7
0BA7C:  MOVLW  00
0BA7E:  MOVWF  FF8
0BA80:  MOVLB  0
0BA82:  CALL   4534
....................         } 
....................         delay_ms(packet->delay_between_repetitions); 
0BA86:  MOVLW  03
0BA88:  MOVLB  C
0BA8A:  ADDWF  x3A,W
0BA8C:  MOVWF  FE9
0BA8E:  MOVLW  00
0BA90:  ADDWFC x3B,W
0BA92:  MOVWF  FEA
0BA94:  MOVFF  FEF,CBE
0BA98:  MOVFF  FEC,CC2
0BA9C:  MOVFF  FEC,CC0
0BAA0:  MOVFF  FEC,CC1
0BAA4:  INCF   xC2,F
0BAA6:  DECF   xC2,F
0BAA8:  BTFSC  FD8.2
0BAAA:  BRA    BABA
0BAAC:  MOVLB  D
0BAAE:  SETF   x52
0BAB0:  MOVLB  0
0BAB2:  CALL   5266
0BAB6:  MOVLB  C
0BAB8:  BRA    BAA6
0BABA:  MOVFF  CBE,D52
0BABE:  MOVLB  0
0BAC0:  CALL   5266
0BAC4:  MOVLB  C
0BAC6:  INCF   xBC,F
0BAC8:  BRA    B90A
....................     } 
....................  
....................     return 0; 
0BACA:  MOVLW  00
0BACC:  MOVWF  01
0BACE:  MOVLB  5
0BAD0:  MOVLB  0
0BAD2:  GOTO   1893E (RETURN)
.................... } 
....................  
.................... // Send 0x26 to REF 
.................... // Send CMD 1 of SEL 1 REF (0x26) to REF_RX, and REF_TX will send back hex number A9 (0xA9) as acknowledgement. 
.................... uint8_t command_sel2_a(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_ref) != mux_sel_ref) { // If MUX did not change 
*
0BF1E:  MOVLW  07
0BF20:  MOVLB  C
0BF22:  MOVWF  xBE
0BF24:  MOVLB  0
0BF26:  CALL   52E8
0BF2A:  MOVF   01,W
0BF2C:  SUBLW  07
0BF2E:  BZ    BF52
....................         if (verbose) { 
0BF30:  MOVLB  5
0BF32:  MOVF   x5A,F
0BF34:  BZ    BF4A
....................             fprintf(PC, "MUX change failed!"); 
0BF36:  MOVLW  12
0BF38:  MOVWF  FF6
0BF3A:  MOVLW  13
0BF3C:  MOVWF  FF7
0BF3E:  MOVLW  00
0BF40:  MOVWF  FF8
0BF42:  MOVLB  0
0BF44:  CALL   4534
0BF48:  MOVLB  5
....................         } 
....................         return 1; 
0BF4A:  MOVLW  01
0BF4C:  MOVWF  01
0BF4E:  BRA    C0AC
0BF50:  MOVLB  0
....................     } 
....................  
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
0BF52:  MOVLB  C
0BF54:  CLRF   x3A
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
0BF56:  CLRF   x3B
0BF58:  MOVF   x3B,W
0BF5A:  SUBLW  02
0BF5C:  BTFSS  FD8.0
0BF5E:  BRA    C068
....................         fprintf(PC, "\r\nAttempt %d\r\n", attempt); 
0BF60:  MOVLW  26
0BF62:  MOVWF  FF6
0BF64:  MOVLW  13
0BF66:  MOVWF  FF7
0BF68:  MOVLW  00
0BF6A:  MOVWF  FF8
0BF6C:  MOVLW  0A
0BF6E:  MOVWF  xC1
0BF70:  MOVLB  0
0BF72:  CALL   5290
0BF76:  MOVFF  C3B,CBE
0BF7A:  MOVLW  18
0BF7C:  MOVLB  C
0BF7E:  MOVWF  xBF
0BF80:  MOVLB  0
0BF82:  CALL   73A8
0BF86:  MOVLW  0D
0BF88:  MOVLB  D
0BF8A:  MOVWF  x6A
0BF8C:  MOVLB  0
0BF8E:  CALL   44EE
0BF92:  MOVLW  0A
0BF94:  MOVLB  D
0BF96:  MOVWF  x6A
0BF98:  MOVLB  0
0BF9A:  CALL   44EE
....................         fputc(0x26, SEL_REF); 
0BF9E:  MOVLW  26
0BFA0:  CALL   5464
....................         delay_ms(1000); // TODO test with and without this delay and see if it is needed 
0BFA4:  MOVLW  04
0BFA6:  MOVLB  C
0BFA8:  MOVWF  x3D
0BFAA:  MOVLW  FA
0BFAC:  MOVLB  D
0BFAE:  MOVWF  x52
0BFB0:  MOVLB  0
0BFB2:  CALL   5266
0BFB6:  MOVLB  C
0BFB8:  DECFSZ x3D,F
0BFBA:  BRA    BFAA
....................  
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
0BFBC:  MOVLW  36
0BFBE:  MOVWF  FF6
0BFC0:  MOVLW  13
0BFC2:  MOVWF  FF7
0BFC4:  MOVLW  00
0BFC6:  MOVWF  FF8
0BFC8:  MOVLB  0
0BFCA:  CALL   4534
....................         while (++timeout < 5) { 
0BFCE:  MOVLB  C
0BFD0:  INCF   x3A,F
0BFD2:  MOVF   x3A,W
0BFD4:  SUBLW  04
0BFD6:  BNC   C062
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
0BFD8:  MOVLW  66
0BFDA:  MOVWF  FF6
0BFDC:  MOVLW  13
0BFDE:  MOVWF  FF7
0BFE0:  MOVLW  00
0BFE2:  MOVWF  FF8
0BFE4:  MOVLB  0
0BFE6:  CALL   4534
....................             if (kbhit(SEL_REF)) { 
0BFEA:  BTFSS  F9E.5
0BFEC:  BRA    C048
....................                 uint8_t r = fgetc(SEL_REF); 
0BFEE:  CALL   213C
0BFF2:  MOVFF  01,C3C
....................                 if (r == 0xA9) { 
0BFF6:  MOVLB  C
0BFF8:  MOVF   x3C,W
0BFFA:  SUBLW  A9
0BFFC:  BNZ   C046
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
0BFFE:  MOVLW  88
0C000:  MOVWF  FF6
0C002:  MOVLW  13
0C004:  MOVWF  FF7
0C006:  MOVLW  00
0C008:  MOVWF  FF8
0C00A:  MOVLW  06
0C00C:  MOVWF  xC1
0C00E:  MOVLB  0
0C010:  CALL   5290
0C014:  MOVFF  C3C,CBF
0C018:  MOVLW  37
0C01A:  MOVLB  C
0C01C:  MOVWF  xC0
0C01E:  MOVLB  0
0C020:  CALL   5A92
0C024:  MOVLW  90
0C026:  MOVWF  FF6
0C028:  MOVLW  13
0C02A:  MOVWF  FF7
0C02C:  MOVLW  00
0C02E:  MOVWF  FF8
0C030:  MOVLW  05
0C032:  MOVLB  C
0C034:  MOVWF  xC1
0C036:  MOVLB  0
0C038:  CALL   5290
....................                     return r; 
0C03C:  MOVFF  C3C,01
0C040:  MOVLB  5
0C042:  BRA    C0AC
0C044:  MOVLB  C
0C046:  MOVLB  0
....................                 } 
....................             } 
....................             delay_ms(1000); 
0C048:  MOVLW  04
0C04A:  MOVLB  C
0C04C:  MOVWF  x3D
0C04E:  MOVLW  FA
0C050:  MOVLB  D
0C052:  MOVWF  x52
0C054:  MOVLB  0
0C056:  CALL   5266
0C05A:  MOVLB  C
0C05C:  DECFSZ x3D,F
0C05E:  BRA    C04E
0C060:  BRA    BFD0
....................         } 
....................         timeout = 0; 
0C062:  CLRF   x3A
0C064:  INCF   x3B,F
0C066:  BRA    BF58
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
0C068:  MOVLW  96
0C06A:  MOVWF  FF6
0C06C:  MOVLW  13
0C06E:  MOVWF  FF7
0C070:  MOVLW  00
0C072:  MOVWF  FF8
0C074:  MOVLW  1B
0C076:  MOVWF  xC1
0C078:  MOVLB  0
0C07A:  CALL   5290
0C07E:  MOVLW  03
0C080:  MOVLB  C
0C082:  MOVWF  xBE
0C084:  MOVLW  18
0C086:  MOVWF  xBF
0C088:  MOVLB  0
0C08A:  CALL   73A8
0C08E:  MOVLW  B3
0C090:  MOVWF  FF6
0C092:  MOVLW  13
0C094:  MOVWF  FF7
0C096:  MOVLW  00
0C098:  MOVWF  FF8
0C09A:  MOVLW  09
0C09C:  MOVLB  C
0C09E:  MOVWF  xC1
0C0A0:  MOVLB  0
0C0A2:  CALL   5290
....................     return 0xFF; 
0C0A6:  MOVLW  FF
0C0A8:  MOVWF  01
0C0AA:  MOVLB  5
0C0AC:  MOVLB  0
0C0AE:  GOTO   18998 (RETURN)
.................... } 
....................  
.................... // Fifteen minutes status check 
.................... uint8_t command_sel2_b(uint8_t* data) 
.................... { 
....................     send_mcp_command(mcp_cmd_ref_status, 0, 0); 
*
0C29A:  MOVLW  35
0C29C:  MOVLB  C
0C29E:  MOVWF  x80
0C2A0:  CLRF   x82
0C2A2:  CLRF   x81
0C2A4:  CLRF   x83
0C2A6:  MOVLB  0
0C2A8:  RCALL  BAD6
....................     return 0; 
0C2AA:  MOVLW  00
0C2AC:  MOVWF  01
0C2AE:  GOTO   189F2 (RETURN)
.................... } 
....................  
.................... // Send 0x5E to REF 
.................... // Send CMD 3 of SEL 1 REF (0x5E) to REF_RX, and REF_TX will send back hex number A7 (0xA7) as data initialization. 
.................... uint8_t command_sel2_c(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_ref) != mux_sel_ref) { // If MUX did not change 
*
0D65E:  MOVLW  07
0D660:  MOVLB  C
0D662:  MOVWF  xBE
0D664:  MOVLB  0
0D666:  CALL   52E8
0D66A:  MOVF   01,W
0D66C:  SUBLW  07
0D66E:  BZ    D692
....................         if (verbose) { 
0D670:  MOVLB  5
0D672:  MOVF   x5A,F
0D674:  BZ    D68A
....................             fprintf(PC, "MUX change failed!"); 
0D676:  MOVLW  BE
0D678:  MOVWF  FF6
0D67A:  MOVLW  13
0D67C:  MOVWF  FF7
0D67E:  MOVLW  00
0D680:  MOVWF  FF8
0D682:  MOVLB  0
0D684:  CALL   4534
0D688:  MOVLB  5
....................         } 
....................         return 1; 
0D68A:  MOVLW  01
0D68C:  MOVWF  01
0D68E:  BRA    D7EC
0D690:  MOVLB  0
....................     } 
....................  
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
0D692:  MOVLB  C
0D694:  CLRF   x3A
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
0D696:  CLRF   x3B
0D698:  MOVF   x3B,W
0D69A:  SUBLW  02
0D69C:  BTFSS  FD8.0
0D69E:  BRA    D7A8
....................         fprintf(PC, "\r\nAttempt %d\r\n", attempt); 
0D6A0:  MOVLW  D2
0D6A2:  MOVWF  FF6
0D6A4:  MOVLW  13
0D6A6:  MOVWF  FF7
0D6A8:  MOVLW  00
0D6AA:  MOVWF  FF8
0D6AC:  MOVLW  0A
0D6AE:  MOVWF  xC1
0D6B0:  MOVLB  0
0D6B2:  CALL   5290
0D6B6:  MOVFF  C3B,CBE
0D6BA:  MOVLW  18
0D6BC:  MOVLB  C
0D6BE:  MOVWF  xBF
0D6C0:  MOVLB  0
0D6C2:  CALL   73A8
0D6C6:  MOVLW  0D
0D6C8:  MOVLB  D
0D6CA:  MOVWF  x6A
0D6CC:  MOVLB  0
0D6CE:  CALL   44EE
0D6D2:  MOVLW  0A
0D6D4:  MOVLB  D
0D6D6:  MOVWF  x6A
0D6D8:  MOVLB  0
0D6DA:  CALL   44EE
....................         fputc(0x5E, SEL_REF); 
0D6DE:  MOVLW  5E
0D6E0:  CALL   5464
....................         delay_ms(700); 
0D6E4:  MOVLW  04
0D6E6:  MOVLB  C
0D6E8:  MOVWF  x3D
0D6EA:  MOVLW  AF
0D6EC:  MOVLB  D
0D6EE:  MOVWF  x52
0D6F0:  MOVLB  0
0D6F2:  CALL   5266
0D6F6:  MOVLB  C
0D6F8:  DECFSZ x3D,F
0D6FA:  BRA    D6EA
....................  
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
0D6FC:  MOVLW  E2
0D6FE:  MOVWF  FF6
0D700:  MOVLW  13
0D702:  MOVWF  FF7
0D704:  MOVLW  00
0D706:  MOVWF  FF8
0D708:  MOVLB  0
0D70A:  CALL   4534
....................         while (++timeout < 5) { 
0D70E:  MOVLB  C
0D710:  INCF   x3A,F
0D712:  MOVF   x3A,W
0D714:  SUBLW  04
0D716:  BNC   D7A2
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
0D718:  MOVLW  12
0D71A:  MOVWF  FF6
0D71C:  MOVLW  14
0D71E:  MOVWF  FF7
0D720:  MOVLW  00
0D722:  MOVWF  FF8
0D724:  MOVLB  0
0D726:  CALL   4534
....................             if (kbhit(SEL_REF)) { 
0D72A:  BTFSS  F9E.5
0D72C:  BRA    D788
....................                 uint8_t r = fgetc(SEL_REF); 
0D72E:  CALL   213C
0D732:  MOVFF  01,C3C
....................                 if (r == 0xA7) { 
0D736:  MOVLB  C
0D738:  MOVF   x3C,W
0D73A:  SUBLW  A7
0D73C:  BNZ   D786
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
0D73E:  MOVLW  34
0D740:  MOVWF  FF6
0D742:  MOVLW  14
0D744:  MOVWF  FF7
0D746:  MOVLW  00
0D748:  MOVWF  FF8
0D74A:  MOVLW  06
0D74C:  MOVWF  xC1
0D74E:  MOVLB  0
0D750:  CALL   5290
0D754:  MOVFF  C3C,CBF
0D758:  MOVLW  37
0D75A:  MOVLB  C
0D75C:  MOVWF  xC0
0D75E:  MOVLB  0
0D760:  CALL   5A92
0D764:  MOVLW  3C
0D766:  MOVWF  FF6
0D768:  MOVLW  14
0D76A:  MOVWF  FF7
0D76C:  MOVLW  00
0D76E:  MOVWF  FF8
0D770:  MOVLW  05
0D772:  MOVLB  C
0D774:  MOVWF  xC1
0D776:  MOVLB  0
0D778:  CALL   5290
....................                     return r; 
0D77C:  MOVFF  C3C,01
0D780:  MOVLB  5
0D782:  BRA    D7EC
0D784:  MOVLB  C
0D786:  MOVLB  0
....................                 } 
....................             } 
....................             delay_ms(1000); 
0D788:  MOVLW  04
0D78A:  MOVLB  C
0D78C:  MOVWF  x3D
0D78E:  MOVLW  FA
0D790:  MOVLB  D
0D792:  MOVWF  x52
0D794:  MOVLB  0
0D796:  CALL   5266
0D79A:  MOVLB  C
0D79C:  DECFSZ x3D,F
0D79E:  BRA    D78E
0D7A0:  BRA    D710
....................         } 
....................         timeout = 0; 
0D7A2:  CLRF   x3A
0D7A4:  INCF   x3B,F
0D7A6:  BRA    D698
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
0D7A8:  MOVLW  42
0D7AA:  MOVWF  FF6
0D7AC:  MOVLW  14
0D7AE:  MOVWF  FF7
0D7B0:  MOVLW  00
0D7B2:  MOVWF  FF8
0D7B4:  MOVLW  1B
0D7B6:  MOVWF  xC1
0D7B8:  MOVLB  0
0D7BA:  CALL   5290
0D7BE:  MOVLW  03
0D7C0:  MOVLB  C
0D7C2:  MOVWF  xBE
0D7C4:  MOVLW  18
0D7C6:  MOVWF  xBF
0D7C8:  MOVLB  0
0D7CA:  CALL   73A8
0D7CE:  MOVLW  5F
0D7D0:  MOVWF  FF6
0D7D2:  MOVLW  14
0D7D4:  MOVWF  FF7
0D7D6:  MOVLW  00
0D7D8:  MOVWF  FF8
0D7DA:  MOVLW  09
0D7DC:  MOVLB  C
0D7DE:  MOVWF  xC1
0D7E0:  MOVLB  0
0D7E2:  CALL   5290
....................     return 0xFF; 
0D7E6:  MOVLW  FF
0D7E8:  MOVWF  01
0D7EA:  MOVLB  5
0D7EC:  MOVLB  0
0D7EE:  GOTO   18B48 (RETURN)
.................... } 
....................  
.................... // Send 0x7E to REF 
.................... // Send CMD 4 of (0x7E) to REF_RX, and REF_TX will send back a first data stream. 
.................... uint8_t command_sel2_d(uint8_t* data) 
0D7F2:  MOVFF  C39,C3B
0D7F6:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (mux_sel(mux_sel_ref) != mux_sel_ref) { // If MUX did not change 
0D7FA:  MOVLW  07
0D7FC:  MOVLB  C
0D7FE:  MOVWF  xBE
0D800:  MOVLB  0
0D802:  CALL   52E8
0D806:  MOVF   01,W
0D808:  SUBLW  07
0D80A:  BZ    D82E
....................         if (verbose) { 
0D80C:  MOVLB  5
0D80E:  MOVF   x5A,F
0D810:  BZ    D826
....................             fprintf(PC, "MUX change failed!"); 
0D812:  MOVLW  6A
0D814:  MOVWF  FF6
0D816:  MOVLW  14
0D818:  MOVWF  FF7
0D81A:  MOVLW  00
0D81C:  MOVWF  FF8
0D81E:  MOVLB  0
0D820:  CALL   4534
0D824:  MOVLB  5
....................         } 
....................         return 1; 
0D826:  MOVLW  01
0D828:  MOVWF  01
0D82A:  BRA    D9F8
0D82C:  MOVLB  0
....................     } 
....................  
....................     uint8_t sel2_d_buffer[128]; 
....................  
....................     for (uint8_t i = 0; i < packet->repetitions; i++) { 
0D82E:  MOVLB  C
0D830:  CLRF   xBC
0D832:  MOVLW  02
0D834:  ADDWF  x3A,W
0D836:  MOVWF  FE9
0D838:  MOVLW  00
0D83A:  ADDWFC x3B,W
0D83C:  MOVWF  FEA
0D83E:  MOVF   FEF,W
0D840:  SUBWF  xBC,W
0D842:  BTFSC  FD8.0
0D844:  BRA    D9F2
....................         fprintf(PC, "Part no. %d: ", i); 
0D846:  MOVLW  7E
0D848:  MOVWF  FF6
0D84A:  MOVLW  14
0D84C:  MOVWF  FF7
0D84E:  MOVLW  00
0D850:  MOVWF  FF8
0D852:  MOVLW  09
0D854:  MOVWF  xC1
0D856:  MOVLB  0
0D858:  CALL   5290
0D85C:  MOVFF  CBC,CBE
0D860:  MOVLW  18
0D862:  MOVLB  C
0D864:  MOVWF  xBF
0D866:  MOVLB  0
0D868:  CALL   73A8
0D86C:  MOVLW  3A
0D86E:  MOVLB  D
0D870:  MOVWF  x6A
0D872:  MOVLB  0
0D874:  CALL   44EE
0D878:  MOVLW  20
0D87A:  MOVLB  D
0D87C:  MOVWF  x6A
0D87E:  MOVLB  0
0D880:  CALL   44EE
....................         // Sending command to the SEL_REF 
....................         fputc(0x7E, SEL_REF); 
0D884:  MOVLW  7E
0D886:  CALL   5464
....................  
....................         uart_download_packet(&uart_port_MSN, sel2_d_buffer, sizeof(sel2_d_buffer), 100000); 
0D88A:  MOVLW  0A
0D88C:  MOVLB  D
0D88E:  MOVWF  x45
0D890:  MOVLW  97
0D892:  MOVWF  x44
0D894:  MOVLW  0C
0D896:  MOVWF  x47
0D898:  MOVLW  3C
0D89A:  MOVWF  x46
0D89C:  CLRF   x4B
0D89E:  CLRF   x4A
0D8A0:  CLRF   x49
0D8A2:  MOVLW  80
0D8A4:  MOVWF  x48
0D8A6:  CLRF   x4F
0D8A8:  MOVLW  01
0D8AA:  MOVWF  x4E
0D8AC:  MOVLW  86
0D8AE:  MOVWF  x4D
0D8B0:  MOVLW  A0
0D8B2:  MOVWF  x4C
0D8B4:  MOVLB  0
0D8B6:  CALL   97CE
....................  
....................         if (sel2_d_buffer[0] == 0x2A && sel2_d_buffer[127] == 0x89) { 
0D8BA:  MOVLB  C
0D8BC:  MOVF   x3C,W
0D8BE:  SUBLW  2A
0D8C0:  BNZ   D99C
0D8C2:  MOVF   xBB,W
0D8C4:  SUBLW  89
0D8C6:  BNZ   D99C
....................             for (uint8_t k = 0; k < 128; k++) { 
0D8C8:  CLRF   xBD
0D8CA:  MOVF   xBD,W
0D8CC:  SUBLW  7F
0D8CE:  BNC   D8FE
....................                 fprintf(PC, "%X ", sel2_d_buffer[k]); 
0D8D0:  CLRF   03
0D8D2:  MOVF   xBD,W
0D8D4:  ADDLW  3C
0D8D6:  MOVWF  FE9
0D8D8:  MOVLW  0C
0D8DA:  ADDWFC 03,W
0D8DC:  MOVWF  FEA
0D8DE:  MOVFF  FEF,CBF
0D8E2:  MOVLW  37
0D8E4:  MOVWF  xC0
0D8E6:  MOVLB  0
0D8E8:  CALL   5A92
0D8EC:  MOVLW  20
0D8EE:  MOVLB  D
0D8F0:  MOVWF  x6A
0D8F2:  MOVLB  0
0D8F4:  CALL   44EE
0D8F8:  MOVLB  C
0D8FA:  INCF   xBD,F
0D8FC:  BRA    D8CA
....................             } 
....................             get_com_shared_fm_access(); 
0D8FE:  MOVLB  0
0D900:  CALL   8672
....................             fprintf(PC, "\r\nSaving SEL REF data: "); 
0D904:  MOVLW  8C
0D906:  MOVWF  FF6
0D908:  MOVLW  14
0D90A:  MOVWF  FF7
0D90C:  MOVLW  00
0D90E:  MOVWF  FF8
0D910:  CALL   4534
....................             fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_sel_ref.current); 
0D914:  MOVLW  A4
0D916:  MOVWF  FF6
0D918:  MOVLW  14
0D91A:  MOVWF  FF7
0D91C:  MOVLW  00
0D91E:  MOVWF  FF8
0D920:  MOVLW  08
0D922:  MOVLB  C
0D924:  MOVWF  xC1
0D926:  MOVLB  0
0D928:  CALL   5290
0D92C:  MOVFF  156,CBF
0D930:  MOVLW  37
0D932:  MOVLB  C
0D934:  MOVWF  xC0
0D936:  MOVLB  0
0D938:  CALL   5A92
0D93C:  MOVFF  155,CBF
0D940:  MOVLW  37
0D942:  MOVLB  C
0D944:  MOVWF  xC0
0D946:  MOVLB  0
0D948:  CALL   5A92
0D94C:  MOVFF  154,CBF
0D950:  MOVLW  37
0D952:  MOVLB  C
0D954:  MOVWF  xC0
0D956:  MOVLB  0
0D958:  CALL   5A92
0D95C:  MOVFF  153,CBF
0D960:  MOVLW  37
0D962:  MOVLB  C
0D964:  MOVWF  xC0
0D966:  MOVLB  0
0D968:  CALL   5A92
0D96C:  MOVLW  20
0D96E:  MOVLB  D
0D970:  MOVWF  x6A
0D972:  MOVLB  0
0D974:  CALL   44EE
....................             flash_cycle_write(&spi_port_COM_FM, sel2_d_buffer, &addr_flags.flash_sel_ref); 
0D978:  MOVLW  0A
0D97A:  MOVLB  C
0D97C:  MOVWF  xBF
0D97E:  MOVLW  A3
0D980:  MOVWF  xBE
0D982:  MOVLW  0C
0D984:  MOVWF  xC1
0D986:  MOVLW  3C
0D988:  MOVWF  xC0
0D98A:  MOVLW  01
0D98C:  MOVWF  xC3
0D98E:  MOVLW  4B
0D990:  MOVWF  xC2
0D992:  MOVLB  0
0D994:  CALL   6658
....................         } else { 
0D998:  BRA    D9AE
0D99A:  MOVLB  C
....................             fprintf(PC, "Failed to get data from SEL.\r\n"); 
0D99C:  MOVLW  B4
0D99E:  MOVWF  FF6
0D9A0:  MOVLW  14
0D9A2:  MOVWF  FF7
0D9A4:  MOVLW  00
0D9A6:  MOVWF  FF8
0D9A8:  MOVLB  0
0D9AA:  CALL   4534
....................         } 
....................         delay_ms(packet->delay_between_repetitions); 
0D9AE:  MOVLW  03
0D9B0:  MOVLB  C
0D9B2:  ADDWF  x3A,W
0D9B4:  MOVWF  FE9
0D9B6:  MOVLW  00
0D9B8:  ADDWFC x3B,W
0D9BA:  MOVWF  FEA
0D9BC:  MOVFF  FEF,CBE
0D9C0:  MOVFF  FEC,CC2
0D9C4:  MOVFF  FEC,CC0
0D9C8:  MOVFF  FEC,CC1
0D9CC:  INCF   xC2,F
0D9CE:  DECF   xC2,F
0D9D0:  BTFSC  FD8.2
0D9D2:  BRA    D9E2
0D9D4:  MOVLB  D
0D9D6:  SETF   x52
0D9D8:  MOVLB  0
0D9DA:  CALL   5266
0D9DE:  MOVLB  C
0D9E0:  BRA    D9CE
0D9E2:  MOVFF  CBE,D52
0D9E6:  MOVLB  0
0D9E8:  CALL   5266
0D9EC:  MOVLB  C
0D9EE:  INCF   xBC,F
0D9F0:  BRA    D832
....................     } 
....................  
....................     return 0; 
0D9F2:  MOVLW  00
0D9F4:  MOVWF  01
0D9F6:  MOVLB  5
0D9F8:  MOVLB  0
0D9FA:  GOTO   18B5A (RETURN)
.................... } 
....................  
.................... uint8_t command_iMTQ_Dipole_Actuation(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
*
1232E:  MOVLW  02
12330:  MOVLB  C
12332:  MOVWF  xBE
12334:  MOVLB  0
12336:  CALL   52E8
1233A:  MOVF   01,W
1233C:  SUBLW  02
1233E:  BZ    12362
....................         if (verbose) { 
12340:  MOVLB  5
12342:  MOVF   x5A,F
12344:  BZ    1235A
....................             fprintf(PC, "MUX change failed!"); 
12346:  MOVLW  D4
12348:  MOVWF  FF6
1234A:  MOVLW  14
1234C:  MOVWF  FF7
1234E:  MOVLW  00
12350:  MOVWF  FF8
12352:  MOVLB  0
12354:  CALL   4534
12358:  MOVLB  5
....................         } 
....................         return 1; 
1235A:  MOVLW  01
1235C:  MOVWF  01
1235E:  BRA    12396
12360:  MOVLB  0
....................     } 
....................     fprintf(PC, "iMTQ Dipole Activation.......\r\n"); 
12362:  MOVLW  E8
12364:  MOVWF  FF6
12366:  MOVLW  14
12368:  MOVWF  FF7
1236A:  MOVLW  00
1236C:  MOVWF  FF8
1236E:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x1D, 0x06, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0x10, 0x27, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
12372:  MOVLB  C
12374:  CLRF   x3A
12376:  MOVF   x3A,W
12378:  SUBLW  2B
1237A:  BNC   12390
....................         fputc(cmd[i], ADCS); 
1237C:  CLRF   03
1237E:  MOVF   x3A,W
12380:  MOVLB  0
12382:  CALL   0204
12386:  CALL   5464
1238A:  MOVLB  C
1238C:  INCF   x3A,F
1238E:  BRA    12376
....................     } 
....................  
....................     return 0; 
12390:  MOVLW  00
12392:  MOVWF  01
12394:  MOVLB  5
12396:  MOVLB  0
12398:  GOTO   18D94 (RETURN)
.................... } 
....................  
.................... uint8_t command_iMTQ_No_Opeartion(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
1239C:  MOVLW  02
1239E:  MOVLB  C
123A0:  MOVWF  xBE
123A2:  MOVLB  0
123A4:  CALL   52E8
123A8:  MOVF   01,W
123AA:  SUBLW  02
123AC:  BZ    123D0
....................         if (verbose) { 
123AE:  MOVLB  5
123B0:  MOVF   x5A,F
123B2:  BZ    123C8
....................             fprintf(PC, "MUX change failed!"); 
123B4:  MOVLW  08
123B6:  MOVWF  FF6
123B8:  MOVLW  15
123BA:  MOVWF  FF7
123BC:  MOVLW  00
123BE:  MOVWF  FF8
123C0:  MOVLB  0
123C2:  CALL   4534
123C6:  MOVLB  5
....................         } 
....................         return 1; 
123C8:  MOVLW  01
123CA:  MOVWF  01
123CC:  BRA    12404
123CE:  MOVLB  0
....................     } 
....................     fprintf(PC, "iMTQ No Opeartion.......\r\n"); 
123D0:  MOVLW  1C
123D2:  MOVWF  FF6
123D4:  MOVLW  15
123D6:  MOVWF  FF7
123D8:  MOVLW  00
123DA:  MOVWF  FF8
123DC:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x1D, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
123E0:  MOVLB  C
123E2:  CLRF   x3A
123E4:  MOVF   x3A,W
123E6:  SUBLW  2B
123E8:  BNC   123FE
....................         fputc(cmd[i], ADCS); 
123EA:  CLRF   03
123EC:  MOVF   x3A,W
123EE:  MOVLB  0
123F0:  CALL   0244
123F4:  CALL   5464
123F8:  MOVLB  C
123FA:  INCF   x3A,F
123FC:  BRA    123E4
....................     } 
....................  
....................     return 0; 
123FE:  MOVLW  00
12400:  MOVWF  01
12402:  MOVLB  5
12404:  MOVLB  0
12406:  GOTO   18DA6 (RETURN)
.................... } 
....................  
.................... uint8_t command_3v3_Enable(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
1240A:  MOVLW  02
1240C:  MOVLB  C
1240E:  MOVWF  xBE
12410:  MOVLB  0
12412:  CALL   52E8
12416:  MOVF   01,W
12418:  SUBLW  02
1241A:  BZ    1243E
....................         if (verbose) { 
1241C:  MOVLB  5
1241E:  MOVF   x5A,F
12420:  BZ    12436
....................             fprintf(PC, "MUX change failed!"); 
12422:  MOVLW  38
12424:  MOVWF  FF6
12426:  MOVLW  15
12428:  MOVWF  FF7
1242A:  MOVLW  00
1242C:  MOVWF  FF8
1242E:  MOVLB  0
12430:  CALL   4534
12434:  MOVLB  5
....................         } 
....................         return 1; 
12436:  MOVLW  01
12438:  MOVWF  01
1243A:  BRA    12472
1243C:  MOVLB  0
....................     } 
....................     fprintf(PC, "RW 3v3 Enable.......\r\n"); 
1243E:  MOVLW  4C
12440:  MOVWF  FF6
12442:  MOVLW  15
12444:  MOVWF  FF7
12446:  MOVLW  00
12448:  MOVWF  FF8
1244A:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
1244E:  MOVLB  C
12450:  CLRF   x3A
12452:  MOVF   x3A,W
12454:  SUBLW  2B
12456:  BNC   1246C
....................         fputc(cmd[i], ADCS); 
12458:  CLRF   03
1245A:  MOVF   x3A,W
1245C:  MOVLB  0
1245E:  CALL   0284
12462:  CALL   5464
12466:  MOVLB  C
12468:  INCF   x3A,F
1246A:  BRA    12452
....................     } 
....................  
....................     return 0; 
1246C:  MOVLW  00
1246E:  MOVWF  01
12470:  MOVLB  5
12472:  MOVLB  0
12474:  GOTO   18DB8 (RETURN)
.................... } 
....................  
.................... uint8_t command_RW_Motor_Enable(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
12478:  MOVLW  02
1247A:  MOVLB  C
1247C:  MOVWF  xBE
1247E:  MOVLB  0
12480:  CALL   52E8
12484:  MOVF   01,W
12486:  SUBLW  02
12488:  BZ    124AC
....................         if (verbose) { 
1248A:  MOVLB  5
1248C:  MOVF   x5A,F
1248E:  BZ    124A4
....................             fprintf(PC, "MUX change failed!"); 
12490:  MOVLW  64
12492:  MOVWF  FF6
12494:  MOVLW  15
12496:  MOVWF  FF7
12498:  MOVLW  00
1249A:  MOVWF  FF8
1249C:  MOVLB  0
1249E:  CALL   4534
124A2:  MOVLB  5
....................         } 
....................         return 1; 
124A4:  MOVLW  01
124A6:  MOVWF  01
124A8:  BRA    124E0
124AA:  MOVLB  0
....................     } 
....................     fprintf(PC, "RW Motor Enable.......\r\n"); 
124AC:  MOVLW  78
124AE:  MOVWF  FF6
124B0:  MOVLW  15
124B2:  MOVWF  FF7
124B4:  MOVLW  00
124B6:  MOVWF  FF8
124B8:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
124BC:  MOVLB  C
124BE:  CLRF   x3A
124C0:  MOVF   x3A,W
124C2:  SUBLW  2B
124C4:  BNC   124DA
....................         fputc(cmd[i], ADCS); 
124C6:  CLRF   03
124C8:  MOVF   x3A,W
124CA:  MOVLB  0
124CC:  CALL   02C4
124D0:  CALL   5464
124D4:  MOVLB  C
124D6:  INCF   x3A,F
124D8:  BRA    124C0
....................     } 
....................  
....................     return 0; 
124DA:  MOVLW  00
124DC:  MOVWF  01
124DE:  MOVLB  5
124E0:  MOVLB  0
124E2:  GOTO   18DCA (RETURN)
.................... } 
....................  
.................... uint8_t command_RW_Enable(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
124E6:  MOVLW  02
124E8:  MOVLB  C
124EA:  MOVWF  xBE
124EC:  MOVLB  0
124EE:  CALL   52E8
124F2:  MOVF   01,W
124F4:  SUBLW  02
124F6:  BZ    1251A
....................         if (verbose) { 
124F8:  MOVLB  5
124FA:  MOVF   x5A,F
124FC:  BZ    12512
....................             fprintf(PC, "MUX change failed!"); 
124FE:  MOVLW  92
12500:  MOVWF  FF6
12502:  MOVLW  15
12504:  MOVWF  FF7
12506:  MOVLW  00
12508:  MOVWF  FF8
1250A:  MOVLB  0
1250C:  CALL   4534
12510:  MOVLB  5
....................         } 
....................         return 1; 
12512:  MOVLW  01
12514:  MOVWF  01
12516:  BRA    1254E
12518:  MOVLB  0
....................     } 
....................     fprintf(PC, "RW Enable......\r\n"); 
1251A:  MOVLW  A6
1251C:  MOVWF  FF6
1251E:  MOVLW  15
12520:  MOVWF  FF7
12522:  MOVLW  00
12524:  MOVWF  FF8
12526:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
1252A:  MOVLB  C
1252C:  CLRF   x3A
1252E:  MOVF   x3A,W
12530:  SUBLW  2B
12532:  BNC   12548
....................         fputc(cmd[i], ADCS); 
12534:  CLRF   03
12536:  MOVF   x3A,W
12538:  MOVLB  0
1253A:  CALL   0304
1253E:  CALL   5464
12542:  MOVLB  C
12544:  INCF   x3A,F
12546:  BRA    1252E
....................     } 
....................  
....................     return 0; 
12548:  MOVLW  00
1254A:  MOVWF  01
1254C:  MOVLB  5
1254E:  MOVLB  0
12550:  GOTO   18DDC (RETURN)
.................... } 
....................  
.................... uint8_t command_RW_Speed(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
12554:  MOVLW  02
12556:  MOVLB  C
12558:  MOVWF  xBE
1255A:  MOVLB  0
1255C:  CALL   52E8
12560:  MOVF   01,W
12562:  SUBLW  02
12564:  BZ    12588
....................         if (verbose) { 
12566:  MOVLB  5
12568:  MOVF   x5A,F
1256A:  BZ    12580
....................             fprintf(PC, "MUX change failed!"); 
1256C:  MOVLW  B8
1256E:  MOVWF  FF6
12570:  MOVLW  15
12572:  MOVWF  FF7
12574:  MOVLW  00
12576:  MOVWF  FF8
12578:  MOVLB  0
1257A:  CALL   4534
1257E:  MOVLB  5
....................         } 
....................         return 1; 
12580:  MOVLW  01
12582:  MOVWF  01
12584:  BRA    125BC
12586:  MOVLB  0
....................     } 
....................     fprintf(PC, "RW Speed.......\r\n"); 
12588:  MOVLW  CC
1258A:  MOVWF  FF6
1258C:  MOVLW  15
1258E:  MOVWF  FF7
12590:  MOVLW  00
12592:  MOVWF  FF8
12594:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x3A, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
12598:  MOVLB  C
1259A:  CLRF   x3A
1259C:  MOVF   x3A,W
1259E:  SUBLW  2B
125A0:  BNC   125B6
....................         fputc(cmd[i], ADCS); 
125A2:  CLRF   03
125A4:  MOVF   x3A,W
125A6:  MOVLB  0
125A8:  CALL   0344
125AC:  CALL   5464
125B0:  MOVLB  C
125B2:  INCF   x3A,F
125B4:  BRA    1259C
....................     } 
....................  
....................     return 0; 
125B6:  MOVLW  00
125B8:  MOVWF  01
125BA:  MOVLB  5
125BC:  MOVLB  0
125BE:  GOTO   18DEE (RETURN)
.................... } 
....................  
.................... uint8_t command_RW_Reset(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
125C2:  MOVLW  02
125C4:  MOVLB  C
125C6:  MOVWF  xBE
125C8:  MOVLB  0
125CA:  CALL   52E8
125CE:  MOVF   01,W
125D0:  SUBLW  02
125D2:  BZ    125F6
....................         if (verbose) { 
125D4:  MOVLB  5
125D6:  MOVF   x5A,F
125D8:  BZ    125EE
....................             fprintf(PC, "MUX change failed!"); 
125DA:  MOVLW  DE
125DC:  MOVWF  FF6
125DE:  MOVLW  15
125E0:  MOVWF  FF7
125E2:  MOVLW  00
125E4:  MOVWF  FF8
125E6:  MOVLB  0
125E8:  CALL   4534
125EC:  MOVLB  5
....................         } 
....................         return 1; 
125EE:  MOVLW  01
125F0:  MOVWF  01
125F2:  BRA    1262A
125F4:  MOVLB  0
....................     } 
....................     fprintf(PC, "RW Reset.......\r\n"); 
125F6:  MOVLW  F2
125F8:  MOVWF  FF6
125FA:  MOVLW  15
125FC:  MOVWF  FF7
125FE:  MOVLW  00
12600:  MOVWF  FF8
12602:  CALL   4534
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x3A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
12606:  MOVLB  C
12608:  CLRF   x3A
1260A:  MOVF   x3A,W
1260C:  SUBLW  2B
1260E:  BNC   12624
....................         fputc(cmd[i], ADCS); 
12610:  CLRF   03
12612:  MOVF   x3A,W
12614:  MOVLB  0
12616:  CALL   0384
1261A:  CALL   5464
1261E:  MOVLB  C
12620:  INCF   x3A,F
12622:  BRA    1260A
....................     } 
....................  
....................     return 0; 
12624:  MOVLW  00
12626:  MOVWF  01
12628:  MOVLB  5
1262A:  MOVLB  0
1262C:  GOTO   18E00 (RETURN)
.................... } 
....................  
.................... // Receive Mission Control PIC Status 
.................... uint8_t command_mission_control_PIC_status(uint8_t* data) 
*
170C8:  MOVFF  C39,C3B
170CC:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t status; 
....................     }* packet = (struct packet*)data; 
....................  
....................     response_rx = 1; // Received a reply 
170D0:  MOVLW  01
170D2:  MOVLB  7
170D4:  MOVWF  x50
....................  
....................     uint16_t status = packet->status; 
170D6:  MOVLW  02
170D8:  MOVLB  C
170DA:  ADDWF  x3A,W
170DC:  MOVWF  FE9
170DE:  MOVLW  00
170E0:  ADDWFC x3B,W
170E2:  MOVWF  FEA
170E4:  MOVFF  FEC,C3D
170E8:  MOVF   FED,F
170EA:  MOVFF  FEF,C3C
....................  
....................     // Print each bit with its corresponding shorthand and value 
....................     fprintf(PC, "MCP: "); 
170EE:  MOVLW  04
170F0:  MOVWF  FF6
170F2:  MOVLW  16
170F4:  MOVWF  FF7
170F6:  MOVLW  00
170F8:  MOVWF  FF8
170FA:  MOVLB  0
170FC:  CALL   4534
....................     fprintf(PC, "opera_5v5_dc_dc = %u, ", (uint8_t)((status & (1 << 0)) ? 1 : 0)); 
17100:  MOVLB  C
17102:  MOVF   x3C,W
17104:  ANDLW  01
17106:  MOVWF  00
17108:  CLRF   03
1710A:  MOVF   00,W
1710C:  IORWF  03,W
1710E:  BZ    17116
17110:  CLRF   03
17112:  MOVLW  01
17114:  BRA    1711A
17116:  CLRF   03
17118:  MOVLW  00
1711A:  MOVWF  x3E
1711C:  MOVLW  0A
1711E:  MOVWF  FF6
17120:  MOVLW  16
17122:  MOVWF  FF7
17124:  MOVLW  00
17126:  MOVWF  FF8
17128:  MOVLW  12
1712A:  MOVWF  xC1
1712C:  MOVLB  0
1712E:  CALL   5290
17132:  MOVFF  C3E,C78
17136:  MOVLW  1B
17138:  MOVLB  C
1713A:  MOVWF  x79
1713C:  MOVLB  0
1713E:  CALL   5ADC
17142:  MOVLW  2C
17144:  MOVLB  D
17146:  MOVWF  x6A
17148:  MOVLB  0
1714A:  CALL   44EE
1714E:  MOVLW  20
17150:  MOVLB  D
17152:  MOVWF  x6A
17154:  MOVLB  0
17156:  CALL   44EE
....................     fprintf(PC, "opera_ocp1 = %u, ", (uint8_t)((status & (1 << 1)) ? 1 : 0)); 
1715A:  MOVLB  C
1715C:  MOVF   x3C,W
1715E:  ANDLW  02
17160:  MOVWF  00
17162:  CLRF   03
17164:  MOVF   00,W
17166:  IORWF  03,W
17168:  BZ    17170
1716A:  CLRF   03
1716C:  MOVLW  01
1716E:  BRA    17174
17170:  CLRF   03
17172:  MOVLW  00
17174:  MOVWF  x3E
17176:  MOVLW  22
17178:  MOVWF  FF6
1717A:  MOVLW  16
1717C:  MOVWF  FF7
1717E:  MOVLW  00
17180:  MOVWF  FF8
17182:  MOVLW  0D
17184:  MOVWF  xC1
17186:  MOVLB  0
17188:  CALL   5290
1718C:  MOVFF  C3E,C78
17190:  MOVLW  1B
17192:  MOVLB  C
17194:  MOVWF  x79
17196:  MOVLB  0
17198:  CALL   5ADC
1719C:  MOVLW  2C
1719E:  MOVLB  D
171A0:  MOVWF  x6A
171A2:  MOVLB  0
171A4:  CALL   44EE
171A8:  MOVLW  20
171AA:  MOVLB  D
171AC:  MOVWF  x6A
171AE:  MOVLB  0
171B0:  CALL   44EE
....................     fprintf(PC, "opera_ocp2 = %u, ", (uint8_t)((status & (1 << 2)) ? 1 : 0)); 
171B4:  MOVLB  C
171B6:  MOVF   x3C,W
171B8:  ANDLW  04
171BA:  MOVWF  00
171BC:  CLRF   03
171BE:  MOVF   00,W
171C0:  IORWF  03,W
171C2:  BZ    171CA
171C4:  CLRF   03
171C6:  MOVLW  01
171C8:  BRA    171CE
171CA:  CLRF   03
171CC:  MOVLW  00
171CE:  MOVWF  x3E
171D0:  MOVLW  34
171D2:  MOVWF  FF6
171D4:  MOVLW  16
171D6:  MOVWF  FF7
171D8:  MOVLW  00
171DA:  MOVWF  FF8
171DC:  MOVLW  0D
171DE:  MOVWF  xC1
171E0:  MOVLB  0
171E2:  CALL   5290
171E6:  MOVFF  C3E,C78
171EA:  MOVLW  1B
171EC:  MOVLB  C
171EE:  MOVWF  x79
171F0:  MOVLB  0
171F2:  CALL   5ADC
171F6:  MOVLW  2C
171F8:  MOVLB  D
171FA:  MOVWF  x6A
171FC:  MOVLB  0
171FE:  CALL   44EE
17202:  MOVLW  20
17204:  MOVLB  D
17206:  MOVWF  x6A
17208:  MOVLB  0
1720A:  CALL   44EE
....................     fprintf(PC, "sel_com_pr = %u, ", (uint8_t)((status & (1 << 3)) ? 1 : 0)); 
1720E:  MOVLB  C
17210:  MOVF   x3C,W
17212:  ANDLW  08
17214:  MOVWF  00
17216:  CLRF   03
17218:  MOVF   00,W
1721A:  IORWF  03,W
1721C:  BZ    17224
1721E:  CLRF   03
17220:  MOVLW  01
17222:  BRA    17228
17224:  CLRF   03
17226:  MOVLW  00
17228:  MOVWF  x3E
1722A:  MOVLW  46
1722C:  MOVWF  FF6
1722E:  MOVLW  16
17230:  MOVWF  FF7
17232:  MOVLW  00
17234:  MOVWF  FF8
17236:  MOVLW  0D
17238:  MOVWF  xC1
1723A:  MOVLB  0
1723C:  CALL   5290
17240:  MOVFF  C3E,C78
17244:  MOVLW  1B
17246:  MOVLB  C
17248:  MOVWF  x79
1724A:  MOVLB  0
1724C:  CALL   5ADC
17250:  MOVLW  2C
17252:  MOVLB  D
17254:  MOVWF  x6A
17256:  MOVLB  0
17258:  CALL   44EE
1725C:  MOVLW  20
1725E:  MOVLB  D
17260:  MOVWF  x6A
17262:  MOVLB  0
17264:  CALL   44EE
....................     fprintf(PC, "sel_com_res = %u, ", (uint8_t)((status & (1 << 4)) ? 1 : 0)); 
17268:  MOVLB  C
1726A:  MOVF   x3C,W
1726C:  ANDLW  10
1726E:  MOVWF  00
17270:  CLRF   03
17272:  MOVF   00,W
17274:  IORWF  03,W
17276:  BZ    1727E
17278:  CLRF   03
1727A:  MOVLW  01
1727C:  BRA    17282
1727E:  CLRF   03
17280:  MOVLW  00
17282:  MOVWF  x3E
17284:  MOVLW  58
17286:  MOVWF  FF6
17288:  MOVLW  16
1728A:  MOVWF  FF7
1728C:  MOVLW  00
1728E:  MOVWF  FF8
17290:  MOVLW  0E
17292:  MOVWF  xC1
17294:  MOVLB  0
17296:  CALL   5290
1729A:  MOVFF  C3E,C78
1729E:  MOVLW  1B
172A0:  MOVLB  C
172A2:  MOVWF  x79
172A4:  MOVLB  0
172A6:  CALL   5ADC
172AA:  MOVLW  2C
172AC:  MOVLB  D
172AE:  MOVWF  x6A
172B0:  MOVLB  0
172B2:  CALL   44EE
172B6:  MOVLW  20
172B8:  MOVLB  D
172BA:  MOVWF  x6A
172BC:  MOVLB  0
172BE:  CALL   44EE
....................     fprintf(PC, "sel_com_pg = %u, ", (uint8_t)((status & (1 << 5)) ? 1 : 0)); 
172C2:  MOVLB  C
172C4:  MOVF   x3C,W
172C6:  ANDLW  20
172C8:  MOVWF  00
172CA:  CLRF   03
172CC:  MOVF   00,W
172CE:  IORWF  03,W
172D0:  BZ    172D8
172D2:  CLRF   03
172D4:  MOVLW  01
172D6:  BRA    172DC
172D8:  CLRF   03
172DA:  MOVLW  00
172DC:  MOVWF  x3E
172DE:  MOVLW  6C
172E0:  MOVWF  FF6
172E2:  MOVLW  16
172E4:  MOVWF  FF7
172E6:  MOVLW  00
172E8:  MOVWF  FF8
172EA:  MOVLW  0D
172EC:  MOVWF  xC1
172EE:  MOVLB  0
172F0:  CALL   5290
172F4:  MOVFF  C3E,C78
172F8:  MOVLW  1B
172FA:  MOVLB  C
172FC:  MOVWF  x79
172FE:  MOVLB  0
17300:  CALL   5ADC
17304:  MOVLW  2C
17306:  MOVLB  D
17308:  MOVWF  x6A
1730A:  MOVLB  0
1730C:  CALL   44EE
17310:  MOVLW  20
17312:  MOVLB  D
17314:  MOVWF  x6A
17316:  MOVLB  0
17318:  CALL   44EE
....................     fprintf(PC, "sel_com_flag = %u, ", (uint8_t)((status & (1 << 6)) ? 1 : 0)); 
1731C:  MOVLB  C
1731E:  MOVF   x3C,W
17320:  ANDLW  40
17322:  MOVWF  00
17324:  CLRF   03
17326:  MOVF   00,W
17328:  IORWF  03,W
1732A:  BZ    17332
1732C:  CLRF   03
1732E:  MOVLW  01
17330:  BRA    17336
17332:  CLRF   03
17334:  MOVLW  00
17336:  MOVWF  x3E
17338:  MOVLW  7E
1733A:  MOVWF  FF6
1733C:  MOVLW  16
1733E:  MOVWF  FF7
17340:  MOVLW  00
17342:  MOVWF  FF8
17344:  MOVLW  0F
17346:  MOVWF  xC1
17348:  MOVLB  0
1734A:  CALL   5290
1734E:  MOVFF  C3E,C78
17352:  MOVLW  1B
17354:  MOVLB  C
17356:  MOVWF  x79
17358:  MOVLB  0
1735A:  CALL   5ADC
1735E:  MOVLW  2C
17360:  MOVLB  D
17362:  MOVWF  x6A
17364:  MOVLB  0
17366:  CALL   44EE
1736A:  MOVLW  20
1736C:  MOVLB  D
1736E:  MOVWF  x6A
17370:  MOVLB  0
17372:  CALL   44EE
....................     fprintf(PC, "tmcr1_ocp = %u, ", (uint8_t)((status & (1 << 7)) ? 1 : 0)); 
17376:  MOVLB  C
17378:  MOVF   x3C,W
1737A:  ANDLW  80
1737C:  MOVWF  00
1737E:  CLRF   03
17380:  MOVF   00,W
17382:  IORWF  03,W
17384:  BZ    1738C
17386:  CLRF   03
17388:  MOVLW  01
1738A:  BRA    17390
1738C:  CLRF   03
1738E:  MOVLW  00
17390:  MOVWF  x3E
17392:  MOVLW  92
17394:  MOVWF  FF6
17396:  MOVLW  16
17398:  MOVWF  FF7
1739A:  MOVLW  00
1739C:  MOVWF  FF8
1739E:  MOVLW  0C
173A0:  MOVWF  xC1
173A2:  MOVLB  0
173A4:  CALL   5290
173A8:  MOVFF  C3E,C78
173AC:  MOVLW  1B
173AE:  MOVLB  C
173B0:  MOVWF  x79
173B2:  MOVLB  0
173B4:  CALL   5ADC
173B8:  MOVLW  2C
173BA:  MOVLB  D
173BC:  MOVWF  x6A
173BE:  MOVLB  0
173C0:  CALL   44EE
173C4:  MOVLW  20
173C6:  MOVLB  D
173C8:  MOVWF  x6A
173CA:  MOVLB  0
173CC:  CALL   44EE
....................     fprintf(PC, "tmcr2_ocp = %u, ", (uint8_t)((status & (1 << 8)) ? 1 : 0)); 
173D0:  ANDLW  00
173D2:  MOVWF  00
173D4:  MOVLB  C
173D6:  MOVF   x3D,W
173D8:  ANDLW  01
173DA:  MOVWF  03
173DC:  MOVF   00,W
173DE:  IORWF  03,W
173E0:  BZ    173E8
173E2:  CLRF   03
173E4:  MOVLW  01
173E6:  BRA    173EC
173E8:  CLRF   03
173EA:  MOVLW  00
173EC:  MOVWF  x3E
173EE:  MOVLW  A4
173F0:  MOVWF  FF6
173F2:  MOVLW  16
173F4:  MOVWF  FF7
173F6:  MOVLW  00
173F8:  MOVWF  FF8
173FA:  MOVLW  0C
173FC:  MOVWF  xC1
173FE:  MOVLB  0
17400:  CALL   5290
17404:  MOVFF  C3E,C78
17408:  MOVLW  1B
1740A:  MOVLB  C
1740C:  MOVWF  x79
1740E:  MOVLB  0
17410:  CALL   5ADC
17414:  MOVLW  2C
17416:  MOVLB  D
17418:  MOVWF  x6A
1741A:  MOVLB  0
1741C:  CALL   44EE
17420:  MOVLW  20
17422:  MOVLB  D
17424:  MOVWF  x6A
17426:  MOVLB  0
17428:  CALL   44EE
....................     fprintf(PC, "sel_status = %u | ", (uint8_t)((status & (1 << 9)) ? 1 : 0)); 
1742C:  ANDLW  00
1742E:  MOVWF  00
17430:  MOVLB  C
17432:  MOVF   x3D,W
17434:  ANDLW  02
17436:  MOVWF  03
17438:  MOVF   00,W
1743A:  IORWF  03,W
1743C:  BZ    17444
1743E:  CLRF   03
17440:  MOVLW  01
17442:  BRA    17448
17444:  CLRF   03
17446:  MOVLW  00
17448:  MOVWF  x3E
1744A:  MOVLW  B6
1744C:  MOVWF  FF6
1744E:  MOVLW  16
17450:  MOVWF  FF7
17452:  MOVLW  00
17454:  MOVWF  FF8
17456:  MOVLW  0D
17458:  MOVWF  xC1
1745A:  MOVLB  0
1745C:  CALL   5290
17460:  MOVFF  C3E,C78
17464:  MOVLW  1B
17466:  MOVLB  C
17468:  MOVWF  x79
1746A:  MOVLB  0
1746C:  CALL   5ADC
17470:  MOVLW  C5
17472:  MOVWF  FF6
17474:  MOVLW  16
17476:  MOVWF  FF7
17478:  MOVLW  00
1747A:  MOVWF  FF8
1747C:  MOVLW  03
1747E:  MOVLB  C
17480:  MOVWF  xC1
17482:  MOVLB  0
17484:  CALL   5290
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_MCPIC); 
17488:  MOVFF  C39,C90
1748C:  MOVFF  C38,C8F
17490:  MOVLW  06
17492:  MOVLB  C
17494:  MOVWF  x91
17496:  MOVLB  0
17498:  CALL   7A5C
....................  
....................     telemetry_time.msn_time = current_time; 
1749C:  MOVFF  3E,EA
174A0:  MOVFF  3D,E9
174A4:  MOVFF  3C,E8
174A8:  MOVFF  3B,E7
....................     memcpy(telemetry.msn_message, data + 2, sizeof(telemetry.msn_message)); 
174AC:  MOVLW  02
174AE:  MOVLB  C
174B0:  ADDWF  x38,W
174B2:  MOVWF  x3E
174B4:  MOVLW  00
174B6:  ADDWFC x39,W
174B8:  MOVWF  FE2
174BA:  MOVFF  C3E,FE1
174BE:  MOVFF  FE6,9C
174C2:  MOVFF  FE6,9D
....................  
....................     return 0; 
174C6:  MOVLW  00
174C8:  MOVWF  01
174CA:  MOVLB  0
174CC:  GOTO   18F9E (RETURN)
.................... } 
....................  
.................... // Used to stop the simulation 
.................... uint8_t command_debug(uint8_t* data) 
.................... { 
.................... #ifdef PC_SIM 
....................     fprintf(PC, "Exiting simulation"); 
....................     continue_program = 0; 
.................... #else 
....................     verbose = !verbose; 
*
0FFB8:  MOVLB  5
0FFBA:  MOVF   x5A,F
0FFBC:  BZ    FFC2
0FFBE:  MOVLW  00
0FFC0:  BRA    FFC4
0FFC2:  MOVLW  01
0FFC4:  MOVWF  x5A
.................... #endif // !PC_SIM 
....................     return 0; 
0FFC6:  MOVLW  00
0FFC8:  MOVWF  01
0FFCA:  MOVLB  0
0FFCC:  GOTO   18E24 (RETURN)
.................... } 
....................  
.................... uint8_t command_opera_full(uint8_t* data) 
.................... { 
....................     enum { packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 }; 
....................  
....................     if (mux_sel(mux_opera) != mux_opera) { // If MUX did not change 
*
16FA0:  MOVLW  04
16FA2:  MOVLB  C
16FA4:  MOVWF  xBE
16FA6:  MOVLB  0
16FA8:  CALL   52E8
16FAC:  MOVF   01,W
16FAE:  SUBLW  04
16FB0:  BZ    16FD4
....................         if (verbose) { 
16FB2:  MOVLB  5
16FB4:  MOVF   x5A,F
16FB6:  BZ    16FCC
....................             fprintf(PC, "MUX change failed!"); 
16FB8:  MOVLW  CA
16FBA:  MOVWF  FF6
16FBC:  MOVLW  16
16FBE:  MOVWF  FF7
16FC0:  MOVLW  00
16FC2:  MOVWF  FF8
16FC4:  MOVLB  0
16FC6:  CALL   4534
16FCA:  MOVLB  5
....................         } 
....................         return 1; 
16FCC:  MOVLW  01
16FCE:  MOVWF  01
16FD0:  BRA    170C2
16FD2:  MOVLB  0
....................     } 
....................     uart_print_pc_hex(data, BUFF_LENGTH); 
16FD4:  MOVFF  C39,C90
16FD8:  MOVFF  C38,C8F
16FDC:  MOVLW  1C
16FDE:  MOVLB  C
16FE0:  MOVWF  x91
16FE2:  MOVLB  0
16FE4:  CALL   7A5C
....................  
....................     uint8_t opera_cmd[packet_size] = { 0 }; 
16FE8:  MOVLB  C
16FEA:  CLRF   x3A
16FEC:  CLRF   x3B
16FEE:  CLRF   x3C
16FF0:  CLRF   x3D
16FF2:  CLRF   x3E
16FF4:  CLRF   x3F
16FF6:  CLRF   x40
16FF8:  CLRF   x41
16FFA:  CLRF   x42
16FFC:  CLRF   x43
16FFE:  CLRF   x44
17000:  CLRF   x45
17002:  CLRF   x46
17004:  CLRF   x47
17006:  CLRF   x48
17008:  CLRF   x49
1700A:  CLRF   x4A
1700C:  CLRF   x4B
1700E:  CLRF   x4C
17010:  CLRF   x4D
17012:  CLRF   x4E
17014:  CLRF   x4F
17016:  CLRF   x50
17018:  CLRF   x51
1701A:  CLRF   x52
1701C:  CLRF   x53
1701E:  CLRF   x54
17020:  CLRF   x55
....................  
....................     opera_cmd[0] = 0x2A; 
17022:  MOVLW  2A
17024:  MOVWF  x3A
....................     memcpy(opera_cmd + 1, data + 2, packet_size - 2); 
17026:  MOVLW  02
17028:  ADDWF  x38,W
1702A:  MOVWF  x57
1702C:  MOVLW  00
1702E:  ADDWFC x39,W
17030:  MOVWF  x58
17032:  MOVLW  0C
17034:  MOVWF  FEA
17036:  MOVLW  3B
17038:  MOVWF  FE9
1703A:  MOVFF  C58,FE2
1703E:  MOVFF  C57,FE1
17042:  MOVLW  1A
17044:  MOVWF  01
17046:  MOVFF  FE6,FEE
1704A:  DECFSZ 01,F
1704C:  BRA    17046
....................     opera_cmd[packet_size - 1] = 0x80; 
1704E:  MOVLW  80
17050:  MOVWF  x55
....................  
....................     uart_send_packet(&uart_port_MSN, opera_cmd, sizeof(opera_cmd)); 
17052:  MOVLW  0A
17054:  MOVLB  D
17056:  MOVWF  x3C
17058:  MOVLW  97
1705A:  MOVWF  x3B
1705C:  MOVLW  0C
1705E:  MOVWF  x3E
17060:  MOVLW  3A
17062:  MOVWF  x3D
17064:  CLRF   x42
17066:  CLRF   x41
17068:  CLRF   x40
1706A:  MOVLW  1C
1706C:  MOVWF  x3F
1706E:  MOVLB  0
17070:  CALL   8EDE
....................     uint8_t ack[1] = { 0 }; 
17074:  MOVLB  C
17076:  CLRF   x56
....................     uart_download_packet(&uart_port_MSN, ack, sizeof(ack), 100000); // Try to get the ACK 
17078:  MOVLW  0A
1707A:  MOVLB  D
1707C:  MOVWF  x45
1707E:  MOVLW  97
17080:  MOVWF  x44
17082:  MOVLW  0C
17084:  MOVWF  x47
17086:  MOVLW  56
17088:  MOVWF  x46
1708A:  CLRF   x4B
1708C:  CLRF   x4A
1708E:  CLRF   x49
17090:  MOVLW  01
17092:  MOVWF  x48
17094:  CLRF   x4F
17096:  MOVWF  x4E
17098:  MOVLW  86
1709A:  MOVWF  x4D
1709C:  MOVLW  A0
1709E:  MOVWF  x4C
170A0:  MOVLB  0
170A2:  CALL   97CE
....................     memset(&opera_GA_part_a, 0, sizeof(opera_GA_part_a));           // Erase old data. 
170A6:  MOVLW  08
170A8:  MOVWF  FEA
170AA:  MOVLW  9A
170AC:  MOVWF  FE9
170AE:  CLRF   00
170B0:  CLRF   02
170B2:  MOVLW  10
170B4:  MOVWF  01
170B6:  CALL   5222
....................     return ack[0]; 
170BA:  MOVLB  C
170BC:  MOVFF  C56,01
170C0:  MOVLB  5
170C2:  MOVLB  0
170C4:  GOTO   18F8C (RETURN)
.................... } 
....................  
.................... uint8_t command_opera_GA_part_a(uint8_t* data) 
*
1696C:  MOVFF  C39,C3B
16970:  MOVFF  C38,C3A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_a_parameters[GA_part_a_size]; 
....................         // No padding is required 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memcpy(opera_GA_part_a, packet->part_a_parameters, GA_part_a_size); 
16974:  MOVLW  02
16976:  MOVLB  C
16978:  ADDWF  x3A,W
1697A:  MOVWF  x3C
1697C:  MOVLW  00
1697E:  ADDWFC x3B,W
16980:  MOVWF  x3D
16982:  MOVLW  08
16984:  MOVWF  FEA
16986:  MOVLW  9A
16988:  MOVWF  FE9
1698A:  MOVFF  C3D,FE2
1698E:  MOVFF  C3C,FE1
16992:  MOVLW  10
16994:  MOVWF  01
16996:  MOVFF  FE6,FEE
1699A:  DECFSZ 01,F
1699C:  BRA    16996
....................  
....................     fprintf(PC, "Received OPERA GA part a: "); 
1699E:  MOVLW  DE
169A0:  MOVWF  FF6
169A2:  MOVLW  16
169A4:  MOVWF  FF7
169A6:  MOVLW  00
169A8:  MOVWF  FF8
169AA:  MOVLB  0
169AC:  CALL   4534
....................     uart_print_pc_hex(opera_GA_part_a, sizeof(opera_GA_part_a)); 
169B0:  MOVLW  08
169B2:  MOVLB  C
169B4:  MOVWF  x90
169B6:  MOVLW  9A
169B8:  MOVWF  x8F
169BA:  MOVLW  10
169BC:  MOVWF  x91
169BE:  MOVLB  0
169C0:  CALL   7A5C
....................  
....................     return 0; 
169C4:  MOVLW  00
169C6:  MOVWF  01
169C8:  GOTO   18F44 (RETURN)
.................... } 
....................  
.................... uint8_t command_opera_GA_part_b(uint8_t* data) 
169CC:  MOVFF  C39,C3B
169D0:  MOVFF  C38,C3A
*
16A48:  MOVLW  08
16A4A:  MOVWF  x84
16A4C:  MOVLW  9A
16A4E:  MOVFF  C84,C75
16A52:  MOVWF  x74
16A54:  MOVLW  08
16A56:  MOVWF  x86
16A58:  MOVLW  9E
16A5A:  MOVFF  C86,C77
16A5E:  MOVWF  x76
16A60:  MOVFF  C75,03
16A64:  MOVFF  C74,FE9
16A68:  MOVFF  C75,FEA
16A6C:  MOVF   FEF,F
16A6E:  BNZ   16A80
16A70:  MOVF   FEC,F
16A72:  BNZ   16A80
16A74:  MOVF   FEC,F
16A76:  BNZ   16A80
16A78:  MOVF   FEC,F
16A7A:  BNZ   16A80
16A7C:  MOVLW  00
16A7E:  BRA    16A82
16A80:  MOVLW  01
16A82:  MOVWF  x78
.................... { 
....................     enum { packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_b_parameters[GA_part_b_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t opera_cmd[packet_size] = { 0xC0, 0xFF }; 
*
169D4:  MOVLW  C0
169D6:  MOVLB  C
169D8:  MOVWF  x3C
169DA:  SETF   x3D
169DC:  CLRF   x3E
169DE:  CLRF   x3F
169E0:  CLRF   x40
169E2:  CLRF   x41
169E4:  CLRF   x42
169E6:  CLRF   x43
169E8:  CLRF   x44
169EA:  CLRF   x45
169EC:  CLRF   x46
169EE:  CLRF   x47
169F0:  CLRF   x48
169F2:  CLRF   x49
169F4:  CLRF   x4A
169F6:  CLRF   x4B
169F8:  CLRF   x4C
169FA:  CLRF   x4D
169FC:  CLRF   x4E
169FE:  CLRF   x4F
16A00:  CLRF   x50
16A02:  CLRF   x51
16A04:  CLRF   x52
16A06:  CLRF   x53
16A08:  CLRF   x54
16A0A:  CLRF   x55
16A0C:  CLRF   x56
16A0E:  CLRF   x57
....................     uint8_t opera_off[packet_size] = { 0xC0, 0xFF, 0xFF }; 
16A10:  MOVWF  x58
16A12:  SETF   x59
16A14:  SETF   x5A
16A16:  CLRF   x5B
16A18:  CLRF   x5C
16A1A:  CLRF   x5D
16A1C:  CLRF   x5E
16A1E:  CLRF   x5F
16A20:  CLRF   x60
16A22:  CLRF   x61
16A24:  CLRF   x62
16A26:  CLRF   x63
16A28:  CLRF   x64
16A2A:  CLRF   x65
16A2C:  CLRF   x66
16A2E:  CLRF   x67
16A30:  CLRF   x68
16A32:  CLRF   x69
16A34:  CLRF   x6A
16A36:  CLRF   x6B
16A38:  CLRF   x6C
16A3A:  CLRF   x6D
16A3C:  CLRF   x6E
16A3E:  CLRF   x6F
16A40:  CLRF   x70
16A42:  CLRF   x71
16A44:  CLRF   x72
16A46:  CLRF   x73
....................  
....................     time_t* opera_turn_on_time = (time_t*)opera_GA_part_a;                            // The first part in the command is time information 
....................     uint16_t* opera_mission_duration = (uint16_t*)(opera_GA_part_a + sizeof(time_t)); // The second part in the command is the mission duration 
....................  
....................     uint8_t scheduled = !!*opera_turn_on_time; 
....................  
....................     if (!*opera_turn_on_time) { 
*
16A84:  MOVFF  C75,03
16A88:  MOVFF  C74,FE9
16A8C:  MOVFF  C75,FEA
16A90:  MOVF   FEF,F
16A92:  BNZ   16AB8
16A94:  MOVF   FEC,F
16A96:  BNZ   16AB8
16A98:  MOVF   FEC,F
16A9A:  BNZ   16AB8
16A9C:  MOVF   FEC,F
16A9E:  BNZ   16AB8
....................         *opera_turn_on_time = current_time; 
16AA0:  MOVFF  C74,FE9
16AA4:  MOVFF  C75,FEA
16AA8:  MOVFF  3B,FEF
16AAC:  MOVFF  3C,FEC
16AB0:  MOVFF  3D,FEC
16AB4:  MOVFF  3E,FEC
....................     } 
....................  
....................     memcpy(opera_cmd + 2, opera_GA_part_a + sizeof(time_t) + sizeof(uint16_t), sizeof(opera_GA_part_a) - sizeof(time_t)); 
16AB8:  MOVLW  0C
16ABA:  MOVWF  FEA
16ABC:  MOVLW  3E
16ABE:  MOVWF  FE9
16AC0:  MOVLW  08
16AC2:  MOVWF  FE2
16AC4:  MOVLW  A0
16AC6:  MOVWF  FE1
16AC8:  MOVLW  0C
16ACA:  MOVWF  01
16ACC:  MOVFF  FE6,FEE
16AD0:  DECFSZ 01,F
16AD2:  BRA    16ACC
....................     memcpy(opera_cmd + 2 + sizeof(opera_GA_part_a) - sizeof(time_t) - sizeof(uint16_t), packet->part_b_parameters, GA_part_b_size); 
16AD4:  MOVLW  02
16AD6:  ADDWF  x3A,W
16AD8:  MOVWF  01
16ADA:  MOVLW  00
16ADC:  ADDWFC x3B,W
16ADE:  MOVWF  03
16AE0:  MOVFF  01,C83
16AE4:  MOVWF  x84
16AE6:  MOVLW  0C
16AE8:  MOVWF  FEA
16AEA:  MOVLW  48
16AEC:  MOVWF  FE9
16AEE:  MOVFF  03,FE2
16AF2:  MOVFF  01,FE1
16AF6:  MOVLW  10
16AF8:  MOVWF  01
16AFA:  MOVFF  FE6,FEE
16AFE:  DECFSZ 01,F
16B00:  BRA    16AFA
....................  
....................     fprintf(PC, "Received OPERA part b: "); 
16B02:  MOVLW  FA
16B04:  MOVWF  FF6
16B06:  MOVLW  16
16B08:  MOVWF  FF7
16B0A:  MOVLW  00
16B0C:  MOVWF  FF8
16B0E:  MOVLB  0
16B10:  CALL   4534
....................     uart_print_pc_hex(opera_cmd + 2, sizeof(opera_cmd) - sizeof(time_t) - 2); 
16B14:  MOVLW  0C
16B16:  MOVLB  C
16B18:  MOVWF  x90
16B1A:  MOVLW  3E
16B1C:  MOVWF  x8F
16B1E:  MOVLW  16
16B20:  MOVWF  x91
16B22:  MOVLB  0
16B24:  CALL   7A5C
....................  
....................     fprintf(PC, " Scheduling commands..."); 
16B28:  MOVLW  12
16B2A:  MOVWF  FF6
16B2C:  MOVLW  17
16B2E:  MOVWF  FF7
16B30:  MOVLW  00
16B32:  MOVWF  FF8
16B34:  CALL   4534
....................  
....................     schedule(*opera_turn_on_time, { 0xC0, 0x2A, mcp_cmd_opera_on, 0x00, 0x00 }); 
16B38:  MOVLW  C0
16B3A:  MOVLB  C
16B3C:  MOVWF  x79
16B3E:  MOVLW  2A
16B40:  MOVWF  x7A
16B42:  MOVLW  20
16B44:  MOVWF  x7B
16B46:  CLRF   x7C
16B48:  CLRF   x7D
16B4A:  MOVFF  C75,03
16B4E:  MOVFF  C74,FE9
16B52:  MOVFF  C75,FEA
16B56:  MOVFF  FEF,C95
16B5A:  MOVFF  FEC,C96
16B5E:  MOVFF  FEC,C97
16B62:  MOVFF  FEC,C98
16B66:  MOVLW  0C
16B68:  MOVWF  x9A
16B6A:  MOVLW  79
16B6C:  MOVWF  x99
16B6E:  MOVLB  0
16B70:  CALL   704C
....................     vschedule(*opera_turn_on_time + obc_flags.opera_boot_duration, opera_cmd); 
16B74:  MOVFF  C75,03
16B78:  MOVFF  C74,FE9
16B7C:  MOVFF  C75,FEA
16B80:  MOVFF  FEF,C83
16B84:  MOVFF  FEC,C84
16B88:  MOVFF  FEC,C85
16B8C:  MOVFF  FEC,C86
16B90:  MOVLB  1
16B92:  MOVF   x0A,W
16B94:  MOVLB  C
16B96:  ADDWF  x83,F
16B98:  MOVLW  00
16B9A:  ADDWFC x84,F
16B9C:  ADDWFC x85,F
16B9E:  ADDWFC x86,F
16BA0:  MOVFF  C86,C98
16BA4:  MOVFF  C85,C97
16BA8:  MOVFF  C84,C96
16BAC:  MOVFF  C83,C95
16BB0:  MOVLW  0C
16BB2:  MOVWF  x9A
16BB4:  MOVLW  3C
16BB6:  MOVWF  x99
16BB8:  MOVLB  0
16BBA:  CALL   704C
....................     vschedule(*opera_turn_on_time + obc_flags.opera_boot_duration + *opera_mission_duration, opera_off); 
16BBE:  MOVFF  C74,FE9
16BC2:  MOVFF  C75,FEA
16BC6:  MOVFF  FEF,C83
16BCA:  MOVFF  FEC,C84
16BCE:  MOVFF  FEC,C85
16BD2:  MOVFF  FEC,C86
16BD6:  MOVLB  1
16BD8:  MOVF   x0A,W
16BDA:  MOVLB  C
16BDC:  ADDWF  x83,F
16BDE:  MOVLW  00
16BE0:  ADDWFC x84,F
16BE2:  ADDWFC x85,F
16BE4:  ADDWFC x86,F
16BE6:  MOVFF  C76,FE9
16BEA:  MOVFF  C77,FEA
16BEE:  MOVFF  FEC,03
16BF2:  MOVF   FED,F
16BF4:  MOVF   FEF,W
16BF6:  ADDWF  x83,F
16BF8:  MOVF   03,W
16BFA:  ADDWFC x84,F
16BFC:  MOVLW  00
16BFE:  ADDWFC x85,F
16C00:  ADDWFC x86,F
16C02:  MOVFF  C86,C98
16C06:  MOVFF  C85,C97
16C0A:  MOVFF  C84,C96
16C0E:  MOVFF  C83,C95
16C12:  MOVLW  0C
16C14:  MOVWF  x9A
16C16:  MOVLW  58
16C18:  MOVWF  x99
16C1A:  MOVLB  0
16C1C:  CALL   704C
....................     schedule(*opera_turn_on_time + obc_flags.opera_boot_duration + *opera_mission_duration + 40, { 0xC0, 0x2A, mcp_cmd_opera_off, 0x00, 0x00 }); 
16C20:  MOVLW  C0
16C22:  MOVLB  C
16C24:  MOVWF  x7E
16C26:  MOVLW  2A
16C28:  MOVWF  x7F
16C2A:  MOVLW  2F
16C2C:  MOVWF  x80
16C2E:  CLRF   x81
16C30:  CLRF   x82
16C32:  MOVFF  C74,FE9
16C36:  MOVFF  C75,FEA
16C3A:  MOVFF  FEF,C83
16C3E:  MOVFF  FEC,C84
16C42:  MOVFF  FEC,C85
16C46:  MOVFF  FEC,C86
16C4A:  MOVLB  1
16C4C:  MOVF   x0A,W
16C4E:  MOVLB  C
16C50:  ADDWF  x83,F
16C52:  MOVLW  00
16C54:  ADDWFC x84,F
16C56:  ADDWFC x85,F
16C58:  ADDWFC x86,F
16C5A:  MOVFF  C76,FE9
16C5E:  MOVFF  C77,FEA
16C62:  MOVFF  FEC,03
16C66:  MOVF   FED,F
16C68:  MOVF   FEF,W
16C6A:  ADDWF  x83,F
16C6C:  MOVF   03,W
16C6E:  ADDWFC x84,F
16C70:  MOVLW  00
16C72:  ADDWFC x85,F
16C74:  ADDWFC x86,F
16C76:  MOVLW  28
16C78:  ADDWF  x83,F
16C7A:  MOVLW  00
16C7C:  ADDWFC x84,F
16C7E:  ADDWFC x85,F
16C80:  ADDWFC x86,F
16C82:  MOVFF  C86,C98
16C86:  MOVFF  C85,C97
16C8A:  MOVFF  C84,C96
16C8E:  MOVFF  C83,C95
16C92:  MOVLW  0C
16C94:  MOVWF  x9A
16C96:  MOVLW  7E
16C98:  MOVWF  x99
16C9A:  MOVLB  0
16C9C:  CALL   704C
....................  
....................     return scheduled; 
16CA0:  MOVLB  C
16CA2:  MOVFF  C78,01
16CA6:  MOVLB  0
16CA8:  GOTO   18F56 (RETURN)
.................... } 
....................  
.................... uint8_t command_opera_GA_single(uint8_t* data) 
16CAC:  MOVFF  C39,C3B
16CB0:  MOVFF  C38,C3A
*
16D28:  MOVLW  02
16D2A:  ADDWF  x3A,W
16D2C:  MOVWF  FE9
16D2E:  MOVLW  00
16D30:  ADDWFC x3B,W
16D32:  MOVWF  FEA
16D34:  MOVF   FEF,F
16D36:  BNZ   16D48
16D38:  MOVF   FEC,F
16D3A:  BNZ   16D48
16D3C:  MOVF   FEC,F
16D3E:  BNZ   16D48
16D40:  MOVF   FEC,F
16D42:  BNZ   16D48
16D44:  MOVLW  00
16D46:  BRA    16D4A
16D48:  MOVLW  01
16D4A:  MOVWF  x74
.................... { 
....................     enum { 
....................         length = 16 - sizeof(time_t) - sizeof(uint16_t), 
....................         packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t opera_turn_on_time; 
....................         uint16_t opera_mission_duration; 
....................         uint8_t opera_command[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t opera_cmd[packet_size] = { 0xC0, 0xFF }; 
*
16CB4:  MOVLW  C0
16CB6:  MOVLB  C
16CB8:  MOVWF  x3C
16CBA:  SETF   x3D
16CBC:  CLRF   x3E
16CBE:  CLRF   x3F
16CC0:  CLRF   x40
16CC2:  CLRF   x41
16CC4:  CLRF   x42
16CC6:  CLRF   x43
16CC8:  CLRF   x44
16CCA:  CLRF   x45
16CCC:  CLRF   x46
16CCE:  CLRF   x47
16CD0:  CLRF   x48
16CD2:  CLRF   x49
16CD4:  CLRF   x4A
16CD6:  CLRF   x4B
16CD8:  CLRF   x4C
16CDA:  CLRF   x4D
16CDC:  CLRF   x4E
16CDE:  CLRF   x4F
16CE0:  CLRF   x50
16CE2:  CLRF   x51
16CE4:  CLRF   x52
16CE6:  CLRF   x53
16CE8:  CLRF   x54
16CEA:  CLRF   x55
16CEC:  CLRF   x56
16CEE:  CLRF   x57
....................     uint8_t opera_off[packet_size] = { 0xC0, 0xFF, 0xFF }; 
16CF0:  MOVWF  x58
16CF2:  SETF   x59
16CF4:  SETF   x5A
16CF6:  CLRF   x5B
16CF8:  CLRF   x5C
16CFA:  CLRF   x5D
16CFC:  CLRF   x5E
16CFE:  CLRF   x5F
16D00:  CLRF   x60
16D02:  CLRF   x61
16D04:  CLRF   x62
16D06:  CLRF   x63
16D08:  CLRF   x64
16D0A:  CLRF   x65
16D0C:  CLRF   x66
16D0E:  CLRF   x67
16D10:  CLRF   x68
16D12:  CLRF   x69
16D14:  CLRF   x6A
16D16:  CLRF   x6B
16D18:  CLRF   x6C
16D1A:  CLRF   x6D
16D1C:  CLRF   x6E
16D1E:  CLRF   x6F
16D20:  CLRF   x70
16D22:  CLRF   x71
16D24:  CLRF   x72
16D26:  CLRF   x73
....................  
....................     uint8_t scheduled = !!packet->opera_turn_on_time; 
....................  
....................     if (!packet->opera_turn_on_time) { 
*
16D4C:  MOVLW  02
16D4E:  ADDWF  x3A,W
16D50:  MOVWF  FE9
16D52:  MOVLW  00
16D54:  ADDWFC x3B,W
16D56:  MOVWF  FEA
16D58:  MOVF   FEF,F
16D5A:  BNZ   16D84
16D5C:  MOVF   FEC,F
16D5E:  BNZ   16D84
16D60:  MOVF   FEC,F
16D62:  BNZ   16D84
16D64:  MOVF   FEC,F
16D66:  BNZ   16D84
....................         packet->opera_turn_on_time = current_time; 
16D68:  MOVLW  02
16D6A:  ADDWF  x3A,W
16D6C:  MOVWF  FE9
16D6E:  MOVLW  00
16D70:  ADDWFC x3B,W
16D72:  MOVWF  FEA
16D74:  MOVFF  3B,FEF
16D78:  MOVFF  3C,FEC
16D7C:  MOVFF  3D,FEC
16D80:  MOVFF  3E,FEC
....................     } 
....................  
....................     memcpy(opera_cmd + 2, packet->opera_command, length); 
16D84:  MOVLW  08
16D86:  ADDWF  x3A,W
16D88:  MOVWF  01
16D8A:  MOVLW  00
16D8C:  ADDWFC x3B,W
16D8E:  MOVWF  03
16D90:  MOVFF  01,C7F
16D94:  MOVWF  x80
16D96:  MOVLW  0C
16D98:  MOVWF  FEA
16D9A:  MOVLW  3E
16D9C:  MOVWF  FE9
16D9E:  MOVFF  03,FE2
16DA2:  MOVFF  01,FE1
16DA6:  MOVLW  0A
16DA8:  MOVWF  01
16DAA:  MOVFF  FE6,FEE
16DAE:  DECFSZ 01,F
16DB0:  BRA    16DAA
....................  
....................     fprintf(PC, "Received OPERA command: "); 
16DB2:  MOVLW  2A
16DB4:  MOVWF  FF6
16DB6:  MOVLW  17
16DB8:  MOVWF  FF7
16DBA:  MOVLW  00
16DBC:  MOVWF  FF8
16DBE:  MOVLB  0
16DC0:  CALL   4534
....................     uart_print_pc_hex(opera_cmd, sizeof(opera_cmd)); 
16DC4:  MOVLW  0C
16DC6:  MOVLB  C
16DC8:  MOVWF  x90
16DCA:  MOVLW  3C
16DCC:  MOVWF  x8F
16DCE:  MOVLW  1C
16DD0:  MOVWF  x91
16DD2:  MOVLB  0
16DD4:  CALL   7A5C
....................  
....................     fprintf(PC, " Scheduling commands..."); 
16DD8:  MOVLW  44
16DDA:  MOVWF  FF6
16DDC:  MOVLW  17
16DDE:  MOVWF  FF7
16DE0:  MOVLW  00
16DE2:  MOVWF  FF8
16DE4:  CALL   4534
....................  
....................     schedule(packet->opera_turn_on_time, { 0xC0, 0x2A, mcp_cmd_opera_on, 0x00, 0x00 }); 
16DE8:  MOVLW  C0
16DEA:  MOVLB  C
16DEC:  MOVWF  x75
16DEE:  MOVLW  2A
16DF0:  MOVWF  x76
16DF2:  MOVLW  20
16DF4:  MOVWF  x77
16DF6:  CLRF   x78
16DF8:  CLRF   x79
16DFA:  MOVLW  02
16DFC:  ADDWF  x3A,W
16DFE:  MOVWF  FE9
16E00:  MOVLW  00
16E02:  ADDWFC x3B,W
16E04:  MOVWF  FEA
16E06:  MOVFF  FEF,C95
16E0A:  MOVFF  FEC,C96
16E0E:  MOVFF  FEC,C97
16E12:  MOVFF  FEC,C98
16E16:  MOVLW  0C
16E18:  MOVWF  x9A
16E1A:  MOVLW  75
16E1C:  MOVWF  x99
16E1E:  MOVLB  0
16E20:  CALL   704C
....................     vschedule(packet->opera_turn_on_time + obc_flags.opera_boot_duration, opera_cmd); 
16E24:  MOVLW  02
16E26:  MOVLB  C
16E28:  ADDWF  x3A,W
16E2A:  MOVWF  FE9
16E2C:  MOVLW  00
16E2E:  ADDWFC x3B,W
16E30:  MOVWF  FEA
16E32:  MOVFF  FEF,C7F
16E36:  MOVFF  FEC,C80
16E3A:  MOVFF  FEC,C81
16E3E:  MOVFF  FEC,C82
16E42:  MOVLB  1
16E44:  MOVF   x0A,W
16E46:  MOVLB  C
16E48:  ADDWF  x7F,F
16E4A:  MOVLW  00
16E4C:  ADDWFC x80,F
16E4E:  ADDWFC x81,F
16E50:  ADDWFC x82,F
16E52:  MOVFF  C82,C98
16E56:  MOVFF  C81,C97
16E5A:  MOVFF  C80,C96
16E5E:  MOVFF  C7F,C95
16E62:  MOVLW  0C
16E64:  MOVWF  x9A
16E66:  MOVLW  3C
16E68:  MOVWF  x99
16E6A:  MOVLB  0
16E6C:  CALL   704C
....................     vschedule(packet->opera_turn_on_time + obc_flags.opera_boot_duration + packet->opera_mission_duration, opera_off); 
16E70:  MOVLW  02
16E72:  MOVLB  C
16E74:  ADDWF  x3A,W
16E76:  MOVWF  FE9
16E78:  MOVLW  00
16E7A:  ADDWFC x3B,W
16E7C:  MOVWF  FEA
16E7E:  MOVFF  FEF,C7F
16E82:  MOVFF  FEC,C80
16E86:  MOVFF  FEC,C81
16E8A:  MOVFF  FEC,C82
16E8E:  MOVLB  1
16E90:  MOVF   x0A,W
16E92:  MOVLB  C
16E94:  ADDWF  x7F,F
16E96:  MOVLW  00
16E98:  ADDWFC x80,F
16E9A:  ADDWFC x81,F
16E9C:  ADDWFC x82,F
16E9E:  MOVLW  06
16EA0:  ADDWF  x3A,W
16EA2:  MOVWF  FE9
16EA4:  MOVLW  00
16EA6:  ADDWFC x3B,W
16EA8:  MOVWF  FEA
16EAA:  MOVFF  FEC,03
16EAE:  MOVF   FED,F
16EB0:  MOVF   FEF,W
16EB2:  ADDWF  x7F,F
16EB4:  MOVF   03,W
16EB6:  ADDWFC x80,F
16EB8:  MOVLW  00
16EBA:  ADDWFC x81,F
16EBC:  ADDWFC x82,F
16EBE:  MOVFF  C82,C98
16EC2:  MOVFF  C81,C97
16EC6:  MOVFF  C80,C96
16ECA:  MOVFF  C7F,C95
16ECE:  MOVLW  0C
16ED0:  MOVWF  x9A
16ED2:  MOVLW  58
16ED4:  MOVWF  x99
16ED6:  MOVLB  0
16ED8:  CALL   704C
....................     schedule(packet->opera_turn_on_time + obc_flags.opera_boot_duration + packet->opera_mission_duration + 40, { 0xC0, 0x2A, mcp_cmd_opera_off, 0x00, 0x00 }); 
16EDC:  MOVLW  C0
16EDE:  MOVLB  C
16EE0:  MOVWF  x7A
16EE2:  MOVLW  2A
16EE4:  MOVWF  x7B
16EE6:  MOVLW  2F
16EE8:  MOVWF  x7C
16EEA:  CLRF   x7D
16EEC:  CLRF   x7E
16EEE:  MOVLW  02
16EF0:  ADDWF  x3A,W
16EF2:  MOVWF  FE9
16EF4:  MOVLW  00
16EF6:  ADDWFC x3B,W
16EF8:  MOVWF  FEA
16EFA:  MOVFF  FEF,C7F
16EFE:  MOVFF  FEC,C80
16F02:  MOVFF  FEC,C81
16F06:  MOVFF  FEC,C82
16F0A:  MOVLB  1
16F0C:  MOVF   x0A,W
16F0E:  MOVLB  C
16F10:  ADDWF  x7F,F
16F12:  MOVLW  00
16F14:  ADDWFC x80,F
16F16:  ADDWFC x81,F
16F18:  ADDWFC x82,F
16F1A:  MOVLW  06
16F1C:  ADDWF  x3A,W
16F1E:  MOVWF  FE9
16F20:  MOVLW  00
16F22:  ADDWFC x3B,W
16F24:  MOVWF  FEA
16F26:  MOVFF  FEC,03
16F2A:  MOVF   FED,F
16F2C:  MOVF   FEF,W
16F2E:  ADDWF  x7F,F
16F30:  MOVF   03,W
16F32:  ADDWFC x80,F
16F34:  MOVLW  00
16F36:  ADDWFC x81,F
16F38:  ADDWFC x82,F
16F3A:  MOVLW  28
16F3C:  ADDWF  x7F,F
16F3E:  MOVLW  00
16F40:  ADDWFC x80,F
16F42:  ADDWFC x81,F
16F44:  ADDWFC x82,F
16F46:  MOVFF  C82,C98
16F4A:  MOVFF  C81,C97
16F4E:  MOVFF  C80,C96
16F52:  MOVFF  C7F,C95
16F56:  MOVLW  0C
16F58:  MOVWF  x9A
16F5A:  MOVLW  7A
16F5C:  MOVWF  x99
16F5E:  MOVLB  0
16F60:  CALL   704C
....................  
....................     return scheduled; 
16F64:  MOVLB  C
16F66:  MOVFF  C74,01
16F6A:  MOVLB  0
16F6C:  GOTO   18F68 (RETURN)
.................... } 
....................  
.................... uint32_t swap32(uint32_t k) 
.................... { 
....................     return ((k << 24) | ((k & 0x0000FF00) << 8) | ((k & 0x00FF0000) >> 8) | (k >> 24)); 
*
138FC:  MOVFF  C86,C8E
13900:  MOVLB  C
13902:  CLRF   x8B
13904:  CLRF   x8C
13906:  CLRF   x8D
13908:  CLRF   x8F
1390A:  MOVFF  C87,C90
1390E:  CLRF   x91
13910:  CLRF   x92
13912:  MOVFF  C91,03
13916:  MOVFF  C87,02
1391A:  MOVFF  C8F,01
1391E:  CLRF   00
13920:  MOVF   00,W
13922:  IORWF  x8B,F
13924:  MOVF   x8F,W
13926:  IORWF  x8C,F
13928:  MOVF   x87,W
1392A:  IORWF  x8D,F
1392C:  MOVF   x91,W
1392E:  IORWF  x8E,F
13930:  CLRF   x8F
13932:  CLRF   x90
13934:  CLRF   x92
13936:  MOVFF  C90,00
1393A:  MOVFF  C88,01
1393E:  MOVFF  C92,02
13942:  CLRF   03
13944:  MOVF   x90,W
13946:  IORWF  x8B,F
13948:  MOVF   x88,W
1394A:  IORWF  x8C,F
1394C:  MOVF   x92,W
1394E:  IORWF  x8D,F
13950:  MOVF   03,W
13952:  IORWF  x8E,F
13954:  MOVFF  C89,00
13958:  CLRF   01
1395A:  CLRF   02
1395C:  CLRF   03
1395E:  MOVF   x89,W
13960:  IORWF  x8B,W
13962:  MOVWF  00
13964:  MOVF   01,W
13966:  IORWF  x8C,W
13968:  MOVWF  01
1396A:  MOVF   02,W
1396C:  IORWF  x8D,W
1396E:  MOVWF  02
13970:  MOVF   03,W
13972:  IORWF  x8E,W
13974:  MOVWF  03
13976:  MOVLB  0
13978:  GOTO   13B74 (RETURN)
.................... } 
....................  
.................... // Ask OPERA to copy data to mission shared FM, then copy data to COM shared FM 
.................... uint8_t command_copy_opera_to_com(uint8_t* data) 
1397C:  MOVFF  C39,C3B
13980:  MOVFF  C38,C3A
*
139BE:  MOVLW  0C
139C0:  MOVWF  x81
139C2:  MOVLW  3C
139C4:  MOVFF  C81,C59
139C8:  MOVWF  x58
*
139CC:  MOVFF  3E,C5E
139D0:  MOVFF  3D,C5D
139D4:  MOVFF  3C,C5C
139D8:  MOVFF  3B,C5B
.................... { 
....................     enum { 
....................         packet_lenght = 10, 
....................         packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xEB 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t mission_number; 
....................         uint32_t address; 
....................         uint8_t n_pages; 
....................         uint8_t state; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t cpacket[MSG_LENGTH_OPERA] = { 0 }; 
*
13984:  MOVLB  C
13986:  CLRF   x3C
13988:  CLRF   x3D
1398A:  CLRF   x3E
1398C:  CLRF   x3F
1398E:  CLRF   x40
13990:  CLRF   x41
13992:  CLRF   x42
13994:  CLRF   x43
13996:  CLRF   x44
13998:  CLRF   x45
1399A:  CLRF   x46
1399C:  CLRF   x47
1399E:  CLRF   x48
139A0:  CLRF   x49
139A2:  CLRF   x4A
139A4:  CLRF   x4B
139A6:  CLRF   x4C
139A8:  CLRF   x4D
139AA:  CLRF   x4E
139AC:  CLRF   x4F
139AE:  CLRF   x50
139B0:  CLRF   x51
139B2:  CLRF   x52
139B4:  CLRF   x53
139B6:  CLRF   x54
139B8:  CLRF   x55
139BA:  CLRF   x56
139BC:  CLRF   x57
....................  
....................     struct copy_packet { 
....................         uint8_t origin;  // 0x2A 
....................         uint8_t command; // 0x2C 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t mission_number; 
....................         uint32_t address; 
....................         uint8_t n_pages; 
....................     }* copy_packet = (struct copy_packet*)cpacket; 
....................  
....................     uint8_t ack[1] = { 0 }; 
*
139CA:  CLRF   x5A
....................     time_t scheduled_time = current_time; 
....................     fprintf(PC, "OPERA copy command: "); 
*
139DC:  MOVLW  5C
139DE:  MOVWF  FF6
139E0:  MOVLW  17
139E2:  MOVWF  FF7
139E4:  MOVLW  00
139E6:  MOVWF  FF8
139E8:  MOVLB  0
139EA:  CALL   4534
....................     uint8_t state = packet->state; 
....................  
....................     time_t opera_copy_delay = 17L * packet->n_pages; 
....................  
....................     enum state_machine { 
....................         state_turn_on = 0, 
....................         state_copy_opera_mission = 1, 
....................         state_turn_off_opera = 2, 
....................         state_copy_mission_com = 3 
....................     }; 
....................  
....................     uint8_t opera_off[packet_size] = { 0xC0, 0xFF, 0xFF }; 
139EE:  MOVLW  0A
139F0:  MOVLB  C
139F2:  ADDWF  x3A,W
139F4:  MOVWF  FE9
139F6:  MOVLW  00
139F8:  ADDWFC x3B,W
139FA:  MOVWF  FEA
139FC:  MOVFF  FEF,C5F
13A00:  MOVLW  09
13A02:  ADDWF  x3A,W
13A04:  MOVWF  FE9
13A06:  MOVLW  00
13A08:  ADDWFC x3B,W
13A0A:  MOVWF  FEA
13A0C:  MOVFF  FEF,CC5
13A10:  CLRF   xC4
13A12:  MOVLW  11
13A14:  MOVWF  xC3
13A16:  CLRF   xC6
13A18:  MOVLB  0
13A1A:  CALL   4D06
13A1E:  MOVFF  02,03
13A22:  MOVFF  01,C60
13A26:  MOVFF  02,C61
13A2A:  CLRF   02
13A2C:  CLRF   03
13A2E:  MOVFF  03,C63
13A32:  MOVFF  02,C62
13A36:  MOVLW  C0
13A38:  MOVLB  C
13A3A:  MOVWF  x64
13A3C:  SETF   x65
13A3E:  SETF   x66
13A40:  CLRF   x67
13A42:  CLRF   x68
13A44:  CLRF   x69
13A46:  CLRF   x6A
13A48:  CLRF   x6B
13A4A:  CLRF   x6C
13A4C:  CLRF   x6D
13A4E:  CLRF   x6E
13A50:  CLRF   x6F
13A52:  CLRF   x70
13A54:  CLRF   x71
13A56:  CLRF   x72
13A58:  CLRF   x73
13A5A:  CLRF   x74
13A5C:  CLRF   x75
13A5E:  CLRF   x76
13A60:  CLRF   x77
13A62:  CLRF   x78
13A64:  CLRF   x79
13A66:  CLRF   x7A
13A68:  CLRF   x7B
13A6A:  CLRF   x7C
13A6C:  CLRF   x7D
13A6E:  CLRF   x7E
13A70:  CLRF   x7F
....................  
....................     switch (state) { 
13A72:  MOVF   x5F,W
13A74:  XORLW  00
13A76:  MOVLB  0
13A78:  BZ    13A8C
13A7A:  XORLW  01
13A7C:  BZ    13AF8
13A7E:  XORLW  03
13A80:  BTFSC  FD8.2
13A82:  BRA    13C8C
13A84:  XORLW  01
13A86:  BTFSC  FD8.2
13A88:  BRA    13D02
13A8A:  BRA    13D8E
....................     case state_turn_on: 
....................         fprintf(PC, "Turning on OPERA..."); 
13A8C:  MOVLW  72
13A8E:  MOVWF  FF6
13A90:  MOVLW  17
13A92:  MOVWF  FF7
13A94:  MOVLW  00
13A96:  MOVWF  FF8
13A98:  CALL   4534
....................         send_mcp_command(mcp_cmd_opera_on, 0, true); 
13A9C:  MOVLW  20
13A9E:  MOVLB  C
13AA0:  MOVWF  x80
13AA2:  CLRF   x82
13AA4:  CLRF   x81
13AA6:  MOVLW  01
13AA8:  MOVWF  x83
13AAA:  MOVLB  0
13AAC:  CALL   BAD6
....................         scheduled_time += obc_flags.opera_boot_duration; 
13AB0:  MOVLB  1
13AB2:  MOVF   x0A,W
13AB4:  MOVLB  C
13AB6:  ADDWF  x5B,F
13AB8:  MOVLW  00
13ABA:  ADDWFC x5C,F
13ABC:  ADDWFC x5D,F
13ABE:  ADDWFC x5E,F
....................         packet->state = state_copy_opera_mission; 
13AC0:  MOVLW  0A
13AC2:  ADDWF  x3A,W
13AC4:  MOVWF  FE9
13AC6:  MOVLW  00
13AC8:  ADDWFC x3B,W
13ACA:  MOVWF  FEA
13ACC:  MOVLW  01
13ACE:  MOVWF  FEF
....................         vschedule(scheduled_time, data); 
13AD0:  MOVFF  C5E,C98
13AD4:  MOVFF  C5D,C97
13AD8:  MOVFF  C5C,C96
13ADC:  MOVFF  C5B,C95
13AE0:  MOVFF  C39,C9A
13AE4:  MOVFF  C38,C99
13AE8:  MOVLB  0
13AEA:  CALL   704C
....................         return state; 
13AEE:  MOVLB  C
13AF0:  MOVFF  C5F,01
13AF4:  BRA    13DAA
13AF6:  MOVLB  0
....................     case state_copy_opera_mission: 
....................         fprintf(PC, "Copying data from OPERA to Mission SFM..."); 
13AF8:  MOVLW  86
13AFA:  MOVWF  FF6
13AFC:  MOVLW  17
13AFE:  MOVWF  FF7
13B00:  MOVLW  00
13B02:  MOVWF  FF8
13B04:  CALL   4534
....................         memcpy(cpacket, data, packet_lenght); 
13B08:  MOVLW  0C
13B0A:  MOVWF  FEA
13B0C:  MOVLW  3C
13B0E:  MOVWF  FE9
13B10:  MOVFF  C39,FE2
13B14:  MOVFF  C38,FE1
13B18:  MOVLW  0A
13B1A:  MOVWF  01
13B1C:  MOVFF  FE6,FEE
13B20:  DECFSZ 01,F
13B22:  BRA    13B1C
....................         copy_packet->origin = 0x2A; 
13B24:  MOVLB  C
13B26:  MOVFF  C58,FE9
13B2A:  MOVFF  C59,FEA
13B2E:  MOVLW  2A
13B30:  MOVWF  FEF
....................         copy_packet->command = 0x2C; 
13B32:  MOVLW  01
13B34:  ADDWF  x58,W
13B36:  MOVWF  FE9
13B38:  MOVLW  00
13B3A:  ADDWFC x59,W
13B3C:  MOVWF  FEA
13B3E:  MOVLW  2C
13B40:  MOVWF  FEF
....................         copy_packet->address = swap32(packet->address); // Convert from little endian to big endian 
13B42:  MOVLW  05
13B44:  ADDWF  x58,W
13B46:  MOVWF  01
13B48:  MOVLW  00
13B4A:  ADDWFC x59,W
13B4C:  MOVWF  03
13B4E:  MOVFF  01,C80
13B52:  MOVWF  x81
13B54:  MOVLW  05
13B56:  ADDWF  x3A,W
13B58:  MOVWF  FE9
13B5A:  MOVLW  00
13B5C:  ADDWFC x3B,W
13B5E:  MOVWF  FEA
13B60:  MOVFF  FEF,C86
13B64:  MOVFF  FEC,C87
13B68:  MOVFF  FEC,C88
13B6C:  MOVFF  FEC,C89
13B70:  MOVLB  0
13B72:  BRA    138FC
13B74:  MOVFF  C81,FEA
13B78:  MOVFF  C80,FE9
13B7C:  MOVFF  00,FEF
13B80:  MOVFF  01,FEC
13B84:  MOVFF  02,FEC
13B88:  MOVFF  03,FEC
....................         cpacket[sizeof(cpacket) - 1] = 0x80;            // Footer 
13B8C:  MOVLW  80
13B8E:  MOVLB  C
13B90:  MOVWF  x57
....................         if (mux_sel(mux_opera) == mux_opera) {          // Try to change mission shared FM mux position to OPERA 
13B92:  MOVLW  04
13B94:  MOVWF  xBE
13B96:  MOVLB  0
13B98:  CALL   52E8
13B9C:  MOVF   01,W
13B9E:  SUBLW  04
13BA0:  BNZ   13BC0
....................             mux_lock_unlock(true, opera_copy_delay);    // Get exclusive access for some time 
13BA2:  MOVLW  01
13BA4:  MOVLB  C
13BA6:  MOVWF  x82
13BA8:  MOVFF  C63,C86
13BAC:  MOVFF  C62,C85
13BB0:  MOVFF  C61,C84
13BB4:  MOVFF  C60,C83
13BB8:  MOVLB  0
13BBA:  CALL   7EB4
....................         } else { 
13BBE:  BRA    13BD8
....................             fprintf(PC, "Error: mux did not change!"); 
13BC0:  MOVLW  B0
13BC2:  MOVWF  FF6
13BC4:  MOVLW  17
13BC6:  MOVWF  FF7
13BC8:  MOVLW  00
13BCA:  MOVWF  FF8
13BCC:  CALL   4534
....................             ack[0] = 0xDE; 
13BD0:  MOVLW  DE
13BD2:  MOVLB  C
13BD4:  MOVWF  x5A
13BD6:  MOVLB  0
....................         } 
....................         delay_ms(100); 
13BD8:  MOVLW  64
13BDA:  MOVLB  D
13BDC:  MOVWF  x52
13BDE:  MOVLB  0
13BE0:  CALL   5266
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_OPERA, 1, 100); // Send 1 times with 100ms delay 
13BE4:  MOVLW  0A
13BE6:  MOVLB  C
13BE8:  MOVWF  xAF
13BEA:  MOVLW  97
13BEC:  MOVWF  xAE
13BEE:  MOVLW  0C
13BF0:  MOVWF  xB1
13BF2:  MOVLW  3C
13BF4:  MOVWF  xB0
13BF6:  CLRF   xB5
13BF8:  CLRF   xB4
13BFA:  CLRF   xB3
13BFC:  MOVLW  1C
13BFE:  MOVWF  xB2
13C00:  MOVLW  01
13C02:  MOVWF  xB6
13C04:  CLRF   xBA
13C06:  CLRF   xB9
13C08:  CLRF   xB8
13C0A:  MOVLW  64
13C0C:  MOVWF  xB7
13C0E:  MOVLB  0
13C10:  CALL   8F3C
....................         uart_download_packet(&uart_port_MSN, ack, sizeof(ack), 100000);             // Try to get a response 
13C14:  MOVLW  0A
13C16:  MOVLB  D
13C18:  MOVWF  x45
13C1A:  MOVLW  97
13C1C:  MOVWF  x44
13C1E:  MOVLW  0C
13C20:  MOVWF  x47
13C22:  MOVLW  5A
13C24:  MOVWF  x46
13C26:  CLRF   x4B
13C28:  CLRF   x4A
13C2A:  CLRF   x49
13C2C:  MOVLW  01
13C2E:  MOVWF  x48
13C30:  CLRF   x4F
13C32:  MOVWF  x4E
13C34:  MOVLW  86
13C36:  MOVWF  x4D
13C38:  MOVLW  A0
13C3A:  MOVWF  x4C
13C3C:  MOVLB  0
13C3E:  CALL   97CE
....................         scheduled_time += opera_copy_delay;                                         // OPERA copy time 
13C42:  MOVLB  C
13C44:  MOVF   x60,W
13C46:  ADDWF  x5B,F
13C48:  MOVF   x61,W
13C4A:  ADDWFC x5C,F
13C4C:  MOVF   x62,W
13C4E:  ADDWFC x5D,F
13C50:  MOVF   x63,W
13C52:  ADDWFC x5E,F
....................         packet->state = state_turn_off_opera; 
13C54:  MOVLW  0A
13C56:  ADDWF  x3A,W
13C58:  MOVWF  FE9
13C5A:  MOVLW  00
13C5C:  ADDWFC x3B,W
13C5E:  MOVWF  FEA
13C60:  MOVLW  02
13C62:  MOVWF  FEF
....................         vschedule(scheduled_time, data); 
13C64:  MOVFF  C5E,C98
13C68:  MOVFF  C5D,C97
13C6C:  MOVFF  C5C,C96
13C70:  MOVFF  C5B,C95
13C74:  MOVFF  C39,C9A
13C78:  MOVFF  C38,C99
13C7C:  MOVLB  0
13C7E:  CALL   704C
....................         return ack[0]; 
13C82:  MOVLB  C
13C84:  MOVFF  C5A,01
13C88:  BRA    13DAA
13C8A:  MOVLB  0
....................     case state_turn_off_opera: 
....................         fprintf(PC, "Sending OPERA turn off command...\r\n"); 
13C8C:  MOVLW  CC
13C8E:  MOVWF  FF6
13C90:  MOVLW  17
13C92:  MOVWF  FF7
13C94:  MOVLW  00
13C96:  MOVWF  FF8
13C98:  CALL   4534
....................         vschedule(current_time, opera_off); 
13C9C:  MOVFF  3E,C98
13CA0:  MOVFF  3D,C97
13CA4:  MOVFF  3C,C96
13CA8:  MOVFF  3B,C95
13CAC:  MOVLW  0C
13CAE:  MOVLB  C
13CB0:  MOVWF  x9A
13CB2:  MOVLW  64
13CB4:  MOVWF  x99
13CB6:  MOVLB  0
13CB8:  CALL   704C
....................         scheduled_time += 40; 
13CBC:  MOVLW  28
13CBE:  MOVLB  C
13CC0:  ADDWF  x5B,F
13CC2:  MOVLW  00
13CC4:  ADDWFC x5C,F
13CC6:  ADDWFC x5D,F
13CC8:  ADDWFC x5E,F
....................         packet->state = state_copy_mission_com; 
13CCA:  MOVLW  0A
13CCC:  ADDWF  x3A,W
13CCE:  MOVWF  FE9
13CD0:  MOVLW  00
13CD2:  ADDWFC x3B,W
13CD4:  MOVWF  FEA
13CD6:  MOVLW  03
13CD8:  MOVWF  FEF
....................         vschedule(scheduled_time, data); 
13CDA:  MOVFF  C5E,C98
13CDE:  MOVFF  C5D,C97
13CE2:  MOVFF  C5C,C96
13CE6:  MOVFF  C5B,C95
13CEA:  MOVFF  C39,C9A
13CEE:  MOVFF  C38,C99
13CF2:  MOVLB  0
13CF4:  CALL   704C
....................         return state; 
13CF8:  MOVLB  C
13CFA:  MOVFF  C5F,01
13CFE:  BRA    13DAA
13D00:  MOVLB  0
....................     case state_copy_mission_com: 
....................         fprintf(PC, "Turning off OPERA and copying data from Mission SFM to COM SFM..."); 
13D02:  MOVLW  F0
13D04:  MOVWF  FF6
13D06:  MOVLW  17
13D08:  MOVWF  FF7
13D0A:  MOVLW  00
13D0C:  MOVWF  FF8
13D0E:  CALL   4534
....................         send_mcp_command(mcp_cmd_opera_off, 0, true); 
13D12:  MOVLW  2F
13D14:  MOVLB  C
13D16:  MOVWF  x80
13D18:  CLRF   x82
13D1A:  CLRF   x81
13D1C:  MOVLW  01
13D1E:  MOVWF  x83
13D20:  MOVLB  0
13D22:  CALL   BAD6
....................         copy(2, 0, packet->address, packet->address, packet->n_pages, 2); // Copy from mission shared FM (2) to com shared FM (0), in byte address mode (2) 
13D26:  MOVLW  05
13D28:  MOVLB  C
13D2A:  ADDWF  x3A,W
13D2C:  MOVWF  FE9
13D2E:  MOVLW  00
13D30:  ADDWFC x3B,W
13D32:  MOVWF  FEA
13D34:  MOVFF  FEF,C8B
13D38:  MOVFF  FEC,C8C
13D3C:  MOVFF  FEC,C8D
13D40:  MOVFF  FEC,C8E
13D44:  MOVLW  05
13D46:  ADDWF  x3A,W
13D48:  MOVWF  FE9
13D4A:  MOVLW  00
13D4C:  ADDWFC x3B,W
13D4E:  MOVWF  FEA
13D50:  MOVFF  FEF,C8F
13D54:  MOVFF  FEC,C90
13D58:  MOVFF  FEC,C91
13D5C:  MOVFF  FEC,C92
13D60:  MOVLW  09
13D62:  ADDWF  x3A,W
13D64:  MOVWF  FE9
13D66:  MOVLW  00
13D68:  ADDWFC x3B,W
13D6A:  MOVWF  FEA
13D6C:  MOVFF  FEF,C93
13D70:  MOVLW  02
13D72:  MOVWF  x89
13D74:  CLRF   x8A
13D76:  CLRF   x96
13D78:  CLRF   x95
13D7A:  CLRF   x94
13D7C:  MOVWF  x97
13D7E:  MOVLB  0
13D80:  CALL   AB50
....................         return state; 
13D84:  MOVLB  C
13D86:  MOVFF  C5F,01
13D8A:  BRA    13DAA
13D8C:  MOVLB  0
....................     default: 
....................         fprintf(PC, "Invalid state!"); 
13D8E:  MOVLW  32
13D90:  MOVWF  FF6
13D92:  MOVLW  18
13D94:  MOVWF  FF7
13D96:  MOVLW  00
13D98:  MOVWF  FF8
13D9A:  CALL   4534
....................         return state; 
13D9E:  MOVLB  C
13DA0:  MOVFF  C5F,01
13DA4:  BRA    13DAA
....................     } 
....................     return 0; 
13DA6:  MOVLW  00
13DA8:  MOVWF  01
13DAA:  MOVLB  0
13DAC:  GOTO   18E7E (RETURN)
.................... } 
....................  
.................... // Ask subsystem to copy data to mission shared FM, then copy data to COM shared FM 
.................... uint8_t command_copy_mission_to_com(uint8_t* data) 
*
12D3A:  MOVFF  C39,C3B
12D3E:  MOVFF  C38,C3A
*
12DC4:  MOVLW  0C
12DC6:  MOVWF  x7F
12DC8:  MOVLW  3C
12DCA:  MOVFF  C7F,C7D
12DCE:  MOVWF  x7C
.................... { 
....................     enum { 
....................         adcs_copy_delay = 54,  // seconds for one sector copy 
....................         pcib_copy_delay = 6,   // seconds for one sector copy 
....................         tmcr1_copy_delay = 54, // seconds for one sector copy 
....................         tmcr2_copy_delay = 54, // seconds for one sector copy 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xEA 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t size;       // in sectors 
....................         uint8_t data_source; // 0: OBC 
....................     }* packet = (struct packet*)data; 
....................  
....................     enum { 
....................         dsource_obc = 0, 
....................         dsource_adcs = 1, 
....................         dsource_relay = 2, 
....................         dsource_tmcr_n = 3, 
....................         dsource_tmcr_b4 = 4 
....................         // OPERA has a separate command 
....................     }; 
....................  
....................     uint8_t cpacket[MAX_LENGTH] = { 0 }; 
*
12D42:  MOVLB  C
12D44:  CLRF   x3C
12D46:  CLRF   x3D
12D48:  CLRF   x3E
12D4A:  CLRF   x3F
12D4C:  CLRF   x40
12D4E:  CLRF   x41
12D50:  CLRF   x42
12D52:  CLRF   x43
12D54:  CLRF   x44
12D56:  CLRF   x45
12D58:  CLRF   x46
12D5A:  CLRF   x47
12D5C:  CLRF   x48
12D5E:  CLRF   x49
12D60:  CLRF   x4A
12D62:  CLRF   x4B
12D64:  CLRF   x4C
12D66:  CLRF   x4D
12D68:  CLRF   x4E
12D6A:  CLRF   x4F
12D6C:  CLRF   x50
12D6E:  CLRF   x51
12D70:  CLRF   x52
12D72:  CLRF   x53
12D74:  CLRF   x54
12D76:  CLRF   x55
12D78:  CLRF   x56
12D7A:  CLRF   x57
12D7C:  CLRF   x58
12D7E:  CLRF   x59
12D80:  CLRF   x5A
12D82:  CLRF   x5B
12D84:  CLRF   x5C
12D86:  CLRF   x5D
12D88:  CLRF   x5E
12D8A:  CLRF   x5F
12D8C:  CLRF   x60
12D8E:  CLRF   x61
12D90:  CLRF   x62
12D92:  CLRF   x63
12D94:  CLRF   x64
12D96:  CLRF   x65
12D98:  CLRF   x66
12D9A:  CLRF   x67
12D9C:  CLRF   x68
12D9E:  CLRF   x69
12DA0:  CLRF   x6A
12DA2:  CLRF   x6B
12DA4:  CLRF   x6C
12DA6:  CLRF   x6D
12DA8:  CLRF   x6E
12DAA:  CLRF   x6F
12DAC:  CLRF   x70
12DAE:  CLRF   x71
12DB0:  CLRF   x72
12DB2:  CLRF   x73
12DB4:  CLRF   x74
12DB6:  CLRF   x75
12DB8:  CLRF   x76
12DBA:  CLRF   x77
12DBC:  CLRF   x78
12DBE:  CLRF   x79
12DC0:  CLRF   x7A
12DC2:  CLRF   x7B
....................  
....................     struct copy_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t size; 
....................         uint8_t data_destination; 
....................         uint8_t data_source; 
....................     }* copy_packet = (struct copy_packet*)cpacket; 
....................  
....................     switch (packet->data_source) { 
*
12DD0:  MOVLW  08
12DD2:  ADDWF  x3A,W
12DD4:  MOVWF  FE9
12DD6:  MOVLW  00
12DD8:  ADDWFC x3B,W
12DDA:  MOVWF  FEA
12DDC:  MOVF   FEF,W
12DDE:  XORLW  00
12DE0:  MOVLB  0
12DE2:  BZ    12E00
12DE4:  XORLW  01
12DE6:  BZ    12E64
12DE8:  XORLW  03
12DEA:  BTFSC  FD8.2
12DEC:  BRA    1310A
12DEE:  XORLW  06
12DF0:  BTFSC  FD8.2
12DF2:  BRA    133AC
12DF4:  XORLW  07
12DF6:  BTFSC  FD8.2
12DF8:  GOTO   1364C
12DFC:  GOTO   138EE
....................     case dsource_obc: 
....................         copy(2, 0, packet->destination_sector, packet->source_sector, packet->size, 1); // Source and destination: 0=COM, 1=MAIN, 2=MISSION ; mode = 1 -> sector copy; get access to memory 
12E00:  MOVLW  02
12E02:  MOVLB  C
12E04:  ADDWF  x3A,W
12E06:  MOVWF  FE9
12E08:  MOVLW  00
12E0A:  ADDWFC x3B,W
12E0C:  MOVWF  FEA
12E0E:  MOVFF  FEC,C8C
12E12:  MOVF   FED,F
12E14:  MOVFF  FEF,C8B
12E18:  MOVLW  04
12E1A:  ADDWF  x3A,W
12E1C:  MOVWF  FE9
12E1E:  MOVLW  00
12E20:  ADDWFC x3B,W
12E22:  MOVWF  FEA
12E24:  MOVFF  FEC,C90
12E28:  MOVF   FED,F
12E2A:  MOVFF  FEF,C8F
12E2E:  MOVLW  06
12E30:  ADDWF  x3A,W
12E32:  MOVWF  FE9
12E34:  MOVLW  00
12E36:  ADDWFC x3B,W
12E38:  MOVWF  FEA
12E3A:  MOVFF  FEC,C94
12E3E:  MOVF   FED,F
12E40:  MOVFF  FEF,C93
12E44:  MOVLW  02
12E46:  MOVWF  x89
12E48:  CLRF   x8A
12E4A:  CLRF   x8E
12E4C:  CLRF   x8D
12E4E:  CLRF   x92
12E50:  CLRF   x91
12E52:  CLRF   x96
12E54:  CLRF   x95
12E56:  MOVLW  01
12E58:  MOVWF  x97
12E5A:  MOVLB  0
12E5C:  CALL   AB50
....................         break; 
12E60:  GOTO   138F4
....................     case dsource_adcs: 
....................         fprintf(PC, "Waiting for ADCS copy..."); 
12E64:  MOVLW  42
12E66:  MOVWF  FF6
12E68:  MOVLW  18
12E6A:  MOVWF  FF7
12E6C:  MOVLW  00
12E6E:  MOVWF  FF8
12E70:  CALL   4534
....................         if (mux_sel(mux_adcs) == mux_adcs) {                                 // Try to change mission shared FM mux position to ADCS 
12E74:  MOVLW  02
12E76:  MOVLB  C
12E78:  MOVWF  xBE
12E7A:  MOVLB  0
12E7C:  CALL   52E8
12E80:  MOVF   01,W
12E82:  SUBLW  02
12E84:  BNZ   12EF8
....................             mux_lock_unlock(true, ((time_t)adcs_copy_delay) * packet->size); // Get exclusive access for some time 
12E86:  MOVLW  06
12E88:  MOVLB  C
12E8A:  ADDWF  x3A,W
12E8C:  MOVWF  FE9
12E8E:  MOVLW  00
12E90:  ADDWFC x3B,W
12E92:  MOVWF  FEA
12E94:  MOVFF  FEC,03
12E98:  MOVF   FED,F
12E9A:  MOVFF  FEF,CB5
12E9E:  MOVFF  03,C7F
12EA2:  MOVFF  FEA,C81
12EA6:  MOVFF  FE9,C80
12EAA:  CLRF   xB4
12EAC:  CLRF   xB3
12EAE:  CLRF   xB2
12EB0:  MOVLW  36
12EB2:  MOVWF  xB1
12EB4:  CLRF   xB8
12EB6:  CLRF   xB7
12EB8:  MOVFF  03,CB6
12EBC:  MOVLB  0
12EBE:  CALL   456E
12EC2:  MOVFF  C81,FEA
12EC6:  MOVFF  C80,FE9
12ECA:  MOVFF  03,C81
12ECE:  MOVFF  02,C80
12ED2:  MOVFF  01,C7F
12ED6:  MOVFF  00,C7E
12EDA:  MOVLW  01
12EDC:  MOVLB  C
12EDE:  MOVWF  x82
12EE0:  MOVFF  03,C86
12EE4:  MOVFF  02,C85
12EE8:  MOVFF  01,C84
12EEC:  MOVFF  00,C83
12EF0:  MOVLB  0
12EF2:  CALL   7EB4
....................         } else { 
12EF6:  BRA    12F00
....................             return 2; // Mux did not change 
12EF8:  MOVLW  02
12EFA:  MOVWF  01
12EFC:  GOTO   138F8
....................         } 
....................         delay_ms(100); 
12F00:  MOVLW  64
12F02:  MOVLB  D
12F04:  MOVWF  x52
12F06:  MOVLB  0
12F08:  CALL   5266
....................         copy_packet->origin = MSG_OBC; 
12F0C:  MOVLB  C
12F0E:  MOVFF  C7C,FE9
12F12:  MOVFF  C7D,FEA
12F16:  MOVLW  0B
12F18:  MOVWF  FEF
....................         copy_packet->command = 0xCB; // Copy sectors command on ADCS pic 
12F1A:  MOVLW  01
12F1C:  ADDWF  x7C,W
12F1E:  MOVWF  FE9
12F20:  MOVLW  00
12F22:  ADDWFC x7D,W
12F24:  MOVWF  FEA
12F26:  MOVLW  CB
12F28:  MOVWF  FEF
....................         copy_packet->destination_sector = packet->destination_sector; 
12F2A:  MOVLW  02
12F2C:  ADDWF  x7C,W
12F2E:  MOVWF  01
12F30:  MOVLW  00
12F32:  ADDWFC x7D,W
12F34:  MOVWF  03
12F36:  MOVWF  x7F
12F38:  MOVLW  02
12F3A:  ADDWF  x3A,W
12F3C:  MOVWF  FE9
12F3E:  MOVLW  00
12F40:  ADDWFC x3B,W
12F42:  MOVWF  FEA
12F44:  MOVFF  FEC,03
12F48:  MOVF   FED,F
12F4A:  MOVFF  FEF,C80
12F4E:  MOVFF  C7F,FEA
12F52:  MOVFF  01,FE9
12F56:  MOVFF  03,FEC
12F5A:  MOVF   FED,F
12F5C:  MOVFF  C80,FEF
....................         copy_packet->source_sector = packet->source_sector; 
12F60:  MOVLW  04
12F62:  ADDWF  x7C,W
12F64:  MOVWF  01
12F66:  MOVLW  00
12F68:  ADDWFC x7D,W
12F6A:  MOVWF  03
12F6C:  MOVWF  x7F
12F6E:  MOVLW  04
12F70:  ADDWF  x3A,W
12F72:  MOVWF  FE9
12F74:  MOVLW  00
12F76:  ADDWFC x3B,W
12F78:  MOVWF  FEA
12F7A:  MOVFF  FEC,03
12F7E:  MOVF   FED,F
12F80:  MOVFF  FEF,C80
12F84:  MOVFF  C7F,FEA
12F88:  MOVFF  01,FE9
12F8C:  MOVFF  03,FEC
12F90:  MOVF   FED,F
12F92:  MOVFF  C80,FEF
....................         copy_packet->size = packet->size; 
12F96:  MOVLW  06
12F98:  ADDWF  x7C,W
12F9A:  MOVWF  01
12F9C:  MOVLW  00
12F9E:  ADDWFC x7D,W
12FA0:  MOVWF  03
12FA2:  MOVWF  x7F
12FA4:  MOVLW  06
12FA6:  ADDWF  x3A,W
12FA8:  MOVWF  FE9
12FAA:  MOVLW  00
12FAC:  ADDWFC x3B,W
12FAE:  MOVWF  FEA
12FB0:  MOVFF  FEC,03
12FB4:  MOVF   FED,F
12FB6:  MOVFF  FEF,C80
12FBA:  MOVFF  C7F,FEA
12FBE:  MOVFF  01,FE9
12FC2:  MOVFF  03,FEC
12FC6:  MOVF   FED,F
12FC8:  MOVFF  C80,FEF
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
12FCC:  MOVLW  08
12FCE:  ADDWF  x7C,W
12FD0:  MOVWF  FE9
12FD2:  MOVLW  00
12FD4:  ADDWFC x7D,W
12FD6:  MOVWF  FEA
12FD8:  MOVLW  01
12FDA:  MOVWF  FEF
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
12FDC:  MOVLW  09
12FDE:  ADDWF  x7C,W
12FE0:  MOVWF  FE9
12FE2:  MOVLW  00
12FE4:  ADDWFC x7D,W
12FE6:  MOVWF  FEA
12FE8:  CLRF   FEF
....................         checksum_obc(cpacket, MSG_LENGTH_ADCS); 
12FEA:  MOVLW  0C
12FEC:  MOVWF  xAF
12FEE:  MOVLW  3C
12FF0:  MOVWF  xAE
12FF2:  MOVLW  2C
12FF4:  MOVWF  xB0
12FF6:  MOVLB  0
12FF8:  CALL   8E80
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_ADCS, 5, 100); // Send 5 times with 100ms delay 
12FFC:  MOVLW  0A
12FFE:  MOVLB  C
13000:  MOVWF  xAF
13002:  MOVLW  97
13004:  MOVWF  xAE
13006:  MOVLW  0C
13008:  MOVWF  xB1
1300A:  MOVLW  3C
1300C:  MOVWF  xB0
1300E:  CLRF   xB5
13010:  CLRF   xB4
13012:  CLRF   xB3
13014:  MOVLW  2C
13016:  MOVWF  xB2
13018:  MOVLW  05
1301A:  MOVWF  xB6
1301C:  CLRF   xBA
1301E:  CLRF   xB9
13020:  CLRF   xB8
13022:  MOVLW  64
13024:  MOVWF  xB7
13026:  MOVLB  0
13028:  CALL   8F3C
....................         packet->data_source = 0; 
1302C:  MOVLW  08
1302E:  MOVLB  C
13030:  ADDWF  x3A,W
13032:  MOVWF  FE9
13034:  MOVLW  00
13036:  ADDWFC x3B,W
13038:  MOVWF  FEA
1303A:  CLRF   FEF
....................         packet->source_sector = packet->destination_sector; 
1303C:  MOVLW  04
1303E:  ADDWF  x3A,W
13040:  MOVWF  01
13042:  MOVLW  00
13044:  ADDWFC x3B,W
13046:  MOVWF  03
13048:  MOVWF  x7F
1304A:  MOVLW  02
1304C:  ADDWF  x3A,W
1304E:  MOVWF  FE9
13050:  MOVLW  00
13052:  ADDWFC x3B,W
13054:  MOVWF  FEA
13056:  MOVFF  FEC,03
1305A:  MOVF   FED,F
1305C:  MOVFF  FEF,C80
13060:  MOVFF  C7F,FEA
13064:  MOVFF  01,FE9
13068:  MOVFF  03,FEC
1306C:  MOVF   FED,F
1306E:  MOVFF  C80,FEF
....................         vschedule(current_time + (time_t)adcs_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
13072:  MOVLW  06
13074:  ADDWF  x3A,W
13076:  MOVWF  FE9
13078:  MOVLW  00
1307A:  ADDWFC x3B,W
1307C:  MOVWF  FEA
1307E:  MOVFF  FEC,03
13082:  MOVF   FED,F
13084:  MOVFF  FEF,00
13088:  MOVFF  03,01
1308C:  CLRF   02
1308E:  CLRF   03
13090:  MOVFF  03,C81
13094:  MOVFF  02,C80
13098:  MOVFF  01,C7F
1309C:  MOVFF  00,C7E
130A0:  MOVFF  FEA,C83
130A4:  MOVFF  FE9,C82
130A8:  CLRF   xB4
130AA:  CLRF   xB3
130AC:  CLRF   xB2
130AE:  MOVLW  36
130B0:  MOVWF  xB1
130B2:  MOVFF  03,CB8
130B6:  MOVFF  02,CB7
130BA:  MOVFF  01,CB6
130BE:  MOVFF  00,CB5
130C2:  MOVLB  0
130C4:  CALL   456E
130C8:  MOVFF  C83,FEA
130CC:  MOVFF  C82,FE9
130D0:  MOVF   00,W
130D2:  ADDWF  3B,W
130D4:  MOVLB  C
130D6:  MOVWF  x7E
130D8:  MOVF   01,W
130DA:  ADDWFC 3C,W
130DC:  MOVWF  x7F
130DE:  MOVF   02,W
130E0:  ADDWFC 3D,W
130E2:  MOVWF  x80
130E4:  MOVF   03,W
130E6:  ADDWFC 3E,W
130E8:  MOVWF  x81
130EA:  MOVWF  x98
130EC:  MOVFF  C80,C97
130F0:  MOVFF  C7F,C96
130F4:  MOVFF  C7E,C95
130F8:  MOVFF  C3B,C9A
130FC:  MOVFF  C3A,C99
13100:  MOVLB  0
13102:  CALL   704C
....................         break; 
13106:  GOTO   138F4
....................     case dsource_relay: 
....................         fprintf(PC, "Waiting for RELAY copy..."); 
1310A:  MOVLW  5C
1310C:  MOVWF  FF6
1310E:  MOVLW  18
13110:  MOVWF  FF7
13112:  MOVLW  00
13114:  MOVWF  FF8
13116:  CALL   4534
....................         if (mux_sel(mux_pcib) == mux_pcib) {                                 // Try to change mission shared FM mux position to PCIB 
1311A:  MOVLW  06
1311C:  MOVLB  C
1311E:  MOVWF  xBE
13120:  MOVLB  0
13122:  CALL   52E8
13126:  MOVF   01,W
13128:  SUBLW  06
1312A:  BNZ   1319E
....................             mux_lock_unlock(true, ((time_t)pcib_copy_delay) * packet->size); // Get exclusive access for some time 
1312C:  MOVLW  06
1312E:  MOVLB  C
13130:  ADDWF  x3A,W
13132:  MOVWF  FE9
13134:  MOVLW  00
13136:  ADDWFC x3B,W
13138:  MOVWF  FEA
1313A:  MOVFF  FEC,03
1313E:  MOVF   FED,F
13140:  MOVFF  FEF,CB5
13144:  MOVFF  03,C7F
13148:  MOVFF  FEA,C81
1314C:  MOVFF  FE9,C80
13150:  CLRF   xB4
13152:  CLRF   xB3
13154:  CLRF   xB2
13156:  MOVLW  06
13158:  MOVWF  xB1
1315A:  CLRF   xB8
1315C:  CLRF   xB7
1315E:  MOVFF  03,CB6
13162:  MOVLB  0
13164:  CALL   456E
13168:  MOVFF  C81,FEA
1316C:  MOVFF  C80,FE9
13170:  MOVFF  03,C81
13174:  MOVFF  02,C80
13178:  MOVFF  01,C7F
1317C:  MOVFF  00,C7E
13180:  MOVLW  01
13182:  MOVLB  C
13184:  MOVWF  x82
13186:  MOVFF  03,C86
1318A:  MOVFF  02,C85
1318E:  MOVFF  01,C84
13192:  MOVFF  00,C83
13196:  MOVLB  0
13198:  CALL   7EB4
....................         } else { 
1319C:  BRA    131A4
....................             return 2; // Mux did not change 
1319E:  MOVLW  02
131A0:  MOVWF  01
131A2:  BRA    138F8
....................         } 
....................         delay_ms(100); 
131A4:  MOVLW  64
131A6:  MOVLB  D
131A8:  MOVWF  x52
131AA:  MOVLB  0
131AC:  CALL   5266
....................         copy_packet->origin = MSG_OBC; 
131B0:  MOVLB  C
131B2:  MOVFF  C7C,FE9
131B6:  MOVFF  C7D,FEA
131BA:  MOVLW  0B
131BC:  MOVWF  FEF
....................         copy_packet->command = 0x0B; // Copy sectors command on RELAY PIC 
131BE:  MOVLW  01
131C0:  ADDWF  x7C,W
131C2:  MOVWF  FE9
131C4:  MOVLW  00
131C6:  ADDWFC x7D,W
131C8:  MOVWF  FEA
131CA:  MOVLW  0B
131CC:  MOVWF  FEF
....................         copy_packet->destination_sector = packet->destination_sector; 
131CE:  MOVLW  02
131D0:  ADDWF  x7C,W
131D2:  MOVWF  01
131D4:  MOVLW  00
131D6:  ADDWFC x7D,W
131D8:  MOVWF  03
131DA:  MOVWF  x7F
131DC:  MOVLW  02
131DE:  ADDWF  x3A,W
131E0:  MOVWF  FE9
131E2:  MOVLW  00
131E4:  ADDWFC x3B,W
131E6:  MOVWF  FEA
131E8:  MOVFF  FEC,03
131EC:  MOVF   FED,F
131EE:  MOVFF  FEF,C80
131F2:  MOVFF  C7F,FEA
131F6:  MOVFF  01,FE9
131FA:  MOVFF  03,FEC
131FE:  MOVF   FED,F
13200:  MOVFF  C80,FEF
....................         copy_packet->source_sector = packet->source_sector; 
13204:  MOVLW  04
13206:  ADDWF  x7C,W
13208:  MOVWF  01
1320A:  MOVLW  00
1320C:  ADDWFC x7D,W
1320E:  MOVWF  03
13210:  MOVWF  x7F
13212:  MOVLW  04
13214:  ADDWF  x3A,W
13216:  MOVWF  FE9
13218:  MOVLW  00
1321A:  ADDWFC x3B,W
1321C:  MOVWF  FEA
1321E:  MOVFF  FEC,03
13222:  MOVF   FED,F
13224:  MOVFF  FEF,C80
13228:  MOVFF  C7F,FEA
1322C:  MOVFF  01,FE9
13230:  MOVFF  03,FEC
13234:  MOVF   FED,F
13236:  MOVFF  C80,FEF
....................         copy_packet->size = packet->size; 
1323A:  MOVLW  06
1323C:  ADDWF  x7C,W
1323E:  MOVWF  01
13240:  MOVLW  00
13242:  ADDWFC x7D,W
13244:  MOVWF  03
13246:  MOVWF  x7F
13248:  MOVLW  06
1324A:  ADDWF  x3A,W
1324C:  MOVWF  FE9
1324E:  MOVLW  00
13250:  ADDWFC x3B,W
13252:  MOVWF  FEA
13254:  MOVFF  FEC,03
13258:  MOVF   FED,F
1325A:  MOVFF  FEF,C80
1325E:  MOVFF  C7F,FEA
13262:  MOVFF  01,FE9
13266:  MOVFF  03,FEC
1326A:  MOVF   FED,F
1326C:  MOVFF  C80,FEF
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
13270:  MOVLW  08
13272:  ADDWF  x7C,W
13274:  MOVWF  FE9
13276:  MOVLW  00
13278:  ADDWFC x7D,W
1327A:  MOVWF  FEA
1327C:  MOVLW  01
1327E:  MOVWF  FEF
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
13280:  MOVLW  09
13282:  ADDWF  x7C,W
13284:  MOVWF  FE9
13286:  MOVLW  00
13288:  ADDWFC x7D,W
1328A:  MOVWF  FEA
1328C:  CLRF   FEF
....................         checksum_obc(cpacket, MSG_LENGTH_PCIB); 
1328E:  MOVLW  0C
13290:  MOVWF  xAF
13292:  MOVLW  3C
13294:  MOVWF  xAE
13296:  MOVLW  24
13298:  MOVWF  xB0
1329A:  MOVLB  0
1329C:  CALL   8E80
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_PCIB, 1, 10); // Send 1 time 
132A0:  MOVLW  0A
132A2:  MOVLB  C
132A4:  MOVWF  xAF
132A6:  MOVLW  97
132A8:  MOVWF  xAE
132AA:  MOVLW  0C
132AC:  MOVWF  xB1
132AE:  MOVLW  3C
132B0:  MOVWF  xB0
132B2:  CLRF   xB5
132B4:  CLRF   xB4
132B6:  CLRF   xB3
132B8:  MOVLW  24
132BA:  MOVWF  xB2
132BC:  MOVLW  01
132BE:  MOVWF  xB6
132C0:  CLRF   xBA
132C2:  CLRF   xB9
132C4:  CLRF   xB8
132C6:  MOVLW  0A
132C8:  MOVWF  xB7
132CA:  MOVLB  0
132CC:  CALL   8F3C
....................         packet->data_source = 0; 
132D0:  MOVLW  08
132D2:  MOVLB  C
132D4:  ADDWF  x3A,W
132D6:  MOVWF  FE9
132D8:  MOVLW  00
132DA:  ADDWFC x3B,W
132DC:  MOVWF  FEA
132DE:  CLRF   FEF
....................         packet->source_sector = packet->destination_sector; 
132E0:  MOVLW  04
132E2:  ADDWF  x3A,W
132E4:  MOVWF  01
132E6:  MOVLW  00
132E8:  ADDWFC x3B,W
132EA:  MOVWF  03
132EC:  MOVWF  x7F
132EE:  MOVLW  02
132F0:  ADDWF  x3A,W
132F2:  MOVWF  FE9
132F4:  MOVLW  00
132F6:  ADDWFC x3B,W
132F8:  MOVWF  FEA
132FA:  MOVFF  FEC,03
132FE:  MOVF   FED,F
13300:  MOVFF  FEF,C80
13304:  MOVFF  C7F,FEA
13308:  MOVFF  01,FE9
1330C:  MOVFF  03,FEC
13310:  MOVF   FED,F
13312:  MOVFF  C80,FEF
....................         vschedule(current_time + (time_t)pcib_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
13316:  MOVLW  06
13318:  ADDWF  x3A,W
1331A:  MOVWF  FE9
1331C:  MOVLW  00
1331E:  ADDWFC x3B,W
13320:  MOVWF  FEA
13322:  MOVFF  FEC,03
13326:  MOVF   FED,F
13328:  MOVFF  FEF,00
1332C:  MOVFF  03,01
13330:  CLRF   02
13332:  CLRF   03
13334:  MOVFF  03,C81
13338:  MOVFF  02,C80
1333C:  MOVFF  01,C7F
13340:  MOVFF  00,C7E
13344:  MOVFF  FEA,C83
13348:  MOVFF  FE9,C82
1334C:  CLRF   xB4
1334E:  CLRF   xB3
13350:  CLRF   xB2
13352:  MOVLW  06
13354:  MOVWF  xB1
13356:  MOVFF  03,CB8
1335A:  MOVFF  02,CB7
1335E:  MOVFF  01,CB6
13362:  MOVFF  00,CB5
13366:  MOVLB  0
13368:  CALL   456E
1336C:  MOVFF  C83,FEA
13370:  MOVFF  C82,FE9
13374:  MOVF   00,W
13376:  ADDWF  3B,W
13378:  MOVLB  C
1337A:  MOVWF  x7E
1337C:  MOVF   01,W
1337E:  ADDWFC 3C,W
13380:  MOVWF  x7F
13382:  MOVF   02,W
13384:  ADDWFC 3D,W
13386:  MOVWF  x80
13388:  MOVF   03,W
1338A:  ADDWFC 3E,W
1338C:  MOVWF  x81
1338E:  MOVWF  x98
13390:  MOVFF  C80,C97
13394:  MOVFF  C7F,C96
13398:  MOVFF  C7E,C95
1339C:  MOVFF  C3B,C9A
133A0:  MOVFF  C3A,C99
133A4:  MOVLB  0
133A6:  CALL   704C
....................         break; 
133AA:  BRA    138F4
....................     case dsource_tmcr_b4: 
....................         fprintf(PC, "Waiting for TMCR B4 copy..."); 
133AC:  MOVLW  76
133AE:  MOVWF  FF6
133B0:  MOVLW  18
133B2:  MOVWF  FF7
133B4:  MOVLW  00
133B6:  MOVWF  FF8
133B8:  CALL   4534
....................         if (mux_sel(mux_tmcr1) == mux_tmcr1) {                                 // Try to change mission shared FM mux position to TMCR1 
133BC:  MOVLW  01
133BE:  MOVLB  C
133C0:  MOVWF  xBE
133C2:  MOVLB  0
133C4:  CALL   52E8
133C8:  DECFSZ 01,W
133CA:  BRA    1343E
....................             mux_lock_unlock(true, ((time_t)tmcr1_copy_delay) * packet->size); // Get exclusive access for some time 
133CC:  MOVLW  06
133CE:  MOVLB  C
133D0:  ADDWF  x3A,W
133D2:  MOVWF  FE9
133D4:  MOVLW  00
133D6:  ADDWFC x3B,W
133D8:  MOVWF  FEA
133DA:  MOVFF  FEC,03
133DE:  MOVF   FED,F
133E0:  MOVFF  FEF,CB5
133E4:  MOVFF  03,C7F
133E8:  MOVFF  FEA,C81
133EC:  MOVFF  FE9,C80
133F0:  CLRF   xB4
133F2:  CLRF   xB3
133F4:  CLRF   xB2
133F6:  MOVLW  36
133F8:  MOVWF  xB1
133FA:  CLRF   xB8
133FC:  CLRF   xB7
133FE:  MOVFF  03,CB6
13402:  MOVLB  0
13404:  CALL   456E
13408:  MOVFF  C81,FEA
1340C:  MOVFF  C80,FE9
13410:  MOVFF  03,C81
13414:  MOVFF  02,C80
13418:  MOVFF  01,C7F
1341C:  MOVFF  00,C7E
13420:  MOVLW  01
13422:  MOVLB  C
13424:  MOVWF  x82
13426:  MOVFF  03,C86
1342A:  MOVFF  02,C85
1342E:  MOVFF  01,C84
13432:  MOVFF  00,C83
13436:  MOVLB  0
13438:  CALL   7EB4
....................         } else { 
1343C:  BRA    13444
....................             return 2; // Mux did not change 
1343E:  MOVLW  02
13440:  MOVWF  01
13442:  BRA    138F8
....................         } 
....................         delay_ms(100); 
13444:  MOVLW  64
13446:  MOVLB  D
13448:  MOVWF  x52
1344A:  MOVLB  0
1344C:  CALL   5266
....................         copy_packet->origin = MSG_OBC; 
13450:  MOVLB  C
13452:  MOVFF  C7C,FE9
13456:  MOVFF  C7D,FEA
1345A:  MOVLW  0B
1345C:  MOVWF  FEF
....................         copy_packet->command = 0x0B; // Copy sectors command on RELAY PIC 
1345E:  MOVLW  01
13460:  ADDWF  x7C,W
13462:  MOVWF  FE9
13464:  MOVLW  00
13466:  ADDWFC x7D,W
13468:  MOVWF  FEA
1346A:  MOVLW  0B
1346C:  MOVWF  FEF
....................         copy_packet->destination_sector = packet->destination_sector; 
1346E:  MOVLW  02
13470:  ADDWF  x7C,W
13472:  MOVWF  01
13474:  MOVLW  00
13476:  ADDWFC x7D,W
13478:  MOVWF  03
1347A:  MOVWF  x7F
1347C:  MOVLW  02
1347E:  ADDWF  x3A,W
13480:  MOVWF  FE9
13482:  MOVLW  00
13484:  ADDWFC x3B,W
13486:  MOVWF  FEA
13488:  MOVFF  FEC,03
1348C:  MOVF   FED,F
1348E:  MOVFF  FEF,C80
13492:  MOVFF  C7F,FEA
13496:  MOVFF  01,FE9
1349A:  MOVFF  03,FEC
1349E:  MOVF   FED,F
134A0:  MOVFF  C80,FEF
....................         copy_packet->source_sector = packet->source_sector; 
134A4:  MOVLW  04
134A6:  ADDWF  x7C,W
134A8:  MOVWF  01
134AA:  MOVLW  00
134AC:  ADDWFC x7D,W
134AE:  MOVWF  03
134B0:  MOVWF  x7F
134B2:  MOVLW  04
134B4:  ADDWF  x3A,W
134B6:  MOVWF  FE9
134B8:  MOVLW  00
134BA:  ADDWFC x3B,W
134BC:  MOVWF  FEA
134BE:  MOVFF  FEC,03
134C2:  MOVF   FED,F
134C4:  MOVFF  FEF,C80
134C8:  MOVFF  C7F,FEA
134CC:  MOVFF  01,FE9
134D0:  MOVFF  03,FEC
134D4:  MOVF   FED,F
134D6:  MOVFF  C80,FEF
....................         copy_packet->size = packet->size; 
134DA:  MOVLW  06
134DC:  ADDWF  x7C,W
134DE:  MOVWF  01
134E0:  MOVLW  00
134E2:  ADDWFC x7D,W
134E4:  MOVWF  03
134E6:  MOVWF  x7F
134E8:  MOVLW  06
134EA:  ADDWF  x3A,W
134EC:  MOVWF  FE9
134EE:  MOVLW  00
134F0:  ADDWFC x3B,W
134F2:  MOVWF  FEA
134F4:  MOVFF  FEC,03
134F8:  MOVF   FED,F
134FA:  MOVFF  FEF,C80
134FE:  MOVFF  C7F,FEA
13502:  MOVFF  01,FE9
13506:  MOVFF  03,FEC
1350A:  MOVF   FED,F
1350C:  MOVFF  C80,FEF
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
13510:  MOVLW  08
13512:  ADDWF  x7C,W
13514:  MOVWF  FE9
13516:  MOVLW  00
13518:  ADDWFC x7D,W
1351A:  MOVWF  FEA
1351C:  MOVLW  01
1351E:  MOVWF  FEF
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
13520:  MOVLW  09
13522:  ADDWF  x7C,W
13524:  MOVWF  FE9
13526:  MOVLW  00
13528:  ADDWFC x7D,W
1352A:  MOVWF  FEA
1352C:  CLRF   FEF
....................         checksum_obc(cpacket, MSG_LENGTH_TMCR1); 
1352E:  MOVLW  0C
13530:  MOVWF  xAF
13532:  MOVLW  3C
13534:  MOVWF  xAE
13536:  MOVLW  24
13538:  MOVWF  xB0
1353A:  MOVLB  0
1353C:  CALL   8E80
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_TMCR1, 1, 10); // Send 1 time 
13540:  MOVLW  0A
13542:  MOVLB  C
13544:  MOVWF  xAF
13546:  MOVLW  97
13548:  MOVWF  xAE
1354A:  MOVLW  0C
1354C:  MOVWF  xB1
1354E:  MOVLW  3C
13550:  MOVWF  xB0
13552:  CLRF   xB5
13554:  CLRF   xB4
13556:  CLRF   xB3
13558:  MOVLW  24
1355A:  MOVWF  xB2
1355C:  MOVLW  01
1355E:  MOVWF  xB6
13560:  CLRF   xBA
13562:  CLRF   xB9
13564:  CLRF   xB8
13566:  MOVLW  0A
13568:  MOVWF  xB7
1356A:  MOVLB  0
1356C:  CALL   8F3C
....................         packet->data_source = 0; 
13570:  MOVLW  08
13572:  MOVLB  C
13574:  ADDWF  x3A,W
13576:  MOVWF  FE9
13578:  MOVLW  00
1357A:  ADDWFC x3B,W
1357C:  MOVWF  FEA
1357E:  CLRF   FEF
....................         packet->source_sector = packet->destination_sector; 
13580:  MOVLW  04
13582:  ADDWF  x3A,W
13584:  MOVWF  01
13586:  MOVLW  00
13588:  ADDWFC x3B,W
1358A:  MOVWF  03
1358C:  MOVWF  x7F
1358E:  MOVLW  02
13590:  ADDWF  x3A,W
13592:  MOVWF  FE9
13594:  MOVLW  00
13596:  ADDWFC x3B,W
13598:  MOVWF  FEA
1359A:  MOVFF  FEC,03
1359E:  MOVF   FED,F
135A0:  MOVFF  FEF,C80
135A4:  MOVFF  C7F,FEA
135A8:  MOVFF  01,FE9
135AC:  MOVFF  03,FEC
135B0:  MOVF   FED,F
135B2:  MOVFF  C80,FEF
....................         vschedule(current_time + (time_t)tmcr1_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
135B6:  MOVLW  06
135B8:  ADDWF  x3A,W
135BA:  MOVWF  FE9
135BC:  MOVLW  00
135BE:  ADDWFC x3B,W
135C0:  MOVWF  FEA
135C2:  MOVFF  FEC,03
135C6:  MOVF   FED,F
135C8:  MOVFF  FEF,00
135CC:  MOVFF  03,01
135D0:  CLRF   02
135D2:  CLRF   03
135D4:  MOVFF  03,C81
135D8:  MOVFF  02,C80
135DC:  MOVFF  01,C7F
135E0:  MOVFF  00,C7E
135E4:  MOVFF  FEA,C83
135E8:  MOVFF  FE9,C82
135EC:  CLRF   xB4
135EE:  CLRF   xB3
135F0:  CLRF   xB2
135F2:  MOVLW  36
135F4:  MOVWF  xB1
135F6:  MOVFF  03,CB8
135FA:  MOVFF  02,CB7
135FE:  MOVFF  01,CB6
13602:  MOVFF  00,CB5
13606:  MOVLB  0
13608:  CALL   456E
1360C:  MOVFF  C83,FEA
13610:  MOVFF  C82,FE9
13614:  MOVF   00,W
13616:  ADDWF  3B,W
13618:  MOVLB  C
1361A:  MOVWF  x7E
1361C:  MOVF   01,W
1361E:  ADDWFC 3C,W
13620:  MOVWF  x7F
13622:  MOVF   02,W
13624:  ADDWFC 3D,W
13626:  MOVWF  x80
13628:  MOVF   03,W
1362A:  ADDWFC 3E,W
1362C:  MOVWF  x81
1362E:  MOVWF  x98
13630:  MOVFF  C80,C97
13634:  MOVFF  C7F,C96
13638:  MOVFF  C7E,C95
1363C:  MOVFF  C3B,C9A
13640:  MOVFF  C3A,C99
13644:  MOVLB  0
13646:  CALL   704C
....................         break; 
1364A:  BRA    138F4
....................     case dsource_tmcr_n: 
....................         fprintf(PC, "Waiting for TMCR N copy..."); 
1364C:  MOVLW  92
1364E:  MOVWF  FF6
13650:  MOVLW  18
13652:  MOVWF  FF7
13654:  MOVLW  00
13656:  MOVWF  FF8
13658:  CALL   4534
....................         if (mux_sel(mux_tmcr2) == mux_tmcr2) {                                 // Try to change mission shared FM mux position to TMCR2 
1365C:  MOVLW  03
1365E:  MOVLB  C
13660:  MOVWF  xBE
13662:  MOVLB  0
13664:  CALL   52E8
13668:  MOVF   01,W
1366A:  SUBLW  03
1366C:  BNZ   136E0
....................             mux_lock_unlock(true, ((time_t)tmcr2_copy_delay) * packet->size); // Get exclusive access for some time 
1366E:  MOVLW  06
13670:  MOVLB  C
13672:  ADDWF  x3A,W
13674:  MOVWF  FE9
13676:  MOVLW  00
13678:  ADDWFC x3B,W
1367A:  MOVWF  FEA
1367C:  MOVFF  FEC,03
13680:  MOVF   FED,F
13682:  MOVFF  FEF,CB5
13686:  MOVFF  03,C7F
1368A:  MOVFF  FEA,C81
1368E:  MOVFF  FE9,C80
13692:  CLRF   xB4
13694:  CLRF   xB3
13696:  CLRF   xB2
13698:  MOVLW  36
1369A:  MOVWF  xB1
1369C:  CLRF   xB8
1369E:  CLRF   xB7
136A0:  MOVFF  03,CB6
136A4:  MOVLB  0
136A6:  CALL   456E
136AA:  MOVFF  C81,FEA
136AE:  MOVFF  C80,FE9
136B2:  MOVFF  03,C81
136B6:  MOVFF  02,C80
136BA:  MOVFF  01,C7F
136BE:  MOVFF  00,C7E
136C2:  MOVLW  01
136C4:  MOVLB  C
136C6:  MOVWF  x82
136C8:  MOVFF  03,C86
136CC:  MOVFF  02,C85
136D0:  MOVFF  01,C84
136D4:  MOVFF  00,C83
136D8:  MOVLB  0
136DA:  CALL   7EB4
....................         } else { 
136DE:  BRA    136E6
....................             return 2; // Mux did not change 
136E0:  MOVLW  02
136E2:  MOVWF  01
136E4:  BRA    138F8
....................         } 
....................         delay_ms(100); 
136E6:  MOVLW  64
136E8:  MOVLB  D
136EA:  MOVWF  x52
136EC:  MOVLB  0
136EE:  CALL   5266
....................         copy_packet->origin = MSG_OBC; 
136F2:  MOVLB  C
136F4:  MOVFF  C7C,FE9
136F8:  MOVFF  C7D,FEA
136FC:  MOVLW  0B
136FE:  MOVWF  FEF
....................         copy_packet->command = 0x0B; // Copy sectors command on RELAY PIC 
13700:  MOVLW  01
13702:  ADDWF  x7C,W
13704:  MOVWF  FE9
13706:  MOVLW  00
13708:  ADDWFC x7D,W
1370A:  MOVWF  FEA
1370C:  MOVLW  0B
1370E:  MOVWF  FEF
....................         copy_packet->destination_sector = packet->destination_sector; 
13710:  MOVLW  02
13712:  ADDWF  x7C,W
13714:  MOVWF  01
13716:  MOVLW  00
13718:  ADDWFC x7D,W
1371A:  MOVWF  03
1371C:  MOVWF  x7F
1371E:  MOVLW  02
13720:  ADDWF  x3A,W
13722:  MOVWF  FE9
13724:  MOVLW  00
13726:  ADDWFC x3B,W
13728:  MOVWF  FEA
1372A:  MOVFF  FEC,03
1372E:  MOVF   FED,F
13730:  MOVFF  FEF,C80
13734:  MOVFF  C7F,FEA
13738:  MOVFF  01,FE9
1373C:  MOVFF  03,FEC
13740:  MOVF   FED,F
13742:  MOVFF  C80,FEF
....................         copy_packet->source_sector = packet->source_sector; 
13746:  MOVLW  04
13748:  ADDWF  x7C,W
1374A:  MOVWF  01
1374C:  MOVLW  00
1374E:  ADDWFC x7D,W
13750:  MOVWF  03
13752:  MOVWF  x7F
13754:  MOVLW  04
13756:  ADDWF  x3A,W
13758:  MOVWF  FE9
1375A:  MOVLW  00
1375C:  ADDWFC x3B,W
1375E:  MOVWF  FEA
13760:  MOVFF  FEC,03
13764:  MOVF   FED,F
13766:  MOVFF  FEF,C80
1376A:  MOVFF  C7F,FEA
1376E:  MOVFF  01,FE9
13772:  MOVFF  03,FEC
13776:  MOVF   FED,F
13778:  MOVFF  C80,FEF
....................         copy_packet->size = packet->size; 
1377C:  MOVLW  06
1377E:  ADDWF  x7C,W
13780:  MOVWF  01
13782:  MOVLW  00
13784:  ADDWFC x7D,W
13786:  MOVWF  03
13788:  MOVWF  x7F
1378A:  MOVLW  06
1378C:  ADDWF  x3A,W
1378E:  MOVWF  FE9
13790:  MOVLW  00
13792:  ADDWFC x3B,W
13794:  MOVWF  FEA
13796:  MOVFF  FEC,03
1379A:  MOVF   FED,F
1379C:  MOVFF  FEF,C80
137A0:  MOVFF  C7F,FEA
137A4:  MOVFF  01,FE9
137A8:  MOVFF  03,FEC
137AC:  MOVF   FED,F
137AE:  MOVFF  C80,FEF
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
137B2:  MOVLW  08
137B4:  ADDWF  x7C,W
137B6:  MOVWF  FE9
137B8:  MOVLW  00
137BA:  ADDWFC x7D,W
137BC:  MOVWF  FEA
137BE:  MOVLW  01
137C0:  MOVWF  FEF
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
137C2:  MOVLW  09
137C4:  ADDWF  x7C,W
137C6:  MOVWF  FE9
137C8:  MOVLW  00
137CA:  ADDWFC x7D,W
137CC:  MOVWF  FEA
137CE:  CLRF   FEF
....................         checksum_obc(cpacket, MSG_LENGTH_TMCR2); 
137D0:  MOVLW  0C
137D2:  MOVWF  xAF
137D4:  MOVLW  3C
137D6:  MOVWF  xAE
137D8:  MOVLW  24
137DA:  MOVWF  xB0
137DC:  MOVLB  0
137DE:  CALL   8E80
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_TMCR2, 1, 10); // Send 1 time 
137E2:  MOVLW  0A
137E4:  MOVLB  C
137E6:  MOVWF  xAF
137E8:  MOVLW  97
137EA:  MOVWF  xAE
137EC:  MOVLW  0C
137EE:  MOVWF  xB1
137F0:  MOVLW  3C
137F2:  MOVWF  xB0
137F4:  CLRF   xB5
137F6:  CLRF   xB4
137F8:  CLRF   xB3
137FA:  MOVLW  24
137FC:  MOVWF  xB2
137FE:  MOVLW  01
13800:  MOVWF  xB6
13802:  CLRF   xBA
13804:  CLRF   xB9
13806:  CLRF   xB8
13808:  MOVLW  0A
1380A:  MOVWF  xB7
1380C:  MOVLB  0
1380E:  CALL   8F3C
....................         packet->data_source = 0; 
13812:  MOVLW  08
13814:  MOVLB  C
13816:  ADDWF  x3A,W
13818:  MOVWF  FE9
1381A:  MOVLW  00
1381C:  ADDWFC x3B,W
1381E:  MOVWF  FEA
13820:  CLRF   FEF
....................         packet->source_sector = packet->destination_sector; 
13822:  MOVLW  04
13824:  ADDWF  x3A,W
13826:  MOVWF  01
13828:  MOVLW  00
1382A:  ADDWFC x3B,W
1382C:  MOVWF  03
1382E:  MOVWF  x7F
13830:  MOVLW  02
13832:  ADDWF  x3A,W
13834:  MOVWF  FE9
13836:  MOVLW  00
13838:  ADDWFC x3B,W
1383A:  MOVWF  FEA
1383C:  MOVFF  FEC,03
13840:  MOVF   FED,F
13842:  MOVFF  FEF,C80
13846:  MOVFF  C7F,FEA
1384A:  MOVFF  01,FE9
1384E:  MOVFF  03,FEC
13852:  MOVF   FED,F
13854:  MOVFF  C80,FEF
....................         vschedule(current_time + (time_t)tmcr2_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
13858:  MOVLW  06
1385A:  ADDWF  x3A,W
1385C:  MOVWF  FE9
1385E:  MOVLW  00
13860:  ADDWFC x3B,W
13862:  MOVWF  FEA
13864:  MOVFF  FEC,03
13868:  MOVF   FED,F
1386A:  MOVFF  FEF,00
1386E:  MOVFF  03,01
13872:  CLRF   02
13874:  CLRF   03
13876:  MOVFF  03,C81
1387A:  MOVFF  02,C80
1387E:  MOVFF  01,C7F
13882:  MOVFF  00,C7E
13886:  MOVFF  FEA,C83
1388A:  MOVFF  FE9,C82
1388E:  CLRF   xB4
13890:  CLRF   xB3
13892:  CLRF   xB2
13894:  MOVLW  36
13896:  MOVWF  xB1
13898:  MOVFF  03,CB8
1389C:  MOVFF  02,CB7
138A0:  MOVFF  01,CB6
138A4:  MOVFF  00,CB5
138A8:  MOVLB  0
138AA:  CALL   456E
138AE:  MOVFF  C83,FEA
138B2:  MOVFF  C82,FE9
138B6:  MOVF   00,W
138B8:  ADDWF  3B,W
138BA:  MOVLB  C
138BC:  MOVWF  x7E
138BE:  MOVF   01,W
138C0:  ADDWFC 3C,W
138C2:  MOVWF  x7F
138C4:  MOVF   02,W
138C6:  ADDWFC 3D,W
138C8:  MOVWF  x80
138CA:  MOVF   03,W
138CC:  ADDWFC 3E,W
138CE:  MOVWF  x81
138D0:  MOVWF  x98
138D2:  MOVFF  C80,C97
138D6:  MOVFF  C7F,C96
138DA:  MOVFF  C7E,C95
138DE:  MOVFF  C3B,C9A
138E2:  MOVFF  C3A,C99
138E6:  MOVLB  0
138E8:  CALL   704C
....................         break; 
138EC:  BRA    138F4
....................     default: 
....................         return 1; 
138EE:  MOVLW  01
138F0:  MOVWF  01
138F2:  BRA    138F8
....................     } 
....................     return 0; 
138F4:  MOVLW  00
138F6:  MOVWF  01
138F8:  GOTO   18E6C (RETURN)
.................... } 
....................  
.................... // Resetting satellite (all powera lines) any time 
.................... uint8_t command_reset_all_power_lines(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................  
....................     save_state(data[1]); // data[1] is the current command id 
*
0E9E2:  MOVLW  01
0E9E4:  MOVLB  C
0E9E6:  ADDWF  x38,W
0E9E8:  MOVWF  FE9
0E9EA:  MOVLW  00
0E9EC:  ADDWFC x39,W
0E9EE:  MOVWF  FEA
0E9F0:  MOVFF  FEF,C60
0E9F4:  MOVLB  0
0E9F6:  CALL   8CAE
....................  
....................     // Reply: 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
0E9FA:  MOVLB  C
0E9FC:  CLRF   x3A
0E9FE:  MOVF   x3A,W
0EA00:  SUBLW  23
0EA02:  BNC   EA18
....................         fputc(cmd[i], RST); 
0EA04:  CLRF   03
0EA06:  MOVF   x3A,W
0EA08:  MOVLB  0
0EA0A:  CALL   03C4
0EA0E:  CALL   544E
0EA12:  MOVLB  C
0EA14:  INCF   x3A,F
0EA16:  BRA    E9FE
....................     } 
....................  
....................     fprintf(PC, "Waiting for resetting all power lines...\r\n"); 
0EA18:  MOVLW  AE
0EA1A:  MOVWF  FF6
0EA1C:  MOVLW  18
0EA1E:  MOVWF  FF7
0EA20:  MOVLW  00
0EA22:  MOVWF  FF8
0EA24:  MOVLB  0
0EA26:  CALL   4534
....................     delay_ms(30000); 
0EA2A:  MOVLW  78
0EA2C:  MOVLB  C
0EA2E:  MOVWF  x3B
0EA30:  MOVLW  FA
0EA32:  MOVLB  D
0EA34:  MOVWF  x52
0EA36:  MOVLB  0
0EA38:  CALL   5266
0EA3C:  MOVLB  C
0EA3E:  DECFSZ x3B,F
0EA40:  BRA    EA30
....................     // delay_ms(60000); 
....................  
....................     return 0; 
0EA42:  MOVLW  00
0EA44:  MOVWF  01
0EA46:  MOVLB  0
0EA48:  GOTO   18C9E (RETURN)
.................... } 
....................  
.................... uint8_t command_rpi_end_of_transmission(uint8_t* data) 
.................... { 
....................     scheduled_command_clear_specified_command(0xC0, 0x5E); // Remove all S-band turn off commands 
*
07FA8:  MOVLW  C0
07FAA:  MOVLB  C
07FAC:  MOVWF  xBE
07FAE:  MOVLW  5E
07FB0:  MOVWF  xBF
07FB2:  MOVLB  0
07FB4:  RCALL  7E00
....................     scheduled_command_clear_specified_command(0xC0, 0xBE); // Remove all RPi turn off commands 
07FB6:  MOVLW  C0
07FB8:  MOVLB  C
07FBA:  MOVWF  xBE
07FBC:  MOVLW  BE
07FBE:  MOVWF  xBF
07FC0:  MOVLB  0
07FC2:  RCALL  7E00
....................     schedule(current_time, { 0xC0, 0x5E, 0x00 });          // Turn off S-band TX now 
07FC4:  MOVLW  C0
07FC6:  MOVLB  C
07FC8:  MOVWF  x3A
07FCA:  MOVLW  5E
07FCC:  MOVWF  x3B
07FCE:  CLRF   x3C
07FD0:  MOVFF  3E,C98
07FD4:  MOVFF  3D,C97
07FD8:  MOVFF  3C,C96
07FDC:  MOVFF  3B,C95
07FE0:  MOVLW  0C
07FE2:  MOVWF  x9A
07FE4:  MOVLW  3A
07FE6:  MOVWF  x99
07FE8:  MOVLB  0
07FEA:  CALL   704C
....................     schedule(current_time + 1, { 0xC0, 0xBE, 0x02 });      // Rpi off (soft) after 1s 
07FEE:  MOVLW  C0
07FF0:  MOVLB  C
07FF2:  MOVWF  x3D
07FF4:  MOVLW  BE
07FF6:  MOVWF  x3E
07FF8:  MOVLW  02
07FFA:  MOVWF  x3F
07FFC:  MOVLW  01
07FFE:  ADDWF  3B,W
08000:  MOVWF  x43
08002:  MOVLW  00
08004:  ADDWFC 3C,W
08006:  MOVWF  x44
08008:  MOVLW  00
0800A:  ADDWFC 3D,W
0800C:  MOVWF  x45
0800E:  MOVLW  00
08010:  ADDWFC 3E,W
08012:  MOVWF  x46
08014:  MOVWF  x98
08016:  MOVFF  C45,C97
0801A:  MOVFF  C44,C96
0801E:  MOVFF  C43,C95
08022:  MOVLW  0C
08024:  MOVWF  x9A
08026:  MOVLW  3D
08028:  MOVWF  x99
0802A:  MOVLB  0
0802C:  CALL   704C
....................     schedule(current_time + 20, { 0xC0, 0xBE, 0x00 });     // Rpi off (hard) after 20s 
08030:  MOVLW  C0
08032:  MOVLB  C
08034:  MOVWF  x40
08036:  MOVLW  BE
08038:  MOVWF  x41
0803A:  CLRF   x42
0803C:  MOVLW  14
0803E:  ADDWF  3B,W
08040:  MOVWF  x43
08042:  MOVLW  00
08044:  ADDWFC 3C,W
08046:  MOVWF  x44
08048:  MOVLW  00
0804A:  ADDWFC 3D,W
0804C:  MOVWF  x45
0804E:  MOVLW  00
08050:  ADDWFC 3E,W
08052:  MOVWF  x46
08054:  MOVWF  x98
08056:  MOVFF  C45,C97
0805A:  MOVFF  C44,C96
0805E:  MOVFF  C43,C95
08062:  MOVLW  0C
08064:  MOVWF  x9A
08066:  MOVLW  40
08068:  MOVWF  x99
0806A:  MOVLB  0
0806C:  CALL   704C
....................     return 0; 
08070:  MOVLW  00
08072:  MOVWF  01
08074:  GOTO   1880E (RETURN)
.................... } 
....................  
.................... // Enable / disable S-band TX 
.................... uint8_t command_enable_disable_sband(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
0D14A:  MOVLW  06
0D14C:  MOVLB  C
0D14E:  MOVWF  xBE
0D150:  MOVLB  0
0D152:  CALL   52E8
0D156:  MOVF   01,W
0D158:  SUBLW  06
0D15A:  BZ    D17E
....................         if (verbose) { 
0D15C:  MOVLB  5
0D15E:  MOVF   x5A,F
0D160:  BZ    D176
....................             fprintf(PC, "MUX change failed!"); 
0D162:  MOVLW  DA
0D164:  MOVWF  FF6
0D166:  MOVLW  18
0D168:  MOVWF  FF7
0D16A:  MOVLW  00
0D16C:  MOVWF  FF8
0D16E:  MOVLB  0
0D170:  CALL   4534
0D174:  MOVLB  5
....................         } 
....................         return 1; 
0D176:  MOVLW  01
0D178:  MOVWF  01
0D17A:  BRA    D26A
0D17C:  MOVLB  0
....................     } 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t enable_disable; // 0 = disabled, 1 = enabled 
....................         uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
0D17E:  MOVLW  0C
0D180:  MOVLB  C
0D182:  MOVWF  x61
0D184:  MOVLW  3A
0D186:  MOVFF  C61,C5F
0D18A:  MOVWF  x5E
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
0D18C:  MOVFF  C5F,FEA
0D190:  MOVFF  C5E,FE9
0D194:  CLRF   00
0D196:  CLRF   02
0D198:  MOVLW  24
0D19A:  MOVWF  01
0D19C:  MOVLB  0
0D19E:  CALL   5222
....................     memcpy(ptr, data, 3); 
0D1A2:  MOVFF  C5F,FEA
0D1A6:  MOVFF  C5E,FE9
0D1AA:  MOVFF  C39,FE2
0D1AE:  MOVFF  C38,FE1
0D1B2:  MOVLW  03
0D1B4:  MOVWF  01
0D1B6:  MOVFF  FE6,FEE
0D1BA:  DECFSZ 01,F
0D1BC:  BRA    D1B6
....................     pcib_pkg.origin = MSG_OBC; 
0D1BE:  MOVLW  0B
0D1C0:  MOVLB  C
0D1C2:  MOVWF  x3A
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
0D1C4:  MOVFF  C5F,CAF
0D1C8:  MOVFF  C5E,CAE
0D1CC:  MOVLW  24
0D1CE:  MOVWF  xB0
0D1D0:  MOVLB  0
0D1D2:  CALL   8E80
....................  
....................     fprintf(PC, "TX "); 
0D1D6:  MOVLW  EE
0D1D8:  MOVWF  FF6
0D1DA:  MOVLW  18
0D1DC:  MOVWF  FF7
0D1DE:  MOVLW  00
0D1E0:  MOVWF  FF8
0D1E2:  CALL   4534
....................     if (pcib_pkg.enable_disable == 0x00) { 
0D1E6:  MOVLB  C
0D1E8:  MOVF   x3C,F
0D1EA:  BNZ   D202
....................         fprintf(PC, "OFF | "); 
0D1EC:  MOVLW  F2
0D1EE:  MOVWF  FF6
0D1F0:  MOVLW  18
0D1F2:  MOVWF  FF7
0D1F4:  MOVLW  00
0D1F6:  MOVWF  FF8
0D1F8:  MOVLB  0
0D1FA:  CALL   4534
....................     } else if (pcib_pkg.enable_disable == 0x01) { 
0D1FE:  BRA    D218
0D200:  MOVLB  C
0D202:  DECFSZ x3C,W
0D204:  BRA    D21A
....................         fprintf(PC, "ON | "); 
0D206:  MOVLW  FA
0D208:  MOVWF  FF6
0D20A:  MOVLW  18
0D20C:  MOVWF  FF7
0D20E:  MOVLW  00
0D210:  MOVWF  FF8
0D212:  MOVLB  0
0D214:  CALL   4534
0D218:  MOVLB  C
....................     } 
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
0D21A:  MOVFF  C5F,C90
0D21E:  MOVFF  C5E,C8F
0D222:  MOVLW  24
0D224:  MOVWF  x91
0D226:  MOVLB  0
0D228:  CALL   7A5C
....................  
....................     sband_tx_status = pcib_pkg.enable_disable; 
0D22C:  MOVFF  C3C,8AA
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); // PCIB -> MSN for structures 
0D230:  MOVLW  0A
0D232:  MOVLB  C
0D234:  MOVWF  xAF
0D236:  MOVLW  97
0D238:  MOVWF  xAE
0D23A:  MOVFF  C5F,CB1
0D23E:  MOVFF  C5E,CB0
0D242:  CLRF   xB5
0D244:  CLRF   xB4
0D246:  CLRF   xB3
0D248:  MOVLW  24
0D24A:  MOVWF  xB2
0D24C:  MOVLW  05
0D24E:  MOVWF  xB6
0D250:  CLRF   xBA
0D252:  CLRF   xB9
0D254:  CLRF   xB8
0D256:  MOVLW  0A
0D258:  MOVWF  xB7
0D25A:  MOVLB  0
0D25C:  CALL   8F3C
....................  
....................     return (pcib_pkg.enable_disable & 0x01); 
0D260:  MOVLB  C
0D262:  MOVF   x3C,W
0D264:  ANDLW  01
0D266:  MOVWF  01
0D268:  MOVLB  5
0D26A:  MOVLB  0
0D26C:  GOTO   18AB8 (RETURN)
.................... } 
....................  
.................... // Enable / disable raspberry pi 
.................... uint8_t command_enable_disable_rpi(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
0EA4C:  MOVLW  06
0EA4E:  MOVLB  C
0EA50:  MOVWF  xBE
0EA52:  MOVLB  0
0EA54:  CALL   52E8
0EA58:  MOVF   01,W
0EA5A:  SUBLW  06
0EA5C:  BZ    EA80
....................         if (verbose) { 
0EA5E:  MOVLB  5
0EA60:  MOVF   x5A,F
0EA62:  BZ    EA78
....................             fprintf(PC, "MUX change failed!"); 
0EA64:  MOVLW  00
0EA66:  MOVWF  FF6
0EA68:  MOVLW  19
0EA6A:  MOVWF  FF7
0EA6C:  MOVLW  00
0EA6E:  MOVWF  FF8
0EA70:  MOVLB  0
0EA72:  CALL   4534
0EA76:  MOVLB  5
....................         } 
....................         return 1; 
0EA78:  MOVLW  01
0EA7A:  MOVWF  01
0EA7C:  BRA    EB7E
0EA7E:  MOVLB  0
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t enable_disable; // 0 = disable, 1 = enable, 2 = warn 
....................         uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
0EA80:  MOVLW  0C
0EA82:  MOVLB  C
0EA84:  MOVWF  x61
0EA86:  MOVLW  3A
0EA88:  MOVFF  C61,C5F
0EA8C:  MOVWF  x5E
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
0EA8E:  MOVFF  C5F,FEA
0EA92:  MOVFF  C5E,FE9
0EA96:  CLRF   00
0EA98:  CLRF   02
0EA9A:  MOVLW  24
0EA9C:  MOVWF  01
0EA9E:  MOVLB  0
0EAA0:  CALL   5222
....................     memcpy(ptr, data, 3); 
0EAA4:  MOVFF  C5F,FEA
0EAA8:  MOVFF  C5E,FE9
0EAAC:  MOVFF  C39,FE2
0EAB0:  MOVFF  C38,FE1
0EAB4:  MOVLW  03
0EAB6:  MOVWF  01
0EAB8:  MOVFF  FE6,FEE
0EABC:  DECFSZ 01,F
0EABE:  BRA    EAB8
....................     pcib_pkg.origin = MSG_OBC; 
0EAC0:  MOVLW  0B
0EAC2:  MOVLB  C
0EAC4:  MOVWF  x3A
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
0EAC6:  MOVFF  C5F,CAF
0EACA:  MOVFF  C5E,CAE
0EACE:  MOVLW  24
0EAD0:  MOVWF  xB0
0EAD2:  MOVLB  0
0EAD4:  CALL   8E80
....................  
....................     if (pcib_pkg.enable_disable == 0x00) { 
0EAD8:  MOVLB  C
0EADA:  MOVF   x3C,F
0EADC:  BNZ   EAF8
....................         fprintf(PC, "RPI OFF | "); 
0EADE:  MOVLW  14
0EAE0:  MOVWF  FF6
0EAE2:  MOVLW  19
0EAE4:  MOVWF  FF7
0EAE6:  MOVLW  00
0EAE8:  MOVWF  FF8
0EAEA:  MOVLB  0
0EAEC:  CALL   4534
....................         rpi_status = pcib_pkg.enable_disable; 
0EAF0:  MOVFF  C3C,8AB
....................     } else if (pcib_pkg.enable_disable == 0x01) { 
0EAF4:  BRA    EB32
0EAF6:  MOVLB  C
0EAF8:  DECFSZ x3C,W
0EAFA:  BRA    EB16
....................         fprintf(PC, "RPI ON | "); 
0EAFC:  MOVLW  20
0EAFE:  MOVWF  FF6
0EB00:  MOVLW  19
0EB02:  MOVWF  FF7
0EB04:  MOVLW  00
0EB06:  MOVWF  FF8
0EB08:  MOVLB  0
0EB0A:  CALL   4534
....................         rpi_status = pcib_pkg.enable_disable; 
0EB0E:  MOVFF  C3C,8AB
....................     } else if (pcib_pkg.enable_disable == 0x02) { 
0EB12:  BRA    EB32
0EB14:  MOVLB  C
0EB16:  MOVF   x3C,W
0EB18:  SUBLW  02
0EB1A:  BNZ   EB34
....................         fprintf(PC, "RPI SOFT | "); 
0EB1C:  MOVLW  2A
0EB1E:  MOVWF  FF6
0EB20:  MOVLW  19
0EB22:  MOVWF  FF7
0EB24:  MOVLW  00
0EB26:  MOVWF  FF8
0EB28:  MOVLB  0
0EB2A:  CALL   4534
....................         rpi_status = pcib_pkg.enable_disable; 
0EB2E:  MOVFF  C3C,8AB
0EB32:  MOVLB  C
....................     } 
....................  
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
0EB34:  MOVFF  C5F,C90
0EB38:  MOVFF  C5E,C8F
0EB3C:  MOVLW  24
0EB3E:  MOVWF  x91
0EB40:  MOVLB  0
0EB42:  CALL   7A5C
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); 
0EB46:  MOVLW  0A
0EB48:  MOVLB  C
0EB4A:  MOVWF  xAF
0EB4C:  MOVLW  97
0EB4E:  MOVWF  xAE
0EB50:  MOVFF  C5F,CB1
0EB54:  MOVFF  C5E,CB0
0EB58:  CLRF   xB5
0EB5A:  CLRF   xB4
0EB5C:  CLRF   xB3
0EB5E:  MOVLW  24
0EB60:  MOVWF  xB2
0EB62:  MOVLW  05
0EB64:  MOVWF  xB6
0EB66:  CLRF   xBA
0EB68:  CLRF   xB9
0EB6A:  CLRF   xB8
0EB6C:  MOVLW  0A
0EB6E:  MOVWF  xB7
0EB70:  MOVLB  0
0EB72:  CALL   8F3C
....................  
....................     return pcib_pkg.enable_disable; 
0EB76:  MOVLB  C
0EB78:  MOVFF  C3C,01
0EB7C:  MOVLB  5
0EB7E:  MOVLB  0
0EB80:  GOTO   18CB0 (RETURN)
.................... } 
....................  
.................... uint8_t command_rpi_clean_up(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
0EB84:  MOVLW  06
0EB86:  MOVLB  C
0EB88:  MOVWF  xBE
0EB8A:  MOVLB  0
0EB8C:  CALL   52E8
0EB90:  MOVF   01,W
0EB92:  SUBLW  06
0EB94:  BZ    EBB8
....................         if (verbose) { 
0EB96:  MOVLB  5
0EB98:  MOVF   x5A,F
0EB9A:  BZ    EBB0
....................             fprintf(PC, "MUX change failed!"); 
0EB9C:  MOVLW  36
0EB9E:  MOVWF  FF6
0EBA0:  MOVLW  19
0EBA2:  MOVWF  FF7
0EBA4:  MOVLW  00
0EBA6:  MOVWF  FF8
0EBA8:  MOVLB  0
0EBAA:  CALL   4534
0EBAE:  MOVLB  5
....................         } 
....................         return 1; 
0EBB0:  MOVLW  01
0EBB2:  MOVWF  01
0EBB4:  BRA    ECFC
0EBB6:  MOVLB  0
....................     } 
....................     const uint8_t packet_erase_time = 60; // in seconds 
....................     const uint8_t rpi_turn_on_time = 60;  // in seconds 
....................  
....................     fprintf(PC, "\r\nRPi command: clean_up\r\n"); 
0EBB8:  MOVLW  4A
0EBBA:  MOVWF  FF6
0EBBC:  MOVLW  19
0EBBE:  MOVWF  FF7
0EBC0:  MOVLW  00
0EBC2:  MOVWF  FF8
0EBC4:  CALL   4534
....................  
....................     schedule(current_time + 2, { 0xC0, 0xBE, 0x01 });                                         // Turn on Rpi 
0EBC8:  MOVLW  C0
0EBCA:  MOVLB  C
0EBCC:  MOVWF  x3A
0EBCE:  MOVLW  BE
0EBD0:  MOVWF  x3B
0EBD2:  MOVLW  01
0EBD4:  MOVWF  x3C
0EBD6:  MOVLW  02
0EBD8:  ADDWF  3B,W
0EBDA:  MOVWF  x46
0EBDC:  MOVLW  00
0EBDE:  ADDWFC 3C,W
0EBE0:  MOVWF  x47
0EBE2:  MOVLW  00
0EBE4:  ADDWFC 3D,W
0EBE6:  MOVWF  x48
0EBE8:  MOVLW  00
0EBEA:  ADDWFC 3E,W
0EBEC:  MOVWF  x49
0EBEE:  MOVWF  x98
0EBF0:  MOVFF  C48,C97
0EBF4:  MOVFF  C47,C96
0EBF8:  MOVFF  C46,C95
0EBFC:  MOVLW  0C
0EBFE:  MOVWF  x9A
0EC00:  MOVLW  3A
0EC02:  MOVWF  x99
0EC04:  MOVLB  0
0EC06:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time, { 0xC0, 0xCC, 0xC0 });                          // Clean up command 
0EC0A:  MOVLW  C0
0EC0C:  MOVLB  C
0EC0E:  MOVWF  x3D
0EC10:  MOVLW  CC
0EC12:  MOVWF  x3E
0EC14:  MOVLW  C0
0EC16:  MOVWF  x3F
0EC18:  MOVLW  3C
0EC1A:  ADDWF  3B,W
0EC1C:  MOVWF  x46
0EC1E:  MOVLW  00
0EC20:  ADDWFC 3C,W
0EC22:  MOVWF  x47
0EC24:  MOVLW  00
0EC26:  ADDWFC 3D,W
0EC28:  MOVWF  x48
0EC2A:  MOVLW  00
0EC2C:  ADDWFC 3E,W
0EC2E:  MOVWF  x49
0EC30:  MOVWF  x98
0EC32:  MOVFF  C48,C97
0EC36:  MOVFF  C47,C96
0EC3A:  MOVFF  C46,C95
0EC3E:  MOVLW  0C
0EC40:  MOVWF  x9A
0EC42:  MOVLW  3D
0EC44:  MOVWF  x99
0EC46:  MOVLB  0
0EC48:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time, { 0xC0, 0xBE, 0x02 });      // Turn off Rpi (soft) 
0EC4C:  MOVLW  C0
0EC4E:  MOVLB  C
0EC50:  MOVWF  x40
0EC52:  MOVLW  BE
0EC54:  MOVWF  x41
0EC56:  MOVLW  02
0EC58:  MOVWF  x42
0EC5A:  MOVLW  3C
0EC5C:  ADDWF  3B,W
0EC5E:  MOVWF  x46
0EC60:  MOVLW  00
0EC62:  ADDWFC 3C,W
0EC64:  MOVWF  x47
0EC66:  MOVLW  00
0EC68:  ADDWFC 3D,W
0EC6A:  MOVWF  x48
0EC6C:  MOVLW  00
0EC6E:  ADDWFC 3E,W
0EC70:  MOVWF  x49
0EC72:  MOVLW  3C
0EC74:  ADDWF  x46,F
0EC76:  MOVLW  00
0EC78:  ADDWFC x47,F
0EC7A:  ADDWFC x48,F
0EC7C:  ADDWFC x49,F
0EC7E:  MOVFF  C49,C98
0EC82:  MOVFF  C48,C97
0EC86:  MOVFF  C47,C96
0EC8A:  MOVFF  C46,C95
0EC8E:  MOVLW  0C
0EC90:  MOVWF  x9A
0EC92:  MOVLW  40
0EC94:  MOVWF  x99
0EC96:  MOVLB  0
0EC98:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time + 20, { 0xC0, 0xBE, 0x00 }); // Turn off Rpi (hard) 
0EC9C:  MOVLW  C0
0EC9E:  MOVLB  C
0ECA0:  MOVWF  x43
0ECA2:  MOVLW  BE
0ECA4:  MOVWF  x44
0ECA6:  CLRF   x45
0ECA8:  MOVLW  3C
0ECAA:  ADDWF  3B,W
0ECAC:  MOVWF  x46
0ECAE:  MOVLW  00
0ECB0:  ADDWFC 3C,W
0ECB2:  MOVWF  x47
0ECB4:  MOVLW  00
0ECB6:  ADDWFC 3D,W
0ECB8:  MOVWF  x48
0ECBA:  MOVLW  00
0ECBC:  ADDWFC 3E,W
0ECBE:  MOVWF  x49
0ECC0:  MOVLW  3C
0ECC2:  ADDWF  x46,F
0ECC4:  MOVLW  00
0ECC6:  ADDWFC x47,F
0ECC8:  ADDWFC x48,F
0ECCA:  ADDWFC x49,F
0ECCC:  MOVLW  14
0ECCE:  ADDWF  x46,F
0ECD0:  MOVLW  00
0ECD2:  ADDWFC x47,F
0ECD4:  ADDWFC x48,F
0ECD6:  ADDWFC x49,F
0ECD8:  MOVFF  C49,C98
0ECDC:  MOVFF  C48,C97
0ECE0:  MOVFF  C47,C96
0ECE4:  MOVFF  C46,C95
0ECE8:  MOVLW  0C
0ECEA:  MOVWF  x9A
0ECEC:  MOVLW  43
0ECEE:  MOVWF  x99
0ECF0:  MOVLB  0
0ECF2:  CALL   704C
....................  
....................     return 0; 
0ECF6:  MOVLW  00
0ECF8:  MOVWF  01
0ECFA:  MOVLB  5
0ECFC:  MOVLB  0
0ECFE:  GOTO   18CC2 (RETURN)
.................... } 
....................  
.................... uint8_t command_rpi_clean_logfile(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
0ED02:  MOVLW  06
0ED04:  MOVLB  C
0ED06:  MOVWF  xBE
0ED08:  MOVLB  0
0ED0A:  CALL   52E8
0ED0E:  MOVF   01,W
0ED10:  SUBLW  06
0ED12:  BZ    ED36
....................         if (verbose) { 
0ED14:  MOVLB  5
0ED16:  MOVF   x5A,F
0ED18:  BZ    ED2E
....................             fprintf(PC, "MUX change failed!"); 
0ED1A:  MOVLW  64
0ED1C:  MOVWF  FF6
0ED1E:  MOVLW  19
0ED20:  MOVWF  FF7
0ED22:  MOVLW  00
0ED24:  MOVWF  FF8
0ED26:  MOVLB  0
0ED28:  CALL   4534
0ED2C:  MOVLB  5
....................         } 
....................         return 1; 
0ED2E:  MOVLW  01
0ED30:  MOVWF  01
0ED32:  BRA    EE7A
0ED34:  MOVLB  0
....................     } 
....................     const uint8_t packet_erase_time = 60; // in seconds 
....................     const uint8_t rpi_turn_on_time = 60;  // in seconds 
....................  
....................     fprintf(PC, "\r\nRPi command: clean_logfile\r\n"); 
0ED36:  MOVLW  78
0ED38:  MOVWF  FF6
0ED3A:  MOVLW  19
0ED3C:  MOVWF  FF7
0ED3E:  MOVLW  00
0ED40:  MOVWF  FF8
0ED42:  CALL   4534
....................  
....................     schedule(current_time + 2, { 0xC0, 0xBE, 0x01 });                                         // Turn on Rpi 
0ED46:  MOVLW  C0
0ED48:  MOVLB  C
0ED4A:  MOVWF  x3A
0ED4C:  MOVLW  BE
0ED4E:  MOVWF  x3B
0ED50:  MOVLW  01
0ED52:  MOVWF  x3C
0ED54:  MOVLW  02
0ED56:  ADDWF  3B,W
0ED58:  MOVWF  x46
0ED5A:  MOVLW  00
0ED5C:  ADDWFC 3C,W
0ED5E:  MOVWF  x47
0ED60:  MOVLW  00
0ED62:  ADDWFC 3D,W
0ED64:  MOVWF  x48
0ED66:  MOVLW  00
0ED68:  ADDWFC 3E,W
0ED6A:  MOVWF  x49
0ED6C:  MOVWF  x98
0ED6E:  MOVFF  C48,C97
0ED72:  MOVFF  C47,C96
0ED76:  MOVFF  C46,C95
0ED7A:  MOVLW  0C
0ED7C:  MOVWF  x9A
0ED7E:  MOVLW  3A
0ED80:  MOVWF  x99
0ED82:  MOVLB  0
0ED84:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time, { 0xC0, 0xCC, 0xC1 });                          // Clean logfile command 
0ED88:  MOVLW  C0
0ED8A:  MOVLB  C
0ED8C:  MOVWF  x3D
0ED8E:  MOVLW  CC
0ED90:  MOVWF  x3E
0ED92:  MOVLW  C1
0ED94:  MOVWF  x3F
0ED96:  MOVLW  3C
0ED98:  ADDWF  3B,W
0ED9A:  MOVWF  x46
0ED9C:  MOVLW  00
0ED9E:  ADDWFC 3C,W
0EDA0:  MOVWF  x47
0EDA2:  MOVLW  00
0EDA4:  ADDWFC 3D,W
0EDA6:  MOVWF  x48
0EDA8:  MOVLW  00
0EDAA:  ADDWFC 3E,W
0EDAC:  MOVWF  x49
0EDAE:  MOVWF  x98
0EDB0:  MOVFF  C48,C97
0EDB4:  MOVFF  C47,C96
0EDB8:  MOVFF  C46,C95
0EDBC:  MOVLW  0C
0EDBE:  MOVWF  x9A
0EDC0:  MOVLW  3D
0EDC2:  MOVWF  x99
0EDC4:  MOVLB  0
0EDC6:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time, { 0xC0, 0xBE, 0x02 });      // Turn off Rpi (soft) 
0EDCA:  MOVLW  C0
0EDCC:  MOVLB  C
0EDCE:  MOVWF  x40
0EDD0:  MOVLW  BE
0EDD2:  MOVWF  x41
0EDD4:  MOVLW  02
0EDD6:  MOVWF  x42
0EDD8:  MOVLW  3C
0EDDA:  ADDWF  3B,W
0EDDC:  MOVWF  x46
0EDDE:  MOVLW  00
0EDE0:  ADDWFC 3C,W
0EDE2:  MOVWF  x47
0EDE4:  MOVLW  00
0EDE6:  ADDWFC 3D,W
0EDE8:  MOVWF  x48
0EDEA:  MOVLW  00
0EDEC:  ADDWFC 3E,W
0EDEE:  MOVWF  x49
0EDF0:  MOVLW  3C
0EDF2:  ADDWF  x46,F
0EDF4:  MOVLW  00
0EDF6:  ADDWFC x47,F
0EDF8:  ADDWFC x48,F
0EDFA:  ADDWFC x49,F
0EDFC:  MOVFF  C49,C98
0EE00:  MOVFF  C48,C97
0EE04:  MOVFF  C47,C96
0EE08:  MOVFF  C46,C95
0EE0C:  MOVLW  0C
0EE0E:  MOVWF  x9A
0EE10:  MOVLW  40
0EE12:  MOVWF  x99
0EE14:  MOVLB  0
0EE16:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time + 20, { 0xC0, 0xBE, 0x00 }); // Turn off Rpi (hard) 
0EE1A:  MOVLW  C0
0EE1C:  MOVLB  C
0EE1E:  MOVWF  x43
0EE20:  MOVLW  BE
0EE22:  MOVWF  x44
0EE24:  CLRF   x45
0EE26:  MOVLW  3C
0EE28:  ADDWF  3B,W
0EE2A:  MOVWF  x46
0EE2C:  MOVLW  00
0EE2E:  ADDWFC 3C,W
0EE30:  MOVWF  x47
0EE32:  MOVLW  00
0EE34:  ADDWFC 3D,W
0EE36:  MOVWF  x48
0EE38:  MOVLW  00
0EE3A:  ADDWFC 3E,W
0EE3C:  MOVWF  x49
0EE3E:  MOVLW  3C
0EE40:  ADDWF  x46,F
0EE42:  MOVLW  00
0EE44:  ADDWFC x47,F
0EE46:  ADDWFC x48,F
0EE48:  ADDWFC x49,F
0EE4A:  MOVLW  14
0EE4C:  ADDWF  x46,F
0EE4E:  MOVLW  00
0EE50:  ADDWFC x47,F
0EE52:  ADDWFC x48,F
0EE54:  ADDWFC x49,F
0EE56:  MOVFF  C49,C98
0EE5A:  MOVFF  C48,C97
0EE5E:  MOVFF  C47,C96
0EE62:  MOVFF  C46,C95
0EE66:  MOVLW  0C
0EE68:  MOVWF  x9A
0EE6A:  MOVLW  43
0EE6C:  MOVWF  x99
0EE6E:  MOVLB  0
0EE70:  CALL   704C
....................  
....................     return 0; 
0EE74:  MOVLW  00
0EE76:  MOVWF  01
0EE78:  MOVLB  5
0EE7A:  MOVLB  0
0EE7C:  GOTO   18CD4 (RETURN)
.................... } 
....................  
.................... uint8_t command_pcib_telemetry(uint8_t* data) 
*
07B26:  MOVLW  01
07B28:  MOVLB  C
07B2A:  MOVWF  x3A
07B2C:  MOVFF  C39,C3C
07B30:  MOVFF  C38,C3B
.................... { 
....................     uint8_t i = 1; 
....................  
....................     enum { 
....................         length = MSG_LENGTH_PCIB, 
....................         magnetometer_size = 6 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         uint16_t sband_temperature; 
....................         uint8_t sband_tx_status; 
....................         uint8_t rpi_status; 
....................         uint8_t magnetometer[magnetometer_size]; 
....................         uint8_t fill[length - 8 - magnetometer_size]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     response_rx = 1; // Received a reply 
07B34:  MOVLB  7
07B36:  MOVWF  x50
....................  
....................     // Pruint8_t for debug: 
....................     fprintf(PC, "RELAY: Ts=%lX, Stx=%d, Rp=%d | ", packet->sband_temperature, packet->sband_tx_status, packet->rpi_status); 
07B38:  MOVLW  02
07B3A:  MOVLB  C
07B3C:  ADDWF  x3B,W
07B3E:  MOVWF  FE9
07B40:  MOVLW  00
07B42:  ADDWFC x3C,W
07B44:  MOVWF  FEA
07B46:  MOVFF  FEC,C90
07B4A:  MOVF   FED,F
07B4C:  MOVFF  FEF,C8F
07B50:  MOVLW  04
07B52:  ADDWF  x3B,W
07B54:  MOVWF  FE9
07B56:  MOVLW  00
07B58:  ADDWFC x3C,W
07B5A:  MOVWF  FEA
07B5C:  MOVFF  FEF,C91
07B60:  MOVLW  05
07B62:  ADDWF  x3B,W
07B64:  MOVWF  FE9
07B66:  MOVLW  00
07B68:  ADDWFC x3C,W
07B6A:  MOVWF  FEA
07B6C:  MOVFF  FEF,C92
07B70:  MOVLW  98
07B72:  MOVWF  FF6
07B74:  MOVLW  19
07B76:  MOVWF  FF7
07B78:  MOVLW  00
07B7A:  MOVWF  FF8
07B7C:  MOVLW  0A
07B7E:  MOVWF  xC1
07B80:  MOVLB  0
07B82:  CALL   5290
07B86:  MOVFF  C90,CBF
07B8A:  MOVLW  37
07B8C:  MOVLB  C
07B8E:  MOVWF  xC0
07B90:  MOVLB  0
07B92:  CALL   5A92
07B96:  MOVFF  C8F,CBF
07B9A:  MOVLW  37
07B9C:  MOVLB  C
07B9E:  MOVWF  xC0
07BA0:  MOVLB  0
07BA2:  CALL   5A92
07BA6:  MOVLW  A5
07BA8:  MOVWF  FF6
07BAA:  MOVLW  19
07BAC:  MOVWF  FF7
07BAE:  MOVLW  00
07BB0:  MOVWF  FF8
07BB2:  MOVLW  06
07BB4:  MOVLB  C
07BB6:  MOVWF  xC1
07BB8:  MOVLB  0
07BBA:  CALL   5290
07BBE:  MOVFF  C91,CBE
07BC2:  MOVLW  18
07BC4:  MOVLB  C
07BC6:  MOVWF  xBF
07BC8:  MOVLB  0
07BCA:  CALL   73A8
07BCE:  MOVLW  AD
07BD0:  MOVWF  FF6
07BD2:  MOVLW  19
07BD4:  MOVWF  FF7
07BD6:  MOVLW  00
07BD8:  MOVWF  FF8
07BDA:  MOVLW  05
07BDC:  MOVLB  C
07BDE:  MOVWF  xC1
07BE0:  MOVLB  0
07BE2:  CALL   5290
07BE6:  MOVFF  C92,CBE
07BEA:  MOVLW  18
07BEC:  MOVLB  C
07BEE:  MOVWF  xBF
07BF0:  MOVLB  0
07BF2:  CALL   73A8
07BF6:  MOVLW  B4
07BF8:  MOVWF  FF6
07BFA:  MOVLW  19
07BFC:  MOVWF  FF7
07BFE:  MOVLW  00
07C00:  MOVWF  FF8
07C02:  MOVLW  03
07C04:  MOVLB  C
07C06:  MOVWF  xC1
07C08:  MOVLB  0
07C0A:  CALL   5290
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_PCIB); 
07C0E:  MOVFF  C39,C90
07C12:  MOVFF  C38,C8F
07C16:  MOVLW  24
07C18:  MOVLB  C
07C1A:  MOVWF  x91
07C1C:  MOVLB  0
07C1E:  RCALL  7A5C
....................  
....................     // PCIB telemetry -> OBC telemetry: 
....................     struct pcib_telemetry { 
....................         uint16_t sband_temperature; 
....................         uint8_t sband_tx_status; 
....................         uint8_t rpi_status; 
....................         uint8_t magnetometer[magnetometer_size]; 
....................     } pcib_telemetry; 
....................  
....................     pcib_telemetry.sband_temperature = packet->sband_temperature; 
07C20:  MOVLW  02
07C22:  MOVLB  C
07C24:  ADDWF  x3B,W
07C26:  MOVWF  FE9
07C28:  MOVLW  00
07C2A:  ADDWFC x3C,W
07C2C:  MOVWF  FEA
07C2E:  MOVFF  FEC,C3E
07C32:  MOVF   FED,F
07C34:  MOVFF  FEF,C3D
....................     pcib_telemetry.sband_tx_status = packet->sband_tx_status; 
07C38:  MOVLW  04
07C3A:  ADDWF  x3B,W
07C3C:  MOVWF  FE9
07C3E:  MOVLW  00
07C40:  ADDWFC x3C,W
07C42:  MOVWF  FEA
07C44:  MOVFF  FEF,C3F
....................     pcib_telemetry.rpi_status = packet->rpi_status; 
07C48:  MOVLW  05
07C4A:  ADDWF  x3B,W
07C4C:  MOVWF  FE9
07C4E:  MOVLW  00
07C50:  ADDWFC x3C,W
07C52:  MOVWF  FEA
07C54:  MOVFF  FEF,C40
....................     memcpy(pcib_telemetry.magnetometer, packet->magnetometer, magnetometer_size); 
07C58:  MOVLW  06
07C5A:  ADDWF  x3B,W
07C5C:  MOVWF  01
07C5E:  MOVLW  00
07C60:  ADDWFC x3C,W
07C62:  MOVWF  03
07C64:  MOVFF  01,C8F
07C68:  MOVWF  x90
07C6A:  MOVLW  0C
07C6C:  MOVWF  FEA
07C6E:  MOVLW  41
07C70:  MOVWF  FE9
07C72:  MOVFF  03,FE2
07C76:  MOVFF  01,FE1
07C7A:  MOVLW  06
07C7C:  MOVWF  01
07C7E:  MOVFF  FE6,FEE
07C82:  DECFSZ 01,F
07C84:  BRA    7C7E
....................  
....................     telemetry_time.pcib_time = current_time; 
07C86:  MOVFF  3E,E6
07C8A:  MOVFF  3D,E5
07C8E:  MOVFF  3C,E4
07C92:  MOVFF  3B,E3
....................     memcpy(telemetry.pcib_message, &pcib_telemetry, sizeof(telemetry.pcib_message)); 
07C96:  CLRF   FEA
07C98:  MOVLW  9F
07C9A:  MOVWF  FE9
07C9C:  MOVLW  0C
07C9E:  MOVWF  FE2
07CA0:  MOVLW  3D
07CA2:  MOVWF  FE1
07CA4:  MOVLW  0A
07CA6:  MOVWF  01
07CA8:  MOVFF  FE6,FEE
07CAC:  DECFSZ 01,F
07CAE:  BRA    7CA8
....................  
....................     // Monitor and fix on/off status: 
....................     if (sband_tx_status != packet->sband_tx_status) { 
07CB0:  MOVLW  04
07CB2:  ADDWF  x3B,W
07CB4:  MOVWF  FE9
07CB6:  MOVLW  00
07CB8:  ADDWFC x3C,W
07CBA:  MOVWF  FEA
07CBC:  MOVF   FEF,W
07CBE:  MOVLB  8
07CC0:  SUBWF  xAA,W
07CC2:  BZ    7D52
....................         fprintf(PC, " Stx -> %d", sband_tx_status); 
07CC4:  MOVLW  B8
07CC6:  MOVWF  FF6
07CC8:  MOVLW  19
07CCA:  MOVWF  FF7
07CCC:  MOVLW  00
07CCE:  MOVWF  FF8
07CD0:  MOVLW  08
07CD2:  MOVLB  C
07CD4:  MOVWF  xC1
07CD6:  MOVLB  0
07CD8:  CALL   5290
07CDC:  MOVFF  8AA,CBE
07CE0:  MOVLW  18
07CE2:  MOVLB  C
07CE4:  MOVWF  xBF
07CE6:  MOVLB  0
07CE8:  CALL   73A8
....................         struct packet_s_tx { 
....................             uint8_t origin;         // 0xC0 
....................             uint8_t command;        // 0x5E 
....................             uint8_t enable_disable; // 0 = disabled, 1 = enabled 
....................             uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................         } packet_s_tx; 
....................         packet_s_tx.origin = 0xC0; 
07CEC:  MOVLW  C0
07CEE:  MOVLB  C
07CF0:  MOVWF  x47
....................         packet_s_tx.command = 0x5E; 
07CF2:  MOVLW  5E
07CF4:  MOVWF  x48
....................         packet_s_tx.enable_disable = sband_tx_status; 
07CF6:  MOVFF  8AA,C49
....................         memset(packet_s_tx.padding, 0, sizeof(packet_s_tx.padding)); 
07CFA:  MOVLW  0C
07CFC:  MOVWF  FEA
07CFE:  MOVLW  4A
07D00:  MOVWF  FE9
07D02:  CLRF   00
07D04:  CLRF   02
07D06:  MOVLW  21
07D08:  MOVWF  01
07D0A:  MOVLB  0
07D0C:  CALL   5222
....................         vschedule(current_time + i++, (uint8_t*)&packet_s_tx); 
07D10:  MOVLB  C
07D12:  MOVF   x3A,W
07D14:  INCF   x3A,F
07D16:  ADDWF  3B,W
07D18:  MOVWF  x8F
07D1A:  MOVLW  00
07D1C:  ADDWFC 3C,W
07D1E:  MOVWF  x90
07D20:  MOVLW  00
07D22:  ADDWFC 3D,W
07D24:  MOVWF  x91
07D26:  MOVLW  00
07D28:  ADDWFC 3E,W
07D2A:  MOVWF  x92
07D2C:  MOVLW  0C
07D2E:  MOVWF  x94
07D30:  MOVLW  47
07D32:  MOVWF  x93
07D34:  MOVFF  C92,C98
07D38:  MOVFF  C91,C97
07D3C:  MOVFF  C90,C96
07D40:  MOVFF  C8F,C95
07D44:  MOVFF  C94,C9A
07D48:  MOVWF  x99
07D4A:  MOVLB  0
07D4C:  CALL   704C
07D50:  MOVLB  8
....................     } 
....................     if (rpi_status != packet->rpi_status) { 
07D52:  MOVLW  05
07D54:  MOVLB  C
07D56:  ADDWF  x3B,W
07D58:  MOVWF  FE9
07D5A:  MOVLW  00
07D5C:  ADDWFC x3C,W
07D5E:  MOVWF  FEA
07D60:  MOVF   FEF,W
07D62:  MOVLB  8
07D64:  SUBWF  xAB,W
07D66:  BZ    7DF6
....................         fprintf(PC, " Rpi -> %d", rpi_status); 
07D68:  MOVLW  C4
07D6A:  MOVWF  FF6
07D6C:  MOVLW  19
07D6E:  MOVWF  FF7
07D70:  MOVLW  00
07D72:  MOVWF  FF8
07D74:  MOVLW  08
07D76:  MOVLB  C
07D78:  MOVWF  xC1
07D7A:  MOVLB  0
07D7C:  CALL   5290
07D80:  MOVFF  8AB,CBE
07D84:  MOVLW  18
07D86:  MOVLB  C
07D88:  MOVWF  xBF
07D8A:  MOVLB  0
07D8C:  CALL   73A8
....................         struct packet_rpi { 
....................             uint8_t origin; 
....................             uint8_t command; 
....................             uint8_t enable_disable; // 0 = disable, 1 = enable, 2 = warn 
....................             uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................         } packet_rpi; 
....................         packet_rpi.origin = 0xC0; 
07D90:  MOVLW  C0
07D92:  MOVLB  C
07D94:  MOVWF  x6B
....................         packet_rpi.command = 0xBE; 
07D96:  MOVLW  BE
07D98:  MOVWF  x6C
....................         packet_rpi.enable_disable = rpi_status; 
07D9A:  MOVFF  8AB,C6D
....................         memset(packet_rpi.padding, 0, sizeof(packet_rpi.padding)); 
07D9E:  MOVLW  0C
07DA0:  MOVWF  FEA
07DA2:  MOVLW  6E
07DA4:  MOVWF  FE9
07DA6:  CLRF   00
07DA8:  CLRF   02
07DAA:  MOVLW  21
07DAC:  MOVWF  01
07DAE:  MOVLB  0
07DB0:  CALL   5222
....................         vschedule(current_time + i++, (uint8_t*)&packet_rpi); 
07DB4:  MOVLB  C
07DB6:  MOVF   x3A,W
07DB8:  INCF   x3A,F
07DBA:  ADDWF  3B,W
07DBC:  MOVWF  x8F
07DBE:  MOVLW  00
07DC0:  ADDWFC 3C,W
07DC2:  MOVWF  x90
07DC4:  MOVLW  00
07DC6:  ADDWFC 3D,W
07DC8:  MOVWF  x91
07DCA:  MOVLW  00
07DCC:  ADDWFC 3E,W
07DCE:  MOVWF  x92
07DD0:  MOVLW  0C
07DD2:  MOVWF  x94
07DD4:  MOVLW  6B
07DD6:  MOVWF  x93
07DD8:  MOVFF  C92,C98
07DDC:  MOVFF  C91,C97
07DE0:  MOVFF  C90,C96
07DE4:  MOVFF  C8F,C95
07DE8:  MOVFF  C94,C9A
07DEC:  MOVWF  x99
07DEE:  MOVLB  0
07DF0:  CALL   704C
07DF4:  MOVLB  8
....................     } 
....................  
....................     return 0; 
07DF6:  MOVLW  00
07DF8:  MOVWF  01
07DFA:  MOVLB  0
07DFC:  GOTO   187E6 (RETURN)
.................... } 
....................  
.................... uint8_t command_tmcr1_telemetry(uint8_t* data) 
*
07AB2:  MOVFF  C39,C3B
07AB6:  MOVFF  C38,C3A
.................... { 
....................     enum { length = MSG_LENGTH_TMCR1 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         uint8_t fill[length - 4]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     (void)packet; // TODO remove 
....................  
....................     response_rx = 1; // Received a reply 
07ABA:  MOVLW  01
07ABC:  MOVLB  7
07ABE:  MOVWF  x50
....................  
....................     fprintf(PC, "TMCR1: "); 
07AC0:  MOVLW  D0
07AC2:  MOVWF  FF6
07AC4:  MOVLW  19
07AC6:  MOVWF  FF7
07AC8:  MOVLW  00
07ACA:  MOVWF  FF8
07ACC:  MOVLB  0
07ACE:  CALL   4534
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_TMCR1); 
07AD2:  MOVFF  C39,C90
07AD6:  MOVFF  C38,C8F
07ADA:  MOVLW  24
07ADC:  MOVLB  C
07ADE:  MOVWF  x91
07AE0:  MOVLB  0
07AE2:  RCALL  7A5C
....................  
....................     // TODO write TMCR1 data to telemetry 
....................  
....................     return 0; 
07AE4:  MOVLW  00
07AE6:  MOVWF  01
07AE8:  GOTO   187BE (RETURN)
.................... } 
....................  
.................... uint8_t command_tmcr2_telemetry(uint8_t* data) 
07AEC:  MOVFF  C39,C3B
07AF0:  MOVFF  C38,C3A
.................... { 
....................     enum { length = MSG_LENGTH_TMCR2 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         uint8_t fill[length - 4]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     (void)packet; // TODO remove 
....................  
....................     response_rx = 1; // Received a reply 
07AF4:  MOVLW  01
07AF6:  MOVLB  7
07AF8:  MOVWF  x50
....................  
....................     fprintf(PC, "TMCR2: "); 
07AFA:  MOVLW  D8
07AFC:  MOVWF  FF6
07AFE:  MOVLW  19
07B00:  MOVWF  FF7
07B02:  MOVLW  00
07B04:  MOVWF  FF8
07B06:  MOVLB  0
07B08:  CALL   4534
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_TMCR2); 
07B0C:  MOVFF  C39,C90
07B10:  MOVFF  C38,C8F
07B14:  MOVLW  24
07B16:  MOVLB  C
07B18:  MOVWF  x91
07B1A:  MOVLB  0
07B1C:  RCALL  7A5C
....................  
....................     // TODO write TMCR2 data to telemetry 
....................  
....................     return 0; 
07B1E:  MOVLW  00
07B20:  MOVWF  01
07B22:  GOTO   187D2 (RETURN)
.................... } 
....................  
.................... uint8_t command_raw_pcib(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
11F3A:  MOVLW  06
11F3C:  MOVLB  C
11F3E:  MOVWF  xBE
11F40:  MOVLB  0
11F42:  CALL   52E8
11F46:  MOVF   01,W
11F48:  SUBLW  06
11F4A:  BZ    11F6E
....................         if (verbose) { 
11F4C:  MOVLB  5
11F4E:  MOVF   x5A,F
11F50:  BZ    11F66
....................             fprintf(PC, "MUX change failed!"); 
11F52:  MOVLW  E0
11F54:  MOVWF  FF6
11F56:  MOVLW  19
11F58:  MOVWF  FF7
11F5A:  MOVLW  00
11F5C:  MOVWF  FF8
11F5E:  MOVLB  0
11F60:  CALL   4534
11F64:  MOVLB  5
....................         } 
....................         return 1; 
11F66:  MOVLW  01
11F68:  MOVWF  01
11F6A:  BRA    1208E
11F6C:  MOVLB  0
....................     } 
....................     enum { cmd_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t pcib_command[cmd_size]; 
....................     }* packet = (struct packet*)data; 
11F6E:  MOVFF  C39,C3B
11F72:  MOVFF  C38,C3A
....................  
....................     if (packet->pcib_command[0] == 0xBE) { 
11F76:  MOVLW  02
11F78:  MOVLB  C
11F7A:  ADDWF  x3A,W
11F7C:  MOVWF  FE9
11F7E:  MOVLW  00
11F80:  ADDWFC x3B,W
11F82:  MOVWF  FEA
11F84:  MOVF   FEF,W
11F86:  SUBLW  BE
11F88:  BNZ   11F9C
....................         rpi_status = packet->pcib_command[1]; 
11F8A:  MOVLW  03
11F8C:  ADDWF  x3A,W
11F8E:  MOVWF  FE9
11F90:  MOVLW  00
11F92:  ADDWFC x3B,W
11F94:  MOVWF  FEA
11F96:  MOVFF  FEF,8AB
....................     } else if (packet->pcib_command[0] == 0x5E) { 
11F9A:  BRA    11FBE
11F9C:  MOVLW  02
11F9E:  ADDWF  x3A,W
11FA0:  MOVWF  FE9
11FA2:  MOVLW  00
11FA4:  ADDWFC x3B,W
11FA6:  MOVWF  FEA
11FA8:  MOVF   FEF,W
11FAA:  SUBLW  5E
11FAC:  BNZ   11FBE
....................         sband_tx_status = packet->pcib_command[1]; 
11FAE:  MOVLW  03
11FB0:  ADDWF  x3A,W
11FB2:  MOVWF  FE9
11FB4:  MOVLW  00
11FB6:  ADDWFC x3B,W
11FB8:  MOVWF  FEA
11FBA:  MOVFF  FEF,8AA
....................     } 
....................  
....................     uint8_t pcib_cmd[MSG_LENGTH_PCIB] = { 0 }; 
11FBE:  CLRF   x3C
11FC0:  CLRF   x3D
11FC2:  CLRF   x3E
11FC4:  CLRF   x3F
11FC6:  CLRF   x40
11FC8:  CLRF   x41
11FCA:  CLRF   x42
11FCC:  CLRF   x43
11FCE:  CLRF   x44
11FD0:  CLRF   x45
11FD2:  CLRF   x46
11FD4:  CLRF   x47
11FD6:  CLRF   x48
11FD8:  CLRF   x49
11FDA:  CLRF   x4A
11FDC:  CLRF   x4B
11FDE:  CLRF   x4C
11FE0:  CLRF   x4D
11FE2:  CLRF   x4E
11FE4:  CLRF   x4F
11FE6:  CLRF   x50
11FE8:  CLRF   x51
11FEA:  CLRF   x52
11FEC:  CLRF   x53
11FEE:  CLRF   x54
11FF0:  CLRF   x55
11FF2:  CLRF   x56
11FF4:  CLRF   x57
11FF6:  CLRF   x58
11FF8:  CLRF   x59
11FFA:  CLRF   x5A
11FFC:  CLRF   x5B
11FFE:  CLRF   x5C
12000:  CLRF   x5D
12002:  CLRF   x5E
12004:  CLRF   x5F
....................     pcib_cmd[0] = 0x0B; 
12006:  MOVLW  0B
12008:  MOVWF  x3C
....................     memcpy(pcib_cmd + 1, packet->pcib_command, cmd_size); 
1200A:  MOVLW  02
1200C:  ADDWF  x3A,W
1200E:  MOVWF  01
12010:  MOVLW  00
12012:  ADDWFC x3B,W
12014:  MOVWF  03
12016:  MOVFF  01,C60
1201A:  MOVWF  x61
1201C:  MOVLW  0C
1201E:  MOVWF  FEA
12020:  MOVLW  3D
12022:  MOVWF  FE9
12024:  MOVFF  03,FE2
12028:  MOVFF  01,FE1
1202C:  MOVLW  08
1202E:  MOVWF  01
12030:  MOVFF  FE6,FEE
12034:  DECFSZ 01,F
12036:  BRA    12030
....................     checksum_obc(pcib_cmd, MSG_LENGTH_PCIB); 
12038:  MOVLW  0C
1203A:  MOVWF  xAF
1203C:  MOVLW  3C
1203E:  MOVWF  xAE
12040:  MOVLW  24
12042:  MOVWF  xB0
12044:  MOVLB  0
12046:  CALL   8E80
....................     uart_send_packet_repeat(&uart_port_MSN, pcib_cmd, MSG_LENGTH_PCIB, 5, 10); 
1204A:  MOVLW  0A
1204C:  MOVLB  C
1204E:  MOVWF  xAF
12050:  MOVLW  97
12052:  MOVWF  xAE
12054:  MOVLW  0C
12056:  MOVWF  xB1
12058:  MOVLW  3C
1205A:  MOVWF  xB0
1205C:  CLRF   xB5
1205E:  CLRF   xB4
12060:  CLRF   xB3
12062:  MOVLW  24
12064:  MOVWF  xB2
12066:  MOVLW  05
12068:  MOVWF  xB6
1206A:  CLRF   xBA
1206C:  CLRF   xB9
1206E:  CLRF   xB8
12070:  MOVLW  0A
12072:  MOVWF  xB7
12074:  MOVLB  0
12076:  CALL   8F3C
....................     return packet->pcib_command[0]; 
1207A:  MOVLW  02
1207C:  MOVLB  C
1207E:  ADDWF  x3A,W
12080:  MOVWF  FE9
12082:  MOVLW  00
12084:  ADDWFC x3B,W
12086:  MOVWF  FEA
12088:  MOVFF  FEF,01
1208C:  MOVLB  5
1208E:  MOVLB  0
12090:  GOTO   18D28 (RETURN)
.................... } 
....................  
.................... uint8_t command_raw_tmcr(uint8_t* data) 
12094:  MOVFF  C39,C3B
12098:  MOVFF  C38,C3A
.................... { 
....................     enum { cmd_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t tmcr_command[cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if(packet->command == 0xCE) { 
1209C:  MOVLW  01
1209E:  MOVLB  C
120A0:  ADDWF  x3A,W
120A2:  MOVWF  FE9
120A4:  MOVLW  00
120A6:  ADDWFC x3B,W
120A8:  MOVWF  FEA
120AA:  MOVF   FEF,W
120AC:  SUBLW  CE
120AE:  BNZ   120E6
....................         if (mux_sel(mux_tmcr1) != mux_tmcr1) { // If MUX did not change 
120B0:  MOVLW  01
120B2:  MOVWF  xBE
120B4:  MOVLB  0
120B6:  CALL   52E8
120BA:  DECFSZ 01,W
120BC:  BRA    120C0
120BE:  BRA    120E2
....................             if (verbose) { 
120C0:  MOVLB  5
120C2:  MOVF   x5A,F
120C4:  BZ    120DA
....................                 fprintf(PC, "MUX change failed!"); 
120C6:  MOVLW  F4
120C8:  MOVWF  FF6
120CA:  MOVLW  19
120CC:  MOVWF  FF7
120CE:  MOVLW  00
120D0:  MOVWF  FF8
120D2:  MOVLB  0
120D4:  CALL   4534
120D8:  MOVLB  5
....................             } 
....................             return 1; 
120DA:  MOVLW  01
120DC:  MOVWF  01
120DE:  BRA    12216
120E0:  MOVLB  0
....................         } 
....................     } else if(packet->command == 0xCF) { 
120E2:  BRA    1214A
120E4:  MOVLB  C
120E6:  MOVLW  01
120E8:  ADDWF  x3A,W
120EA:  MOVWF  FE9
120EC:  MOVLW  00
120EE:  ADDWFC x3B,W
120F0:  MOVWF  FEA
120F2:  MOVF   FEF,W
120F4:  SUBLW  CF
120F6:  BNZ   1212E
....................         if (mux_sel(mux_tmcr2) != mux_tmcr2) { // If MUX did not change 
120F8:  MOVLW  03
120FA:  MOVWF  xBE
120FC:  MOVLB  0
120FE:  CALL   52E8
12102:  MOVF   01,W
12104:  SUBLW  03
12106:  BZ    1212A
....................             if (verbose) { 
12108:  MOVLB  5
1210A:  MOVF   x5A,F
1210C:  BZ    12122
....................                 fprintf(PC, "MUX change failed!"); 
1210E:  MOVLW  08
12110:  MOVWF  FF6
12112:  MOVLW  1A
12114:  MOVWF  FF7
12116:  MOVLW  00
12118:  MOVWF  FF8
1211A:  MOVLB  0
1211C:  CALL   4534
12120:  MOVLB  5
....................             } 
....................             return 1; 
12122:  MOVLW  01
12124:  MOVWF  01
12126:  BRA    12216
12128:  MOVLB  0
....................         } 
....................     } else { 
1212A:  BRA    1214A
1212C:  MOVLB  C
....................         fprintf(PC, "Unexpected command ID!"); 
1212E:  MOVLW  1C
12130:  MOVWF  FF6
12132:  MOVLW  1A
12134:  MOVWF  FF7
12136:  MOVLW  00
12138:  MOVWF  FF8
1213A:  MOVLB  0
1213C:  CALL   4534
....................         return -1; 
12140:  MOVLW  FF
12142:  MOVWF  01
12144:  MOVLB  5
12146:  BRA    12216
12148:  MOVLB  0
....................     } 
....................  
....................     uint8_t tmcr_cmd[MSG_LENGTH_TMCR1] = { 0 }; 
1214A:  MOVLB  C
1214C:  CLRF   x3C
1214E:  CLRF   x3D
12150:  CLRF   x3E
12152:  CLRF   x3F
12154:  CLRF   x40
12156:  CLRF   x41
12158:  CLRF   x42
1215A:  CLRF   x43
1215C:  CLRF   x44
1215E:  CLRF   x45
12160:  CLRF   x46
12162:  CLRF   x47
12164:  CLRF   x48
12166:  CLRF   x49
12168:  CLRF   x4A
1216A:  CLRF   x4B
1216C:  CLRF   x4C
1216E:  CLRF   x4D
12170:  CLRF   x4E
12172:  CLRF   x4F
12174:  CLRF   x50
12176:  CLRF   x51
12178:  CLRF   x52
1217A:  CLRF   x53
1217C:  CLRF   x54
1217E:  CLRF   x55
12180:  CLRF   x56
12182:  CLRF   x57
12184:  CLRF   x58
12186:  CLRF   x59
12188:  CLRF   x5A
1218A:  CLRF   x5B
1218C:  CLRF   x5C
1218E:  CLRF   x5D
12190:  CLRF   x5E
12192:  CLRF   x5F
....................     tmcr_cmd[0] = 0x0B; 
12194:  MOVLW  0B
12196:  MOVWF  x3C
....................     memcpy(tmcr_cmd + 1, packet->tmcr_command, cmd_size); 
12198:  MOVLW  02
1219A:  ADDWF  x3A,W
1219C:  MOVWF  x60
1219E:  MOVLW  00
121A0:  ADDWFC x3B,W
121A2:  MOVWF  x61
121A4:  MOVLW  0C
121A6:  MOVWF  FEA
121A8:  MOVLW  3D
121AA:  MOVWF  FE9
121AC:  MOVFF  C61,FE2
121B0:  MOVFF  C60,FE1
121B4:  MOVLW  08
121B6:  MOVWF  01
121B8:  MOVFF  FE6,FEE
121BC:  DECFSZ 01,F
121BE:  BRA    121B8
....................     checksum_obc(tmcr_cmd, MSG_LENGTH_TMCR1); 
121C0:  MOVLW  0C
121C2:  MOVWF  xAF
121C4:  MOVLW  3C
121C6:  MOVWF  xAE
121C8:  MOVLW  24
121CA:  MOVWF  xB0
121CC:  MOVLB  0
121CE:  CALL   8E80
....................     uart_send_packet_repeat(&uart_port_MSN, tmcr_cmd, MSG_LENGTH_TMCR1, 5, 10); 
121D2:  MOVLW  0A
121D4:  MOVLB  C
121D6:  MOVWF  xAF
121D8:  MOVLW  97
121DA:  MOVWF  xAE
121DC:  MOVLW  0C
121DE:  MOVWF  xB1
121E0:  MOVLW  3C
121E2:  MOVWF  xB0
121E4:  CLRF   xB5
121E6:  CLRF   xB4
121E8:  CLRF   xB3
121EA:  MOVLW  24
121EC:  MOVWF  xB2
121EE:  MOVLW  05
121F0:  MOVWF  xB6
121F2:  CLRF   xBA
121F4:  CLRF   xB9
121F6:  CLRF   xB8
121F8:  MOVLW  0A
121FA:  MOVWF  xB7
121FC:  MOVLB  0
121FE:  CALL   8F3C
....................     return packet->tmcr_command[0]; 
12202:  MOVLW  02
12204:  MOVLB  C
12206:  ADDWF  x3A,W
12208:  MOVWF  FE9
1220A:  MOVLW  00
1220C:  ADDWFC x3B,W
1220E:  MOVWF  FEA
12210:  MOVFF  FEF,01
12214:  MOVLB  5
12216:  MOVLB  0
12218:  RETURN 0
.................... } 
....................  
.................... // Revert s-band configuration command 
.................... uint8_t command_sband_defaults(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
12AE4:  MOVLW  06
12AE6:  MOVLB  C
12AE8:  MOVWF  xBE
12AEA:  MOVLB  0
12AEC:  CALL   52E8
12AF0:  MOVF   01,W
12AF2:  SUBLW  06
12AF4:  BZ    12B18
....................         if (verbose) { 
12AF6:  MOVLB  5
12AF8:  MOVF   x5A,F
12AFA:  BZ    12B10
....................             fprintf(PC, "MUX change failed!"); 
12AFC:  MOVLW  34
12AFE:  MOVWF  FF6
12B00:  MOVLW  1A
12B02:  MOVWF  FF7
12B04:  MOVLW  00
12B06:  MOVWF  FF8
12B08:  MOVLB  0
12B0A:  CALL   4534
12B0E:  MOVLB  5
....................         } 
....................         return 1; 
12B10:  MOVLW  01
12B12:  MOVWF  01
12B14:  BRA    12BF2
12B16:  MOVLB  0
....................     } 
....................     fprintf(PC, "Reverting s-band configuration... "); 
12B18:  MOVLW  48
12B1A:  MOVWF  FF6
12B1C:  MOVLW  1A
12B1E:  MOVWF  FF7
12B20:  MOVLW  00
12B22:  MOVWF  FF8
12B24:  CALL   4534
....................     uint8_t pcib_pkg[MSG_LENGTH_PCIB] = { 0 }; 
12B28:  MOVLB  C
12B2A:  CLRF   x3A
12B2C:  CLRF   x3B
12B2E:  CLRF   x3C
12B30:  CLRF   x3D
12B32:  CLRF   x3E
12B34:  CLRF   x3F
12B36:  CLRF   x40
12B38:  CLRF   x41
12B3A:  CLRF   x42
12B3C:  CLRF   x43
12B3E:  CLRF   x44
12B40:  CLRF   x45
12B42:  CLRF   x46
12B44:  CLRF   x47
12B46:  CLRF   x48
12B48:  CLRF   x49
12B4A:  CLRF   x4A
12B4C:  CLRF   x4B
12B4E:  CLRF   x4C
12B50:  CLRF   x4D
12B52:  CLRF   x4E
12B54:  CLRF   x4F
12B56:  CLRF   x50
12B58:  CLRF   x51
12B5A:  CLRF   x52
12B5C:  CLRF   x53
12B5E:  CLRF   x54
12B60:  CLRF   x55
12B62:  CLRF   x56
12B64:  CLRF   x57
12B66:  CLRF   x58
12B68:  CLRF   x59
12B6A:  CLRF   x5A
12B6C:  CLRF   x5B
12B6E:  CLRF   x5C
12B70:  CLRF   x5D
....................     memset(pcib_pkg, 0, MSG_LENGTH_PCIB); 
12B72:  MOVLW  0C
12B74:  MOVWF  FEA
12B76:  MOVLW  3A
12B78:  MOVWF  FE9
12B7A:  CLRF   00
12B7C:  CLRF   02
12B7E:  MOVLW  24
12B80:  MOVWF  01
12B82:  MOVLB  0
12B84:  CALL   5222
....................     memcpy(pcib_pkg, data, 10); 
12B88:  MOVLW  0C
12B8A:  MOVWF  FEA
12B8C:  MOVLW  3A
12B8E:  MOVWF  FE9
12B90:  MOVFF  C39,FE2
12B94:  MOVFF  C38,FE1
12B98:  MOVLW  0A
12B9A:  MOVWF  01
12B9C:  MOVFF  FE6,FEE
12BA0:  DECFSZ 01,F
12BA2:  BRA    12B9C
....................     pcib_pkg[0] = MSG_OBC; 
12BA4:  MOVLW  0B
12BA6:  MOVLB  C
12BA8:  MOVWF  x3A
....................     checksum_obc(pcib_pkg, MSG_LENGTH_PCIB); 
12BAA:  MOVLW  0C
12BAC:  MOVWF  xAF
12BAE:  MOVLW  3A
12BB0:  MOVWF  xAE
12BB2:  MOVLW  24
12BB4:  MOVWF  xB0
12BB6:  MOVLB  0
12BB8:  CALL   8E80
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, pcib_pkg, MSG_LENGTH_PCIB, 5, 10); 
12BBC:  MOVLW  0A
12BBE:  MOVLB  C
12BC0:  MOVWF  xAF
12BC2:  MOVLW  97
12BC4:  MOVWF  xAE
12BC6:  MOVLW  0C
12BC8:  MOVWF  xB1
12BCA:  MOVLW  3A
12BCC:  MOVWF  xB0
12BCE:  CLRF   xB5
12BD0:  CLRF   xB4
12BD2:  CLRF   xB3
12BD4:  MOVLW  24
12BD6:  MOVWF  xB2
12BD8:  MOVLW  05
12BDA:  MOVWF  xB6
12BDC:  CLRF   xBA
12BDE:  CLRF   xB9
12BE0:  CLRF   xB8
12BE2:  MOVLW  0A
12BE4:  MOVWF  xB7
12BE6:  MOVLB  0
12BE8:  CALL   8F3C
....................  
....................     return 0; 
12BEC:  MOVLW  00
12BEE:  MOVWF  01
12BF0:  MOVLB  5
12BF2:  MOVLB  0
12BF4:  GOTO   18E48 (RETURN)
.................... } 
....................  
.................... uint8_t command_sband_downlink(uint8_t* data) 
.................... { 
....................     enum { param_size = 12 }; 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
13DB0:  MOVLW  06
13DB2:  MOVLB  C
13DB4:  MOVWF  xBE
13DB6:  MOVLB  0
13DB8:  CALL   52E8
13DBC:  MOVF   01,W
13DBE:  SUBLW  06
13DC0:  BZ    13DE4
....................         if (verbose) { 
13DC2:  MOVLB  5
13DC4:  MOVF   x5A,F
13DC6:  BZ    13DDC
....................             fprintf(PC, "MUX change failed!"); 
13DC8:  MOVLW  6C
13DCA:  MOVWF  FF6
13DCC:  MOVLW  1A
13DCE:  MOVWF  FF7
13DD0:  MOVLW  00
13DD2:  MOVWF  FF8
13DD4:  MOVLB  0
13DD6:  CALL   4534
13DDA:  MOVLB  5
....................         } 
....................         return 1; 
13DDC:  MOVLW  01
13DDE:  MOVWF  01
13DE0:  BRA    1446C
13DE2:  MOVLB  0
....................     } 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xED 
....................         time_t scheduled_time; 
....................         uint8_t mission_parameters[param_size]; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 18]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     const uint8_t rpi_turn_on_time = 60;  // in seconds 
....................     const uint8_t sband_warm_up_time = 1; // in seconds 
....................  
....................     uint16_t bit_offset = 0; 
....................  
....................     uint16_t downlink_timeout = get_bits(packet->mission_parameters, &bit_offset, 10); 
....................     uint8_t adcs_mode = get_bits(packet->mission_parameters, &bit_offset, 5); 
13DE4:  MOVFF  C39,C3B
13DE8:  MOVFF  C38,C3A
13DEC:  MOVLB  C
13DEE:  CLRF   x3D
13DF0:  CLRF   x3C
13DF2:  MOVLW  06
13DF4:  ADDWF  x3A,W
13DF6:  MOVWF  01
13DF8:  MOVLW  00
13DFA:  ADDWFC x3B,W
13DFC:  MOVWF  03
13DFE:  MOVFF  01,C5A
13E02:  MOVWF  x5B
13E04:  MOVWF  x78
13E06:  MOVFF  01,C77
13E0A:  MOVLW  0C
13E0C:  MOVWF  x7A
13E0E:  MOVLW  3C
13E10:  MOVWF  x79
13E12:  MOVLW  0A
13E14:  MOVWF  x7B
13E16:  MOVLB  0
13E18:  CALL   EED4
13E1C:  MOVFF  01,C3F
13E20:  MOVFF  00,C3E
13E24:  MOVLW  06
13E26:  MOVLB  C
13E28:  ADDWF  x3A,W
13E2A:  MOVWF  01
13E2C:  MOVLW  00
13E2E:  ADDWFC x3B,W
13E30:  MOVWF  03
13E32:  MOVFF  01,C5A
13E36:  MOVWF  x5B
13E38:  MOVWF  x78
13E3A:  MOVFF  01,C77
13E3E:  MOVLW  0C
13E40:  MOVWF  x7A
13E42:  MOVLW  3C
13E44:  MOVWF  x79
13E46:  MOVLW  05
13E48:  MOVWF  x7B
13E4A:  MOVLB  0
13E4C:  CALL   EED4
13E50:  MOVFF  00,C40
....................  
....................     downlink_timeout = downlink_timeout ? downlink_timeout : 300; // in seconds; if zero, 300 seconds 
13E54:  MOVLB  C
13E56:  MOVF   x3E,W
13E58:  IORWF  x3F,W
13E5A:  BZ    13E64
13E5C:  MOVFF  C3F,03
13E60:  MOVF   x3E,W
13E62:  BRA    13E6A
13E64:  MOVLW  01
13E66:  MOVWF  03
13E68:  MOVLW  2C
13E6A:  MOVWF  x3E
13E6C:  MOVFF  03,C3F
....................  
....................     // If not zero, convert and print the scheduled time 
....................     if(packet->scheduled_time) { 
13E70:  MOVLW  02
13E72:  ADDWF  x3A,W
13E74:  MOVWF  FE9
13E76:  MOVLW  00
13E78:  ADDWFC x3B,W
13E7A:  MOVWF  FEA
13E7C:  MOVF   FEF,F
13E7E:  BNZ   13E8E
13E80:  MOVF   FEC,F
13E82:  BNZ   13E8E
13E84:  MOVF   FEC,F
13E86:  BNZ   13E8E
13E88:  MOVF   FEC,F
13E8A:  BTFSC  FD8.2
13E8C:  BRA    140FE
....................         fprintf(PC, "\r\n"); 
13E8E:  MOVLW  0D
13E90:  MOVLB  D
13E92:  MOVWF  x6A
13E94:  MOVLB  0
13E96:  CALL   44EE
13E9A:  MOVLW  0A
13E9C:  MOVLB  D
13E9E:  MOVWF  x6A
13EA0:  MOVLB  0
13EA2:  CALL   44EE
....................  
....................         struct tm* local_time = localtime(&packet->scheduled_time); 
13EA6:  MOVLW  02
13EA8:  MOVLB  C
13EAA:  ADDWF  x3A,W
13EAC:  MOVWF  01
13EAE:  MOVLW  00
13EB0:  ADDWFC x3B,W
13EB2:  MOVWF  03
13EB4:  MOVFF  01,C5A
13EB8:  MOVWF  x5B
13EBA:  MOVWF  x84
13EBC:  MOVFF  01,C83
13EC0:  MOVLB  0
13EC2:  CALL   4D28
13EC6:  MOVFF  02,C42
13ECA:  MOVFF  01,C41
....................         fprintf(PC, "Scheduled Time: %04ld/%02d/%02d %02d:%02d:%02d (0x%08lX)\r\n", 
....................             local_time->tm_year + 1900, 
....................             local_time->tm_mon + 1, 
....................             local_time->tm_mday, 
....................             local_time->tm_hour, 
....................             local_time->tm_min, 
....................             local_time->tm_sec, 
....................             (uint32_t)packet->scheduled_time); // 32 bits 
13ECE:  MOVLW  05
13ED0:  MOVLB  C
13ED2:  ADDWF  x41,W
13ED4:  MOVWF  FE9
13ED6:  MOVLW  00
13ED8:  ADDWFC x42,W
13EDA:  MOVWF  FEA
13EDC:  MOVFF  FEC,C5B
13EE0:  MOVF   FED,F
13EE2:  MOVFF  FEF,C5A
13EE6:  MOVLW  6C
13EE8:  ADDWF  x5A,F
13EEA:  MOVLW  07
13EEC:  ADDWFC x5B,F
13EEE:  MOVLW  04
13EF0:  ADDWF  x41,W
13EF2:  MOVWF  FE9
13EF4:  MOVLW  00
13EF6:  ADDWFC x42,W
13EF8:  MOVWF  FEA
13EFA:  MOVLW  01
13EFC:  ADDWF  FEF,W
13EFE:  MOVWF  x5C
13F00:  MOVLW  03
13F02:  ADDWF  x41,W
13F04:  MOVWF  FE9
13F06:  MOVLW  00
13F08:  ADDWFC x42,W
13F0A:  MOVWF  FEA
13F0C:  MOVFF  FEF,C5D
13F10:  MOVLW  02
13F12:  ADDWF  x41,W
13F14:  MOVWF  FE9
13F16:  MOVLW  00
13F18:  ADDWFC x42,W
13F1A:  MOVWF  FEA
13F1C:  MOVFF  FEF,C5E
13F20:  MOVLW  01
13F22:  ADDWF  x41,W
13F24:  MOVWF  FE9
13F26:  MOVLW  00
13F28:  ADDWFC x42,W
13F2A:  MOVWF  FEA
13F2C:  MOVFF  FEF,C5F
13F30:  MOVFF  C41,FE9
13F34:  MOVFF  C42,FEA
13F38:  MOVFF  FEF,C60
13F3C:  MOVLW  02
13F3E:  ADDWF  x3A,W
13F40:  MOVWF  FE9
13F42:  MOVLW  00
13F44:  ADDWFC x3B,W
13F46:  MOVWF  FEA
13F48:  MOVFF  FEF,C61
13F4C:  MOVFF  FEC,C62
13F50:  MOVFF  FEC,C63
13F54:  MOVFF  FEC,C64
13F58:  MOVLW  80
13F5A:  MOVWF  FF6
13F5C:  MOVLW  1A
13F5E:  MOVWF  FF7
13F60:  MOVLW  00
13F62:  MOVWF  FF8
13F64:  MOVLW  10
13F66:  MOVWF  xC1
13F68:  MOVLB  0
13F6A:  CALL   5290
13F6E:  MOVLW  0A
13F70:  MOVWF  FE9
13F72:  MOVFF  C5B,C66
13F76:  MOVFF  C5A,C65
13F7A:  CALL   7894
13F7E:  MOVLW  2F
13F80:  MOVLB  D
13F82:  MOVWF  x6A
13F84:  MOVLB  0
13F86:  CALL   44EE
13F8A:  MOVFF  C5C,C65
13F8E:  MOVLW  01
13F90:  MOVLB  C
13F92:  MOVWF  x66
13F94:  MOVLB  0
13F96:  CALL   7994
13F9A:  MOVLW  2F
13F9C:  MOVLB  D
13F9E:  MOVWF  x6A
13FA0:  MOVLB  0
13FA2:  CALL   44EE
13FA6:  MOVFF  C5D,C65
13FAA:  MOVLW  01
13FAC:  MOVLB  C
13FAE:  MOVWF  x66
13FB0:  MOVLB  0
13FB2:  CALL   7994
13FB6:  MOVLW  20
13FB8:  MOVLB  D
13FBA:  MOVWF  x6A
13FBC:  MOVLB  0
13FBE:  CALL   44EE
13FC2:  MOVFF  C5E,C65
13FC6:  MOVLW  01
13FC8:  MOVLB  C
13FCA:  MOVWF  x66
13FCC:  MOVLB  0
13FCE:  CALL   7994
13FD2:  MOVLW  3A
13FD4:  MOVLB  D
13FD6:  MOVWF  x6A
13FD8:  MOVLB  0
13FDA:  CALL   44EE
13FDE:  MOVFF  C5F,C65
13FE2:  MOVLW  01
13FE4:  MOVLB  C
13FE6:  MOVWF  x66
13FE8:  MOVLB  0
13FEA:  CALL   7994
13FEE:  MOVLW  3A
13FF0:  MOVLB  D
13FF2:  MOVWF  x6A
13FF4:  MOVLB  0
13FF6:  CALL   44EE
13FFA:  MOVFF  C60,C65
13FFE:  MOVLW  01
14000:  MOVLB  C
14002:  MOVWF  x66
14004:  MOVLB  0
14006:  CALL   7994
1400A:  MOVLW  AE
1400C:  MOVWF  FF6
1400E:  MOVLW  1A
14010:  MOVWF  FF7
14012:  MOVLW  00
14014:  MOVWF  FF8
14016:  MOVLW  04
14018:  MOVLB  C
1401A:  MOVWF  xC1
1401C:  MOVLB  0
1401E:  CALL   5290
14022:  MOVFF  C64,CBF
14026:  MOVLW  37
14028:  MOVLB  C
1402A:  MOVWF  xC0
1402C:  MOVLB  0
1402E:  CALL   5A92
14032:  MOVFF  C63,CBF
14036:  MOVLW  37
14038:  MOVLB  C
1403A:  MOVWF  xC0
1403C:  MOVLB  0
1403E:  CALL   5A92
14042:  MOVFF  C62,CBF
14046:  MOVLW  37
14048:  MOVLB  C
1404A:  MOVWF  xC0
1404C:  MOVLB  0
1404E:  CALL   5A92
14052:  MOVFF  C61,CBF
14056:  MOVLW  37
14058:  MOVLB  C
1405A:  MOVWF  xC0
1405C:  MOVLB  0
1405E:  CALL   5A92
14062:  MOVLW  B7
14064:  MOVWF  FF6
14066:  MOVLW  1A
14068:  MOVWF  FF7
1406A:  MOVLW  00
1406C:  MOVWF  FF8
1406E:  MOVLW  03
14070:  MOVLB  C
14072:  MOVWF  xC1
14074:  MOVLB  0
14076:  CALL   5290
....................  
....................         // Print the deserialized values for verification 
....................         fprintf(PC, "Downlink Timeout: %lu\r\n", downlink_timeout); // 16 bits 
1407A:  MOVLW  BC
1407C:  MOVWF  FF6
1407E:  MOVLW  1A
14080:  MOVWF  FF7
14082:  MOVLW  00
14084:  MOVWF  FF8
14086:  MOVLW  12
14088:  MOVLB  C
1408A:  MOVWF  xC1
1408C:  MOVLB  0
1408E:  CALL   5290
14092:  MOVLW  10
14094:  MOVWF  FE9
14096:  MOVFF  C3F,C76
1409A:  MOVFF  C3E,C75
1409E:  CALL   59CA
140A2:  MOVLW  0D
140A4:  MOVLB  D
140A6:  MOVWF  x6A
140A8:  MOVLB  0
140AA:  CALL   44EE
140AE:  MOVLW  0A
140B0:  MOVLB  D
140B2:  MOVWF  x6A
140B4:  MOVLB  0
140B6:  CALL   44EE
....................         fprintf(PC, "ADCS Mode: %u\r\n", adcs_mode);                // 8 bits 
140BA:  MOVLW  D4
140BC:  MOVWF  FF6
140BE:  MOVLW  1A
140C0:  MOVWF  FF7
140C2:  MOVLW  00
140C4:  MOVWF  FF8
140C6:  MOVLW  0B
140C8:  MOVLB  C
140CA:  MOVWF  xC1
140CC:  MOVLB  0
140CE:  CALL   5290
140D2:  MOVFF  C40,C78
140D6:  MOVLW  1B
140D8:  MOVLB  C
140DA:  MOVWF  x79
140DC:  MOVLB  0
140DE:  CALL   5ADC
140E2:  MOVLW  0D
140E4:  MOVLB  D
140E6:  MOVWF  x6A
140E8:  MOVLB  0
140EA:  CALL   44EE
140EE:  MOVLW  0A
140F0:  MOVLB  D
140F2:  MOVWF  x6A
140F4:  MOVLB  0
140F6:  CALL   44EE
....................     } else { 
140FA:  BRA    14110
140FC:  MOVLB  C
....................         fprintf(PC, "Starting s-band downlink routine.\r\n"); 
140FE:  MOVLW  E4
14100:  MOVWF  FF6
14102:  MOVLW  1A
14104:  MOVWF  FF7
14106:  MOVLW  00
14108:  MOVWF  FF8
1410A:  MOVLB  0
1410C:  CALL   4534
....................     } 
....................  
....................     if (packet->scheduled_time != 0) { 
14110:  MOVLW  02
14112:  MOVLB  C
14114:  ADDWF  x3A,W
14116:  MOVWF  FE9
14118:  MOVLW  00
1411A:  ADDWFC x3B,W
1411C:  MOVWF  FEA
1411E:  MOVFF  FEF,C5A
14122:  MOVFF  FEC,C5B
14126:  MOVFF  FEC,C5C
1412A:  MOVFF  FEC,C5D
1412E:  MOVF   x5A,F
14130:  BNZ   14140
14132:  MOVF   x5B,F
14134:  BNZ   14140
14136:  MOVF   x5C,F
14138:  BNZ   14140
1413A:  MOVF   x5D,F
1413C:  BTFSC  FD8.2
1413E:  BRA    14262
....................         time_t scheduled_time = packet->scheduled_time - rpi_turn_on_time - sband_warm_up_time; 
14140:  MOVLW  02
14142:  ADDWF  x3A,W
14144:  MOVWF  FE9
14146:  MOVLW  00
14148:  ADDWFC x3B,W
1414A:  MOVWF  FEA
1414C:  MOVFF  FEF,C5A
14150:  MOVFF  FEC,C5B
14154:  MOVFF  FEC,C5C
14158:  MOVFF  FEC,C5D
1415C:  MOVLW  3C
1415E:  SUBWF  x5A,F
14160:  MOVLW  00
14162:  SUBWFB x5B,F
14164:  SUBWFB x5C,F
14166:  SUBWFB x5D,F
14168:  MOVLW  01
1416A:  SUBWF  x5A,W
1416C:  MOVWF  x43
1416E:  MOVLW  00
14170:  SUBWFB x5B,W
14172:  MOVWF  x44
14174:  MOVLW  00
14176:  SUBWFB x5C,W
14178:  MOVWF  x45
1417A:  MOVLW  00
1417C:  SUBWFB x5D,W
1417E:  MOVWF  x46
....................         packet->scheduled_time = 0; 
14180:  MOVLW  02
14182:  ADDWF  x3A,W
14184:  MOVWF  FE9
14186:  MOVLW  00
14188:  ADDWFC x3B,W
1418A:  MOVWF  FEA
1418C:  CLRF   FEF
1418E:  CLRF   FEC
14190:  CLRF   FEC
14192:  CLRF   FEC
....................         vschedule(scheduled_time, data); // Scheduling itself with time set as zero 
14194:  MOVFF  C46,C98
14198:  MOVFF  C45,C97
1419C:  MOVFF  C44,C96
141A0:  MOVFF  C43,C95
141A4:  MOVFF  C39,C9A
141A8:  MOVFF  C38,C99
141AC:  MOVLB  0
141AE:  CALL   704C
....................         if (adcs_mode) { 
141B2:  MOVLB  C
141B4:  MOVF   x40,F
141B6:  BZ    14246
....................             struct adcs_mode_st { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint8_t mode; 
....................                 uint8_t permanent; 
....................             } adcs_mode_st; 
....................             adcs_mode_st.origin = MSG_COMM; 
141B8:  MOVLW  C0
141BA:  MOVWF  x47
....................             adcs_mode_st.command = 0xAD; 
141BC:  MOVLW  AD
141BE:  MOVWF  x48
....................             adcs_mode_st.mode = adcs_mode; 
141C0:  MOVFF  C40,C49
....................             adcs_mode_st.permanent = false; 
141C4:  CLRF   x4A
....................             vschedule(scheduled_time - 3 * 60 * 60, (uint8_t*)&adcs_mode_st); // ADCS nadir camera 3 hours before 
141C6:  MOVLW  30
141C8:  SUBWF  x43,W
141CA:  MOVWF  x5A
141CC:  MOVLW  2A
141CE:  SUBWFB x44,W
141D0:  MOVWF  x5B
141D2:  MOVLW  00
141D4:  SUBWFB x45,W
141D6:  MOVWF  x5C
141D8:  MOVLW  00
141DA:  SUBWFB x46,W
141DC:  MOVWF  x5D
141DE:  MOVLW  0C
141E0:  MOVWF  x5F
141E2:  MOVLW  47
141E4:  MOVWF  x5E
141E6:  MOVFF  C5D,C98
141EA:  MOVFF  C5C,C97
141EE:  MOVFF  C5B,C96
141F2:  MOVFF  C5A,C95
141F6:  MOVFF  C5F,C9A
141FA:  MOVWF  x99
141FC:  MOVLB  0
141FE:  CALL   704C
....................             adcs_mode_st.mode = obc_flags.adcs_initial_value; 
14202:  MOVFF  104,C49
....................             vschedule(scheduled_time + 10 * 60, (uint8_t*)&adcs_mode_st); // ADCS back to default mode after 10m 
14206:  MOVLW  58
14208:  MOVLB  C
1420A:  ADDWF  x43,W
1420C:  MOVWF  x5A
1420E:  MOVLW  02
14210:  ADDWFC x44,W
14212:  MOVWF  x5B
14214:  MOVLW  00
14216:  ADDWFC x45,W
14218:  MOVWF  x5C
1421A:  MOVLW  00
1421C:  ADDWFC x46,W
1421E:  MOVWF  x5D
14220:  MOVLW  0C
14222:  MOVWF  x5F
14224:  MOVLW  47
14226:  MOVWF  x5E
14228:  MOVFF  C5D,C98
1422C:  MOVFF  C5C,C97
14230:  MOVFF  C5B,C96
14234:  MOVFF  C5A,C95
14238:  MOVFF  C5F,C9A
1423C:  MOVWF  x99
1423E:  MOVLB  0
14240:  CALL   704C
14244:  MOVLB  C
....................         } 
....................         fprintf(PC, "Scheduling s-band DL command."); 
14246:  MOVLW  08
14248:  MOVWF  FF6
1424A:  MOVLW  1B
1424C:  MOVWF  FF7
1424E:  MOVLW  00
14250:  MOVWF  FF8
14252:  MOVLB  0
14254:  CALL   4534
....................         return 0; 
14258:  MOVLW  00
1425A:  MOVWF  01
1425C:  MOVLB  5
1425E:  BRA    1446C
14260:  MOVLB  C
....................     } 
....................  
....................     packet->command = 0xEE; 
14262:  MOVLW  01
14264:  ADDWF  x3A,W
14266:  MOVWF  FE9
14268:  MOVLW  00
1426A:  ADDWFC x3B,W
1426C:  MOVWF  FEA
1426E:  MOVLW  EE
14270:  MOVWF  FEF
....................  
....................     schedule(current_time + 2, { 0xC0, 0xBE, 0x01 });                                                             // Turn on Rpi 
14272:  MOVLW  C0
14274:  MOVWF  x4B
14276:  MOVLW  BE
14278:  MOVWF  x4C
1427A:  MOVLW  01
1427C:  MOVWF  x4D
1427E:  MOVLW  02
14280:  ADDWF  3B,W
14282:  MOVWF  x5A
14284:  MOVLW  00
14286:  ADDWFC 3C,W
14288:  MOVWF  x5B
1428A:  MOVLW  00
1428C:  ADDWFC 3D,W
1428E:  MOVWF  x5C
14290:  MOVLW  00
14292:  ADDWFC 3E,W
14294:  MOVWF  x5D
14296:  MOVWF  x98
14298:  MOVFF  C5C,C97
1429C:  MOVFF  C5B,C96
142A0:  MOVFF  C5A,C95
142A4:  MOVLW  0C
142A6:  MOVWF  x9A
142A8:  MOVLW  4B
142AA:  MOVWF  x99
142AC:  MOVLB  0
142AE:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time, { 0xC0, 0x5E, 0x01 });                                              // Turn on S-band TX 
142B2:  MOVLW  C0
142B4:  MOVLB  C
142B6:  MOVWF  x4E
142B8:  MOVLW  5E
142BA:  MOVWF  x4F
142BC:  MOVLW  01
142BE:  MOVWF  x50
142C0:  MOVLW  3C
142C2:  ADDWF  3B,W
142C4:  MOVWF  x5A
142C6:  MOVLW  00
142C8:  ADDWFC 3C,W
142CA:  MOVWF  x5B
142CC:  MOVLW  00
142CE:  ADDWFC 3D,W
142D0:  MOVWF  x5C
142D2:  MOVLW  00
142D4:  ADDWFC 3E,W
142D6:  MOVWF  x5D
142D8:  MOVWF  x98
142DA:  MOVFF  C5C,C97
142DE:  MOVFF  C5B,C96
142E2:  MOVFF  C5A,C95
142E6:  MOVLW  0C
142E8:  MOVWF  x9A
142EA:  MOVLW  4E
142EC:  MOVWF  x99
142EE:  MOVLB  0
142F0:  CALL   704C
....................     vschedule(current_time + rpi_turn_on_time + sband_warm_up_time, data);                                        // Downlink command 
142F4:  MOVLW  3C
142F6:  ADDWF  3B,W
142F8:  MOVLB  C
142FA:  MOVWF  x5A
142FC:  MOVLW  00
142FE:  ADDWFC 3C,W
14300:  MOVWF  x5B
14302:  MOVLW  00
14304:  ADDWFC 3D,W
14306:  MOVWF  x5C
14308:  MOVLW  00
1430A:  ADDWFC 3E,W
1430C:  MOVWF  x5D
1430E:  MOVLW  01
14310:  ADDWF  x5A,F
14312:  MOVLW  00
14314:  ADDWFC x5B,F
14316:  ADDWFC x5C,F
14318:  ADDWFC x5D,F
1431A:  MOVFF  C5D,C98
1431E:  MOVFF  C5C,C97
14322:  MOVFF  C5B,C96
14326:  MOVFF  C5A,C95
1432A:  MOVFF  C39,C9A
1432E:  MOVFF  C38,C99
14332:  MOVLB  0
14334:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + sband_warm_up_time + downlink_timeout, { 0xC0, 0x5E, 0x00 });      // Turn off S-band TX 
14338:  MOVLW  C0
1433A:  MOVLB  C
1433C:  MOVWF  x51
1433E:  MOVLW  5E
14340:  MOVWF  x52
14342:  CLRF   x53
14344:  MOVLW  3C
14346:  ADDWF  3B,W
14348:  MOVWF  x5A
1434A:  MOVLW  00
1434C:  ADDWFC 3C,W
1434E:  MOVWF  x5B
14350:  MOVLW  00
14352:  ADDWFC 3D,W
14354:  MOVWF  x5C
14356:  MOVLW  00
14358:  ADDWFC 3E,W
1435A:  MOVWF  x5D
1435C:  MOVLW  01
1435E:  ADDWF  x5A,F
14360:  MOVLW  00
14362:  ADDWFC x5B,F
14364:  ADDWFC x5C,F
14366:  ADDWFC x5D,F
14368:  MOVF   x3E,W
1436A:  ADDWF  x5A,F
1436C:  MOVF   x3F,W
1436E:  ADDWFC x5B,F
14370:  MOVLW  00
14372:  ADDWFC x5C,F
14374:  ADDWFC x5D,F
14376:  MOVFF  C5D,C98
1437A:  MOVFF  C5C,C97
1437E:  MOVFF  C5B,C96
14382:  MOVFF  C5A,C95
14386:  MOVLW  0C
14388:  MOVWF  x9A
1438A:  MOVLW  51
1438C:  MOVWF  x99
1438E:  MOVLB  0
14390:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + sband_warm_up_time + downlink_timeout + 1, { 0xC0, 0xBE, 0x02 });  // Turn off Rpi (soft) 
14394:  MOVLW  C0
14396:  MOVLB  C
14398:  MOVWF  x54
1439A:  MOVLW  BE
1439C:  MOVWF  x55
1439E:  MOVLW  02
143A0:  MOVWF  x56
143A2:  MOVLW  3C
143A4:  ADDWF  3B,W
143A6:  MOVWF  x5A
143A8:  MOVLW  00
143AA:  ADDWFC 3C,W
143AC:  MOVWF  x5B
143AE:  MOVLW  00
143B0:  ADDWFC 3D,W
143B2:  MOVWF  x5C
143B4:  MOVLW  00
143B6:  ADDWFC 3E,W
143B8:  MOVWF  x5D
143BA:  MOVLW  01
143BC:  ADDWF  x5A,F
143BE:  MOVLW  00
143C0:  ADDWFC x5B,F
143C2:  ADDWFC x5C,F
143C4:  ADDWFC x5D,F
143C6:  MOVF   x3E,W
143C8:  ADDWF  x5A,F
143CA:  MOVF   x3F,W
143CC:  ADDWFC x5B,F
143CE:  MOVLW  00
143D0:  ADDWFC x5C,F
143D2:  ADDWFC x5D,F
143D4:  MOVLW  01
143D6:  ADDWF  x5A,F
143D8:  MOVLW  00
143DA:  ADDWFC x5B,F
143DC:  ADDWFC x5C,F
143DE:  ADDWFC x5D,F
143E0:  MOVFF  C5D,C98
143E4:  MOVFF  C5C,C97
143E8:  MOVFF  C5B,C96
143EC:  MOVFF  C5A,C95
143F0:  MOVLW  0C
143F2:  MOVWF  x9A
143F4:  MOVLW  54
143F6:  MOVWF  x99
143F8:  MOVLB  0
143FA:  CALL   704C
....................     schedule(current_time + rpi_turn_on_time + sband_warm_up_time + downlink_timeout + 21, { 0xC0, 0xBE, 0x00 }); // Turn off Rpi (hard) 
143FE:  MOVLW  C0
14400:  MOVLB  C
14402:  MOVWF  x57
14404:  MOVLW  BE
14406:  MOVWF  x58
14408:  CLRF   x59
1440A:  MOVLW  3C
1440C:  ADDWF  3B,W
1440E:  MOVWF  x5A
14410:  MOVLW  00
14412:  ADDWFC 3C,W
14414:  MOVWF  x5B
14416:  MOVLW  00
14418:  ADDWFC 3D,W
1441A:  MOVWF  x5C
1441C:  MOVLW  00
1441E:  ADDWFC 3E,W
14420:  MOVWF  x5D
14422:  MOVLW  01
14424:  ADDWF  x5A,F
14426:  MOVLW  00
14428:  ADDWFC x5B,F
1442A:  ADDWFC x5C,F
1442C:  ADDWFC x5D,F
1442E:  MOVF   x3E,W
14430:  ADDWF  x5A,F
14432:  MOVF   x3F,W
14434:  ADDWFC x5B,F
14436:  MOVLW  00
14438:  ADDWFC x5C,F
1443A:  ADDWFC x5D,F
1443C:  MOVLW  15
1443E:  ADDWF  x5A,F
14440:  MOVLW  00
14442:  ADDWFC x5B,F
14444:  ADDWFC x5C,F
14446:  ADDWFC x5D,F
14448:  MOVFF  C5D,C98
1444C:  MOVFF  C5C,C97
14450:  MOVFF  C5B,C96
14454:  MOVFF  C5A,C95
14458:  MOVLW  0C
1445A:  MOVWF  x9A
1445C:  MOVLW  57
1445E:  MOVWF  x99
14460:  MOVLB  0
14462:  CALL   704C
....................  
....................     return 0; 
14466:  MOVLW  00
14468:  MOVWF  01
1446A:  MOVLB  5
1446C:  MOVLB  0
1446E:  GOTO   18E90 (RETURN)
.................... } 
....................  
.................... // End to end test command 
.................... uint8_t command_sband_end_to_end(uint8_t* data) 
.................... { 
....................     enum { param_size = 12 }; 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
14472:  MOVLW  06
14474:  MOVLB  C
14476:  MOVWF  xBE
14478:  MOVLB  0
1447A:  CALL   52E8
1447E:  MOVF   01,W
14480:  SUBLW  06
14482:  BZ    144A6
....................         if (verbose) { 
14484:  MOVLB  5
14486:  MOVF   x5A,F
14488:  BZ    1449E
....................             fprintf(PC, "MUX change failed!"); 
1448A:  MOVLW  26
1448C:  MOVWF  FF6
1448E:  MOVLW  1B
14490:  MOVWF  FF7
14492:  MOVLW  00
14494:  MOVWF  FF8
14496:  MOVLB  0
14498:  CALL   4534
1449C:  MOVLB  5
....................         } 
....................         return 1; 
1449E:  MOVLW  01
144A0:  MOVWF  01
144A2:  BRA    14C34
144A4:  MOVLB  0
....................     } 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xEE 
....................         time_t scheduled_time; 
....................         uint8_t mission_parameters[param_size]; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 18]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint16_t bit_offset = 0; 
....................  
....................     uint16_t downlink_timeout = get_bits(packet->mission_parameters, &bit_offset, 10); 
....................     uint8_t adcs_mode = get_bits(packet->mission_parameters, &bit_offset, 5); 
....................     uint16_t file_number = get_bits(packet->mission_parameters, &bit_offset, 16); 
....................     uint16_t first_packet = get_bits(packet->mission_parameters, &bit_offset, 16); 
....................     uint16_t end_packet = get_bits(packet->mission_parameters, &bit_offset, 16); 
....................     uint8_t number_of_repetitions = get_bits(packet->mission_parameters, &bit_offset, 5); 
....................     uint8_t bitrate = get_bits(packet->mission_parameters, &bit_offset, 3); 
....................     uint8_t power = get_bits(packet->mission_parameters, &bit_offset, 1); 
....................     uint8_t delay_before_tx = get_bits(packet->mission_parameters, &bit_offset, 6); 
....................     uint8_t image_seq_start = get_bits(packet->mission_parameters, &bit_offset, 6); 
....................     uint8_t image_seq_end = get_bits(packet->mission_parameters, &bit_offset, 6); 
....................     uint8_t type = get_bits(packet->mission_parameters, &bit_offset, 3); 
....................     uint8_t camera_selection = get_bits(packet->mission_parameters, &bit_offset, 3); 
144A6:  MOVFF  C39,C3B
144AA:  MOVFF  C38,C3A
144AE:  MOVLB  C
144B0:  CLRF   x3D
144B2:  CLRF   x3C
144B4:  MOVLW  06
144B6:  ADDWF  x3A,W
144B8:  MOVWF  01
144BA:  MOVLW  00
144BC:  ADDWFC x3B,W
144BE:  MOVWF  03
144C0:  MOVFF  01,C75
144C4:  MOVWF  x76
144C6:  MOVWF  x78
144C8:  MOVFF  01,C77
144CC:  MOVLW  0C
144CE:  MOVWF  x7A
144D0:  MOVLW  3C
144D2:  MOVWF  x79
144D4:  MOVLW  0A
144D6:  MOVWF  x7B
144D8:  MOVLB  0
144DA:  CALL   EED4
144DE:  MOVFF  01,C3F
144E2:  MOVFF  00,C3E
144E6:  MOVLW  06
144E8:  MOVLB  C
144EA:  ADDWF  x3A,W
144EC:  MOVWF  01
144EE:  MOVLW  00
144F0:  ADDWFC x3B,W
144F2:  MOVWF  03
144F4:  MOVFF  01,C75
144F8:  MOVWF  x76
144FA:  MOVWF  x78
144FC:  MOVFF  01,C77
14500:  MOVLW  0C
14502:  MOVWF  x7A
14504:  MOVLW  3C
14506:  MOVWF  x79
14508:  MOVLW  05
1450A:  MOVWF  x7B
1450C:  MOVLB  0
1450E:  CALL   EED4
14512:  MOVFF  00,C40
14516:  MOVLW  06
14518:  MOVLB  C
1451A:  ADDWF  x3A,W
1451C:  MOVWF  01
1451E:  MOVLW  00
14520:  ADDWFC x3B,W
14522:  MOVWF  03
14524:  MOVFF  01,C75
14528:  MOVWF  x76
1452A:  MOVWF  x78
1452C:  MOVFF  01,C77
14530:  MOVLW  0C
14532:  MOVWF  x7A
14534:  MOVLW  3C
14536:  MOVWF  x79
14538:  MOVLW  10
1453A:  MOVWF  x7B
1453C:  MOVLB  0
1453E:  CALL   EED4
14542:  MOVFF  01,C42
14546:  MOVFF  00,C41
1454A:  MOVLW  06
1454C:  MOVLB  C
1454E:  ADDWF  x3A,W
14550:  MOVWF  01
14552:  MOVLW  00
14554:  ADDWFC x3B,W
14556:  MOVWF  03
14558:  MOVFF  01,C75
1455C:  MOVWF  x76
1455E:  MOVWF  x78
14560:  MOVFF  01,C77
14564:  MOVLW  0C
14566:  MOVWF  x7A
14568:  MOVLW  3C
1456A:  MOVWF  x79
1456C:  MOVLW  10
1456E:  MOVWF  x7B
14570:  MOVLB  0
14572:  CALL   EED4
14576:  MOVFF  01,C44
1457A:  MOVFF  00,C43
1457E:  MOVLW  06
14580:  MOVLB  C
14582:  ADDWF  x3A,W
14584:  MOVWF  01
14586:  MOVLW  00
14588:  ADDWFC x3B,W
1458A:  MOVWF  03
1458C:  MOVFF  01,C75
14590:  MOVWF  x76
14592:  MOVWF  x78
14594:  MOVFF  01,C77
14598:  MOVLW  0C
1459A:  MOVWF  x7A
1459C:  MOVLW  3C
1459E:  MOVWF  x79
145A0:  MOVLW  10
145A2:  MOVWF  x7B
145A4:  MOVLB  0
145A6:  CALL   EED4
145AA:  MOVFF  01,C46
145AE:  MOVFF  00,C45
145B2:  MOVLW  06
145B4:  MOVLB  C
145B6:  ADDWF  x3A,W
145B8:  MOVWF  01
145BA:  MOVLW  00
145BC:  ADDWFC x3B,W
145BE:  MOVWF  03
145C0:  MOVFF  01,C75
145C4:  MOVWF  x76
145C6:  MOVWF  x78
145C8:  MOVFF  01,C77
145CC:  MOVLW  0C
145CE:  MOVWF  x7A
145D0:  MOVLW  3C
145D2:  MOVWF  x79
145D4:  MOVLW  05
145D6:  MOVWF  x7B
145D8:  MOVLB  0
145DA:  CALL   EED4
145DE:  MOVFF  00,C47
145E2:  MOVLW  06
145E4:  MOVLB  C
145E6:  ADDWF  x3A,W
145E8:  MOVWF  01
145EA:  MOVLW  00
145EC:  ADDWFC x3B,W
145EE:  MOVWF  03
145F0:  MOVFF  01,C75
145F4:  MOVWF  x76
145F6:  MOVWF  x78
145F8:  MOVFF  01,C77
145FC:  MOVLW  0C
145FE:  MOVWF  x7A
14600:  MOVLW  3C
14602:  MOVWF  x79
14604:  MOVLW  03
14606:  MOVWF  x7B
14608:  MOVLB  0
1460A:  CALL   EED4
1460E:  MOVFF  00,C48
14612:  MOVLW  06
14614:  MOVLB  C
14616:  ADDWF  x3A,W
14618:  MOVWF  01
1461A:  MOVLW  00
1461C:  ADDWFC x3B,W
1461E:  MOVWF  03
14620:  MOVFF  01,C75
14624:  MOVWF  x76
14626:  MOVWF  x78
14628:  MOVFF  01,C77
1462C:  MOVLW  0C
1462E:  MOVWF  x7A
14630:  MOVLW  3C
14632:  MOVWF  x79
14634:  MOVLW  01
14636:  MOVWF  x7B
14638:  MOVLB  0
1463A:  CALL   EED4
1463E:  MOVFF  00,C49
14642:  MOVLW  06
14644:  MOVLB  C
14646:  ADDWF  x3A,W
14648:  MOVWF  01
1464A:  MOVLW  00
1464C:  ADDWFC x3B,W
1464E:  MOVWF  03
14650:  MOVFF  01,C75
14654:  MOVWF  x76
14656:  MOVWF  x78
14658:  MOVFF  01,C77
1465C:  MOVLW  0C
1465E:  MOVWF  x7A
14660:  MOVLW  3C
14662:  MOVWF  x79
14664:  MOVLW  06
14666:  MOVWF  x7B
14668:  MOVLB  0
1466A:  CALL   EED4
1466E:  MOVFF  00,C4A
14672:  MOVLW  06
14674:  MOVLB  C
14676:  ADDWF  x3A,W
14678:  MOVWF  01
1467A:  MOVLW  00
1467C:  ADDWFC x3B,W
1467E:  MOVWF  03
14680:  MOVFF  01,C75
14684:  MOVWF  x76
14686:  MOVWF  x78
14688:  MOVFF  01,C77
1468C:  MOVLW  0C
1468E:  MOVWF  x7A
14690:  MOVLW  3C
14692:  MOVWF  x79
14694:  MOVLW  06
14696:  MOVWF  x7B
14698:  MOVLB  0
1469A:  CALL   EED4
1469E:  MOVFF  00,C4B
146A2:  MOVLW  06
146A4:  MOVLB  C
146A6:  ADDWF  x3A,W
146A8:  MOVWF  01
146AA:  MOVLW  00
146AC:  ADDWFC x3B,W
146AE:  MOVWF  03
146B0:  MOVFF  01,C75
146B4:  MOVWF  x76
146B6:  MOVWF  x78
146B8:  MOVFF  01,C77
146BC:  MOVLW  0C
146BE:  MOVWF  x7A
146C0:  MOVLW  3C
146C2:  MOVWF  x79
146C4:  MOVLW  06
146C6:  MOVWF  x7B
146C8:  MOVLB  0
146CA:  CALL   EED4
146CE:  MOVFF  00,C4C
146D2:  MOVLW  06
146D4:  MOVLB  C
146D6:  ADDWF  x3A,W
146D8:  MOVWF  01
146DA:  MOVLW  00
146DC:  ADDWFC x3B,W
146DE:  MOVWF  03
146E0:  MOVFF  01,C75
146E4:  MOVWF  x76
146E6:  MOVWF  x78
146E8:  MOVFF  01,C77
146EC:  MOVLW  0C
146EE:  MOVWF  x7A
146F0:  MOVLW  3C
146F2:  MOVWF  x79
146F4:  MOVLW  03
146F6:  MOVWF  x7B
146F8:  MOVLB  0
146FA:  CALL   EED4
146FE:  MOVFF  00,C4D
14702:  MOVLW  06
14704:  MOVLB  C
14706:  ADDWF  x3A,W
14708:  MOVWF  01
1470A:  MOVLW  00
1470C:  ADDWFC x3B,W
1470E:  MOVWF  03
14710:  MOVFF  01,C75
14714:  MOVWF  x76
14716:  MOVWF  x78
14718:  MOVFF  01,C77
1471C:  MOVLW  0C
1471E:  MOVWF  x7A
14720:  MOVLW  3C
14722:  MOVWF  x79
14724:  MOVLW  03
14726:  MOVWF  x7B
14728:  MOVLB  0
1472A:  CALL   EED4
1472E:  MOVFF  00,C4E
....................  
....................     downlink_timeout = downlink_timeout ? downlink_timeout : 300; // in seconds; if zero, 300 seconds 
14732:  MOVLB  C
14734:  MOVF   x3E,W
14736:  IORWF  x3F,W
14738:  BZ    14742
1473A:  MOVFF  C3F,03
1473E:  MOVF   x3E,W
14740:  BRA    14748
14742:  MOVLW  01
14744:  MOVWF  03
14746:  MOVLW  2C
14748:  MOVWF  x3E
1474A:  MOVFF  03,C3F
....................  
....................     fprintf(PC, "\r\n"); 
1474E:  MOVLW  0D
14750:  MOVLB  D
14752:  MOVWF  x6A
14754:  MOVLB  0
14756:  CALL   44EE
1475A:  MOVLW  0A
1475C:  MOVLB  D
1475E:  MOVWF  x6A
14760:  MOVLB  0
14762:  CALL   44EE
....................  
....................     // Print the deserialized values for verification 
....................     fprintf(PC, "Downlink Timeout: %lu\r\n", downlink_timeout);          // 16 bits 
14766:  MOVLW  3A
14768:  MOVWF  FF6
1476A:  MOVLW  1B
1476C:  MOVWF  FF7
1476E:  MOVLW  00
14770:  MOVWF  FF8
14772:  MOVLW  12
14774:  MOVLB  C
14776:  MOVWF  xC1
14778:  MOVLB  0
1477A:  CALL   5290
1477E:  MOVLW  10
14780:  MOVWF  FE9
14782:  MOVFF  C3F,C76
14786:  MOVFF  C3E,C75
1478A:  CALL   59CA
1478E:  MOVLW  0D
14790:  MOVLB  D
14792:  MOVWF  x6A
14794:  MOVLB  0
14796:  CALL   44EE
1479A:  MOVLW  0A
1479C:  MOVLB  D
1479E:  MOVWF  x6A
147A0:  MOVLB  0
147A2:  CALL   44EE
....................     fprintf(PC, "ADCS Mode: %u\r\n", adcs_mode);                         // 8 bits 
147A6:  MOVLW  52
147A8:  MOVWF  FF6
147AA:  MOVLW  1B
147AC:  MOVWF  FF7
147AE:  MOVLW  00
147B0:  MOVWF  FF8
147B2:  MOVLW  0B
147B4:  MOVLB  C
147B6:  MOVWF  xC1
147B8:  MOVLB  0
147BA:  CALL   5290
147BE:  MOVFF  C40,C78
147C2:  MOVLW  1B
147C4:  MOVLB  C
147C6:  MOVWF  x79
147C8:  MOVLB  0
147CA:  CALL   5ADC
147CE:  MOVLW  0D
147D0:  MOVLB  D
147D2:  MOVWF  x6A
147D4:  MOVLB  0
147D6:  CALL   44EE
147DA:  MOVLW  0A
147DC:  MOVLB  D
147DE:  MOVWF  x6A
147E0:  MOVLB  0
147E2:  CALL   44EE
....................     fprintf(PC, "File Number: %lu\r\n", file_number);                    // 16 bits 
147E6:  MOVLW  62
147E8:  MOVWF  FF6
147EA:  MOVLW  1B
147EC:  MOVWF  FF7
147EE:  MOVLW  00
147F0:  MOVWF  FF8
147F2:  MOVLW  0D
147F4:  MOVLB  C
147F6:  MOVWF  xC1
147F8:  MOVLB  0
147FA:  CALL   5290
147FE:  MOVLW  10
14800:  MOVWF  FE9
14802:  MOVFF  C42,C76
14806:  MOVFF  C41,C75
1480A:  CALL   59CA
1480E:  MOVLW  0D
14810:  MOVLB  D
14812:  MOVWF  x6A
14814:  MOVLB  0
14816:  CALL   44EE
1481A:  MOVLW  0A
1481C:  MOVLB  D
1481E:  MOVWF  x6A
14820:  MOVLB  0
14822:  CALL   44EE
....................     fprintf(PC, "First Packet: %lu\r\n", first_packet);                  // 16 bits 
14826:  MOVLW  76
14828:  MOVWF  FF6
1482A:  MOVLW  1B
1482C:  MOVWF  FF7
1482E:  MOVLW  00
14830:  MOVWF  FF8
14832:  MOVLW  0E
14834:  MOVLB  C
14836:  MOVWF  xC1
14838:  MOVLB  0
1483A:  CALL   5290
1483E:  MOVLW  10
14840:  MOVWF  FE9
14842:  MOVFF  C44,C76
14846:  MOVFF  C43,C75
1484A:  CALL   59CA
1484E:  MOVLW  0D
14850:  MOVLB  D
14852:  MOVWF  x6A
14854:  MOVLB  0
14856:  CALL   44EE
1485A:  MOVLW  0A
1485C:  MOVLB  D
1485E:  MOVWF  x6A
14860:  MOVLB  0
14862:  CALL   44EE
....................     fprintf(PC, "End Packet: %lu\r\n", end_packet);                      // 16 bits 
14866:  MOVLW  8A
14868:  MOVWF  FF6
1486A:  MOVLW  1B
1486C:  MOVWF  FF7
1486E:  MOVLW  00
14870:  MOVWF  FF8
14872:  MOVLW  0C
14874:  MOVLB  C
14876:  MOVWF  xC1
14878:  MOVLB  0
1487A:  CALL   5290
1487E:  MOVLW  10
14880:  MOVWF  FE9
14882:  MOVFF  C46,C76
14886:  MOVFF  C45,C75
1488A:  CALL   59CA
1488E:  MOVLW  0D
14890:  MOVLB  D
14892:  MOVWF  x6A
14894:  MOVLB  0
14896:  CALL   44EE
1489A:  MOVLW  0A
1489C:  MOVLB  D
1489E:  MOVWF  x6A
148A0:  MOVLB  0
148A2:  CALL   44EE
....................     fprintf(PC, "Number of Repetitions: %u\r\n", number_of_repetitions); // 8 bits 
148A6:  MOVLW  9C
148A8:  MOVWF  FF6
148AA:  MOVLW  1B
148AC:  MOVWF  FF7
148AE:  MOVLW  00
148B0:  MOVWF  FF8
148B2:  MOVLW  17
148B4:  MOVLB  C
148B6:  MOVWF  xC1
148B8:  MOVLB  0
148BA:  CALL   5290
148BE:  MOVFF  C47,C78
148C2:  MOVLW  1B
148C4:  MOVLB  C
148C6:  MOVWF  x79
148C8:  MOVLB  0
148CA:  CALL   5ADC
148CE:  MOVLW  0D
148D0:  MOVLB  D
148D2:  MOVWF  x6A
148D4:  MOVLB  0
148D6:  CALL   44EE
148DA:  MOVLW  0A
148DC:  MOVLB  D
148DE:  MOVWF  x6A
148E0:  MOVLB  0
148E2:  CALL   44EE
....................  
....................     fprintf(PC, "Bitrate: "); 
148E6:  MOVLW  B8
148E8:  MOVWF  FF6
148EA:  MOVLW  1B
148EC:  MOVWF  FF7
148EE:  MOVLW  00
148F0:  MOVWF  FF8
148F2:  CALL   4534
....................     switch (bitrate) { 
148F6:  MOVLB  C
148F8:  MOVF   x48,W
148FA:  ADDLW  F8
148FC:  BC    149A8
148FE:  ADDLW  08
14900:  MOVLB  0
14902:  GOTO   14C3A
....................     case 0: fprintf(PC, "10kbps\r\n"); break; 
14906:  MOVLW  C2
14908:  MOVWF  FF6
1490A:  MOVLW  1B
1490C:  MOVWF  FF7
1490E:  MOVLW  00
14910:  MOVWF  FF8
14912:  CALL   4534
14916:  MOVLB  C
14918:  BRA    149A8
....................     case 1: fprintf(PC, "20kbps\r\n"); break; 
1491A:  MOVLW  CC
1491C:  MOVWF  FF6
1491E:  MOVLW  1B
14920:  MOVWF  FF7
14922:  MOVLW  00
14924:  MOVWF  FF8
14926:  CALL   4534
1492A:  MOVLB  C
1492C:  BRA    149A8
....................     case 2: fprintf(PC, "25kbps\r\n"); break; 
1492E:  MOVLW  D6
14930:  MOVWF  FF6
14932:  MOVLW  1B
14934:  MOVWF  FF7
14936:  MOVLW  00
14938:  MOVWF  FF8
1493A:  CALL   4534
1493E:  MOVLB  C
14940:  BRA    149A8
....................     case 3: fprintf(PC, "50kbps\r\n"); break; 
14942:  MOVLW  E0
14944:  MOVWF  FF6
14946:  MOVLW  1B
14948:  MOVWF  FF7
1494A:  MOVLW  00
1494C:  MOVWF  FF8
1494E:  CALL   4534
14952:  MOVLB  C
14954:  BRA    149A8
....................     case 4: fprintf(PC, "64kbps\r\n"); break; 
14956:  MOVLW  EA
14958:  MOVWF  FF6
1495A:  MOVLW  1B
1495C:  MOVWF  FF7
1495E:  MOVLW  00
14960:  MOVWF  FF8
14962:  CALL   4534
14966:  MOVLB  C
14968:  BRA    149A8
....................     case 5: fprintf(PC, "100kbps\r\n"); break; 
1496A:  MOVLW  F4
1496C:  MOVWF  FF6
1496E:  MOVLW  1B
14970:  MOVWF  FF7
14972:  MOVLW  00
14974:  MOVWF  FF8
14976:  CALL   4534
1497A:  MOVLB  C
1497C:  BRA    149A8
....................     case 6: fprintf(PC, "250kbps\r\n"); break; 
1497E:  MOVLW  FE
14980:  MOVWF  FF6
14982:  MOVLW  1B
14984:  MOVWF  FF7
14986:  MOVLW  00
14988:  MOVWF  FF8
1498A:  CALL   4534
1498E:  MOVLB  C
14990:  BRA    149A8
....................     case 7: fprintf(PC, "500kbps\r\n"); break; 
14992:  MOVLW  08
14994:  MOVWF  FF6
14996:  MOVLW  1C
14998:  MOVWF  FF7
1499A:  MOVLW  00
1499C:  MOVWF  FF8
1499E:  CALL   4534
149A2:  MOVLB  C
149A4:  BRA    149A8
149A6:  MOVLB  C
....................     } 
....................  
....................     fprintf(PC, "Power: %u\r\n", power);                      // 8 bits 
149A8:  MOVLW  12
149AA:  MOVWF  FF6
149AC:  MOVLW  1C
149AE:  MOVWF  FF7
149B0:  MOVLW  00
149B2:  MOVWF  FF8
149B4:  MOVLW  07
149B6:  MOVWF  xC1
149B8:  MOVLB  0
149BA:  CALL   5290
149BE:  MOVFF  C49,C78
149C2:  MOVLW  1B
149C4:  MOVLB  C
149C6:  MOVWF  x79
149C8:  MOVLB  0
149CA:  CALL   5ADC
149CE:  MOVLW  0D
149D0:  MOVLB  D
149D2:  MOVWF  x6A
149D4:  MOVLB  0
149D6:  CALL   44EE
149DA:  MOVLW  0A
149DC:  MOVLB  D
149DE:  MOVWF  x6A
149E0:  MOVLB  0
149E2:  CALL   44EE
....................     fprintf(PC, "Delay Before Tx: %u\r\n", delay_before_tx);  // 8 bits 
149E6:  MOVLW  1E
149E8:  MOVWF  FF6
149EA:  MOVLW  1C
149EC:  MOVWF  FF7
149EE:  MOVLW  00
149F0:  MOVWF  FF8
149F2:  MOVLW  11
149F4:  MOVLB  C
149F6:  MOVWF  xC1
149F8:  MOVLB  0
149FA:  CALL   5290
149FE:  MOVFF  C4A,C78
14A02:  MOVLW  1B
14A04:  MOVLB  C
14A06:  MOVWF  x79
14A08:  MOVLB  0
14A0A:  CALL   5ADC
14A0E:  MOVLW  0D
14A10:  MOVLB  D
14A12:  MOVWF  x6A
14A14:  MOVLB  0
14A16:  CALL   44EE
14A1A:  MOVLW  0A
14A1C:  MOVLB  D
14A1E:  MOVWF  x6A
14A20:  MOVLB  0
14A22:  CALL   44EE
....................     fprintf(PC, "Image seq. start: %u\r\n", image_seq_start); // 8 bits 
14A26:  MOVLW  34
14A28:  MOVWF  FF6
14A2A:  MOVLW  1C
14A2C:  MOVWF  FF7
14A2E:  MOVLW  00
14A30:  MOVWF  FF8
14A32:  MOVLW  12
14A34:  MOVLB  C
14A36:  MOVWF  xC1
14A38:  MOVLB  0
14A3A:  CALL   5290
14A3E:  MOVFF  C4B,C78
14A42:  MOVLW  1B
14A44:  MOVLB  C
14A46:  MOVWF  x79
14A48:  MOVLB  0
14A4A:  CALL   5ADC
14A4E:  MOVLW  0D
14A50:  MOVLB  D
14A52:  MOVWF  x6A
14A54:  MOVLB  0
14A56:  CALL   44EE
14A5A:  MOVLW  0A
14A5C:  MOVLB  D
14A5E:  MOVWF  x6A
14A60:  MOVLB  0
14A62:  CALL   44EE
....................     fprintf(PC, "Image seq. end: %u\r\n", image_seq_end);     // 8 bits 
14A66:  MOVLW  4C
14A68:  MOVWF  FF6
14A6A:  MOVLW  1C
14A6C:  MOVWF  FF7
14A6E:  MOVLW  00
14A70:  MOVWF  FF8
14A72:  MOVLW  10
14A74:  MOVLB  C
14A76:  MOVWF  xC1
14A78:  MOVLB  0
14A7A:  CALL   5290
14A7E:  MOVFF  C4C,C78
14A82:  MOVLW  1B
14A84:  MOVLB  C
14A86:  MOVWF  x79
14A88:  MOVLB  0
14A8A:  CALL   5ADC
14A8E:  MOVLW  0D
14A90:  MOVLB  D
14A92:  MOVWF  x6A
14A94:  MOVLB  0
14A96:  CALL   44EE
14A9A:  MOVLW  0A
14A9C:  MOVLB  D
14A9E:  MOVWF  x6A
14AA0:  MOVLB  0
14AA2:  CALL   44EE
....................     fprintf(PC, "Type: %u\r\n", type);                        // 8 bits 
14AA6:  MOVLW  62
14AA8:  MOVWF  FF6
14AAA:  MOVLW  1C
14AAC:  MOVWF  FF7
14AAE:  MOVLW  00
14AB0:  MOVWF  FF8
14AB2:  MOVLW  06
14AB4:  MOVLB  C
14AB6:  MOVWF  xC1
14AB8:  MOVLB  0
14ABA:  CALL   5290
14ABE:  MOVFF  C4D,C78
14AC2:  MOVLW  1B
14AC4:  MOVLB  C
14AC6:  MOVWF  x79
14AC8:  MOVLB  0
14ACA:  CALL   5ADC
14ACE:  MOVLW  0D
14AD0:  MOVLB  D
14AD2:  MOVWF  x6A
14AD4:  MOVLB  0
14AD6:  CALL   44EE
14ADA:  MOVLW  0A
14ADC:  MOVLB  D
14ADE:  MOVWF  x6A
14AE0:  MOVLB  0
14AE2:  CALL   44EE
....................     fprintf(PC, "Camera Selection: %u%u%u\r\n", 
....................         (camera_selection >> 2) & 0x1, 
....................         (camera_selection >> 1) & 0x1, 
....................         camera_selection & 0x1); // 3 bits 
14AE6:  MOVLB  C
14AE8:  RRCF   x4E,W
14AEA:  MOVWF  00
14AEC:  RRCF   00,F
14AEE:  MOVLW  3F
14AF0:  ANDWF  00,F
14AF2:  MOVF   00,W
14AF4:  ANDLW  01
14AF6:  MOVWF  x75
14AF8:  BCF    FD8.0
14AFA:  RRCF   x4E,W
14AFC:  ANDLW  01
14AFE:  MOVWF  x76
14B00:  MOVF   x4E,W
14B02:  ANDLW  01
14B04:  MOVWF  x77
14B06:  MOVLW  6E
14B08:  MOVWF  FF6
14B0A:  MOVLW  1C
14B0C:  MOVWF  FF7
14B0E:  MOVLW  00
14B10:  MOVWF  FF8
14B12:  MOVLW  12
14B14:  MOVWF  xC1
14B16:  MOVLB  0
14B18:  CALL   5290
14B1C:  MOVFF  C75,C78
14B20:  MOVLW  1B
14B22:  MOVLB  C
14B24:  MOVWF  x79
14B26:  MOVLB  0
14B28:  CALL   5ADC
14B2C:  MOVFF  C76,C78
14B30:  MOVLW  1B
14B32:  MOVLB  C
14B34:  MOVWF  x79
14B36:  MOVLB  0
14B38:  CALL   5ADC
14B3C:  MOVFF  C77,C78
14B40:  MOVLW  1B
14B42:  MOVLB  C
14B44:  MOVWF  x79
14B46:  MOVLB  0
14B48:  CALL   5ADC
14B4C:  MOVLW  0D
14B4E:  MOVLB  D
14B50:  MOVWF  x6A
14B52:  MOVLB  0
14B54:  CALL   44EE
14B58:  MOVLW  0A
14B5A:  MOVLB  D
14B5C:  MOVWF  x6A
14B5E:  MOVLB  0
14B60:  CALL   44EE
....................  
....................     struct sband_command { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mission_parameters[param_size]; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 14]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
14B64:  MOVLW  0C
14B66:  MOVLB  C
14B68:  MOVWF  x76
14B6A:  MOVLW  4F
14B6C:  MOVFF  C76,C74
14B70:  MOVWF  x73
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
14B72:  MOVFF  C74,FEA
14B76:  MOVFF  C73,FE9
14B7A:  CLRF   00
14B7C:  CLRF   02
14B7E:  MOVLW  24
14B80:  MOVWF  01
14B82:  MOVLB  0
14B84:  CALL   5222
....................     pcib_pkg.origin = MSG_OBC; 
14B88:  MOVLW  0B
14B8A:  MOVLB  C
14B8C:  MOVWF  x4F
....................     pcib_pkg.command = 0xEE; 
14B8E:  MOVLW  EE
14B90:  MOVWF  x50
....................     memcpy(pcib_pkg.mission_parameters, packet->mission_parameters, param_size); 
14B92:  MOVLW  06
14B94:  ADDWF  x3A,W
14B96:  MOVWF  01
14B98:  MOVLW  00
14B9A:  ADDWFC x3B,W
14B9C:  MOVWF  03
14B9E:  MOVFF  01,C75
14BA2:  MOVWF  x76
14BA4:  MOVLW  0C
14BA6:  MOVWF  FEA
14BA8:  MOVLW  51
14BAA:  MOVWF  FE9
14BAC:  MOVFF  03,FE2
14BB0:  MOVFF  01,FE1
14BB4:  MOVLW  0C
14BB6:  MOVWF  01
14BB8:  MOVFF  FE6,FEE
14BBC:  DECFSZ 01,F
14BBE:  BRA    14BB8
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
14BC0:  MOVFF  C74,CAF
14BC4:  MOVFF  C73,CAE
14BC8:  MOVLW  24
14BCA:  MOVWF  xB0
14BCC:  MOVLB  0
14BCE:  CALL   8E80
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
14BD2:  MOVFF  C74,C90
14BD6:  MOVFF  C73,C8F
14BDA:  MOVLW  24
14BDC:  MOVLB  C
14BDE:  MOVWF  x91
14BE0:  MOVLB  0
14BE2:  CALL   7A5C
....................  
....................     mux_lock_unlock(true, downlink_timeout); 
14BE6:  MOVLW  01
14BE8:  MOVLB  C
14BEA:  MOVWF  x82
14BEC:  CLRF   x86
14BEE:  CLRF   x85
14BF0:  MOVFF  C3F,C84
14BF4:  MOVFF  C3E,C83
14BF8:  MOVLB  0
14BFA:  CALL   7EB4
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); 
14BFE:  MOVLW  0A
14C00:  MOVLB  C
14C02:  MOVWF  xAF
14C04:  MOVLW  97
14C06:  MOVWF  xAE
14C08:  MOVFF  C74,CB1
14C0C:  MOVFF  C73,CB0
14C10:  CLRF   xB5
14C12:  CLRF   xB4
14C14:  CLRF   xB3
14C16:  MOVLW  24
14C18:  MOVWF  xB2
14C1A:  MOVLW  05
14C1C:  MOVWF  xB6
14C1E:  CLRF   xBA
14C20:  CLRF   xB9
14C22:  CLRF   xB8
14C24:  MOVLW  0A
14C26:  MOVWF  xB7
14C28:  MOVLB  0
14C2A:  CALL   8F3C
....................  
....................     return 0; 
14C2E:  MOVLW  00
14C30:  MOVWF  01
14C32:  MOVLB  5
14C34:  MOVLB  0
14C36:  GOTO   18EA2 (RETURN)
.................... } 
....................  
.................... // S-band test command for anechoic chamber 
.................... uint8_t command_sband_test(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
14C6A:  MOVLW  06
14C6C:  MOVLB  C
14C6E:  MOVWF  xBE
14C70:  MOVLB  0
14C72:  CALL   52E8
14C76:  MOVF   01,W
14C78:  SUBLW  06
14C7A:  BZ    14C9E
....................         if (verbose) { 
14C7C:  MOVLB  5
14C7E:  MOVF   x5A,F
14C80:  BZ    14C96
....................             fprintf(PC, "MUX change failed!"); 
14C82:  MOVLW  8A
14C84:  MOVWF  FF6
14C86:  MOVLW  1C
14C88:  MOVWF  FF7
14C8A:  MOVLW  00
14C8C:  MOVWF  FF8
14C8E:  MOVLB  0
14C90:  CALL   4534
14C94:  MOVLB  5
....................         } 
....................         return 1; 
14C96:  MOVLW  01
14C98:  MOVWF  01
14C9A:  BRA    14E70
14C9C:  MOVLB  0
....................     } 
....................  
....................     struct cband_test { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t bitrate; 
....................         uint8_t low_high_power; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 4]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
14C9E:  MOVLW  0C
14CA0:  MOVLB  C
14CA2:  MOVWF  x61
14CA4:  MOVLW  3A
14CA6:  MOVFF  C61,C5F
14CAA:  MOVWF  x5E
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
14CAC:  MOVFF  C5F,FEA
14CB0:  MOVFF  C5E,FE9
14CB4:  CLRF   00
14CB6:  CLRF   02
14CB8:  MOVLW  24
14CBA:  MOVWF  01
14CBC:  MOVLB  0
14CBE:  CALL   5222
....................     memcpy(ptr, data, 10); 
14CC2:  MOVFF  C5F,FEA
14CC6:  MOVFF  C5E,FE9
14CCA:  MOVFF  C39,FE2
14CCE:  MOVFF  C38,FE1
14CD2:  MOVLW  0A
14CD4:  MOVWF  01
14CD6:  MOVFF  FE6,FEE
14CDA:  DECFSZ 01,F
14CDC:  BRA    14CD6
....................     pcib_pkg.origin = MSG_OBC; 
14CDE:  MOVLW  0B
14CE0:  MOVLB  C
14CE2:  MOVWF  x3A
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
14CE4:  MOVFF  C5F,CAF
14CE8:  MOVFF  C5E,CAE
14CEC:  MOVLW  24
14CEE:  MOVWF  xB0
14CF0:  MOVLB  0
14CF2:  CALL   8E80
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
14CF6:  MOVFF  C5F,C90
14CFA:  MOVFF  C5E,C8F
14CFE:  MOVLW  24
14D00:  MOVLB  C
14D02:  MOVWF  x91
14D04:  MOVLB  0
14D06:  CALL   7A5C
....................  
....................     fprintf(PC, " S-band test command: "); 
14D0A:  MOVLW  9E
14D0C:  MOVWF  FF6
14D0E:  MOVLW  1C
14D10:  MOVWF  FF7
14D12:  MOVLW  00
14D14:  MOVWF  FF8
14D16:  CALL   4534
....................  
....................     switch (pcib_pkg.bitrate) { 
14D1A:  MOVLB  C
14D1C:  MOVF   x3C,W
14D1E:  XORLW  00
14D20:  MOVLB  0
14D22:  BZ    14D42
14D24:  XORLW  01
14D26:  BZ    14D54
14D28:  XORLW  03
14D2A:  BZ    14D66
14D2C:  XORLW  01
14D2E:  BZ    14D78
14D30:  XORLW  07
14D32:  BZ    14D8A
14D34:  XORLW  01
14D36:  BZ    14D9C
14D38:  XORLW  03
14D3A:  BZ    14DAE
14D3C:  XORLW  01
14D3E:  BZ    14DC0
14D40:  BRA    14DD2
....................     case 0: fprintf(PC, "10kbps, "); break; 
14D42:  MOVLW  B6
14D44:  MOVWF  FF6
14D46:  MOVLW  1C
14D48:  MOVWF  FF7
14D4A:  MOVLW  00
14D4C:  MOVWF  FF8
14D4E:  CALL   4534
14D52:  BRA    14DEC
....................     case 1: fprintf(PC, "20kbps, "); break; 
14D54:  MOVLW  C0
14D56:  MOVWF  FF6
14D58:  MOVLW  1C
14D5A:  MOVWF  FF7
14D5C:  MOVLW  00
14D5E:  MOVWF  FF8
14D60:  CALL   4534
14D64:  BRA    14DEC
....................     case 2: fprintf(PC, "25kbps, "); break; 
14D66:  MOVLW  CA
14D68:  MOVWF  FF6
14D6A:  MOVLW  1C
14D6C:  MOVWF  FF7
14D6E:  MOVLW  00
14D70:  MOVWF  FF8
14D72:  CALL   4534
14D76:  BRA    14DEC
....................     case 3: fprintf(PC, "50kbps, "); break; 
14D78:  MOVLW  D4
14D7A:  MOVWF  FF6
14D7C:  MOVLW  1C
14D7E:  MOVWF  FF7
14D80:  MOVLW  00
14D82:  MOVWF  FF8
14D84:  CALL   4534
14D88:  BRA    14DEC
....................     case 4: fprintf(PC, "64kbps, "); break; 
14D8A:  MOVLW  DE
14D8C:  MOVWF  FF6
14D8E:  MOVLW  1C
14D90:  MOVWF  FF7
14D92:  MOVLW  00
14D94:  MOVWF  FF8
14D96:  CALL   4534
14D9A:  BRA    14DEC
....................     case 5: fprintf(PC, "100kbps, "); break; 
14D9C:  MOVLW  E8
14D9E:  MOVWF  FF6
14DA0:  MOVLW  1C
14DA2:  MOVWF  FF7
14DA4:  MOVLW  00
14DA6:  MOVWF  FF8
14DA8:  CALL   4534
14DAC:  BRA    14DEC
....................     case 6: fprintf(PC, "250kbps, "); break; 
14DAE:  MOVLW  F2
14DB0:  MOVWF  FF6
14DB2:  MOVLW  1C
14DB4:  MOVWF  FF7
14DB6:  MOVLW  00
14DB8:  MOVWF  FF8
14DBA:  CALL   4534
14DBE:  BRA    14DEC
....................     case 7: fprintf(PC, "500kbps, "); break; 
14DC0:  MOVLW  FC
14DC2:  MOVWF  FF6
14DC4:  MOVLW  1C
14DC6:  MOVWF  FF7
14DC8:  MOVLW  00
14DCA:  MOVWF  FF8
14DCC:  CALL   4534
14DD0:  BRA    14DEC
....................     default: fprintf(PC, "invalid bitrate."); return 1; 
14DD2:  MOVLW  06
14DD4:  MOVWF  FF6
14DD6:  MOVLW  1D
14DD8:  MOVWF  FF7
14DDA:  MOVLW  00
14DDC:  MOVWF  FF8
14DDE:  CALL   4534
14DE2:  MOVLW  01
14DE4:  MOVWF  01
14DE6:  MOVLB  5
14DE8:  BRA    14E70
14DEA:  MOVLB  0
....................     } 
....................  
....................     switch (pcib_pkg.low_high_power) { 
14DEC:  MOVLB  C
14DEE:  MOVF   x3D,W
14DF0:  XORLW  00
14DF2:  MOVLB  0
14DF4:  BZ    14DFC
14DF6:  XORLW  01
14DF8:  BZ    14E0E
14DFA:  BRA    14E20
....................     case 0: fprintf(PC, "low power."); break; 
14DFC:  MOVLW  18
14DFE:  MOVWF  FF6
14E00:  MOVLW  1D
14E02:  MOVWF  FF7
14E04:  MOVLW  00
14E06:  MOVWF  FF8
14E08:  CALL   4534
14E0C:  BRA    14E3A
....................     case 1: fprintf(PC, "high power."); break; 
14E0E:  MOVLW  24
14E10:  MOVWF  FF6
14E12:  MOVLW  1D
14E14:  MOVWF  FF7
14E16:  MOVLW  00
14E18:  MOVWF  FF8
14E1A:  CALL   4534
14E1E:  BRA    14E3A
....................     default: fprintf(PC, "invalid power."); return 2; 
14E20:  MOVLW  30
14E22:  MOVWF  FF6
14E24:  MOVLW  1D
14E26:  MOVWF  FF7
14E28:  MOVLW  00
14E2A:  MOVWF  FF8
14E2C:  CALL   4534
14E30:  MOVLW  02
14E32:  MOVWF  01
14E34:  MOVLB  5
14E36:  BRA    14E70
14E38:  MOVLB  0
....................     } 
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); 
14E3A:  MOVLW  0A
14E3C:  MOVLB  C
14E3E:  MOVWF  xAF
14E40:  MOVLW  97
14E42:  MOVWF  xAE
14E44:  MOVFF  C5F,CB1
14E48:  MOVFF  C5E,CB0
14E4C:  CLRF   xB5
14E4E:  CLRF   xB4
14E50:  CLRF   xB3
14E52:  MOVLW  24
14E54:  MOVWF  xB2
14E56:  MOVLW  05
14E58:  MOVWF  xB6
14E5A:  CLRF   xBA
14E5C:  CLRF   xB9
14E5E:  CLRF   xB8
14E60:  MOVLW  0A
14E62:  MOVWF  xB7
14E64:  MOVLB  0
14E66:  CALL   8F3C
....................  
....................     return 0; 
14E6A:  MOVLW  00
14E6C:  MOVWF  01
14E6E:  MOVLB  5
14E70:  MOVLB  0
14E72:  GOTO   18EB4 (RETURN)
.................... } 
....................  
.................... // Data downlink from S-band through Relay PIC 
.................... uint8_t command_relay_data_downlink_from_flash(uint8_t* data) 
.................... { 
....................     enum { data_size = 16 }; 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
*
0C2B2:  MOVLW  06
0C2B4:  MOVLB  C
0C2B6:  MOVWF  xBE
0C2B8:  MOVLB  0
0C2BA:  CALL   52E8
0C2BE:  MOVF   01,W
0C2C0:  SUBLW  06
0C2C2:  BZ    C2E6
....................         if (verbose) { 
0C2C4:  MOVLB  5
0C2C6:  MOVF   x5A,F
0C2C8:  BZ    C2DE
....................             fprintf(PC, "MUX change failed!"); 
0C2CA:  MOVLW  40
0C2CC:  MOVWF  FF6
0C2CE:  MOVLW  1D
0C2D0:  MOVWF  FF7
0C2D2:  MOVLW  00
0C2D4:  MOVWF  FF8
0C2D6:  MOVLB  0
0C2D8:  CALL   4534
0C2DC:  MOVLB  5
....................         } 
....................         return 1; 
0C2DE:  MOVLW  01
0C2E0:  MOVWF  01
0C2E2:  BRA    C486
0C2E4:  MOVLB  0
....................     } 
....................  
....................     uint8_t cmd[MSG_LENGTH_PCIB] = {0}; 
0C2E6:  MOVLB  C
0C2E8:  CLRF   x3A
0C2EA:  CLRF   x3B
0C2EC:  CLRF   x3C
0C2EE:  CLRF   x3D
0C2F0:  CLRF   x3E
0C2F2:  CLRF   x3F
0C2F4:  CLRF   x40
0C2F6:  CLRF   x41
0C2F8:  CLRF   x42
0C2FA:  CLRF   x43
0C2FC:  CLRF   x44
0C2FE:  CLRF   x45
0C300:  CLRF   x46
0C302:  CLRF   x47
0C304:  CLRF   x48
0C306:  CLRF   x49
0C308:  CLRF   x4A
0C30A:  CLRF   x4B
0C30C:  CLRF   x4C
0C30E:  CLRF   x4D
0C310:  CLRF   x4E
0C312:  CLRF   x4F
0C314:  CLRF   x50
0C316:  CLRF   x51
0C318:  CLRF   x52
0C31A:  CLRF   x53
0C31C:  CLRF   x54
0C31E:  CLRF   x55
0C320:  CLRF   x56
0C322:  CLRF   x57
0C324:  CLRF   x58
0C326:  CLRF   x59
0C328:  CLRF   x5A
0C32A:  CLRF   x5B
0C32C:  CLRF   x5C
0C32E:  CLRF   x5D
....................  
....................     struct relay_command { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[data_size]; 
....................     }* relay_command = (struct relay_command*)cmd; 
0C330:  MOVLW  0C
0C332:  MOVWF  x63
0C334:  MOVLW  3A
0C336:  MOVFF  C63,C5F
0C33A:  MOVWF  x5E
....................  
....................     relay_command->origin = MSG_OBC; 
0C33C:  MOVFF  C5E,FE9
0C340:  MOVFF  C5F,FEA
0C344:  MOVLW  0B
0C346:  MOVWF  FEF
....................     relay_command->command = data[1]; 
0C348:  MOVLW  01
0C34A:  ADDWF  x5E,W
0C34C:  MOVWF  01
0C34E:  MOVLW  00
0C350:  ADDWFC x5F,W
0C352:  MOVWF  03
0C354:  MOVLW  01
0C356:  ADDWF  x38,W
0C358:  MOVWF  FE9
0C35A:  MOVLW  00
0C35C:  ADDWFC x39,W
0C35E:  MOVWF  FEA
0C360:  MOVFF  FEF,C64
0C364:  MOVFF  03,FEA
0C368:  MOVFF  01,FE9
0C36C:  MOVFF  C64,FEF
....................     memcpy(relay_command->data, data + 2, data_size); 
0C370:  MOVLW  02
0C372:  ADDWF  x5E,W
0C374:  MOVWF  01
0C376:  MOVLW  00
0C378:  ADDWFC x5F,W
0C37A:  MOVWF  03
0C37C:  MOVFF  01,C62
0C380:  MOVWF  x63
0C382:  MOVLW  02
0C384:  ADDWF  x38,W
0C386:  MOVWF  x64
0C388:  MOVLW  00
0C38A:  ADDWFC x39,W
0C38C:  MOVWF  x65
0C38E:  MOVFF  03,FEA
0C392:  MOVFF  01,FE9
0C396:  MOVWF  FE2
0C398:  MOVFF  C64,FE1
0C39C:  MOVLW  10
0C39E:  MOVWF  01
0C3A0:  MOVFF  FE6,FEE
0C3A4:  DECFSZ 01,F
0C3A6:  BRA    C3A0
....................     checksum_obc(cmd, MSG_LENGTH_PCIB); 
0C3A8:  MOVLW  0C
0C3AA:  MOVWF  xAF
0C3AC:  MOVLW  3A
0C3AE:  MOVWF  xAE
0C3B0:  MOVLW  24
0C3B2:  MOVWF  xB0
0C3B4:  MOVLB  0
0C3B6:  CALL   8E80
....................     uart_print_pc_hex(cmd, MSG_LENGTH_PCIB); 
0C3BA:  MOVLW  0C
0C3BC:  MOVLB  C
0C3BE:  MOVWF  x90
0C3C0:  MOVLW  3A
0C3C2:  MOVWF  x8F
0C3C4:  MOVLW  24
0C3C6:  MOVWF  x91
0C3C8:  MOVLB  0
0C3CA:  CALL   7A5C
....................  
....................     uint8_t duration = data[6]; 
....................  
....................     uint8_t mux_status = 0; 
0C3CE:  MOVLW  06
0C3D0:  MOVLB  C
0C3D2:  ADDWF  x38,W
0C3D4:  MOVWF  FE9
0C3D6:  MOVLW  00
0C3D8:  ADDWFC x39,W
0C3DA:  MOVWF  FEA
0C3DC:  MOVFF  FEF,C60
0C3E0:  CLRF   x61
....................  
....................     if(relay_command->command == 0x36) { 
0C3E2:  MOVLW  01
0C3E4:  ADDWF  x5E,W
0C3E6:  MOVWF  FE9
0C3E8:  MOVLW  00
0C3EA:  ADDWFC x5F,W
0C3EC:  MOVWF  FEA
0C3EE:  MOVF   FEF,W
0C3F0:  SUBLW  36
0C3F2:  BNZ   C450
....................         mux_status = mux_lock_unlock(true, ((time_t)duration) * 60); 
0C3F4:  CLRF   x65
0C3F6:  CLRF   x64
0C3F8:  CLRF   x63
0C3FA:  MOVFF  C60,C62
0C3FE:  MOVFF  C65,CB4
0C402:  MOVFF  C64,CB3
0C406:  MOVFF  C63,CB2
0C40A:  MOVFF  C60,CB1
0C40E:  CLRF   xB8
0C410:  CLRF   xB7
0C412:  CLRF   xB6
0C414:  MOVLW  3C
0C416:  MOVWF  xB5
0C418:  MOVLB  0
0C41A:  CALL   456E
0C41E:  MOVFF  03,C65
0C422:  MOVFF  02,C64
0C426:  MOVFF  01,C63
0C42A:  MOVFF  00,C62
0C42E:  MOVLW  01
0C430:  MOVLB  C
0C432:  MOVWF  x82
0C434:  MOVFF  03,C86
0C438:  MOVFF  02,C85
0C43C:  MOVFF  01,C84
0C440:  MOVFF  00,C83
0C444:  MOVLB  0
0C446:  CALL   7EB4
0C44A:  MOVFF  01,C61
0C44E:  MOVLB  C
....................     } 
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, cmd, MSG_LENGTH_PCIB, 5, 10); 
0C450:  MOVLW  0A
0C452:  MOVWF  xAF
0C454:  MOVLW  97
0C456:  MOVWF  xAE
0C458:  MOVLW  0C
0C45A:  MOVWF  xB1
0C45C:  MOVLW  3A
0C45E:  MOVWF  xB0
0C460:  CLRF   xB5
0C462:  CLRF   xB4
0C464:  CLRF   xB3
0C466:  MOVLW  24
0C468:  MOVWF  xB2
0C46A:  MOVLW  05
0C46C:  MOVWF  xB6
0C46E:  CLRF   xBA
0C470:  CLRF   xB9
0C472:  CLRF   xB8
0C474:  MOVLW  0A
0C476:  MOVWF  xB7
0C478:  MOVLB  0
0C47A:  CALL   8F3C
....................  
....................     return mux_status; 
0C47E:  MOVLB  C
0C480:  MOVFF  C61,01
0C484:  MOVLB  5
0C486:  MOVLB  0
0C488:  RETURN 0
.................... } 
....................  
.................... // ===================================================== 
....................  
.................... typedef struct mission { 
....................     time_t mission_time;                            // time when the command is sent to the mission (Unix time) 
....................     uint16_t mission_duration;                      // how long does it take to execute the mission in seconds; 0 = do not turn off 
....................     uint8_t adcs_mode;                              // adcs mode during mission 
....................     uint16_t adcs_maneuver_duration;                // how early to change the ADCS before sending the mission command (in seconds); 0 = never 
....................     uint16_t mission_on_time;                       // how early to turn on the mission before sending the mission command (in seconds) 
....................     uint8_t turn_on_value;                          // active high will turn on the subsystem 
....................     uint16_t pin_number;                            // pin number to turn on/off the subsystem; 0 = do not change 
....................     uart_fn* command_port;                          // UART port to send the command 
....................     uart_fn* on_off_command_port;                   // UART port to send on/off commands 
....................     uint8_t mux_position_command;                   // mux position when sending mission commands 
....................     uint8_t mux_position_on_off;                    // mux position when sending on/off commands 
....................     uint8_t command[MSG_LENGTH_PCIB];               // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t command_size;                           // the size of the command above; 0 = do not send 
....................     uint8_t turn_on_command[MSG_LENGTH_PCIB];       // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t turn_on_command_size;                   // the size of the command above; 0 = do not send 
....................     uint8_t turn_off_soft_command[MSG_LENGTH_PCIB]; // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t turn_off_soft_command_size;             // the size of the command above; 0 = do not send 
....................     uint8_t turn_off_hard_command[MSG_LENGTH_PCIB]; // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t turn_off_hard_command_size;             // the size of the command above; 0 = do not send 
....................     uint16_t turn_off_duration;                     // time it takes between sending the turn off warning and mission power off (in seconds); 0 = never turn off 
....................     uint8_t mux_lock;                               // if true, the mux position is locked for mux_lock_duration seconds 
....................     uint16_t mux_lock_duration;                     // duration to lock the mux seconds 
.................... } mission; 
....................  
.................... mission camera = { 
....................     0,                        // mission_time 
....................     65,                       // mission_duration 
....................     adcs_mode_horizon_camera, // adcs_mode 
....................     3 * 60 * 60,              // adcs_maneuver_duration (3 hours) 
....................     60,                       // mission_on_time 
....................     true,                     // turn_on_value 
....................     0,                        // pin_number 
....................     &uart_port_MSN,           // command_port 
....................     &uart_port_MSN,           // on_off_port 
....................     mux_pcib,                 // mux_position_command 
....................     mux_pcib,                 // mux_position_on_off 
....................     { 0 },                    // command 
....................     MSG_LENGTH_PCIB,          // command_size 
....................     { MSG_OBC, 0xBE, 0x01 },  // turn_on_command 
....................     MSG_LENGTH_PCIB,          // turn_on_command_size 
....................     { MSG_OBC, 0xBE, 0x02 },  // turn_off_soft_command 
....................     MSG_LENGTH_PCIB,          // turn_off_soft_command_size 
....................     { MSG_OBC, 0xBE, 0x00 },  // turn_off_hard_command 
....................     MSG_LENGTH_PCIB,          // turn_off_hard_command_size 
....................     20,                       // turn_off_duration 
....................     false,                    // mux_lock 
....................     65                        // mux_lock_duration 
.................... }; 
....................  
.................... // TODO: Add copy command at the end of the mission 
....................  
.................... // Controls the mission execution 
.................... uint8_t command_generic_mission(mission *m, uint8_t data[]) 
*
11622:  MOVLW  02
11624:  MOVLB  C
11626:  ADDWF  x3A,W
11628:  MOVWF  01
1162A:  MOVLW  00
1162C:  ADDWFC x3B,W
1162E:  MOVFF  01,C3C
11632:  MOVWF  x3D
11634:  MOVLW  03
11636:  ADDWF  x3A,W
11638:  MOVWF  01
1163A:  MOVLW  00
1163C:  ADDWFC x3B,W
1163E:  MOVFF  01,C3E
11642:  MOVWF  x3F
.................... { 
....................     uint8_t* state = &data[2];        // The state is kept in the command 
....................     uint8_t* adcs_enabled = &data[3]; // ADCS enabled flag is also kept in the command 
....................  
....................     enum state_machine { 
....................         state_schedule = 0, 
....................         state_initial_adcs_mode = 1, 
....................         state_turn_on_subsystem = 2, 
....................         state_send_uplink_command = 3, 
....................         state_turn_off_subsystem_soft = 4, 
....................         state_turn_off_subsystem_hard = 5, 
....................         state_end = 6 
....................     }; 
....................  
....................     // Print the current state 
....................     switch (*state) { 
11644:  MOVFF  C3D,03
11648:  MOVF   x3C,W
1164A:  MOVWF  FE9
1164C:  MOVFF  03,FEA
11650:  MOVF   FEF,W
11652:  XORLW  00
11654:  MOVLB  0
11656:  BZ    11672
11658:  XORLW  01
1165A:  BZ    11684
1165C:  XORLW  03
1165E:  BZ    11696
11660:  XORLW  01
11662:  BZ    116A8
11664:  XORLW  07
11666:  BZ    116BA
11668:  XORLW  01
1166A:  BZ    116CC
1166C:  XORLW  03
1166E:  BZ    116DE
11670:  BRA    116F0
....................     case state_schedule: fprintf(PC, "State: schedule\n"); break; 
11672:  MOVLW  54
11674:  MOVWF  FF6
11676:  MOVLW  1D
11678:  MOVWF  FF7
1167A:  MOVLW  00
1167C:  MOVWF  FF8
1167E:  CALL   4534
11682:  BRA    11700
....................     case state_initial_adcs_mode: fprintf(PC, "State: initial adcs mode\n"); break; 
11684:  MOVLW  66
11686:  MOVWF  FF6
11688:  MOVLW  1D
1168A:  MOVWF  FF7
1168C:  MOVLW  00
1168E:  MOVWF  FF8
11690:  CALL   4534
11694:  BRA    11700
....................     case state_turn_on_subsystem: fprintf(PC, "State: turn on subsystem\n"); break; 
11696:  MOVLW  80
11698:  MOVWF  FF6
1169A:  MOVLW  1D
1169C:  MOVWF  FF7
1169E:  MOVLW  00
116A0:  MOVWF  FF8
116A2:  CALL   4534
116A6:  BRA    11700
....................     case state_send_uplink_command: fprintf(PC, "State: send uplink command\n"); break; 
116A8:  MOVLW  9A
116AA:  MOVWF  FF6
116AC:  MOVLW  1D
116AE:  MOVWF  FF7
116B0:  MOVLW  00
116B2:  MOVWF  FF8
116B4:  CALL   4534
116B8:  BRA    11700
....................     case state_turn_off_subsystem_soft: fprintf(PC, "State: turn off subsystem soft\n"); break; 
116BA:  MOVLW  B6
116BC:  MOVWF  FF6
116BE:  MOVLW  1D
116C0:  MOVWF  FF7
116C2:  MOVLW  00
116C4:  MOVWF  FF8
116C6:  CALL   4534
116CA:  BRA    11700
....................     case state_turn_off_subsystem_hard: fprintf(PC, "State: turn off subsystem hard\n"); break; 
116CC:  MOVLW  D6
116CE:  MOVWF  FF6
116D0:  MOVLW  1D
116D2:  MOVWF  FF7
116D4:  MOVLW  00
116D6:  MOVWF  FF8
116D8:  CALL   4534
116DC:  BRA    11700
....................     case state_end: fprintf(PC, "State: end\n"); break; 
116DE:  MOVLW  F6
116E0:  MOVWF  FF6
116E2:  MOVLW  1D
116E4:  MOVWF  FF7
116E6:  MOVLW  00
116E8:  MOVWF  FF8
116EA:  CALL   4534
116EE:  BRA    11700
....................     default: fprintf(PC, "Unknown state\n"); break; 
116F0:  MOVLW  02
116F2:  MOVWF  FF6
116F4:  MOVLW  1E
116F6:  MOVWF  FF7
116F8:  MOVLW  00
116FA:  MOVWF  FF8
116FC:  CALL   4534
....................     } 
....................  
....................     // Execute the actions for the current state 
....................     switch (*state) { 
11700:  MOVFF  C3D,03
11704:  MOVLB  C
11706:  MOVF   x3C,W
11708:  MOVWF  FE9
1170A:  MOVFF  03,FEA
1170E:  MOVF   FEF,W
11710:  XORLW  00
11712:  MOVLB  0
11714:  BZ    11732
11716:  XORLW  01
11718:  BZ    11734
1171A:  XORLW  03
1171C:  BZ    11750
1171E:  XORLW  01
11720:  BTFSC  FD8.2
11722:  BRA    11890
11724:  XORLW  07
11726:  BTFSC  FD8.2
11728:  BRA    11962
1172A:  XORLW  01
1172C:  BTFSC  FD8.2
1172E:  BRA    11A66
11730:  BRA    11BA6
....................     case state_schedule: 
....................         break; 
11732:  BRA    11BCC
....................     case state_initial_adcs_mode: 
....................         change_adcs_mode(m->adcs_mode, false); 
11734:  MOVLW  06
11736:  MOVLB  C
11738:  ADDWF  x38,W
1173A:  MOVWF  FE9
1173C:  MOVLW  00
1173E:  ADDWFC x39,W
11740:  MOVWF  FEA
11742:  MOVFF  FEF,C41
11746:  CLRF   x42
11748:  MOVLB  0
1174A:  CALL   E70E
....................         break; 
1174E:  BRA    11BCC
....................     case state_turn_on_subsystem: 
....................         if (m->pin_number) { 
11750:  MOVLW  0C
11752:  MOVLB  C
11754:  ADDWF  x38,W
11756:  MOVWF  FE9
11758:  MOVLW  00
1175A:  ADDWFC x39,W
1175C:  MOVWF  FEA
1175E:  MOVF   FEF,F
11760:  BNZ   11766
11762:  MOVF   FEC,F
11764:  BZ    117C0
....................             output_bit(m->pin_number, m->turn_on_value); 
11766:  MOVLW  0C
11768:  ADDWF  x38,W
1176A:  MOVWF  FE9
1176C:  MOVLW  00
1176E:  ADDWFC x39,W
11770:  MOVWF  FEA
11772:  MOVFF  FEC,C41
11776:  MOVF   FED,F
11778:  MOVFF  FEF,C40
1177C:  MOVLW  0B
1177E:  ADDWF  x38,W
11780:  MOVWF  FE9
11782:  MOVLW  00
11784:  ADDWFC x39,W
11786:  MOVWF  FEA
11788:  MOVF   FEF,F
1178A:  BNZ   11790
1178C:  MOVLW  00
1178E:  BRA    11792
11790:  MOVLW  01
11792:  MOVFF  C40,D68
11796:  MOVLB  D
11798:  MOVWF  x69
1179A:  MOVLW  0F
1179C:  MOVWF  x6B
1179E:  MOVLW  89
117A0:  MOVWF  x6A
117A2:  MOVLB  0
117A4:  CALL   53D6
117A8:  MOVFF  C40,D68
117AC:  MOVLB  D
117AE:  CLRF   x69
117B0:  MOVLW  0F
117B2:  MOVWF  x6B
117B4:  MOVLW  92
117B6:  MOVWF  x6A
117B8:  MOVLB  0
117BA:  CALL   53D6
117BE:  MOVLB  C
....................         } 
....................         if (m->turn_on_command_size) { 
117C0:  MOVLW  5D
117C2:  ADDWF  x38,W
117C4:  MOVWF  FE9
117C6:  MOVLW  00
117C8:  ADDWFC x39,W
117CA:  MOVWF  FEA
117CC:  MOVF   FEF,F
117CE:  BZ    1188C
....................             checksum_obc(m->turn_on_command, m->turn_on_command_size); 
117D0:  MOVLW  39
117D2:  ADDWF  x38,W
117D4:  MOVWF  01
117D6:  MOVLW  00
117D8:  ADDWFC x39,W
117DA:  MOVWF  03
117DC:  MOVFF  01,C40
117E0:  MOVWF  x41
117E2:  MOVLW  5D
117E4:  ADDWF  x38,W
117E6:  MOVWF  FE9
117E8:  MOVLW  00
117EA:  ADDWFC x39,W
117EC:  MOVWF  FEA
117EE:  MOVFF  FEF,CB0
117F2:  MOVFF  03,CAF
117F6:  MOVFF  01,CAE
117FA:  MOVLB  0
117FC:  CALL   8E80
....................             mux_sel(m->mux_position_on_off); 
11800:  MOVLW  13
11802:  MOVLB  C
11804:  ADDWF  x38,W
11806:  MOVWF  FE9
11808:  MOVLW  00
1180A:  ADDWFC x39,W
1180C:  MOVWF  FEA
1180E:  MOVFF  FEF,CBE
11812:  MOVLB  0
11814:  CALL   52E8
....................             uart_send_packet(m->on_off_command_port, m->turn_on_command, m->turn_on_command_size); 
11818:  MOVLW  10
1181A:  MOVLB  C
1181C:  ADDWF  x38,W
1181E:  MOVWF  FE9
11820:  MOVLW  00
11822:  ADDWFC x39,W
11824:  MOVWF  FEA
11826:  MOVFF  FEC,D3C
1182A:  MOVF   FED,F
1182C:  MOVFF  FEF,D3B
11830:  MOVLW  39
11832:  ADDWF  x38,W
11834:  MOVWF  01
11836:  MOVLW  00
11838:  ADDWFC x39,W
1183A:  MOVWF  03
1183C:  MOVFF  01,C42
11840:  MOVWF  x43
11842:  MOVLW  5D
11844:  ADDWF  x38,W
11846:  MOVWF  FE9
11848:  MOVLW  00
1184A:  ADDWFC x39,W
1184C:  MOVWF  FEA
1184E:  MOVFF  FEF,D3F
11852:  MOVFF  03,D3E
11856:  MOVFF  01,D3D
1185A:  MOVLB  D
1185C:  CLRF   x42
1185E:  CLRF   x41
11860:  CLRF   x40
11862:  MOVLB  0
11864:  CALL   8EDE
....................             if(m->turn_on_command[1] == 0xBE) { // Workaround to set the monitor byte 
11868:  MOVLW  3A
1186A:  MOVLB  C
1186C:  ADDWF  x38,W
1186E:  MOVWF  FE9
11870:  MOVLW  00
11872:  ADDWFC x39,W
11874:  MOVWF  FEA
11876:  MOVF   FEF,W
11878:  SUBLW  BE
1187A:  BNZ   1188C
....................                 rpi_status = m->turn_on_command[2]; 
1187C:  MOVLW  3B
1187E:  ADDWF  x38,W
11880:  MOVWF  FE9
11882:  MOVLW  00
11884:  ADDWFC x39,W
11886:  MOVWF  FEA
11888:  MOVFF  FEF,8AB
....................             } 
....................         } 
....................         break; 
1188C:  MOVLB  0
1188E:  BRA    11BCC
....................     case state_send_uplink_command: 
....................         checksum_obc(m->command, m->command_size); 
11890:  MOVLW  14
11892:  MOVLB  C
11894:  ADDWF  x38,W
11896:  MOVWF  01
11898:  MOVLW  00
1189A:  ADDWFC x39,W
1189C:  MOVWF  03
1189E:  MOVFF  01,C40
118A2:  MOVWF  x41
118A4:  MOVLW  38
118A6:  ADDWF  x38,W
118A8:  MOVWF  FE9
118AA:  MOVLW  00
118AC:  ADDWFC x39,W
118AE:  MOVWF  FEA
118B0:  MOVFF  FEF,CB0
118B4:  MOVFF  03,CAF
118B8:  MOVFF  01,CAE
118BC:  MOVLB  0
118BE:  CALL   8E80
....................         mux_sel(m->mux_position_command); 
118C2:  MOVLW  12
118C4:  MOVLB  C
118C6:  ADDWF  x38,W
118C8:  MOVWF  FE9
118CA:  MOVLW  00
118CC:  ADDWFC x39,W
118CE:  MOVWF  FEA
118D0:  MOVFF  FEF,CBE
118D4:  MOVLB  0
118D6:  CALL   52E8
....................         if(m->mux_lock) { 
118DA:  MOVLW  AA
118DC:  MOVLB  C
118DE:  ADDWF  x38,W
118E0:  MOVWF  FE9
118E2:  MOVLW  00
118E4:  ADDWFC x39,W
118E6:  MOVWF  FEA
118E8:  MOVF   FEF,F
118EA:  BZ    11912
....................             mux_lock_unlock(true, m->mux_lock_duration); 
118EC:  MOVLW  AB
118EE:  ADDWF  x38,W
118F0:  MOVWF  FE9
118F2:  MOVLW  00
118F4:  ADDWFC x39,W
118F6:  MOVWF  FEA
118F8:  MOVFF  FEC,C84
118FC:  MOVF   FED,F
118FE:  MOVFF  FEF,C83
11902:  MOVLW  01
11904:  MOVWF  x82
11906:  CLRF   x86
11908:  CLRF   x85
1190A:  MOVLB  0
1190C:  CALL   7EB4
11910:  MOVLB  C
....................         } 
....................         uart_send_packet(m->command_port, m->command, m->command_size); 
11912:  MOVLW  0E
11914:  ADDWF  x38,W
11916:  MOVWF  FE9
11918:  MOVLW  00
1191A:  ADDWFC x39,W
1191C:  MOVWF  FEA
1191E:  MOVFF  FEC,D3C
11922:  MOVF   FED,F
11924:  MOVFF  FEF,D3B
11928:  MOVLW  14
1192A:  ADDWF  x38,W
1192C:  MOVWF  01
1192E:  MOVLW  00
11930:  ADDWFC x39,W
11932:  MOVWF  03
11934:  MOVFF  01,C42
11938:  MOVWF  x43
1193A:  MOVLW  38
1193C:  ADDWF  x38,W
1193E:  MOVWF  FE9
11940:  MOVLW  00
11942:  ADDWFC x39,W
11944:  MOVWF  FEA
11946:  MOVFF  FEF,D3F
1194A:  MOVFF  03,D3E
1194E:  MOVFF  01,D3D
11952:  MOVLB  D
11954:  CLRF   x42
11956:  CLRF   x41
11958:  CLRF   x40
1195A:  MOVLB  0
1195C:  CALL   8EDE
....................         break; 
11960:  BRA    11BCC
....................     case state_turn_off_subsystem_soft: 
....................         if (*adcs_enabled && m->adcs_maneuver_duration) { 
11962:  MOVFF  C3F,03
11966:  MOVLB  C
11968:  MOVFF  C3E,FE9
1196C:  MOVFF  C3F,FEA
11970:  MOVF   FEF,F
11972:  BZ    11996
11974:  MOVLW  07
11976:  ADDWF  x38,W
11978:  MOVWF  FE9
1197A:  MOVLW  00
1197C:  ADDWFC x39,W
1197E:  MOVWF  FEA
11980:  MOVF   FEF,F
11982:  BNZ   11988
11984:  MOVF   FEC,F
11986:  BZ    11996
....................             change_adcs_mode(obc_flags.adcs_initial_value, false); 
11988:  MOVFF  104,C41
1198C:  CLRF   x42
1198E:  MOVLB  0
11990:  CALL   E70E
11994:  MOVLB  C
....................         } 
....................         if (m->turn_off_soft_command_size) { 
11996:  MOVLW  82
11998:  ADDWF  x38,W
1199A:  MOVWF  FE9
1199C:  MOVLW  00
1199E:  ADDWFC x39,W
119A0:  MOVWF  FEA
119A2:  MOVF   FEF,F
119A4:  BZ    11A62
....................             checksum_obc(m->turn_off_soft_command, m->turn_off_soft_command_size); 
119A6:  MOVLW  5E
119A8:  ADDWF  x38,W
119AA:  MOVWF  01
119AC:  MOVLW  00
119AE:  ADDWFC x39,W
119B0:  MOVWF  03
119B2:  MOVFF  01,C40
119B6:  MOVWF  x41
119B8:  MOVLW  82
119BA:  ADDWF  x38,W
119BC:  MOVWF  FE9
119BE:  MOVLW  00
119C0:  ADDWFC x39,W
119C2:  MOVWF  FEA
119C4:  MOVFF  FEF,CB0
119C8:  MOVFF  03,CAF
119CC:  MOVFF  01,CAE
119D0:  MOVLB  0
119D2:  CALL   8E80
....................             mux_sel(m->mux_position_on_off); 
119D6:  MOVLW  13
119D8:  MOVLB  C
119DA:  ADDWF  x38,W
119DC:  MOVWF  FE9
119DE:  MOVLW  00
119E0:  ADDWFC x39,W
119E2:  MOVWF  FEA
119E4:  MOVFF  FEF,CBE
119E8:  MOVLB  0
119EA:  CALL   52E8
....................             uart_send_packet(m->on_off_command_port, m->turn_off_soft_command, m->turn_off_soft_command_size); 
119EE:  MOVLW  10
119F0:  MOVLB  C
119F2:  ADDWF  x38,W
119F4:  MOVWF  FE9
119F6:  MOVLW  00
119F8:  ADDWFC x39,W
119FA:  MOVWF  FEA
119FC:  MOVFF  FEC,D3C
11A00:  MOVF   FED,F
11A02:  MOVFF  FEF,D3B
11A06:  MOVLW  5E
11A08:  ADDWF  x38,W
11A0A:  MOVWF  01
11A0C:  MOVLW  00
11A0E:  ADDWFC x39,W
11A10:  MOVWF  03
11A12:  MOVFF  01,C42
11A16:  MOVWF  x43
11A18:  MOVLW  82
11A1A:  ADDWF  x38,W
11A1C:  MOVWF  FE9
11A1E:  MOVLW  00
11A20:  ADDWFC x39,W
11A22:  MOVWF  FEA
11A24:  MOVFF  FEF,D3F
11A28:  MOVFF  03,D3E
11A2C:  MOVFF  01,D3D
11A30:  MOVLB  D
11A32:  CLRF   x42
11A34:  CLRF   x41
11A36:  CLRF   x40
11A38:  MOVLB  0
11A3A:  CALL   8EDE
....................             if(m->turn_off_soft_command[1] == 0xBE){ // Workaround to set the monitor byte 
11A3E:  MOVLW  5F
11A40:  MOVLB  C
11A42:  ADDWF  x38,W
11A44:  MOVWF  FE9
11A46:  MOVLW  00
11A48:  ADDWFC x39,W
11A4A:  MOVWF  FEA
11A4C:  MOVF   FEF,W
11A4E:  SUBLW  BE
11A50:  BNZ   11A62
....................                 rpi_status = m->turn_off_soft_command[2]; 
11A52:  MOVLW  60
11A54:  ADDWF  x38,W
11A56:  MOVWF  FE9
11A58:  MOVLW  00
11A5A:  ADDWFC x39,W
11A5C:  MOVWF  FEA
11A5E:  MOVFF  FEF,8AB
....................             } 
....................         } 
....................         break; 
11A62:  MOVLB  0
11A64:  BRA    11BCC
....................     case state_turn_off_subsystem_hard: 
....................         if (m->pin_number) { 
11A66:  MOVLW  0C
11A68:  MOVLB  C
11A6A:  ADDWF  x38,W
11A6C:  MOVWF  FE9
11A6E:  MOVLW  00
11A70:  ADDWFC x39,W
11A72:  MOVWF  FEA
11A74:  MOVF   FEF,F
11A76:  BNZ   11A7C
11A78:  MOVF   FEC,F
11A7A:  BZ    11AD6
....................             output_bit(m->pin_number, !m->turn_on_value); 
11A7C:  MOVLW  0C
11A7E:  ADDWF  x38,W
11A80:  MOVWF  FE9
11A82:  MOVLW  00
11A84:  ADDWFC x39,W
11A86:  MOVWF  FEA
11A88:  MOVFF  FEC,C41
11A8C:  MOVF   FED,F
11A8E:  MOVFF  FEF,C40
11A92:  MOVLW  0B
11A94:  ADDWF  x38,W
11A96:  MOVWF  FE9
11A98:  MOVLW  00
11A9A:  ADDWFC x39,W
11A9C:  MOVWF  FEA
11A9E:  MOVF   FEF,F
11AA0:  BZ    11AA6
11AA2:  MOVLW  00
11AA4:  BRA    11AA8
11AA6:  MOVLW  01
11AA8:  MOVFF  C40,D68
11AAC:  MOVLB  D
11AAE:  MOVWF  x69
11AB0:  MOVLW  0F
11AB2:  MOVWF  x6B
11AB4:  MOVLW  89
11AB6:  MOVWF  x6A
11AB8:  MOVLB  0
11ABA:  CALL   53D6
11ABE:  MOVFF  C40,D68
11AC2:  MOVLB  D
11AC4:  CLRF   x69
11AC6:  MOVLW  0F
11AC8:  MOVWF  x6B
11ACA:  MOVLW  92
11ACC:  MOVWF  x6A
11ACE:  MOVLB  0
11AD0:  CALL   53D6
11AD4:  MOVLB  C
....................         } 
....................         if (m->turn_off_hard_command_size) { 
11AD6:  MOVLW  A7
11AD8:  ADDWF  x38,W
11ADA:  MOVWF  FE9
11ADC:  MOVLW  00
11ADE:  ADDWFC x39,W
11AE0:  MOVWF  FEA
11AE2:  MOVF   FEF,F
11AE4:  BZ    11BA2
....................             checksum_obc(m->turn_off_hard_command, m->turn_off_hard_command_size); 
11AE6:  MOVLW  83
11AE8:  ADDWF  x38,W
11AEA:  MOVWF  01
11AEC:  MOVLW  00
11AEE:  ADDWFC x39,W
11AF0:  MOVWF  03
11AF2:  MOVFF  01,C40
11AF6:  MOVWF  x41
11AF8:  MOVLW  A7
11AFA:  ADDWF  x38,W
11AFC:  MOVWF  FE9
11AFE:  MOVLW  00
11B00:  ADDWFC x39,W
11B02:  MOVWF  FEA
11B04:  MOVFF  FEF,CB0
11B08:  MOVFF  03,CAF
11B0C:  MOVFF  01,CAE
11B10:  MOVLB  0
11B12:  CALL   8E80
....................             mux_sel(m->mux_position_on_off); 
11B16:  MOVLW  13
11B18:  MOVLB  C
11B1A:  ADDWF  x38,W
11B1C:  MOVWF  FE9
11B1E:  MOVLW  00
11B20:  ADDWFC x39,W
11B22:  MOVWF  FEA
11B24:  MOVFF  FEF,CBE
11B28:  MOVLB  0
11B2A:  CALL   52E8
....................             uart_send_packet(m->on_off_command_port, m->turn_off_hard_command, m->turn_off_hard_command_size); 
11B2E:  MOVLW  10
11B30:  MOVLB  C
11B32:  ADDWF  x38,W
11B34:  MOVWF  FE9
11B36:  MOVLW  00
11B38:  ADDWFC x39,W
11B3A:  MOVWF  FEA
11B3C:  MOVFF  FEC,D3C
11B40:  MOVF   FED,F
11B42:  MOVFF  FEF,D3B
11B46:  MOVLW  83
11B48:  ADDWF  x38,W
11B4A:  MOVWF  01
11B4C:  MOVLW  00
11B4E:  ADDWFC x39,W
11B50:  MOVWF  03
11B52:  MOVFF  01,C42
11B56:  MOVWF  x43
11B58:  MOVLW  A7
11B5A:  ADDWF  x38,W
11B5C:  MOVWF  FE9
11B5E:  MOVLW  00
11B60:  ADDWFC x39,W
11B62:  MOVWF  FEA
11B64:  MOVFF  FEF,D3F
11B68:  MOVFF  03,D3E
11B6C:  MOVFF  01,D3D
11B70:  MOVLB  D
11B72:  CLRF   x42
11B74:  CLRF   x41
11B76:  CLRF   x40
11B78:  MOVLB  0
11B7A:  CALL   8EDE
....................             if(m->turn_off_hard_command[1] == 0xBE){ // Workaround to set the monitor byte 
11B7E:  MOVLW  84
11B80:  MOVLB  C
11B82:  ADDWF  x38,W
11B84:  MOVWF  FE9
11B86:  MOVLW  00
11B88:  ADDWFC x39,W
11B8A:  MOVWF  FEA
11B8C:  MOVF   FEF,W
11B8E:  SUBLW  BE
11B90:  BNZ   11BA2
....................                 rpi_status = m->turn_off_hard_command[2]; 
11B92:  MOVLW  85
11B94:  ADDWF  x38,W
11B96:  MOVWF  FE9
11B98:  MOVLW  00
11B9A:  ADDWFC x39,W
11B9C:  MOVWF  FEA
11B9E:  MOVFF  FEF,8AB
....................             } 
....................         } 
....................         break; 
11BA2:  MOVLB  0
11BA4:  BRA    11BCC
....................     default: 
....................         fprintf(PC, "Invalid state!"); 
11BA6:  MOVLW  12
11BA8:  MOVWF  FF6
11BAA:  MOVLW  1E
11BAC:  MOVWF  FF7
11BAE:  MOVLW  00
11BB0:  MOVWF  FF8
11BB2:  CALL   4534
....................         return *state; 
11BB6:  MOVFF  C3D,03
11BBA:  MOVLB  C
11BBC:  MOVFF  C3C,FE9
11BC0:  MOVFF  C3D,FEA
11BC4:  MOVFF  FEF,01
11BC8:  BRA    11F34
11BCA:  MOVLB  0
....................     } 
....................  
....................     // Determine the next state 
....................     switch (*state) { 
11BCC:  MOVFF  C3D,03
11BD0:  MOVLB  C
11BD2:  MOVF   x3C,W
11BD4:  MOVWF  FE9
11BD6:  MOVFF  03,FEA
11BDA:  MOVF   FEF,W
11BDC:  XORLW  00
11BDE:  MOVLB  0
11BE0:  BZ    11C02
11BE2:  XORLW  01
11BE4:  BTFSC  FD8.2
11BE6:  BRA    11D4E
11BE8:  XORLW  03
11BEA:  BTFSC  FD8.2
11BEC:  BRA    11DCC
11BEE:  XORLW  01
11BF0:  BTFSC  FD8.2
11BF2:  BRA    11E02
11BF4:  XORLW  07
11BF6:  BTFSC  FD8.2
11BF8:  BRA    11E80
11BFA:  XORLW  01
11BFC:  BTFSC  FD8.2
11BFE:  BRA    11F1E
11C00:  BRA    11F1E
....................     case state_schedule: 
....................         *adcs_enabled = m->mission_time ? true : false; // Disable the ADCS maneuvers if not a scheduled command 
11C02:  MOVFF  C3F,03
11C06:  MOVLB  C
11C08:  MOVFF  C3E,C40
11C0C:  MOVFF  C3F,C41
11C10:  MOVFF  C38,FE9
11C14:  MOVFF  C39,FEA
11C18:  MOVF   FEF,F
11C1A:  BNZ   11C28
11C1C:  MOVF   FEC,F
11C1E:  BNZ   11C28
11C20:  MOVF   FEC,F
11C22:  BNZ   11C28
11C24:  MOVF   FEC,F
11C26:  BZ    11C2C
11C28:  MOVLW  01
11C2A:  BRA    11C2E
11C2C:  MOVLW  00
11C2E:  MOVFF  C41,FEA
11C32:  MOVFF  C40,FE9
11C36:  MOVWF  FEF
....................         if(m->mission_time == 0){ 
11C38:  MOVFF  C38,FE9
11C3C:  MOVFF  C39,FEA
11C40:  MOVFF  FEF,C40
11C44:  MOVFF  FEC,C41
11C48:  MOVFF  FEC,C42
11C4C:  MOVFF  FEC,C43
11C50:  MOVF   x40,F
11C52:  BNZ   11CD6
11C54:  MOVF   x41,F
11C56:  BNZ   11CD6
11C58:  MOVF   x42,F
11C5A:  BNZ   11CD6
11C5C:  MOVF   x43,F
11C5E:  BNZ   11CD6
....................             if(m->mission_on_time == 0) { 
11C60:  MOVLW  09
11C62:  ADDWF  x38,W
11C64:  MOVWF  FE9
11C66:  MOVLW  00
11C68:  ADDWFC x39,W
11C6A:  MOVWF  FEA
11C6C:  MOVFF  FEC,C41
11C70:  MOVF   FED,F
11C72:  MOVFF  FEF,C40
11C76:  MOVF   x40,F
11C78:  BNZ   11C98
11C7A:  MOVF   x41,F
11C7C:  BNZ   11C98
....................                 m->mission_time = current_time; 
11C7E:  MOVFF  C38,FE9
11C82:  MOVFF  C39,FEA
11C86:  MOVFF  3B,FEF
11C8A:  MOVFF  3C,FEC
11C8E:  MOVFF  3D,FEC
11C92:  MOVFF  3E,FEC
....................             } else { 
11C96:  BRA    11CD6
....................                 m->mission_time = current_time + m->mission_on_time; 
11C98:  MOVLW  09
11C9A:  ADDWF  x38,W
11C9C:  MOVWF  FE9
11C9E:  MOVLW  00
11CA0:  ADDWFC x39,W
11CA2:  MOVWF  FEA
11CA4:  MOVFF  FEC,03
11CA8:  MOVF   FED,F
11CAA:  MOVF   FEF,W
11CAC:  ADDWF  3B,W
11CAE:  MOVWF  00
11CB0:  MOVF   03,W
11CB2:  ADDWFC 3C,W
11CB4:  MOVWF  01
11CB6:  MOVLW  00
11CB8:  ADDWFC 3D,W
11CBA:  MOVWF  02
11CBC:  MOVLW  00
11CBE:  ADDWFC 3E,W
11CC0:  MOVFF  C39,FEA
11CC4:  MOVFF  C38,FE9
11CC8:  MOVFF  00,FEF
11CCC:  MOVFF  01,FEC
11CD0:  MOVFF  02,FEC
11CD4:  MOVWF  FEC
....................             } 
....................         } 
....................         if (*adcs_enabled) { 
11CD6:  MOVFF  C3F,03
11CDA:  MOVFF  C3E,FE9
11CDE:  MOVFF  C3F,FEA
11CE2:  MOVF   FEF,F
11CE4:  BZ    11D4C
....................             *state = state_initial_adcs_mode; 
11CE6:  MOVFF  C3C,FE9
11CEA:  MOVFF  C3D,FEA
11CEE:  MOVLW  01
11CF0:  MOVWF  FEF
....................             vschedule(m->mission_time - m->adcs_maneuver_duration, data); 
11CF2:  MOVFF  C38,FE9
11CF6:  MOVFF  C39,FEA
11CFA:  MOVFF  FEF,C40
11CFE:  MOVFF  FEC,C41
11D02:  MOVFF  FEC,C42
11D06:  MOVFF  FEC,C43
11D0A:  MOVLW  07
11D0C:  ADDWF  x38,W
11D0E:  MOVWF  FE9
11D10:  MOVLW  00
11D12:  ADDWFC x39,W
11D14:  MOVWF  FEA
11D16:  MOVFF  FEC,03
11D1A:  MOVF   FED,F
11D1C:  MOVF   FEF,W
11D1E:  SUBWF  x40,F
11D20:  MOVF   03,W
11D22:  SUBWFB x41,F
11D24:  MOVLW  00
11D26:  SUBWFB x42,F
11D28:  SUBWFB x43,F
11D2A:  MOVFF  C43,C98
11D2E:  MOVFF  C42,C97
11D32:  MOVFF  C41,C96
11D36:  MOVFF  C40,C95
11D3A:  MOVFF  C3B,C9A
11D3E:  MOVFF  C3A,C99
11D42:  MOVLB  0
11D44:  CALL   704C
....................             break; 
11D48:  BRA    11F2E
11D4A:  MOVLB  C
11D4C:  MOVLB  0
....................         } 
....................     case state_initial_adcs_mode: 
....................         if (m->mission_on_time) { 
11D4E:  MOVLW  09
11D50:  MOVLB  C
11D52:  ADDWF  x38,W
11D54:  MOVWF  FE9
11D56:  MOVLW  00
11D58:  ADDWFC x39,W
11D5A:  MOVWF  FEA
11D5C:  MOVF   FEF,F
11D5E:  BNZ   11D64
11D60:  MOVF   FEC,F
11D62:  BZ    11DCA
....................             *state = state_turn_on_subsystem; 
11D64:  MOVFF  C3C,FE9
11D68:  MOVFF  C3D,FEA
11D6C:  MOVLW  02
11D6E:  MOVWF  FEF
....................             vschedule(m->mission_time - m->mission_on_time, data); 
11D70:  MOVFF  C38,FE9
11D74:  MOVFF  C39,FEA
11D78:  MOVFF  FEF,C40
11D7C:  MOVFF  FEC,C41
11D80:  MOVFF  FEC,C42
11D84:  MOVFF  FEC,C43
11D88:  MOVLW  09
11D8A:  ADDWF  x38,W
11D8C:  MOVWF  FE9
11D8E:  MOVLW  00
11D90:  ADDWFC x39,W
11D92:  MOVWF  FEA
11D94:  MOVFF  FEC,03
11D98:  MOVF   FED,F
11D9A:  MOVF   FEF,W
11D9C:  SUBWF  x40,F
11D9E:  MOVF   03,W
11DA0:  SUBWFB x41,F
11DA2:  MOVLW  00
11DA4:  SUBWFB x42,F
11DA6:  SUBWFB x43,F
11DA8:  MOVFF  C43,C98
11DAC:  MOVFF  C42,C97
11DB0:  MOVFF  C41,C96
11DB4:  MOVFF  C40,C95
11DB8:  MOVFF  C3B,C9A
11DBC:  MOVFF  C3A,C99
11DC0:  MOVLB  0
11DC2:  CALL   704C
....................             break; 
11DC6:  BRA    11F2E
11DC8:  MOVLB  C
11DCA:  MOVLB  0
....................         } 
....................     case state_turn_on_subsystem: 
....................         *state = state_send_uplink_command; 
11DCC:  MOVLB  C
11DCE:  MOVFF  C3C,FE9
11DD2:  MOVFF  C3D,FEA
11DD6:  MOVLW  03
11DD8:  MOVWF  FEF
....................         vschedule(m->mission_time, data); 
11DDA:  MOVFF  C38,FE9
11DDE:  MOVFF  C39,FEA
11DE2:  MOVFF  FEF,C95
11DE6:  MOVFF  FEC,C96
11DEA:  MOVFF  FEC,C97
11DEE:  MOVFF  FEC,C98
11DF2:  MOVFF  C3B,C9A
11DF6:  MOVFF  C3A,C99
11DFA:  MOVLB  0
11DFC:  CALL   704C
....................         break; 
11E00:  BRA    11F2E
....................     case state_send_uplink_command: 
....................         if (m->mission_duration) { 
11E02:  MOVLW  04
11E04:  MOVLB  C
11E06:  ADDWF  x38,W
11E08:  MOVWF  FE9
11E0A:  MOVLW  00
11E0C:  ADDWFC x39,W
11E0E:  MOVWF  FEA
11E10:  MOVF   FEF,F
11E12:  BNZ   11E18
11E14:  MOVF   FEC,F
11E16:  BZ    11E7E
....................             *state = state_turn_off_subsystem_soft; 
11E18:  MOVFF  C3C,FE9
11E1C:  MOVFF  C3D,FEA
11E20:  MOVLW  04
11E22:  MOVWF  FEF
....................             vschedule(m->mission_time + m->mission_duration, data); 
11E24:  MOVFF  C38,FE9
11E28:  MOVFF  C39,FEA
11E2C:  MOVFF  FEF,C40
11E30:  MOVFF  FEC,C41
11E34:  MOVFF  FEC,C42
11E38:  MOVFF  FEC,C43
11E3C:  MOVLW  04
11E3E:  ADDWF  x38,W
11E40:  MOVWF  FE9
11E42:  MOVLW  00
11E44:  ADDWFC x39,W
11E46:  MOVWF  FEA
11E48:  MOVFF  FEC,03
11E4C:  MOVF   FED,F
11E4E:  MOVF   FEF,W
11E50:  ADDWF  x40,F
11E52:  MOVF   03,W
11E54:  ADDWFC x41,F
11E56:  MOVLW  00
11E58:  ADDWFC x42,F
11E5A:  ADDWFC x43,F
11E5C:  MOVFF  C43,C98
11E60:  MOVFF  C42,C97
11E64:  MOVFF  C41,C96
11E68:  MOVFF  C40,C95
11E6C:  MOVFF  C3B,C9A
11E70:  MOVFF  C3A,C99
11E74:  MOVLB  0
11E76:  CALL   704C
....................             break; 
11E7A:  BRA    11F2E
11E7C:  MOVLB  C
11E7E:  MOVLB  0
....................         } 
....................     case state_turn_off_subsystem_soft: 
....................         if (m->turn_off_duration) { 
11E80:  MOVLW  A8
11E82:  MOVLB  C
11E84:  ADDWF  x38,W
11E86:  MOVWF  FE9
11E88:  MOVLW  00
11E8A:  ADDWFC x39,W
11E8C:  MOVWF  FEA
11E8E:  MOVF   FEF,F
11E90:  BNZ   11E96
11E92:  MOVF   FEC,F
11E94:  BZ    11F1C
....................             *state = state_turn_off_subsystem_hard; 
11E96:  MOVFF  C3C,FE9
11E9A:  MOVFF  C3D,FEA
11E9E:  MOVLW  05
11EA0:  MOVWF  FEF
....................             vschedule(m->mission_time + m->mission_duration + m->turn_off_duration, data); 
11EA2:  MOVFF  C38,FE9
11EA6:  MOVFF  C39,FEA
11EAA:  MOVFF  FEF,C40
11EAE:  MOVFF  FEC,C41
11EB2:  MOVFF  FEC,C42
11EB6:  MOVFF  FEC,C43
11EBA:  MOVLW  04
11EBC:  ADDWF  x38,W
11EBE:  MOVWF  FE9
11EC0:  MOVLW  00
11EC2:  ADDWFC x39,W
11EC4:  MOVWF  FEA
11EC6:  MOVFF  FEC,03
11ECA:  MOVF   FED,F
11ECC:  MOVF   FEF,W
11ECE:  ADDWF  x40,F
11ED0:  MOVF   03,W
11ED2:  ADDWFC x41,F
11ED4:  MOVLW  00
11ED6:  ADDWFC x42,F
11ED8:  ADDWFC x43,F
11EDA:  MOVLW  A8
11EDC:  ADDWF  x38,W
11EDE:  MOVWF  FE9
11EE0:  MOVLW  00
11EE2:  ADDWFC x39,W
11EE4:  MOVWF  FEA
11EE6:  MOVFF  FEC,03
11EEA:  MOVF   FED,F
11EEC:  MOVF   FEF,W
11EEE:  ADDWF  x40,F
11EF0:  MOVF   03,W
11EF2:  ADDWFC x41,F
11EF4:  MOVLW  00
11EF6:  ADDWFC x42,F
11EF8:  ADDWFC x43,F
11EFA:  MOVFF  C43,C98
11EFE:  MOVFF  C42,C97
11F02:  MOVFF  C41,C96
11F06:  MOVFF  C40,C95
11F0A:  MOVFF  C3B,C9A
11F0E:  MOVFF  C3A,C99
11F12:  MOVLB  0
11F14:  CALL   704C
....................             break; 
11F18:  BRA    11F2E
11F1A:  MOVLB  C
11F1C:  MOVLB  0
....................         } 
....................     case state_turn_off_subsystem_hard: 
....................     default: 
....................         *state = state_end; 
11F1E:  MOVLB  C
11F20:  MOVFF  C3C,FE9
11F24:  MOVFF  C3D,FEA
11F28:  MOVLW  06
11F2A:  MOVWF  FEF
....................         break; 
11F2C:  MOVLB  0
....................     } 
....................  
....................     return 0; 
11F2E:  MOVLW  00
11F30:  MOVWF  01
11F32:  MOVLB  C
11F34:  MOVLB  0
11F36:  GOTO   18D16 (RETURN)
.................... } 
....................  
.................... uint16_t camera_still_duration(uint8_t* data) 
*
1071C:  MOVFF  C52,C54
10720:  MOVFF  C51,C53
10724:  MOVLB  C
10726:  CLRF   x56
10728:  CLRF   x55
.................... { 
....................     enum constants { 
....................         camera_config_length = 11, 
....................         camera_capture_length = 4, 
....................         a = 1, 
....................         b = 60 
....................     }; 
....................  
....................     struct rpi_camera_still { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[camera_config_length + camera_capture_length]; 
....................     }* packet = (struct rpi_camera_still*)data; 
....................  
....................     uint16_t bitOffset = 0; 
....................  
....................     // Camera capture configuration command 
....................     uint32_t shutterSpeed[3]; 
....................  
....................     for (int i = 0; i < 3; ++i) { 
1072A:  CLRF   x63
1072C:  MOVF   x63,W
1072E:  SUBLW  02
10730:  BTFSS  FD8.0
10732:  BRA    1089C
....................         uint8_t shutterSpeedMantissa = get_bits(packet->data, &bitOffset, 4); 
....................         uint8_t shutterSpeedExponent = get_bits(packet->data, &bitOffset, 3); 
10734:  MOVLW  02
10736:  ADDWF  x53,W
10738:  MOVWF  x6D
1073A:  MOVLW  00
1073C:  ADDWFC x54,W
1073E:  MOVWF  x6E
10740:  MOVFF  C6E,C78
10744:  MOVFF  C6D,C77
10748:  MOVLW  0C
1074A:  MOVWF  x7A
1074C:  MOVLW  55
1074E:  MOVWF  x79
10750:  MOVLW  04
10752:  MOVWF  x7B
10754:  MOVLB  0
10756:  CALL   EED4
1075A:  MOVFF  00,C64
1075E:  MOVLW  02
10760:  MOVLB  C
10762:  ADDWF  x53,W
10764:  MOVWF  x6D
10766:  MOVLW  00
10768:  ADDWFC x54,W
1076A:  MOVWF  x6E
1076C:  MOVFF  C6E,C78
10770:  MOVFF  C6D,C77
10774:  MOVLW  0C
10776:  MOVWF  x7A
10778:  MOVLW  55
1077A:  MOVWF  x79
1077C:  MOVLW  03
1077E:  MOVWF  x7B
10780:  MOVLB  0
10782:  CALL   EED4
10786:  MOVFF  00,C65
....................         shutterSpeed[i] = (double)shutterSpeedMantissa * pow(10, shutterSpeedExponent) + 0.5; // Using base 10 exponentiation 
1078A:  MOVLB  C
1078C:  MOVF   x63,W
1078E:  MULLW  04
10790:  MOVF   FF3,W
10792:  CLRF   03
10794:  ADDLW  57
10796:  MOVWF  x6D
10798:  MOVLW  0C
1079A:  ADDWFC 03,W
1079C:  MOVWF  x6E
1079E:  CLRF   xA8
107A0:  MOVFF  C64,CA7
107A4:  MOVLB  0
107A6:  CALL   EFF2
107AA:  MOVFF  03,C72
107AE:  MOVFF  02,C71
107B2:  MOVFF  01,C70
107B6:  MOVFF  00,C6F
107BA:  MOVLB  C
107BC:  CLRF   xA8
107BE:  MOVFF  C65,CA7
107C2:  MOVLB  0
107C4:  CALL   EFF2
107C8:  MOVFF  03,C76
107CC:  MOVFF  02,C75
107D0:  MOVFF  01,C74
107D4:  MOVFF  00,C73
107D8:  MOVLB  C
107DA:  CLRF   x7A
107DC:  CLRF   x79
107DE:  MOVLW  20
107E0:  MOVWF  x78
107E2:  MOVLW  82
107E4:  MOVWF  x77
107E6:  MOVFF  C76,C7E
107EA:  MOVFF  C75,C7D
107EE:  MOVFF  C74,C7C
107F2:  MOVFF  C73,C7B
107F6:  MOVLB  0
107F8:  BRA    10410
107FA:  MOVFF  C72,CA6
107FE:  MOVFF  C71,CA5
10802:  MOVFF  C70,CA4
10806:  MOVFF  C6F,CA3
1080A:  MOVFF  03,CAA
1080E:  MOVFF  02,CA9
10812:  MOVFF  01,CA8
10816:  MOVFF  00,CA7
1081A:  CALL   F23C
1081E:  MOVFF  03,C72
10822:  MOVFF  02,C71
10826:  MOVFF  01,C70
1082A:  MOVFF  00,C6F
1082E:  MOVFF  FEA,C74
10832:  MOVFF  FE9,C73
10836:  BCF    FD8.1
10838:  MOVFF  C72,CAA
1083C:  MOVFF  C71,CA9
10840:  MOVFF  C70,CA8
10844:  MOVFF  C6F,CA7
10848:  MOVLB  C
1084A:  CLRF   xAE
1084C:  CLRF   xAD
1084E:  CLRF   xAC
10850:  MOVLW  7E
10852:  MOVWF  xAB
10854:  MOVLB  0
10856:  CALL   F332
1085A:  MOVFF  C74,FEA
1085E:  MOVFF  C73,FE9
10862:  MOVFF  03,C78
10866:  MOVFF  02,C77
1086A:  MOVFF  01,C76
1086E:  MOVFF  00,C75
10872:  CALL   FE76
10876:  MOVFF  C6E,FEA
1087A:  MOVFF  C6D,FE9
1087E:  MOVFF  00,FEF
10882:  MOVFF  01,FEC
10886:  MOVFF  02,FEC
1088A:  MOVFF  03,FEC
....................  
....................         bitOffset += 20; 
1088E:  MOVLW  14
10890:  MOVLB  C
10892:  ADDWF  x55,F
10894:  MOVLW  00
10896:  ADDWFC x56,F
10898:  INCF   x63,F
1089A:  BRA    1072C
....................     } 
....................  
....................     bitOffset += 7; 
1089C:  MOVLW  07
1089E:  ADDWF  x55,F
108A0:  MOVLW  00
108A2:  ADDWFC x56,F
....................  
....................     // Camera capture command 
....................     uint8_t cameraSelection[3]; 
....................     cameraSelection[0] = get_bits(packet->data, &bitOffset, 1); 
108A4:  MOVLW  02
108A6:  ADDWF  x53,W
108A8:  MOVWF  x6D
108AA:  MOVLW  00
108AC:  ADDWFC x54,W
108AE:  MOVWF  x6E
108B0:  MOVFF  C6E,C78
108B4:  MOVFF  C6D,C77
108B8:  MOVLW  0C
108BA:  MOVWF  x7A
108BC:  MOVLW  55
108BE:  MOVWF  x79
108C0:  MOVLW  01
108C2:  MOVWF  x7B
108C4:  MOVLB  0
108C6:  CALL   EED4
108CA:  MOVFF  00,C66
....................     cameraSelection[1] = get_bits(packet->data, &bitOffset, 1); 
108CE:  MOVLW  02
108D0:  MOVLB  C
108D2:  ADDWF  x53,W
108D4:  MOVWF  x6D
108D6:  MOVLW  00
108D8:  ADDWFC x54,W
108DA:  MOVWF  x6E
108DC:  MOVFF  C6E,C78
108E0:  MOVFF  C6D,C77
108E4:  MOVLW  0C
108E6:  MOVWF  x7A
108E8:  MOVLW  55
108EA:  MOVWF  x79
108EC:  MOVLW  01
108EE:  MOVWF  x7B
108F0:  MOVLB  0
108F2:  CALL   EED4
108F6:  MOVFF  00,C67
....................     cameraSelection[2] = get_bits(packet->data, &bitOffset, 1); 
108FA:  MOVLW  02
108FC:  MOVLB  C
108FE:  ADDWF  x53,W
10900:  MOVWF  x6D
10902:  MOVLW  00
10904:  ADDWFC x54,W
10906:  MOVWF  x6E
10908:  MOVFF  C6E,C78
1090C:  MOVFF  C6D,C77
10910:  MOVLW  0C
10912:  MOVWF  x7A
10914:  MOVLW  55
10916:  MOVWF  x79
10918:  MOVLW  01
1091A:  MOVWF  x7B
1091C:  MOVLB  0
1091E:  CALL   EED4
10922:  MOVFF  00,C68
....................  
....................     bitOffset += 16; 
10926:  MOVLW  10
10928:  MOVLB  C
1092A:  ADDWF  x55,F
1092C:  MOVLW  00
1092E:  ADDWFC x56,F
....................     uint8_t sequentialPictures = get_bits(packet->data, &bitOffset, 6); 
....................     uint8_t intervalBetweenPictures = get_bits(packet->data, &bitOffset, 7); 
10930:  MOVLW  02
10932:  ADDWF  x53,W
10934:  MOVWF  x6D
10936:  MOVLW  00
10938:  ADDWFC x54,W
1093A:  MOVWF  x6E
1093C:  MOVFF  C6E,C78
10940:  MOVFF  C6D,C77
10944:  MOVLW  0C
10946:  MOVWF  x7A
10948:  MOVLW  55
1094A:  MOVWF  x79
1094C:  MOVLW  06
1094E:  MOVWF  x7B
10950:  MOVLB  0
10952:  CALL   EED4
10956:  MOVFF  00,C69
1095A:  MOVLW  02
1095C:  MOVLB  C
1095E:  ADDWF  x53,W
10960:  MOVWF  x6D
10962:  MOVLW  00
10964:  ADDWFC x54,W
10966:  MOVWF  x6E
10968:  MOVFF  C6E,C78
1096C:  MOVFF  C6D,C77
10970:  MOVLW  0C
10972:  MOVWF  x7A
10974:  MOVLW  55
10976:  MOVWF  x79
10978:  MOVLW  07
1097A:  MOVWF  x7B
1097C:  MOVLB  0
1097E:  CALL   EED4
10982:  MOVFF  00,C6A
....................  
....................     // Print human-readable output to PC 
....................     if (verbose) { 
10986:  MOVLB  5
10988:  MOVF   x5A,F
1098A:  BTFSC  FD8.2
1098C:  BRA    10B00
....................         fprintf(PC, 
....................             "Camera capture configuration:\r\n" 
....................             "Camera Selection: %u, %u, %u\r\n" 
....................             "Sequential Pictures: %u\r\n" 
....................             "Interval Between Pictures: %u seconds\r\n" 
....................             "Shutter Speeds: %lu, %lu, %lu (microseconds)\r\n", 
....................             cameraSelection[0],                               // 8-bit value 
....................             cameraSelection[1],                               // 8-bit value 
....................             cameraSelection[2],                               // 8-bit value 
....................             sequentialPictures,                               // 8-bit value 
....................             intervalBetweenPictures,                          // 8-bit value 
....................             shutterSpeed[0], shutterSpeed[1], shutterSpeed[2] // 32-bit values 
....................         ); 
1098E:  MOVLW  22
10990:  MOVWF  FF6
10992:  MOVLW  1E
10994:  MOVWF  FF7
10996:  MOVLW  00
10998:  MOVWF  FF8
1099A:  MOVLW  31
1099C:  MOVLB  C
1099E:  MOVWF  xC1
109A0:  MOVLB  0
109A2:  CALL   5290
109A6:  MOVFF  C66,C78
109AA:  MOVLW  1B
109AC:  MOVLB  C
109AE:  MOVWF  x79
109B0:  MOVLB  0
109B2:  CALL   5ADC
109B6:  MOVLW  2C
109B8:  MOVLB  D
109BA:  MOVWF  x6A
109BC:  MOVLB  0
109BE:  CALL   44EE
109C2:  MOVLW  20
109C4:  MOVLB  D
109C6:  MOVWF  x6A
109C8:  MOVLB  0
109CA:  CALL   44EE
109CE:  MOVFF  C67,C78
109D2:  MOVLW  1B
109D4:  MOVLB  C
109D6:  MOVWF  x79
109D8:  MOVLB  0
109DA:  CALL   5ADC
109DE:  MOVLW  2C
109E0:  MOVLB  D
109E2:  MOVWF  x6A
109E4:  MOVLB  0
109E6:  CALL   44EE
109EA:  MOVLW  20
109EC:  MOVLB  D
109EE:  MOVWF  x6A
109F0:  MOVLB  0
109F2:  CALL   44EE
109F6:  MOVFF  C68,C78
109FA:  MOVLW  1B
109FC:  MOVLB  C
109FE:  MOVWF  x79
10A00:  MOVLB  0
10A02:  CALL   5ADC
10A06:  MOVLW  5D
10A08:  MOVWF  FF6
10A0A:  MOVLW  1E
10A0C:  MOVWF  FF7
10A0E:  MOVLW  00
10A10:  MOVWF  FF8
10A12:  MOVLW  17
10A14:  MOVLB  C
10A16:  MOVWF  xC1
10A18:  MOVLB  0
10A1A:  CALL   5290
10A1E:  MOVFF  C69,C78
10A22:  MOVLW  1B
10A24:  MOVLB  C
10A26:  MOVWF  x79
10A28:  MOVLB  0
10A2A:  CALL   5ADC
10A2E:  MOVLW  76
10A30:  MOVWF  FF6
10A32:  MOVLW  1E
10A34:  MOVWF  FF7
10A36:  MOVLW  00
10A38:  MOVWF  FF8
10A3A:  MOVLW  1D
10A3C:  MOVLB  C
10A3E:  MOVWF  xC1
10A40:  MOVLB  0
10A42:  CALL   5290
10A46:  MOVFF  C6A,C78
10A4A:  MOVLW  1B
10A4C:  MOVLB  C
10A4E:  MOVWF  x79
10A50:  MOVLB  0
10A52:  CALL   5ADC
10A56:  MOVLW  95
10A58:  MOVWF  FF6
10A5A:  MOVLW  1E
10A5C:  MOVWF  FF7
10A5E:  MOVLW  00
10A60:  MOVWF  FF8
10A62:  MOVLW  1A
10A64:  MOVLB  C
10A66:  MOVWF  xC1
10A68:  MOVLB  0
10A6A:  CALL   5290
10A6E:  MOVLW  41
10A70:  MOVWF  FE9
10A72:  MOVFF  C5A,C70
10A76:  MOVFF  C59,C6F
10A7A:  MOVFF  C58,C6E
10A7E:  MOVFF  C57,C6D
10A82:  CALL   FEB8
10A86:  MOVLW  2C
10A88:  MOVLB  D
10A8A:  MOVWF  x6A
10A8C:  MOVLB  0
10A8E:  CALL   44EE
10A92:  MOVLW  20
10A94:  MOVLB  D
10A96:  MOVWF  x6A
10A98:  MOVLB  0
10A9A:  CALL   44EE
10A9E:  MOVLW  41
10AA0:  MOVWF  FE9
10AA2:  MOVFF  C5E,C70
10AA6:  MOVFF  C5D,C6F
10AAA:  MOVFF  C5C,C6E
10AAE:  MOVFF  C5B,C6D
10AB2:  CALL   FEB8
10AB6:  MOVLW  2C
10AB8:  MOVLB  D
10ABA:  MOVWF  x6A
10ABC:  MOVLB  0
10ABE:  CALL   44EE
10AC2:  MOVLW  20
10AC4:  MOVLB  D
10AC6:  MOVWF  x6A
10AC8:  MOVLB  0
10ACA:  CALL   44EE
10ACE:  MOVLW  41
10AD0:  MOVWF  FE9
10AD2:  MOVFF  C62,C70
10AD6:  MOVFF  C61,C6F
10ADA:  MOVFF  C60,C6E
10ADE:  MOVFF  C5F,C6D
10AE2:  CALL   FEB8
10AE6:  MOVLW  BC
10AE8:  MOVWF  FF6
10AEA:  MOVLW  1E
10AEC:  MOVWF  FF7
10AEE:  MOVLW  00
10AF0:  MOVWF  FF8
10AF2:  MOVLW  11
10AF4:  MOVLB  C
10AF6:  MOVWF  xC1
10AF8:  MOVLB  0
10AFA:  CALL   5290
10AFE:  MOVLB  5
....................     } 
....................  
....................     uint16_t delay = (uint16_t)sequentialPictures * ((uint16_t)intervalBetweenPictures + (a * cameraSelection[0] * shutterSpeed[0] / 1000000L + a * cameraSelection[1] * shutterSpeed[1] / 1000000L + a * cameraSelection[2] * shutterSpeed[2] / 1000000L)) + b; 
10B00:  MOVLB  C
10B02:  CLRF   x6E
10B04:  MOVFF  C69,C6D
10B08:  CLRF   x70
10B0A:  MOVFF  C6A,C6F
10B0E:  CLRF   xB4
10B10:  CLRF   xB3
10B12:  CLRF   xB2
10B14:  MOVFF  C66,CB1
10B18:  MOVFF  C5A,CB8
10B1C:  MOVFF  C59,CB7
10B20:  MOVFF  C58,CB6
10B24:  MOVFF  C57,CB5
10B28:  MOVLB  0
10B2A:  CALL   456E
10B2E:  MOVFF  03,C74
10B32:  MOVFF  02,C73
10B36:  MOVFF  01,C72
10B3A:  MOVFF  00,C71
10B3E:  BCF    FD8.1
10B40:  MOVFF  C74,CB3
10B44:  MOVFF  C73,CB2
10B48:  MOVFF  C72,CB1
10B4C:  MOVFF  C71,CB0
10B50:  MOVLB  C
10B52:  CLRF   xB7
10B54:  MOVLW  0F
10B56:  MOVWF  xB6
10B58:  MOVLW  42
10B5A:  MOVWF  xB5
10B5C:  MOVLW  40
10B5E:  MOVWF  xB4
10B60:  MOVLB  0
10B62:  CALL   5852
10B66:  MOVFF  03,C74
10B6A:  MOVFF  02,C73
10B6E:  MOVFF  01,C72
10B72:  MOVFF  00,C71
10B76:  MOVLB  C
10B78:  CLRF   xB4
10B7A:  CLRF   xB3
10B7C:  CLRF   xB2
10B7E:  MOVFF  C67,CB1
10B82:  MOVFF  C5E,CB8
10B86:  MOVFF  C5D,CB7
10B8A:  MOVFF  C5C,CB6
10B8E:  MOVFF  C5B,CB5
10B92:  MOVLB  0
10B94:  CALL   456E
10B98:  MOVFF  03,C78
10B9C:  MOVFF  02,C77
10BA0:  MOVFF  01,C76
10BA4:  MOVFF  00,C75
10BA8:  BCF    FD8.1
10BAA:  MOVFF  C78,CB3
10BAE:  MOVFF  C77,CB2
10BB2:  MOVFF  C76,CB1
10BB6:  MOVFF  C75,CB0
10BBA:  MOVLB  C
10BBC:  CLRF   xB7
10BBE:  MOVLW  0F
10BC0:  MOVWF  xB6
10BC2:  MOVLW  42
10BC4:  MOVWF  xB5
10BC6:  MOVLW  40
10BC8:  MOVWF  xB4
10BCA:  MOVLB  0
10BCC:  CALL   5852
10BD0:  MOVF   00,W
10BD2:  MOVLB  C
10BD4:  ADDWF  x71,F
10BD6:  MOVF   01,W
10BD8:  ADDWFC x72,F
10BDA:  MOVF   02,W
10BDC:  ADDWFC x73,F
10BDE:  MOVF   03,W
10BE0:  ADDWFC x74,F
10BE2:  CLRF   xB4
10BE4:  CLRF   xB3
10BE6:  CLRF   xB2
10BE8:  MOVFF  C68,CB1
10BEC:  MOVFF  C62,CB8
10BF0:  MOVFF  C61,CB7
10BF4:  MOVFF  C60,CB6
10BF8:  MOVFF  C5F,CB5
10BFC:  MOVLB  0
10BFE:  CALL   456E
10C02:  MOVFF  03,C78
10C06:  MOVFF  02,C77
10C0A:  MOVFF  01,C76
10C0E:  MOVFF  00,C75
10C12:  BCF    FD8.1
10C14:  MOVFF  C78,CB3
10C18:  MOVFF  C77,CB2
10C1C:  MOVFF  C76,CB1
10C20:  MOVFF  C75,CB0
10C24:  MOVLB  C
10C26:  CLRF   xB7
10C28:  MOVLW  0F
10C2A:  MOVWF  xB6
10C2C:  MOVLW  42
10C2E:  MOVWF  xB5
10C30:  MOVLW  40
10C32:  MOVWF  xB4
10C34:  MOVLB  0
10C36:  CALL   5852
10C3A:  MOVLB  C
10C3C:  MOVF   x71,W
10C3E:  ADDWF  00,F
10C40:  MOVF   x72,W
10C42:  ADDWFC 01,F
10C44:  MOVF   x73,W
10C46:  ADDWFC 02,F
10C48:  MOVF   x74,W
10C4A:  ADDWFC 03,F
10C4C:  MOVF   00,W
10C4E:  ADDWF  x6F,F
10C50:  MOVF   01,W
10C52:  ADDWFC x70,F
10C54:  MOVLW  00
10C56:  ADDWFC 02,W
10C58:  MOVWF  x71
10C5A:  MOVLW  00
10C5C:  ADDWFC 03,W
10C5E:  MOVWF  x72
10C60:  CLRF   xB4
10C62:  CLRF   xB3
10C64:  MOVFF  C6E,CB2
10C68:  MOVFF  C6D,CB1
10C6C:  MOVFF  C72,CB8
10C70:  MOVFF  C71,CB7
10C74:  MOVFF  C70,CB6
10C78:  MOVFF  C6F,CB5
10C7C:  MOVLB  0
10C7E:  CALL   456E
10C82:  MOVFF  03,C70
10C86:  MOVFF  02,C6F
10C8A:  MOVFF  01,C6E
10C8E:  MOVFF  00,C6D
10C92:  MOVLW  3C
10C94:  MOVLB  C
10C96:  ADDWF  x6D,W
10C98:  MOVWF  x6B
10C9A:  MOVLW  00
10C9C:  ADDWFC x6E,W
10C9E:  MOVWF  x6C
....................  
....................     if (verbose) { 
10CA0:  MOVLB  5
10CA2:  MOVF   x5A,F
10CA4:  BZ    10CE8
....................         fprintf(PC, "Delay: %lu\r\n", delay); 
10CA6:  MOVLW  CE
10CA8:  MOVWF  FF6
10CAA:  MOVLW  1E
10CAC:  MOVWF  FF7
10CAE:  MOVLW  00
10CB0:  MOVWF  FF8
10CB2:  MOVLW  07
10CB4:  MOVLB  C
10CB6:  MOVWF  xC1
10CB8:  MOVLB  0
10CBA:  CALL   5290
10CBE:  MOVLW  10
10CC0:  MOVWF  FE9
10CC2:  MOVFF  C6C,C76
10CC6:  MOVFF  C6B,C75
10CCA:  CALL   59CA
10CCE:  MOVLW  0D
10CD0:  MOVLB  D
10CD2:  MOVWF  x6A
10CD4:  MOVLB  0
10CD6:  CALL   44EE
10CDA:  MOVLW  0A
10CDC:  MOVLB  D
10CDE:  MOVWF  x6A
10CE0:  MOVLB  0
10CE2:  CALL   44EE
10CE6:  MOVLB  5
....................     } 
....................  
....................     return delay; 
10CE8:  MOVLB  C
10CEA:  MOVFF  C6B,01
10CEE:  MOVFF  C6C,02
10CF2:  MOVLB  0
10CF4:  GOTO   112DA (RETURN)
.................... } 
....................  
.................... uint16_t camera_image_transform_duration(uint8_t* data) 
10CF8:  MOVFF  C52,C54
10CFC:  MOVFF  C51,C53
10D00:  MOVLB  C
10D02:  CLRF   x56
10D04:  MOVLW  55
10D06:  MOVWF  x55
.................... { 
....................     enum constants { 
....................         camera_image_transform_length = 11, 
....................         a = 20, 
....................         b = 20 
....................     }; 
....................  
....................     struct rpi_camera_transform { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[camera_image_transform_length]; 
....................     }* packet = (struct rpi_camera_transform*)data; 
....................  
....................     uint16_t bitOffset = 85; 
....................  
....................     uint8_t cameraSelection[3]; 
....................     cameraSelection[0] = get_bits(packet->data, &bitOffset, 1); 
10D08:  MOVLW  02
10D0A:  ADDWF  x53,W
10D0C:  MOVWF  01
10D0E:  MOVLW  00
10D10:  ADDWFC x54,W
10D12:  MOVWF  03
10D14:  MOVFF  01,C5C
10D18:  MOVWF  x5D
10D1A:  MOVWF  x78
10D1C:  MOVFF  01,C77
10D20:  MOVLW  0C
10D22:  MOVWF  x7A
10D24:  MOVLW  55
10D26:  MOVWF  x79
10D28:  MOVLW  01
10D2A:  MOVWF  x7B
10D2C:  MOVLB  0
10D2E:  CALL   EED4
10D32:  MOVFF  00,C57
....................     cameraSelection[1] = get_bits(packet->data, &bitOffset, 1); 
10D36:  MOVLW  02
10D38:  MOVLB  C
10D3A:  ADDWF  x53,W
10D3C:  MOVWF  01
10D3E:  MOVLW  00
10D40:  ADDWFC x54,W
10D42:  MOVWF  03
10D44:  MOVFF  01,C5C
10D48:  MOVWF  x5D
10D4A:  MOVWF  x78
10D4C:  MOVFF  01,C77
10D50:  MOVLW  0C
10D52:  MOVWF  x7A
10D54:  MOVLW  55
10D56:  MOVWF  x79
10D58:  MOVLW  01
10D5A:  MOVWF  x7B
10D5C:  MOVLB  0
10D5E:  CALL   EED4
10D62:  MOVFF  00,C58
....................     cameraSelection[2] = get_bits(packet->data, &bitOffset, 1); 
10D66:  MOVLW  02
10D68:  MOVLB  C
10D6A:  ADDWF  x53,W
10D6C:  MOVWF  01
10D6E:  MOVLW  00
10D70:  ADDWFC x54,W
10D72:  MOVWF  03
10D74:  MOVFF  01,C5C
10D78:  MOVWF  x5D
10D7A:  MOVWF  x78
10D7C:  MOVFF  01,C77
10D80:  MOVLW  0C
10D82:  MOVWF  x7A
10D84:  MOVLW  55
10D86:  MOVWF  x79
10D88:  MOVLW  01
10D8A:  MOVWF  x7B
10D8C:  MOVLB  0
10D8E:  CALL   EED4
10D92:  MOVFF  00,C59
....................  
....................     // Print human-readable output to PC 
....................     if (verbose) { 
10D96:  MOVLB  5
10D98:  MOVF   x5A,F
10D9A:  BZ    10DFE
....................         fprintf(PC, 
....................             "Camera Selection: %u%u%u\r\n", 
....................             cameraSelection[0], 
....................             cameraSelection[1], 
....................             cameraSelection[2]); 
10D9C:  MOVLW  DC
10D9E:  MOVWF  FF6
10DA0:  MOVLW  1E
10DA2:  MOVWF  FF7
10DA4:  MOVLW  00
10DA6:  MOVWF  FF8
10DA8:  MOVLW  12
10DAA:  MOVLB  C
10DAC:  MOVWF  xC1
10DAE:  MOVLB  0
10DB0:  CALL   5290
10DB4:  MOVFF  C57,C78
10DB8:  MOVLW  1B
10DBA:  MOVLB  C
10DBC:  MOVWF  x79
10DBE:  MOVLB  0
10DC0:  CALL   5ADC
10DC4:  MOVFF  C58,C78
10DC8:  MOVLW  1B
10DCA:  MOVLB  C
10DCC:  MOVWF  x79
10DCE:  MOVLB  0
10DD0:  CALL   5ADC
10DD4:  MOVFF  C59,C78
10DD8:  MOVLW  1B
10DDA:  MOVLB  C
10DDC:  MOVWF  x79
10DDE:  MOVLB  0
10DE0:  CALL   5ADC
10DE4:  MOVLW  0D
10DE6:  MOVLB  D
10DE8:  MOVWF  x6A
10DEA:  MOVLB  0
10DEC:  CALL   44EE
10DF0:  MOVLW  0A
10DF2:  MOVLB  D
10DF4:  MOVWF  x6A
10DF6:  MOVLB  0
10DF8:  CALL   44EE
10DFC:  MOVLB  5
....................     } 
....................  
....................     uint16_t delay = (uint16_t)cameraSelection[0] * a + (uint16_t)cameraSelection[1] * a + (uint16_t)cameraSelection[2] * a + b; 
10DFE:  MOVLB  C
10E00:  CLRF   x5D
10E02:  MOVFF  C57,C5C
10E06:  MOVFF  C5D,CC4
10E0A:  MOVFF  C57,CC3
10E0E:  CLRF   xC6
10E10:  MOVLW  14
10E12:  MOVWF  xC5
10E14:  MOVLB  0
10E16:  CALL   4D06
10E1A:  MOVFF  02,C5D
10E1E:  MOVFF  01,C5C
10E22:  MOVLB  C
10E24:  CLRF   x5F
10E26:  MOVFF  C58,C5E
10E2A:  MOVFF  C5F,CC4
10E2E:  MOVFF  C58,CC3
10E32:  CLRF   xC6
10E34:  MOVLW  14
10E36:  MOVWF  xC5
10E38:  MOVLB  0
10E3A:  CALL   4D06
10E3E:  MOVFF  02,03
10E42:  MOVF   01,W
10E44:  MOVLB  C
10E46:  ADDWF  x5C,F
10E48:  MOVF   02,W
10E4A:  ADDWFC x5D,F
10E4C:  CLRF   x5F
10E4E:  MOVFF  C59,C5E
10E52:  MOVFF  C5F,CC4
10E56:  MOVFF  C59,CC3
10E5A:  CLRF   xC6
10E5C:  MOVLW  14
10E5E:  MOVWF  xC5
10E60:  MOVLB  0
10E62:  CALL   4D06
10E66:  MOVF   01,W
10E68:  MOVLB  C
10E6A:  ADDWF  x5C,F
10E6C:  MOVF   02,W
10E6E:  ADDWFC x5D,F
10E70:  MOVLW  14
10E72:  ADDWF  x5C,W
10E74:  MOVWF  x5A
10E76:  MOVLW  00
10E78:  ADDWFC x5D,W
10E7A:  MOVWF  x5B
....................  
....................     if (verbose) { 
10E7C:  MOVLB  5
10E7E:  MOVF   x5A,F
10E80:  BZ    10EC4
....................         fprintf(PC, "Delay: %lu\r\n", delay); 
10E82:  MOVLW  F8
10E84:  MOVWF  FF6
10E86:  MOVLW  1E
10E88:  MOVWF  FF7
10E8A:  MOVLW  00
10E8C:  MOVWF  FF8
10E8E:  MOVLW  07
10E90:  MOVLB  C
10E92:  MOVWF  xC1
10E94:  MOVLB  0
10E96:  CALL   5290
10E9A:  MOVLW  10
10E9C:  MOVWF  FE9
10E9E:  MOVFF  C5B,C76
10EA2:  MOVFF  C5A,C75
10EA6:  CALL   59CA
10EAA:  MOVLW  0D
10EAC:  MOVLB  D
10EAE:  MOVWF  x6A
10EB0:  MOVLB  0
10EB2:  CALL   44EE
10EB6:  MOVLW  0A
10EB8:  MOVLB  D
10EBA:  MOVWF  x6A
10EBC:  MOVLB  0
10EBE:  CALL   44EE
10EC2:  MOVLB  5
....................     } 
....................  
....................     return delay; 
10EC4:  MOVLB  C
10EC6:  MOVFF  C5A,01
10ECA:  MOVFF  C5B,02
10ECE:  MOVLB  0
10ED0:  GOTO   113A6 (RETURN)
.................... } 
....................  
.................... uint16_t camera_video_duration(uint8_t* data) 
10ED4:  MOVFF  C52,C54
10ED8:  MOVFF  C51,C53
10EDC:  MOVLB  C
10EDE:  CLRF   x56
10EE0:  MOVLW  15
10EE2:  MOVWF  x55
.................... { 
....................     enum constants { 
....................         camera_video_length = 11, 
....................         a = 20 
....................     }; 
....................  
....................     struct rpi_camera_video { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[camera_video_length]; 
....................     }* packet = (struct rpi_camera_video*)data; 
....................  
....................     uint16_t bitOffset = 21; // Skip ADCS mode and ADCS maneuver duration 
....................  
....................     uint8_t cameraSelection[3]; 
....................     cameraSelection[0] = get_bits(packet->data, &bitOffset, 1); 
10EE4:  MOVLW  02
10EE6:  ADDWF  x53,W
10EE8:  MOVWF  01
10EEA:  MOVLW  00
10EEC:  ADDWFC x54,W
10EEE:  MOVWF  03
10EF0:  MOVFF  01,C60
10EF4:  MOVWF  x61
10EF6:  MOVWF  x78
10EF8:  MOVFF  01,C77
10EFC:  MOVLW  0C
10EFE:  MOVWF  x7A
10F00:  MOVLW  55
10F02:  MOVWF  x79
10F04:  MOVLW  01
10F06:  MOVWF  x7B
10F08:  MOVLB  0
10F0A:  CALL   EED4
10F0E:  MOVFF  00,C57
....................     cameraSelection[1] = get_bits(packet->data, &bitOffset, 1); 
10F12:  MOVLW  02
10F14:  MOVLB  C
10F16:  ADDWF  x53,W
10F18:  MOVWF  01
10F1A:  MOVLW  00
10F1C:  ADDWFC x54,W
10F1E:  MOVWF  03
10F20:  MOVFF  01,C60
10F24:  MOVWF  x61
10F26:  MOVWF  x78
10F28:  MOVFF  01,C77
10F2C:  MOVLW  0C
10F2E:  MOVWF  x7A
10F30:  MOVLW  55
10F32:  MOVWF  x79
10F34:  MOVLW  01
10F36:  MOVWF  x7B
10F38:  MOVLB  0
10F3A:  CALL   EED4
10F3E:  MOVFF  00,C58
....................     cameraSelection[2] = get_bits(packet->data, &bitOffset, 1); 
10F42:  MOVLW  02
10F44:  MOVLB  C
10F46:  ADDWF  x53,W
10F48:  MOVWF  01
10F4A:  MOVLW  00
10F4C:  ADDWFC x54,W
10F4E:  MOVWF  03
10F50:  MOVFF  01,C60
10F54:  MOVWF  x61
10F56:  MOVWF  x78
10F58:  MOVFF  01,C77
10F5C:  MOVLW  0C
10F5E:  MOVWF  x7A
10F60:  MOVLW  55
10F62:  MOVWF  x79
10F64:  MOVLW  01
10F66:  MOVWF  x7B
10F68:  MOVLB  0
10F6A:  CALL   EED4
10F6E:  MOVFF  00,C59
....................  
....................     bitOffset += 16; 
10F72:  MOVLW  10
10F74:  MOVLB  C
10F76:  ADDWF  x55,F
10F78:  MOVLW  00
10F7A:  ADDWFC x56,F
....................  
....................     uint8_t timeout[3]; 
....................  
....................     for (int i = 0; i < 3; ++i) { 
10F7C:  CLRF   x5D
10F7E:  MOVF   x5D,W
10F80:  SUBLW  02
10F82:  BNC   10FDC
....................         bitOffset += 10; 
10F84:  MOVLW  0A
10F86:  ADDWF  x55,F
10F88:  MOVLW  00
10F8A:  ADDWFC x56,F
....................         timeout[i] = get_bits(packet->data, &bitOffset, 6); 
10F8C:  CLRF   03
10F8E:  MOVF   x5D,W
10F90:  ADDLW  5A
10F92:  MOVWF  01
10F94:  MOVLW  0C
10F96:  ADDWFC 03,F
10F98:  MOVFF  01,C60
10F9C:  MOVFF  03,C61
10FA0:  MOVLW  02
10FA2:  ADDWF  x53,W
10FA4:  MOVWF  01
10FA6:  MOVLW  00
10FA8:  ADDWFC x54,W
10FAA:  MOVWF  03
10FAC:  MOVFF  01,C62
10FB0:  MOVWF  x63
10FB2:  MOVWF  x78
10FB4:  MOVFF  01,C77
10FB8:  MOVLW  0C
10FBA:  MOVWF  x7A
10FBC:  MOVLW  55
10FBE:  MOVWF  x79
10FC0:  MOVLW  06
10FC2:  MOVWF  x7B
10FC4:  MOVLB  0
10FC6:  CALL   EED4
10FCA:  MOVFF  C61,FEA
10FCE:  MOVFF  C60,FE9
10FD2:  MOVFF  00,FEF
10FD6:  MOVLB  C
10FD8:  INCF   x5D,F
10FDA:  BRA    10F7E
....................     } 
....................  
....................     // Print human-readable output to PC 
....................     if (verbose) { 
10FDC:  MOVLB  5
10FDE:  MOVF   x5A,F
10FE0:  BZ    110BC
....................         fprintf(PC, 
....................             "Video capture command:\r\n" 
....................             "Camera Selection: %u%u%u\r\n" 
....................             "Timeout: %u, %u, %u seconds\r\n", 
....................             cameraSelection[0], 
....................             cameraSelection[1], 
....................             cameraSelection[2], 
....................             timeout[0], timeout[1], timeout[2]); 
10FE2:  MOVLW  06
10FE4:  MOVWF  FF6
10FE6:  MOVLW  1F
10FE8:  MOVWF  FF7
10FEA:  MOVLW  00
10FEC:  MOVWF  FF8
10FEE:  MOVLW  2A
10FF0:  MOVLB  C
10FF2:  MOVWF  xC1
10FF4:  MOVLB  0
10FF6:  CALL   5290
10FFA:  MOVFF  C57,C78
10FFE:  MOVLW  1B
11000:  MOVLB  C
11002:  MOVWF  x79
11004:  MOVLB  0
11006:  CALL   5ADC
1100A:  MOVFF  C58,C78
1100E:  MOVLW  1B
11010:  MOVLB  C
11012:  MOVWF  x79
11014:  MOVLB  0
11016:  CALL   5ADC
1101A:  MOVFF  C59,C78
1101E:  MOVLW  1B
11020:  MOVLB  C
11022:  MOVWF  x79
11024:  MOVLB  0
11026:  CALL   5ADC
1102A:  MOVLW  36
1102C:  MOVWF  FF6
1102E:  MOVLW  1F
11030:  MOVWF  FF7
11032:  MOVLW  00
11034:  MOVWF  FF8
11036:  MOVLW  0B
11038:  MOVLB  C
1103A:  MOVWF  xC1
1103C:  MOVLB  0
1103E:  CALL   5290
11042:  MOVFF  C5A,C78
11046:  MOVLW  1B
11048:  MOVLB  C
1104A:  MOVWF  x79
1104C:  MOVLB  0
1104E:  CALL   5ADC
11052:  MOVLW  2C
11054:  MOVLB  D
11056:  MOVWF  x6A
11058:  MOVLB  0
1105A:  CALL   44EE
1105E:  MOVLW  20
11060:  MOVLB  D
11062:  MOVWF  x6A
11064:  MOVLB  0
11066:  CALL   44EE
1106A:  MOVFF  C5B,C78
1106E:  MOVLW  1B
11070:  MOVLB  C
11072:  MOVWF  x79
11074:  MOVLB  0
11076:  CALL   5ADC
1107A:  MOVLW  2C
1107C:  MOVLB  D
1107E:  MOVWF  x6A
11080:  MOVLB  0
11082:  CALL   44EE
11086:  MOVLW  20
11088:  MOVLB  D
1108A:  MOVWF  x6A
1108C:  MOVLB  0
1108E:  CALL   44EE
11092:  MOVFF  C5C,C78
11096:  MOVLW  1B
11098:  MOVLB  C
1109A:  MOVWF  x79
1109C:  MOVLB  0
1109E:  CALL   5ADC
110A2:  MOVLW  4B
110A4:  MOVWF  FF6
110A6:  MOVLW  1F
110A8:  MOVWF  FF7
110AA:  MOVLW  00
110AC:  MOVWF  FF8
110AE:  MOVLW  0A
110B0:  MOVLB  C
110B2:  MOVWF  xC1
110B4:  MOVLB  0
110B6:  CALL   5290
110BA:  MOVLB  5
....................     } 
....................  
....................     uint16_t delay = (uint16_t)cameraSelection[0] * timeout[0] + (uint16_t)cameraSelection[1] * timeout[1] + (uint16_t)cameraSelection[2] * timeout[2] + a; 
110BC:  MOVLB  C
110BE:  CLRF   x61
110C0:  MOVFF  C57,C60
110C4:  MOVFF  C61,CC4
110C8:  MOVFF  C57,CC3
110CC:  CLRF   xC6
110CE:  MOVFF  C5A,CC5
110D2:  MOVLB  0
110D4:  CALL   4D06
110D8:  MOVFF  02,C61
110DC:  MOVFF  01,C60
110E0:  MOVLB  C
110E2:  CLRF   x63
110E4:  MOVFF  C58,C62
110E8:  MOVFF  C63,CC4
110EC:  MOVFF  C58,CC3
110F0:  CLRF   xC6
110F2:  MOVFF  C5B,CC5
110F6:  MOVLB  0
110F8:  CALL   4D06
110FC:  MOVFF  02,03
11100:  MOVF   01,W
11102:  MOVLB  C
11104:  ADDWF  x60,F
11106:  MOVF   02,W
11108:  ADDWFC x61,F
1110A:  CLRF   x63
1110C:  MOVFF  C59,C62
11110:  MOVFF  C63,CC4
11114:  MOVFF  C59,CC3
11118:  CLRF   xC6
1111A:  MOVFF  C5C,CC5
1111E:  MOVLB  0
11120:  CALL   4D06
11124:  MOVF   01,W
11126:  MOVLB  C
11128:  ADDWF  x60,F
1112A:  MOVF   02,W
1112C:  ADDWFC x61,F
1112E:  MOVLW  14
11130:  ADDWF  x60,W
11132:  MOVWF  x5E
11134:  MOVLW  00
11136:  ADDWFC x61,W
11138:  MOVWF  x5F
....................  
....................     if (verbose) { 
1113A:  MOVLB  5
1113C:  MOVF   x5A,F
1113E:  BZ    11182
....................         fprintf(PC, "Delay: %lu\r\n", delay); 
11140:  MOVLW  56
11142:  MOVWF  FF6
11144:  MOVLW  1F
11146:  MOVWF  FF7
11148:  MOVLW  00
1114A:  MOVWF  FF8
1114C:  MOVLW  07
1114E:  MOVLB  C
11150:  MOVWF  xC1
11152:  MOVLB  0
11154:  CALL   5290
11158:  MOVLW  10
1115A:  MOVWF  FE9
1115C:  MOVFF  C5F,C76
11160:  MOVFF  C5E,C75
11164:  CALL   59CA
11168:  MOVLW  0D
1116A:  MOVLB  D
1116C:  MOVWF  x6A
1116E:  MOVLB  0
11170:  CALL   44EE
11174:  MOVLW  0A
11176:  MOVLB  D
11178:  MOVWF  x6A
1117A:  MOVLB  0
1117C:  CALL   44EE
11180:  MOVLB  5
....................     } 
....................  
....................     return delay; 
11182:  MOVLB  C
11184:  MOVFF  C5E,01
11188:  MOVFF  C5F,02
1118C:  MOVLB  0
1118E:  GOTO   11506 (RETURN)
.................... } 
....................  
.................... uint8_t command_camera_mission(uint8_t* data) 
11192:  MOVLW  02
11194:  MOVLB  C
11196:  ADDWF  x38,W
11198:  MOVWF  FE9
1119A:  MOVLW  00
1119C:  ADDWFC x39,W
1119E:  MOVWF  FEA
111A0:  MOVFF  FEF,C3A
.................... { 
....................     enum constants { 
....................         camera_config_length = 11, 
....................         camera_capture_length = 4, 
....................         camera_image_transform_length = 11, 
....................         camera_video_length = 11, 
....................         xmodem_rpi_to_bus_length = 4, 
....................     }; 
....................  
....................     enum inner_commands { 
....................         camera_capture_configuration = 0, 
....................         camera_capture = 1, 
....................         image_transformation = 2, 
....................         video_capture = 3, 
....................         xmodem_rpi_to_bus = 4 
....................     }; 
....................  
....................     uint8_t inner_command = data[2]; 
....................  
....................     if (inner_command == camera_capture_configuration) { 
111A4:  MOVF   x3A,F
111A6:  BNZ   1121C
....................  
....................         struct packet_0 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             uint8_t data[camera_config_length]; 
....................         }* packet_0 = (struct packet_0*)data; 
111A8:  MOVFF  C39,C3C
111AC:  MOVFF  C38,C3B
....................  
....................         fprintf(PC, "Camera capture configuration command, saving configuration..."); 
111B0:  MOVLW  64
111B2:  MOVWF  FF6
111B4:  MOVLW  1F
111B6:  MOVWF  FF7
111B8:  MOVLW  00
111BA:  MOVWF  FF8
111BC:  MOVLB  0
111BE:  CALL   4534
....................         memcpy(obc_flags.camera_parameters, packet_0->data, camera_config_length); 
111C2:  MOVLW  03
111C4:  MOVLB  C
111C6:  ADDWF  x3B,W
111C8:  MOVWF  01
111CA:  MOVLW  00
111CC:  ADDWFC x3C,W
111CE:  MOVWF  03
111D0:  MOVFF  01,C51
111D4:  MOVWF  x52
111D6:  MOVLW  01
111D8:  MOVWF  FEA
111DA:  MOVLW  0C
111DC:  MOVWF  FE9
111DE:  MOVFF  03,FE2
111E2:  MOVFF  01,FE1
111E6:  MOVLW  0B
111E8:  MOVWF  01
111EA:  MOVFF  FE6,FEE
111EE:  DECFSZ 01,F
111F0:  BRA    111EA
....................         save_state(packet_0->cmd); 
111F2:  MOVLW  01
111F4:  ADDWF  x3B,W
111F6:  MOVWF  FE9
111F8:  MOVLW  00
111FA:  ADDWFC x3C,W
111FC:  MOVWF  FEA
111FE:  MOVFF  FEF,C60
11202:  MOVLB  0
11204:  CALL   8CAE
....................         fprintf(PC, " done!"); 
11208:  MOVLW  A2
1120A:  MOVWF  FF6
1120C:  MOVLW  1F
1120E:  MOVWF  FF7
11210:  MOVLW  00
11212:  MOVWF  FF8
11214:  CALL   4534
....................  
....................     } else if (inner_command == camera_capture) { 
11218:  BRA    11616
1121A:  MOVLB  C
1121C:  DECFSZ x3A,W
1121E:  BRA    11318
....................  
....................         struct packet_1 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint8_t data[camera_capture_length]; 
....................             uint8_t adcs_mode; 
....................             uint16_t adcs_maneuver_duration; 
....................         }* packet_1 = (struct packet_1*)data; 
11220:  MOVFF  C39,C3E
11224:  MOVFF  C38,C3D
....................  
....................         fprintf(PC, "Camera capture command, starting state machine..."); 
11228:  MOVLW  AA
1122A:  MOVWF  FF6
1122C:  MOVLW  1F
1122E:  MOVWF  FF7
11230:  MOVLW  00
11232:  MOVWF  FF8
11234:  MOVLB  0
11236:  CALL   4534
....................  
....................         camera.mission_time = packet_1->start_time; 
1123A:  MOVLW  03
1123C:  MOVLB  C
1123E:  ADDWF  x3D,W
11240:  MOVWF  FE9
11242:  MOVLW  00
11244:  ADDWFC x3E,W
11246:  MOVWF  FEA
11248:  MOVFF  FEF,ADC
1124C:  MOVFF  FEC,ADD
11250:  MOVFF  FEC,ADE
11254:  MOVFF  FEC,ADF
....................         camera.adcs_maneuver_duration = packet_1->adcs_maneuver_duration; 
11258:  MOVLW  0C
1125A:  ADDWF  x3D,W
1125C:  MOVWF  FE9
1125E:  MOVLW  00
11260:  ADDWFC x3E,W
11262:  MOVWF  FEA
11264:  MOVFF  FEC,AE4
11268:  MOVF   FED,F
1126A:  MOVFF  FEF,AE3
....................         camera.mux_lock = false; 
1126E:  MOVLB  B
11270:  CLRF   x86
....................         camera.adcs_mode = packet_1->adcs_mode; 
11272:  MOVLW  0B
11274:  MOVLB  C
11276:  ADDWF  x3D,W
11278:  MOVWF  FE9
1127A:  MOVLW  00
1127C:  ADDWFC x3E,W
1127E:  MOVWF  FEA
11280:  MOVFF  FEF,AE2
....................  
....................         camera.command[0] = MSG_OBC; 
11284:  MOVLW  0B
11286:  MOVLB  A
11288:  MOVWF  xF0
....................         camera.command[1] = 0xCA; 
1128A:  MOVLW  CA
1128C:  MOVWF  xF1
....................         memcpy(&camera.command[2], obc_flags.camera_parameters, camera_config_length);            // first part of the config comes from the obc flags 
1128E:  MOVLW  0A
11290:  MOVWF  FEA
11292:  MOVLW  F2
11294:  MOVWF  FE9
11296:  MOVLW  01
11298:  MOVWF  FE2
1129A:  MOVLW  0C
1129C:  MOVWF  FE1
1129E:  MOVLW  0B
112A0:  MOVWF  01
112A2:  MOVFF  FE6,FEE
112A6:  DECFSZ 01,F
112A8:  BRA    112A2
....................         memcpy(&camera.command[2 + camera_config_length], packet_1->data, camera_capture_length); // second part comes from this command 
112AA:  MOVLW  07
112AC:  MOVLB  C
112AE:  ADDWF  x3D,W
112B0:  MOVWF  01
112B2:  MOVLW  00
112B4:  ADDWFC x3E,W
112B6:  MOVWF  FE2
112B8:  MOVFF  01,FE1
112BC:  MOVFF  FE6,AFD
112C0:  MOVFF  FE6,AFE
112C4:  MOVFF  FE6,AFF
112C8:  MOVFF  FE6,B00
....................         camera.mission_duration = camera_still_duration(camera.command); 
112CC:  MOVLW  0A
112CE:  MOVWF  x52
112D0:  MOVLW  F0
112D2:  MOVWF  x51
112D4:  MOVLB  0
112D6:  GOTO   1071C
112DA:  MOVFF  02,AE1
112DE:  MOVFF  01,AE0
....................         camera.mux_lock_duration = camera.mission_duration; 
112E2:  MOVFF  AE1,B88
112E6:  MOVFF  AE0,B87
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
112EA:  MOVLW  C0
112EC:  MOVLB  C
112EE:  MOVWF  x3F
112F0:  MOVLW  CB
112F2:  MOVWF  x40
112F4:  CLRF   x41
112F6:  MOVFF  3E,C98
112FA:  MOVFF  3D,C97
112FE:  MOVFF  3C,C96
11302:  MOVFF  3B,C95
11306:  MOVLW  0C
11308:  MOVWF  x9A
1130A:  MOVLW  3F
1130C:  MOVWF  x99
1130E:  MOVLB  0
11310:  CALL   704C
....................  
....................     } else if (inner_command == image_transformation) { 
11314:  BRA    11616
11316:  MOVLB  C
11318:  MOVF   x3A,W
1131A:  SUBLW  02
1131C:  BNZ   113E4
....................  
....................         struct packet_2 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint8_t data[camera_image_transform_length]; 
....................         }* packet_2 = (struct packet_2*)data; 
1131E:  MOVFF  C39,C43
11322:  MOVFF  C38,C42
....................  
....................         fprintf(PC, "Camera image transformation command, starting state machine..."); 
11326:  MOVLW  DC
11328:  MOVWF  FF6
1132A:  MOVLW  1F
1132C:  MOVWF  FF7
1132E:  MOVLW  00
11330:  MOVWF  FF8
11332:  MOVLB  0
11334:  CALL   4534
....................  
....................         camera.mission_time = packet_2->start_time; 
11338:  MOVLW  03
1133A:  MOVLB  C
1133C:  ADDWF  x42,W
1133E:  MOVWF  FE9
11340:  MOVLW  00
11342:  ADDWFC x43,W
11344:  MOVWF  FEA
11346:  MOVFF  FEF,ADC
1134A:  MOVFF  FEC,ADD
1134E:  MOVFF  FEC,ADE
11352:  MOVFF  FEC,ADF
....................         camera.adcs_maneuver_duration = 0; 
11356:  MOVLB  A
11358:  CLRF   xE4
1135A:  CLRF   xE3
....................         camera.mux_lock = false; 
1135C:  MOVLB  B
1135E:  CLRF   x86
....................  
....................         camera.command[0] = MSG_OBC; 
11360:  MOVLW  0B
11362:  MOVLB  A
11364:  MOVWF  xF0
....................         camera.command[1] = 0xCB; 
11366:  MOVLW  CB
11368:  MOVWF  xF1
....................         memcpy(&camera.command[2], packet_2->data, camera_image_transform_length); 
1136A:  MOVLW  07
1136C:  MOVLB  C
1136E:  ADDWF  x42,W
11370:  MOVWF  01
11372:  MOVLW  00
11374:  ADDWFC x43,W
11376:  MOVWF  03
11378:  MOVFF  01,C51
1137C:  MOVWF  x52
1137E:  MOVLW  0A
11380:  MOVWF  FEA
11382:  MOVLW  F2
11384:  MOVWF  FE9
11386:  MOVFF  03,FE2
1138A:  MOVFF  01,FE1
1138E:  MOVLW  0B
11390:  MOVWF  01
11392:  MOVFF  FE6,FEE
11396:  DECFSZ 01,F
11398:  BRA    11392
....................         camera.mission_duration = camera_image_transform_duration(camera.command); 
1139A:  MOVLW  0A
1139C:  MOVWF  x52
1139E:  MOVLW  F0
113A0:  MOVWF  x51
113A2:  MOVLB  0
113A4:  BRA    10CF8
113A6:  MOVFF  02,AE1
113AA:  MOVFF  01,AE0
....................         camera.mux_lock_duration = camera.mission_duration; 
113AE:  MOVFF  AE1,B88
113B2:  MOVFF  AE0,B87
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
113B6:  MOVLW  C0
113B8:  MOVLB  C
113BA:  MOVWF  x44
113BC:  MOVLW  CB
113BE:  MOVWF  x45
113C0:  CLRF   x46
113C2:  MOVFF  3E,C98
113C6:  MOVFF  3D,C97
113CA:  MOVFF  3C,C96
113CE:  MOVFF  3B,C95
113D2:  MOVLW  0C
113D4:  MOVWF  x9A
113D6:  MOVLW  44
113D8:  MOVWF  x99
113DA:  MOVLB  0
113DC:  CALL   704C
....................  
....................     } else if (inner_command == video_capture) { 
113E0:  BRA    11616
113E2:  MOVLB  C
113E4:  MOVF   x3A,W
113E6:  SUBLW  03
113E8:  BTFSS  FD8.2
113EA:  BRA    11544
....................  
....................         struct packet_3 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint8_t data[camera_video_length]; 
....................         }* packet_3 = (struct packet_3*)data; 
113EC:  MOVFF  C39,C48
113F0:  MOVFF  C38,C47
....................  
....................         fprintf(PC, "Camera image video command, starting state machine..."); 
113F4:  MOVLW  1C
113F6:  MOVWF  FF6
113F8:  MOVLW  20
113FA:  MOVWF  FF7
113FC:  MOVLW  00
113FE:  MOVWF  FF8
11400:  MOVLB  0
11402:  CALL   4534
....................  
....................         camera.mission_time = packet_3->start_time; 
11406:  MOVLW  03
11408:  MOVLB  C
1140A:  ADDWF  x47,W
1140C:  MOVWF  FE9
1140E:  MOVLW  00
11410:  ADDWFC x48,W
11412:  MOVWF  FEA
11414:  MOVFF  FEF,ADC
11418:  MOVFF  FEC,ADD
1141C:  MOVFF  FEC,ADE
11420:  MOVFF  FEC,ADF
....................         camera.adcs_maneuver_duration = ((packet_3->data[0] & 0xE0) >> 5); 
11424:  MOVLW  07
11426:  ADDWF  x47,W
11428:  MOVWF  FE9
1142A:  MOVLW  00
1142C:  ADDWFC x48,W
1142E:  MOVWF  FEA
11430:  MOVF   FEF,W
11432:  ANDLW  E0
11434:  MOVWF  02
11436:  MOVLB  A
11438:  CLRF   xE4
1143A:  RRCF   02,W
1143C:  MOVWF  xE3
1143E:  RRCF   xE3,F
11440:  RRCF   xE3,F
11442:  RRCF   xE3,F
11444:  RRCF   xE3,F
11446:  MOVLW  07
11448:  ANDWF  xE3,F
....................         camera.adcs_maneuver_duration |= ((uint16_t)packet_3->data[1] << 3); 
1144A:  MOVLW  08
1144C:  MOVLB  C
1144E:  ADDWF  x47,W
11450:  MOVWF  FE9
11452:  MOVLW  00
11454:  ADDWFC x48,W
11456:  MOVWF  FEA
11458:  MOVF   FEF,W
1145A:  CLRF   x52
1145C:  MOVWF  x51
1145E:  RLCF   x51,W
11460:  MOVWF  02
11462:  RLCF   x52,W
11464:  MOVWF  03
11466:  RLCF   02,F
11468:  RLCF   03,F
1146A:  RLCF   02,F
1146C:  RLCF   03,F
1146E:  MOVLW  F8
11470:  ANDWF  02,F
11472:  MOVF   02,W
11474:  MOVLB  A
11476:  IORWF  xE3,F
11478:  MOVF   03,W
1147A:  IORWF  xE4,F
....................         camera.adcs_maneuver_duration |= ((uint16_t)(packet_3->data[2] & 0x1F) << 11); 
1147C:  MOVLW  09
1147E:  MOVLB  C
11480:  ADDWF  x47,W
11482:  MOVWF  FE9
11484:  MOVLW  00
11486:  ADDWFC x48,W
11488:  MOVWF  FEA
1148A:  MOVF   FEF,W
1148C:  ANDLW  1F
1148E:  MOVWF  x51
11490:  CLRF   02
11492:  RLCF   x51,W
11494:  MOVWF  03
11496:  RLCF   03,F
11498:  RLCF   03,F
1149A:  MOVLW  F8
1149C:  ANDWF  03,F
1149E:  MOVF   02,W
114A0:  MOVLB  A
114A2:  IORWF  xE3,F
114A4:  MOVF   03,W
114A6:  IORWF  xE4,F
....................         camera.mux_lock = false; 
114A8:  MOVLB  B
114AA:  CLRF   x86
....................         camera.adcs_mode = packet_3->data[0] & 0x1F; 
114AC:  MOVLW  07
114AE:  MOVLB  C
114B0:  ADDWF  x47,W
114B2:  MOVWF  FE9
114B4:  MOVLW  00
114B6:  ADDWFC x48,W
114B8:  MOVWF  FEA
114BA:  MOVF   FEF,W
114BC:  ANDLW  1F
114BE:  MOVLB  A
114C0:  MOVWF  xE2
....................  
....................         camera.command[0] = MSG_OBC; 
114C2:  MOVLW  0B
114C4:  MOVWF  xF0
....................         camera.command[1] = 0xCC; 
114C6:  MOVLW  CC
114C8:  MOVWF  xF1
....................         memcpy(&camera.command[2], packet_3->data, camera_video_length); 
114CA:  MOVLW  07
114CC:  MOVLB  C
114CE:  ADDWF  x47,W
114D0:  MOVWF  01
114D2:  MOVLW  00
114D4:  ADDWFC x48,W
114D6:  MOVWF  03
114D8:  MOVFF  01,C51
114DC:  MOVWF  x52
114DE:  MOVLW  0A
114E0:  MOVWF  FEA
114E2:  MOVLW  F2
114E4:  MOVWF  FE9
114E6:  MOVFF  03,FE2
114EA:  MOVFF  01,FE1
114EE:  MOVLW  0B
114F0:  MOVWF  01
114F2:  MOVFF  FE6,FEE
114F6:  DECFSZ 01,F
114F8:  BRA    114F2
....................         camera.mission_duration = camera_video_duration(camera.command); 
114FA:  MOVLW  0A
114FC:  MOVWF  x52
114FE:  MOVLW  F0
11500:  MOVWF  x51
11502:  MOVLB  0
11504:  BRA    10ED4
11506:  MOVFF  02,AE1
1150A:  MOVFF  01,AE0
....................         camera.mux_lock_duration = camera.mission_duration; 
1150E:  MOVFF  AE1,B88
11512:  MOVFF  AE0,B87
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
11516:  MOVLW  C0
11518:  MOVLB  C
1151A:  MOVWF  x49
1151C:  MOVLW  CB
1151E:  MOVWF  x4A
11520:  CLRF   x4B
11522:  MOVFF  3E,C98
11526:  MOVFF  3D,C97
1152A:  MOVFF  3C,C96
1152E:  MOVFF  3B,C95
11532:  MOVLW  0C
11534:  MOVWF  x9A
11536:  MOVLW  49
11538:  MOVWF  x99
1153A:  MOVLB  0
1153C:  CALL   704C
....................  
....................     } else if (inner_command == xmodem_rpi_to_bus) { 
11540:  BRA    11616
11542:  MOVLB  C
11544:  MOVF   x3A,W
11546:  SUBLW  04
11548:  BNZ   11604
....................  
....................         struct packet_4 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint16_t timeout; 
....................             uint8_t data[xmodem_rpi_to_bus_length]; 
....................         }* packet_4 = (struct packet_4*)data; 
1154A:  MOVFF  C39,C4D
1154E:  MOVFF  C38,C4C
....................  
....................         fprintf(PC, "XMODEM copy command RPi to bus, starting state machine..."); 
11552:  MOVLW  52
11554:  MOVWF  FF6
11556:  MOVLW  20
11558:  MOVWF  FF7
1155A:  MOVLW  00
1155C:  MOVWF  FF8
1155E:  MOVLB  0
11560:  CALL   4534
....................  
....................         camera.mission_time = packet_4->start_time; 
11564:  MOVLW  03
11566:  MOVLB  C
11568:  ADDWF  x4C,W
1156A:  MOVWF  FE9
1156C:  MOVLW  00
1156E:  ADDWFC x4D,W
11570:  MOVWF  FEA
11572:  MOVFF  FEF,ADC
11576:  MOVFF  FEC,ADD
1157A:  MOVFF  FEC,ADE
1157E:  MOVFF  FEC,ADF
....................         camera.mission_duration = packet_4->timeout; 
11582:  MOVLW  07
11584:  ADDWF  x4C,W
11586:  MOVWF  FE9
11588:  MOVLW  00
1158A:  ADDWFC x4D,W
1158C:  MOVWF  FEA
1158E:  MOVFF  FEC,AE1
11592:  MOVF   FED,F
11594:  MOVFF  FEF,AE0
....................         camera.adcs_maneuver_duration = 0; 
11598:  MOVLB  A
1159A:  CLRF   xE4
1159C:  CLRF   xE3
....................         camera.mux_lock = true; 
1159E:  MOVLW  01
115A0:  MOVLB  B
115A2:  MOVWF  x86
....................         camera.mux_lock_duration = camera.mission_duration; 
115A4:  MOVFF  AE1,B88
115A8:  MOVFF  AE0,B87
....................  
....................         camera.command[0] = MSG_OBC; 
115AC:  MOVLW  0B
115AE:  MOVLB  A
115B0:  MOVWF  xF0
....................         camera.command[1] = 0xC2; 
115B2:  MOVLW  C2
115B4:  MOVWF  xF1
....................         memcpy(&camera.command[2], packet_4->data, xmodem_rpi_to_bus_length); 
115B6:  MOVLW  09
115B8:  MOVLB  C
115BA:  ADDWF  x4C,W
115BC:  MOVWF  01
115BE:  MOVLW  00
115C0:  ADDWFC x4D,W
115C2:  MOVWF  FE2
115C4:  MOVFF  01,FE1
115C8:  MOVFF  FE6,AF2
115CC:  MOVFF  FE6,AF3
115D0:  MOVFF  FE6,AF4
115D4:  MOVFF  FE6,AF5
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
115D8:  MOVLW  C0
115DA:  MOVWF  x4E
115DC:  MOVLW  CB
115DE:  MOVWF  x4F
115E0:  CLRF   x50
115E2:  MOVFF  3E,C98
115E6:  MOVFF  3D,C97
115EA:  MOVFF  3C,C96
115EE:  MOVFF  3B,C95
115F2:  MOVLW  0C
115F4:  MOVWF  x9A
115F6:  MOVLW  4E
115F8:  MOVWF  x99
115FA:  MOVLB  0
115FC:  CALL   704C
....................  
....................     } else { 
11600:  BRA    11616
11602:  MOVLB  C
....................         fprintf(PC, "Inner command not implemented."); 
11604:  MOVLW  8C
11606:  MOVWF  FF6
11608:  MOVLW  20
1160A:  MOVWF  FF7
1160C:  MOVLW  00
1160E:  MOVWF  FF8
11610:  MOVLB  0
11612:  CALL   4534
....................     } 
....................  
....................     return inner_command; 
11616:  MOVLB  C
11618:  MOVFF  C3A,01
1161C:  MOVLB  0
1161E:  GOTO   18CF8 (RETURN)
.................... } 
....................  
.................... // ===================================================== 
....................  
.................... // Function that executes a command, by looking up on the table of available commands. 
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled) 
*
17C34:  MOVLB  C
17C36:  CLRF   x2A
.................... { 
....................     uint8_t error = 0; 
....................  
....................     if (origin == data[0] || origin == MSG_WILDCARD) { 
17C38:  MOVFF  C26,FE9
17C3C:  MOVFF  C27,FEA
17C40:  MOVF   FEF,W
17C42:  SUBWF  x28,W
17C44:  BZ    17C4C
17C46:  INCFSZ x28,W
17C48:  GOTO   19122
....................  
....................         // COM reply 
....................         if (data[0] == 0xC0) { 
17C4C:  MOVFF  C26,FE9
17C50:  MOVFF  C27,FEA
17C54:  MOVF   FEF,W
17C56:  SUBLW  C0
17C58:  BNZ   17CCA
....................             if (data[1] == 0x42) { 
17C5A:  MOVLW  01
17C5C:  ADDWF  x26,W
17C5E:  MOVWF  FE9
17C60:  MOVLW  00
17C62:  ADDWFC x27,W
17C64:  MOVWF  FEA
17C66:  MOVF   FEF,W
17C68:  SUBLW  42
17C6A:  BNZ   17CCA
....................                 if (data[4] != 0x00) { // 0x00 is a request for memory dump 
17C6C:  MOVLW  04
17C6E:  ADDWF  x26,W
17C70:  MOVWF  FE9
17C72:  MOVLW  00
17C74:  ADDWFC x27,W
17C76:  MOVWF  FEA
17C78:  MOVF   FEF,F
17C7A:  BZ    17C98
....................                     send_com_ack(data + 2); 
17C7C:  MOVLW  02
17C7E:  ADDWF  x26,W
17C80:  MOVWF  x38
17C82:  MOVLW  00
17C84:  ADDWFC x27,W
17C86:  MOVWF  x39
17C88:  MOVWF  x4F
17C8A:  MOVFF  C38,C4E
17C8E:  MOVLB  0
17C90:  CALL   77A2
....................                 } else { 
17C94:  BRA    17CC8
17C96:  MOVLB  C
.................... #ifndef PC_SIM 
....................                     uint32_t* ptr = *(uint32_t*)&data[5]; 
17C98:  MOVLW  05
17C9A:  ADDWF  x26,W
17C9C:  MOVWF  01
17C9E:  MOVLW  00
17CA0:  ADDWFC x27,W
17CA2:  MOVFF  01,FE9
17CA6:  MOVWF  FEA
17CA8:  MOVFF  FEF,C2B
17CAC:  MOVFF  FEC,C2C
....................                     send_com_ack(ptr + &current_time); 
17CB0:  MOVLW  3B
17CB2:  ADDWF  x2B,W
17CB4:  MOVWF  x38
17CB6:  MOVLW  00
17CB8:  ADDWFC x2C,W
17CBA:  MOVWF  x39
17CBC:  MOVWF  x4F
17CBE:  MOVFF  C38,C4E
17CC2:  MOVLB  0
17CC4:  CALL   77A2
17CC8:  MOVLB  C
.................... #endif 
....................                 } 
....................             } 
....................         } 
....................  
....................         // Satellite log 
....................         log_entry log; 
....................         log.origin = data[0]; 
17CCA:  MOVFF  C26,FE9
17CCE:  MOVFF  C27,FEA
17CD2:  MOVFF  FEF,C31
....................         log.command = data[1]; 
17CD6:  MOVLW  01
17CD8:  ADDWF  x26,W
17CDA:  MOVWF  FE9
17CDC:  MOVLW  00
17CDE:  ADDWFC x27,W
17CE0:  MOVWF  FEA
17CE2:  MOVFF  FEF,C32
....................  
....................         struct_tm* local_time = localtime(&current_time); 
17CE6:  CLRF   x84
17CE8:  MOVLW  3B
17CEA:  MOVWF  x83
17CEC:  MOVLB  0
17CEE:  CALL   4D28
17CF2:  MOVFF  02,C35
17CF6:  MOVFF  01,C34
....................  
....................         // Execute command 
....................         if (log_enabled) 
17CFA:  MOVLB  C
17CFC:  MOVF   x29,F
17CFE:  BTFSC  FD8.2
17D00:  BRA    17EBA
....................             fprintf(PC, "%04ld/%02d/%02d %02d:%02d:%02d | %02d | %02X %02X | ", local_time->tm_year + 1900, 
....................                 (uint8_t)local_time->tm_mon + 1, 
....................                 local_time->tm_mday, 
....................                 local_time->tm_hour, 
....................                 local_time->tm_min, 
....................                 local_time->tm_sec, 
....................                 scheduled_command_count(), 
....................                 data[0], 
....................                 data[1]); 
17D02:  MOVLW  05
17D04:  ADDWF  x34,W
17D06:  MOVWF  FE9
17D08:  MOVLW  00
17D0A:  ADDWFC x35,W
17D0C:  MOVWF  FEA
17D0E:  MOVFF  FEC,C39
17D12:  MOVF   FED,F
17D14:  MOVFF  FEF,C38
17D18:  MOVLW  6C
17D1A:  ADDWF  x38,F
17D1C:  MOVLW  07
17D1E:  ADDWFC x39,F
17D20:  MOVLW  04
17D22:  ADDWF  x34,W
17D24:  MOVWF  FE9
17D26:  MOVLW  00
17D28:  ADDWFC x35,W
17D2A:  MOVWF  FEA
17D2C:  MOVLW  01
17D2E:  ADDWF  FEF,W
17D30:  MOVWF  x3A
17D32:  MOVLW  03
17D34:  ADDWF  x34,W
17D36:  MOVWF  FE9
17D38:  MOVLW  00
17D3A:  ADDWFC x35,W
17D3C:  MOVWF  FEA
17D3E:  MOVFF  FEF,C3B
17D42:  MOVLW  02
17D44:  ADDWF  x34,W
17D46:  MOVWF  FE9
17D48:  MOVLW  00
17D4A:  ADDWFC x35,W
17D4C:  MOVWF  FEA
17D4E:  MOVFF  FEF,C3C
17D52:  MOVLW  01
17D54:  ADDWF  x34,W
17D56:  MOVWF  FE9
17D58:  MOVLW  00
17D5A:  ADDWFC x35,W
17D5C:  MOVWF  FEA
17D5E:  MOVFF  FEF,C3D
17D62:  MOVFF  C34,FE9
17D66:  MOVFF  C35,FEA
17D6A:  MOVFF  FEF,C3E
17D6E:  MOVLB  0
17D70:  CALL   7830
17D74:  MOVFF  01,C3F
17D78:  MOVLB  C
17D7A:  MOVFF  C26,FE9
17D7E:  MOVFF  C27,FEA
17D82:  MOVFF  FEF,C40
17D86:  MOVLW  01
17D88:  ADDWF  x26,W
17D8A:  MOVWF  FE9
17D8C:  MOVLW  00
17D8E:  ADDWFC x27,W
17D90:  MOVWF  FEA
17D92:  MOVFF  FEF,C41
17D96:  MOVLW  0A
17D98:  MOVWF  FE9
17D9A:  MOVFF  C39,C66
17D9E:  MOVFF  C38,C65
17DA2:  MOVLB  0
17DA4:  CALL   7894
17DA8:  MOVLW  2F
17DAA:  MOVLB  D
17DAC:  MOVWF  x6A
17DAE:  MOVLB  0
17DB0:  CALL   44EE
17DB4:  MOVFF  C3A,C65
17DB8:  MOVLW  01
17DBA:  MOVLB  C
17DBC:  MOVWF  x66
17DBE:  MOVLB  0
17DC0:  CALL   7994
17DC4:  MOVLW  2F
17DC6:  MOVLB  D
17DC8:  MOVWF  x6A
17DCA:  MOVLB  0
17DCC:  CALL   44EE
17DD0:  MOVFF  C3B,C65
17DD4:  MOVLW  01
17DD6:  MOVLB  C
17DD8:  MOVWF  x66
17DDA:  MOVLB  0
17DDC:  CALL   7994
17DE0:  MOVLW  20
17DE2:  MOVLB  D
17DE4:  MOVWF  x6A
17DE6:  MOVLB  0
17DE8:  CALL   44EE
17DEC:  MOVFF  C3C,C65
17DF0:  MOVLW  01
17DF2:  MOVLB  C
17DF4:  MOVWF  x66
17DF6:  MOVLB  0
17DF8:  CALL   7994
17DFC:  MOVLW  3A
17DFE:  MOVLB  D
17E00:  MOVWF  x6A
17E02:  MOVLB  0
17E04:  CALL   44EE
17E08:  MOVFF  C3D,C65
17E0C:  MOVLW  01
17E0E:  MOVLB  C
17E10:  MOVWF  x66
17E12:  MOVLB  0
17E14:  CALL   7994
17E18:  MOVLW  3A
17E1A:  MOVLB  D
17E1C:  MOVWF  x6A
17E1E:  MOVLB  0
17E20:  CALL   44EE
17E24:  MOVFF  C3E,C65
17E28:  MOVLW  01
17E2A:  MOVLB  C
17E2C:  MOVWF  x66
17E2E:  MOVLB  0
17E30:  CALL   7994
17E34:  MOVLW  CA
17E36:  MOVWF  FF6
17E38:  MOVLW  20
17E3A:  MOVWF  FF7
17E3C:  MOVLW  00
17E3E:  MOVWF  FF8
17E40:  MOVLW  03
17E42:  MOVLB  C
17E44:  MOVWF  xC1
17E46:  MOVLB  0
17E48:  CALL   5290
17E4C:  MOVFF  C3F,C65
17E50:  MOVLW  01
17E52:  MOVLB  C
17E54:  MOVWF  x66
17E56:  MOVLB  0
17E58:  CALL   7994
17E5C:  MOVLW  D1
17E5E:  MOVWF  FF6
17E60:  MOVLW  20
17E62:  MOVWF  FF7
17E64:  MOVLW  00
17E66:  MOVWF  FF8
17E68:  MOVLW  03
17E6A:  MOVLB  C
17E6C:  MOVWF  xC1
17E6E:  MOVLB  0
17E70:  CALL   5290
17E74:  MOVFF  C40,CBF
17E78:  MOVLW  37
17E7A:  MOVLB  C
17E7C:  MOVWF  xC0
17E7E:  MOVLB  0
17E80:  CALL   5A92
17E84:  MOVLW  20
17E86:  MOVLB  D
17E88:  MOVWF  x6A
17E8A:  MOVLB  0
17E8C:  CALL   44EE
17E90:  MOVFF  C41,CBF
17E94:  MOVLW  37
17E96:  MOVLB  C
17E98:  MOVWF  xC0
17E9A:  MOVLB  0
17E9C:  CALL   5A92
17EA0:  MOVLW  DD
17EA2:  MOVWF  FF6
17EA4:  MOVLW  20
17EA6:  MOVWF  FF7
17EA8:  MOVLW  00
17EAA:  MOVWF  FF8
17EAC:  MOVLW  03
17EAE:  MOVLB  C
17EB0:  MOVWF  xC1
17EB2:  MOVLB  0
17EB4:  CALL   5290
17EB8:  MOVLB  C
....................  
....................         uint16_t command = make16(data[0], data[1]); 
17EBA:  MOVFF  C26,FE9
17EBE:  MOVFF  C27,FEA
17EC2:  MOVFF  FEF,C37
17EC6:  MOVLW  01
17EC8:  ADDWF  x26,W
17ECA:  MOVWF  FE9
17ECC:  MOVLW  00
17ECE:  ADDWFC x27,W
17ED0:  MOVWF  FEA
17ED2:  MOVFF  FEF,C36
....................  
....................         // The table of available commands. 
....................         switch (command) { 
17ED6:  MOVF   x36,W
17ED8:  MOVWF  00
17EDA:  MOVF   x37,W
17EDC:  MOVWF  03
17EDE:  MOVLW  1C
17EE0:  SUBWF  03,W
17EE2:  BNZ   17EF2
17EE4:  MOVLW  AA
17EE6:  SUBWF  00,W
17EE8:  MOVLB  0
17EEA:  BTFSC  FD8.2
17EEC:  GOTO   187B2
17EF0:  MOVLB  C
17EF2:  MOVLW  1D
17EF4:  SUBWF  03,W
17EF6:  BNZ   17F06
17EF8:  MOVLW  AA
17EFA:  SUBWF  00,W
17EFC:  MOVLB  0
17EFE:  BTFSC  FD8.2
17F00:  GOTO   187C6
17F04:  MOVLB  C
17F06:  MOVLW  AB
17F08:  SUBWF  03,W
17F0A:  BNZ   17F1A
17F0C:  MOVLW  AA
17F0E:  SUBWF  00,W
17F10:  MOVLB  0
17F12:  BTFSC  FD8.2
17F14:  GOTO   187DA
17F18:  MOVLB  C
17F1A:  MOVLW  AB
17F1C:  SUBWF  03,W
17F1E:  BNZ   17F2E
17F20:  MOVLW  02
17F22:  SUBWF  00,W
17F24:  MOVLB  0
17F26:  BTFSC  FD8.2
17F28:  GOTO   187EE
17F2C:  MOVLB  C
17F2E:  MOVLW  AB
17F30:  SUBWF  03,W
17F32:  BNZ   17F42
17F34:  MOVLW  F0
17F36:  SUBWF  00,W
17F38:  MOVLB  0
17F3A:  BTFSC  FD8.2
17F3C:  GOTO   18802
17F40:  MOVLB  C
17F42:  MOVLW  AD
17F44:  SUBWF  03,W
17F46:  BNZ   17F56
17F48:  MOVLW  90
17F4A:  SUBWF  00,W
17F4C:  MOVLB  0
17F4E:  BTFSC  FD8.2
17F50:  GOTO   18816
17F54:  MOVLB  C
17F56:  MOVLW  AD
17F58:  SUBWF  03,W
17F5A:  BNZ   17F6A
17F5C:  MOVLW  DA
17F5E:  SUBWF  00,W
17F60:  MOVLB  0
17F62:  BTFSC  FD8.2
17F64:  GOTO   1882A
17F68:  MOVLB  C
17F6A:  MOVLW  B0
17F6C:  SUBWF  03,W
17F6E:  BNZ   17F7E
17F70:  MOVLW  A0
17F72:  SUBWF  00,W
17F74:  MOVLB  0
17F76:  BTFSC  FD8.2
17F78:  GOTO   1883E
17F7C:  MOVLB  C
17F7E:  MOVLW  B0
17F80:  SUBWF  03,W
17F82:  BNZ   17F92
17F84:  MOVLW  A2
17F86:  SUBWF  00,W
17F88:  MOVLB  0
17F8A:  BTFSC  FD8.2
17F8C:  GOTO   18852
17F90:  MOVLB  C
17F92:  MOVLW  C0
17F94:  SUBWF  03,W
17F96:  BNZ   17FA4
17F98:  MOVF   00,F
17F9A:  MOVLB  0
17F9C:  BTFSC  FD8.2
17F9E:  GOTO   18866
17FA2:  MOVLB  C
17FA4:  MOVLW  C0
17FA6:  SUBWF  03,W
17FA8:  BNZ   17FB8
17FAA:  MOVLW  01
17FAC:  SUBWF  00,W
17FAE:  MOVLB  0
17FB0:  BTFSC  FD8.2
17FB2:  GOTO   1887A
17FB6:  MOVLB  C
17FB8:  MOVLW  C0
17FBA:  SUBWF  03,W
17FBC:  BNZ   17FCC
17FBE:  MOVLW  02
17FC0:  SUBWF  00,W
17FC2:  MOVLB  0
17FC4:  BTFSC  FD8.2
17FC6:  GOTO   1888E
17FCA:  MOVLB  C
17FCC:  MOVLW  C0
17FCE:  SUBWF  03,W
17FD0:  BNZ   17FE0
17FD2:  MOVLW  03
17FD4:  SUBWF  00,W
17FD6:  MOVLB  0
17FD8:  BTFSC  FD8.2
17FDA:  GOTO   188A2
17FDE:  MOVLB  C
17FE0:  MOVLW  C0
17FE2:  SUBWF  03,W
17FE4:  BNZ   17FF4
17FE6:  MOVLW  08
17FE8:  SUBWF  00,W
17FEA:  MOVLB  0
17FEC:  BTFSC  FD8.2
17FEE:  GOTO   188B4
17FF2:  MOVLB  C
17FF4:  MOVLW  C0
17FF6:  SUBWF  03,W
17FF8:  BNZ   18008
17FFA:  MOVLW  09
17FFC:  SUBWF  00,W
17FFE:  MOVLB  0
18000:  BTFSC  FD8.2
18002:  GOTO   188C6
18006:  MOVLB  C
18008:  MOVLW  C0
1800A:  SUBWF  03,W
1800C:  BNZ   1801C
1800E:  MOVLW  0A
18010:  SUBWF  00,W
18012:  MOVLB  0
18014:  BTFSC  FD8.2
18016:  GOTO   188D8
1801A:  MOVLB  C
1801C:  MOVLW  C0
1801E:  SUBWF  03,W
18020:  BNZ   18030
18022:  MOVLW  0B
18024:  SUBWF  00,W
18026:  MOVLB  0
18028:  BTFSC  FD8.2
1802A:  GOTO   188EA
1802E:  MOVLB  C
18030:  MOVLW  C0
18032:  SUBWF  03,W
18034:  BNZ   18044
18036:  MOVLW  0C
18038:  SUBWF  00,W
1803A:  MOVLB  0
1803C:  BTFSC  FD8.2
1803E:  GOTO   188FC
18042:  MOVLB  C
18044:  MOVLW  C0
18046:  SUBWF  03,W
18048:  BNZ   18058
1804A:  MOVLW  0D
1804C:  SUBWF  00,W
1804E:  MOVLB  0
18050:  BTFSC  FD8.2
18052:  GOTO   1890E
18056:  MOVLB  C
18058:  MOVLW  C0
1805A:  SUBWF  03,W
1805C:  BNZ   1806C
1805E:  MOVLW  0F
18060:  SUBWF  00,W
18062:  MOVLB  0
18064:  BTFSC  FD8.2
18066:  GOTO   18920
1806A:  MOVLB  C
1806C:  MOVLW  C0
1806E:  SUBWF  03,W
18070:  BNZ   18080
18072:  MOVLW  12
18074:  SUBWF  00,W
18076:  MOVLB  0
18078:  BTFSC  FD8.2
1807A:  GOTO   18932
1807E:  MOVLB  C
18080:  MOVLW  C0
18082:  SUBWF  03,W
18084:  BNZ   18094
18086:  MOVLW  18
18088:  SUBWF  00,W
1808A:  MOVLB  0
1808C:  BTFSC  FD8.2
1808E:  GOTO   18944
18092:  MOVLB  C
18094:  MOVLW  C0
18096:  SUBWF  03,W
18098:  BNZ   180A8
1809A:  MOVLW  19
1809C:  SUBWF  00,W
1809E:  MOVLB  0
180A0:  BTFSC  FD8.2
180A2:  GOTO   18956
180A6:  MOVLB  C
180A8:  MOVLW  C0
180AA:  SUBWF  03,W
180AC:  BNZ   180BC
180AE:  MOVLW  1A
180B0:  SUBWF  00,W
180B2:  MOVLB  0
180B4:  BTFSC  FD8.2
180B6:  GOTO   18968
180BA:  MOVLB  C
180BC:  MOVLW  C0
180BE:  SUBWF  03,W
180C0:  BNZ   180D0
180C2:  MOVLW  1B
180C4:  SUBWF  00,W
180C6:  MOVLB  0
180C8:  BTFSC  FD8.2
180CA:  GOTO   1897A
180CE:  MOVLB  C
180D0:  MOVLW  C0
180D2:  SUBWF  03,W
180D4:  BNZ   180E4
180D6:  MOVLW  1F
180D8:  SUBWF  00,W
180DA:  MOVLB  0
180DC:  BTFSC  FD8.2
180DE:  GOTO   1898C
180E2:  MOVLB  C
180E4:  MOVLW  C0
180E6:  SUBWF  03,W
180E8:  BNZ   180F8
180EA:  MOVLW  2A
180EC:  SUBWF  00,W
180EE:  MOVLB  0
180F0:  BTFSC  FD8.2
180F2:  GOTO   1899E
180F6:  MOVLB  C
180F8:  MOVLW  C0
180FA:  SUBWF  03,W
180FC:  BNZ   1810C
180FE:  MOVLW  25
18100:  SUBWF  00,W
18102:  MOVLB  0
18104:  BTFSC  FD8.2
18106:  GOTO   189B0
1810A:  MOVLB  C
1810C:  MOVLW  C0
1810E:  SUBWF  03,W
18110:  BNZ   18120
18112:  MOVLW  26
18114:  SUBWF  00,W
18116:  MOVLB  0
18118:  BTFSC  FD8.2
1811A:  GOTO   189C2
1811E:  MOVLB  C
18120:  MOVLW  C0
18122:  SUBWF  03,W
18124:  BNZ   18134
18126:  MOVLW  28
18128:  SUBWF  00,W
1812A:  MOVLB  0
1812C:  BTFSC  FD8.2
1812E:  GOTO   189D4
18132:  MOVLB  C
18134:  MOVLW  C0
18136:  SUBWF  03,W
18138:  BNZ   18148
1813A:  MOVLW  31
1813C:  SUBWF  00,W
1813E:  MOVLB  0
18140:  BTFSC  FD8.2
18142:  GOTO   189E6
18146:  MOVLB  C
18148:  MOVLW  C0
1814A:  SUBWF  03,W
1814C:  BNZ   1815C
1814E:  MOVLW  36
18150:  SUBWF  00,W
18152:  MOVLB  0
18154:  BTFSC  FD8.2
18156:  GOTO   189F8
1815A:  MOVLB  C
1815C:  MOVLW  C0
1815E:  SUBWF  03,W
18160:  BNZ   18170
18162:  MOVLW  37
18164:  SUBWF  00,W
18166:  MOVLB  0
18168:  BTFSC  FD8.2
1816A:  GOTO   18A0A
1816E:  MOVLB  C
18170:  MOVLW  C0
18172:  SUBWF  03,W
18174:  BNZ   18184
18176:  MOVLW  3A
18178:  SUBWF  00,W
1817A:  MOVLB  0
1817C:  BTFSC  FD8.2
1817E:  GOTO   18A1C
18182:  MOVLB  C
18184:  MOVLW  C0
18186:  SUBWF  03,W
18188:  BNZ   18198
1818A:  MOVLW  3B
1818C:  SUBWF  00,W
1818E:  MOVLB  0
18190:  BTFSC  FD8.2
18192:  GOTO   18A2E
18196:  MOVLB  C
18198:  MOVLW  C0
1819A:  SUBWF  03,W
1819C:  BNZ   181AC
1819E:  MOVLW  3C
181A0:  SUBWF  00,W
181A2:  MOVLB  0
181A4:  BTFSC  FD8.2
181A6:  GOTO   18A40
181AA:  MOVLB  C
181AC:  MOVLW  C0
181AE:  SUBWF  03,W
181B0:  BNZ   181C0
181B2:  MOVLW  42
181B4:  SUBWF  00,W
181B6:  MOVLB  0
181B8:  BTFSC  FD8.2
181BA:  GOTO   18A52
181BE:  MOVLB  C
181C0:  MOVLW  C0
181C2:  SUBWF  03,W
181C4:  BNZ   181D4
181C6:  MOVLW  50
181C8:  SUBWF  00,W
181CA:  MOVLB  0
181CC:  BTFSC  FD8.2
181CE:  GOTO   18A64
181D2:  MOVLB  C
181D4:  MOVLW  C0
181D6:  SUBWF  03,W
181D8:  BNZ   181E8
181DA:  MOVLW  55
181DC:  SUBWF  00,W
181DE:  MOVLB  0
181E0:  BTFSC  FD8.2
181E2:  GOTO   18A76
181E6:  MOVLB  C
181E8:  MOVLW  C0
181EA:  SUBWF  03,W
181EC:  BNZ   181FC
181EE:  MOVLW  58
181F0:  SUBWF  00,W
181F2:  MOVLB  0
181F4:  BTFSC  FD8.2
181F6:  GOTO   18A88
181FA:  MOVLB  C
181FC:  MOVLW  C0
181FE:  SUBWF  03,W
18200:  BNZ   18210
18202:  MOVLW  59
18204:  SUBWF  00,W
18206:  MOVLB  0
18208:  BTFSC  FD8.2
1820A:  GOTO   18A9A
1820E:  MOVLB  C
18210:  MOVLW  C0
18212:  SUBWF  03,W
18214:  BNZ   18224
18216:  MOVLW  5E
18218:  SUBWF  00,W
1821A:  MOVLB  0
1821C:  BTFSC  FD8.2
1821E:  GOTO   18AAC
18222:  MOVLB  C
18224:  MOVLW  C0
18226:  SUBWF  03,W
18228:  BNZ   18238
1822A:  MOVLW  60
1822C:  SUBWF  00,W
1822E:  MOVLB  0
18230:  BTFSC  FD8.2
18232:  GOTO   18ABE
18236:  MOVLB  C
18238:  MOVLW  C0
1823A:  SUBWF  03,W
1823C:  BNZ   1824C
1823E:  MOVLW  61
18240:  SUBWF  00,W
18242:  MOVLB  0
18244:  BTFSC  FD8.2
18246:  GOTO   18AD0
1824A:  MOVLB  C
1824C:  MOVLW  C0
1824E:  SUBWF  03,W
18250:  BNZ   18260
18252:  MOVLW  6C
18254:  SUBWF  00,W
18256:  MOVLB  0
18258:  BTFSC  FD8.2
1825A:  GOTO   18AE2
1825E:  MOVLB  C
18260:  MOVLW  C0
18262:  SUBWF  03,W
18264:  BNZ   18274
18266:  MOVLW  6D
18268:  SUBWF  00,W
1826A:  MOVLB  0
1826C:  BTFSC  FD8.2
1826E:  GOTO   18AF4
18272:  MOVLB  C
18274:  MOVLW  C0
18276:  SUBWF  03,W
18278:  BNZ   18288
1827A:  MOVLW  70
1827C:  SUBWF  00,W
1827E:  MOVLB  0
18280:  BTFSC  FD8.2
18282:  GOTO   18B06
18286:  MOVLB  C
18288:  MOVLW  C0
1828A:  SUBWF  03,W
1828C:  BNZ   1829C
1828E:  MOVLW  71
18290:  SUBWF  00,W
18292:  MOVLB  0
18294:  BTFSC  FD8.2
18296:  GOTO   18B18
1829A:  MOVLB  C
1829C:  MOVLW  C0
1829E:  SUBWF  03,W
182A0:  BNZ   182B0
182A2:  MOVLW  72
182A4:  SUBWF  00,W
182A6:  MOVLB  0
182A8:  BTFSC  FD8.2
182AA:  GOTO   18B2A
182AE:  MOVLB  C
182B0:  MOVLW  C0
182B2:  SUBWF  03,W
182B4:  BNZ   182C4
182B6:  MOVLW  80
182B8:  SUBWF  00,W
182BA:  MOVLB  0
182BC:  BTFSC  FD8.2
182BE:  GOTO   18B3C
182C2:  MOVLB  C
182C4:  MOVLW  C0
182C6:  SUBWF  03,W
182C8:  BNZ   182D8
182CA:  MOVLW  81
182CC:  SUBWF  00,W
182CE:  MOVLB  0
182D0:  BTFSC  FD8.2
182D2:  GOTO   18B4E
182D6:  MOVLB  C
182D8:  MOVLW  C0
182DA:  SUBWF  03,W
182DC:  BNZ   182EC
182DE:  MOVLW  90
182E0:  SUBWF  00,W
182E2:  MOVLB  0
182E4:  BTFSC  FD8.2
182E6:  GOTO   18B60
182EA:  MOVLB  C
182EC:  MOVLW  C0
182EE:  SUBWF  03,W
182F0:  BNZ   18300
182F2:  MOVLW  91
182F4:  SUBWF  00,W
182F6:  MOVLB  0
182F8:  BTFSC  FD8.2
182FA:  GOTO   18B72
182FE:  MOVLB  C
18300:  MOVLW  C0
18302:  SUBWF  03,W
18304:  BNZ   18314
18306:  MOVLW  92
18308:  SUBWF  00,W
1830A:  MOVLB  0
1830C:  BTFSC  FD8.2
1830E:  GOTO   18B84
18312:  MOVLB  C
18314:  MOVLW  C0
18316:  SUBWF  03,W
18318:  BNZ   18328
1831A:  MOVLW  93
1831C:  SUBWF  00,W
1831E:  MOVLB  0
18320:  BTFSC  FD8.2
18322:  GOTO   18B96
18326:  MOVLB  C
18328:  MOVLW  C0
1832A:  SUBWF  03,W
1832C:  BNZ   1833C
1832E:  MOVLW  94
18330:  SUBWF  00,W
18332:  MOVLB  0
18334:  BTFSC  FD8.2
18336:  GOTO   18BA8
1833A:  MOVLB  C
1833C:  MOVLW  C0
1833E:  SUBWF  03,W
18340:  BNZ   18350
18342:  MOVLW  95
18344:  SUBWF  00,W
18346:  MOVLB  0
18348:  BTFSC  FD8.2
1834A:  GOTO   18BBA
1834E:  MOVLB  C
18350:  MOVLW  C0
18352:  SUBWF  03,W
18354:  BNZ   18364
18356:  MOVLW  96
18358:  SUBWF  00,W
1835A:  MOVLB  0
1835C:  BTFSC  FD8.2
1835E:  GOTO   18BCC
18362:  MOVLB  C
18364:  MOVLW  C0
18366:  SUBWF  03,W
18368:  BNZ   18378
1836A:  MOVLW  A0
1836C:  SUBWF  00,W
1836E:  MOVLB  0
18370:  BTFSC  FD8.2
18372:  GOTO   18BDE
18376:  MOVLB  C
18378:  MOVLW  C0
1837A:  SUBWF  03,W
1837C:  BNZ   1838C
1837E:  MOVLW  A1
18380:  SUBWF  00,W
18382:  MOVLB  0
18384:  BTFSC  FD8.2
18386:  GOTO   18BF0
1838A:  MOVLB  C
1838C:  MOVLW  C0
1838E:  SUBWF  03,W
18390:  BNZ   183A0
18392:  MOVLW  A2
18394:  SUBWF  00,W
18396:  MOVLB  0
18398:  BTFSC  FD8.2
1839A:  GOTO   18C02
1839E:  MOVLB  C
183A0:  MOVLW  C0
183A2:  SUBWF  03,W
183A4:  BNZ   183B4
183A6:  MOVLW  A6
183A8:  SUBWF  00,W
183AA:  MOVLB  0
183AC:  BTFSC  FD8.2
183AE:  GOTO   18C14
183B2:  MOVLB  C
183B4:  MOVLW  C0
183B6:  SUBWF  03,W
183B8:  BNZ   183C8
183BA:  MOVLW  AA
183BC:  SUBWF  00,W
183BE:  MOVLB  0
183C0:  BTFSC  FD8.2
183C2:  GOTO   18C26
183C6:  MOVLB  C
183C8:  MOVLW  C0
183CA:  SUBWF  03,W
183CC:  BNZ   183DC
183CE:  MOVLW  AB
183D0:  SUBWF  00,W
183D2:  MOVLB  0
183D4:  BTFSC  FD8.2
183D6:  GOTO   18C38
183DA:  MOVLB  C
183DC:  MOVLW  C0
183DE:  SUBWF  03,W
183E0:  BNZ   183F0
183E2:  MOVLW  AC
183E4:  SUBWF  00,W
183E6:  MOVLB  0
183E8:  BTFSC  FD8.2
183EA:  GOTO   18C4A
183EE:  MOVLB  C
183F0:  MOVLW  C0
183F2:  SUBWF  03,W
183F4:  BNZ   18404
183F6:  MOVLW  AD
183F8:  SUBWF  00,W
183FA:  MOVLB  0
183FC:  BTFSC  FD8.2
183FE:  GOTO   18C5C
18402:  MOVLB  C
18404:  MOVLW  C0
18406:  SUBWF  03,W
18408:  BNZ   18418
1840A:  MOVLW  AE
1840C:  SUBWF  00,W
1840E:  MOVLB  0
18410:  BTFSC  FD8.2
18412:  GOTO   18C6E
18416:  MOVLB  C
18418:  MOVLW  C0
1841A:  SUBWF  03,W
1841C:  BNZ   1842C
1841E:  MOVLW  AF
18420:  SUBWF  00,W
18422:  MOVLB  0
18424:  BTFSC  FD8.2
18426:  GOTO   18C80
1842A:  MOVLB  C
1842C:  MOVLW  C0
1842E:  SUBWF  03,W
18430:  BNZ   18440
18432:  MOVLW  B7
18434:  SUBWF  00,W
18436:  MOVLB  0
18438:  BTFSC  FD8.2
1843A:  GOTO   18C92
1843E:  MOVLB  C
18440:  MOVLW  C0
18442:  SUBWF  03,W
18444:  BNZ   18454
18446:  MOVLW  BE
18448:  SUBWF  00,W
1844A:  MOVLB  0
1844C:  BTFSC  FD8.2
1844E:  GOTO   18CA4
18452:  MOVLB  C
18454:  MOVLW  C0
18456:  SUBWF  03,W
18458:  BNZ   18468
1845A:  MOVLW  C0
1845C:  SUBWF  00,W
1845E:  MOVLB  0
18460:  BTFSC  FD8.2
18462:  GOTO   18CB6
18466:  MOVLB  C
18468:  MOVLW  C0
1846A:  SUBWF  03,W
1846C:  BNZ   1847C
1846E:  MOVLW  C1
18470:  SUBWF  00,W
18472:  MOVLB  0
18474:  BTFSC  FD8.2
18476:  GOTO   18CC8
1847A:  MOVLB  C
1847C:  MOVLW  C0
1847E:  SUBWF  03,W
18480:  BNZ   18490
18482:  MOVLW  C5
18484:  SUBWF  00,W
18486:  MOVLB  0
18488:  BTFSC  FD8.2
1848A:  GOTO   18CDA
1848E:  MOVLB  C
18490:  MOVLW  C0
18492:  SUBWF  03,W
18494:  BNZ   184A4
18496:  MOVLW  CA
18498:  SUBWF  00,W
1849A:  MOVLB  0
1849C:  BTFSC  FD8.2
1849E:  GOTO   18CEC
184A2:  MOVLB  C
184A4:  MOVLW  C0
184A6:  SUBWF  03,W
184A8:  BNZ   184B8
184AA:  MOVLW  CB
184AC:  SUBWF  00,W
184AE:  MOVLB  0
184B0:  BTFSC  FD8.2
184B2:  GOTO   18CFE
184B6:  MOVLB  C
184B8:  MOVLW  C0
184BA:  SUBWF  03,W
184BC:  BNZ   184CC
184BE:  MOVLW  CC
184C0:  SUBWF  00,W
184C2:  MOVLB  0
184C4:  BTFSC  FD8.2
184C6:  GOTO   18D1C
184CA:  MOVLB  C
184CC:  MOVLW  C0
184CE:  SUBWF  03,W
184D0:  BNZ   184E0
184D2:  MOVLW  CD
184D4:  SUBWF  00,W
184D6:  MOVLB  0
184D8:  BTFSC  FD8.2
184DA:  GOTO   18D2E
184DE:  MOVLB  C
184E0:  MOVLW  C0
184E2:  SUBWF  03,W
184E4:  BNZ   184F4
184E6:  MOVLW  CE
184E8:  SUBWF  00,W
184EA:  MOVLB  0
184EC:  BTFSC  FD8.2
184EE:  GOTO   18D40
184F2:  MOVLB  C
184F4:  MOVLW  C0
184F6:  SUBWF  03,W
184F8:  BNZ   18508
184FA:  MOVLW  CF
184FC:  SUBWF  00,W
184FE:  MOVLB  0
18500:  BTFSC  FD8.2
18502:  GOTO   18D52
18506:  MOVLB  C
18508:  MOVLW  C0
1850A:  SUBWF  03,W
1850C:  BNZ   1851C
1850E:  MOVLW  D0
18510:  SUBWF  00,W
18512:  MOVLB  0
18514:  BTFSC  FD8.2
18516:  GOTO   18D64
1851A:  MOVLB  C
1851C:  MOVLW  C0
1851E:  SUBWF  03,W
18520:  BNZ   18530
18522:  MOVLW  D1
18524:  SUBWF  00,W
18526:  MOVLB  0
18528:  BTFSC  FD8.2
1852A:  GOTO   18D76
1852E:  MOVLB  C
18530:  MOVLW  C0
18532:  SUBWF  03,W
18534:  BNZ   18544
18536:  MOVLW  D2
18538:  SUBWF  00,W
1853A:  MOVLB  0
1853C:  BTFSC  FD8.2
1853E:  GOTO   18D88
18542:  MOVLB  C
18544:  MOVLW  C0
18546:  SUBWF  03,W
18548:  BNZ   18558
1854A:  MOVLW  D3
1854C:  SUBWF  00,W
1854E:  MOVLB  0
18550:  BTFSC  FD8.2
18552:  GOTO   18D9A
18556:  MOVLB  C
18558:  MOVLW  C0
1855A:  SUBWF  03,W
1855C:  BNZ   1856C
1855E:  MOVLW  D4
18560:  SUBWF  00,W
18562:  MOVLB  0
18564:  BTFSC  FD8.2
18566:  GOTO   18DAC
1856A:  MOVLB  C
1856C:  MOVLW  C0
1856E:  SUBWF  03,W
18570:  BNZ   18580
18572:  MOVLW  D5
18574:  SUBWF  00,W
18576:  MOVLB  0
18578:  BTFSC  FD8.2
1857A:  GOTO   18DBE
1857E:  MOVLB  C
18580:  MOVLW  C0
18582:  SUBWF  03,W
18584:  BNZ   18594
18586:  MOVLW  D6
18588:  SUBWF  00,W
1858A:  MOVLB  0
1858C:  BTFSC  FD8.2
1858E:  GOTO   18DD0
18592:  MOVLB  C
18594:  MOVLW  C0
18596:  SUBWF  03,W
18598:  BNZ   185A8
1859A:  MOVLW  D7
1859C:  SUBWF  00,W
1859E:  MOVLB  0
185A0:  BTFSC  FD8.2
185A2:  GOTO   18DE2
185A6:  MOVLB  C
185A8:  MOVLW  C0
185AA:  SUBWF  03,W
185AC:  BNZ   185BC
185AE:  MOVLW  D8
185B0:  SUBWF  00,W
185B2:  MOVLB  0
185B4:  BTFSC  FD8.2
185B6:  GOTO   18DF4
185BA:  MOVLB  C
185BC:  MOVLW  C0
185BE:  SUBWF  03,W
185C0:  BNZ   185D0
185C2:  MOVLW  DA
185C4:  SUBWF  00,W
185C6:  MOVLB  0
185C8:  BTFSC  FD8.2
185CA:  GOTO   18E06
185CE:  MOVLB  C
185D0:  MOVLW  C0
185D2:  SUBWF  03,W
185D4:  BNZ   185E4
185D6:  MOVLW  DB
185D8:  SUBWF  00,W
185DA:  MOVLB  0
185DC:  BTFSC  FD8.2
185DE:  GOTO   18E18
185E2:  MOVLB  C
185E4:  MOVLW  C0
185E6:  SUBWF  03,W
185E8:  BNZ   185F8
185EA:  MOVLW  DD
185EC:  SUBWF  00,W
185EE:  MOVLB  0
185F0:  BTFSC  FD8.2
185F2:  GOTO   18E2A
185F6:  MOVLB  C
185F8:  MOVLW  C0
185FA:  SUBWF  03,W
185FC:  BNZ   1860C
185FE:  MOVLW  DE
18600:  SUBWF  00,W
18602:  MOVLB  0
18604:  BTFSC  FD8.2
18606:  GOTO   18E3C
1860A:  MOVLB  C
1860C:  MOVLW  C0
1860E:  SUBWF  03,W
18610:  BNZ   18620
18612:  MOVLW  DF
18614:  SUBWF  00,W
18616:  MOVLB  0
18618:  BTFSC  FD8.2
1861A:  GOTO   18E4E
1861E:  MOVLB  C
18620:  MOVLW  C0
18622:  SUBWF  03,W
18624:  BNZ   18634
18626:  MOVLW  EA
18628:  SUBWF  00,W
1862A:  MOVLB  0
1862C:  BTFSC  FD8.2
1862E:  GOTO   18E60
18632:  MOVLB  C
18634:  MOVLW  C0
18636:  SUBWF  03,W
18638:  BNZ   18648
1863A:  MOVLW  EB
1863C:  SUBWF  00,W
1863E:  MOVLB  0
18640:  BTFSC  FD8.2
18642:  GOTO   18E72
18646:  MOVLB  C
18648:  MOVLW  C0
1864A:  SUBWF  03,W
1864C:  BNZ   1865C
1864E:  MOVLW  ED
18650:  SUBWF  00,W
18652:  MOVLB  0
18654:  BTFSC  FD8.2
18656:  GOTO   18E84
1865A:  MOVLB  C
1865C:  MOVLW  C0
1865E:  SUBWF  03,W
18660:  BNZ   18670
18662:  MOVLW  EE
18664:  SUBWF  00,W
18666:  MOVLB  0
18668:  BTFSC  FD8.2
1866A:  GOTO   18E96
1866E:  MOVLB  C
18670:  MOVLW  C0
18672:  SUBWF  03,W
18674:  BNZ   18684
18676:  MOVLW  EF
18678:  SUBWF  00,W
1867A:  MOVLB  0
1867C:  BTFSC  FD8.2
1867E:  GOTO   18EA8
18682:  MOVLB  C
18684:  MOVLW  C0
18686:  SUBWF  03,W
18688:  BNZ   18698
1868A:  MOVLW  F0
1868C:  SUBWF  00,W
1868E:  MOVLB  0
18690:  BTFSC  FD8.2
18692:  GOTO   18EBA
18696:  MOVLB  C
18698:  MOVLW  C0
1869A:  SUBWF  03,W
1869C:  BNZ   186AC
1869E:  MOVLW  F5
186A0:  SUBWF  00,W
186A2:  MOVLB  0
186A4:  BTFSC  FD8.2
186A6:  GOTO   18ECC
186AA:  MOVLB  C
186AC:  MOVLW  C0
186AE:  SUBWF  03,W
186B0:  BNZ   186C0
186B2:  MOVLW  F6
186B4:  SUBWF  00,W
186B6:  MOVLB  0
186B8:  BTFSC  FD8.2
186BA:  GOTO   18EDE
186BE:  MOVLB  C
186C0:  MOVLW  C0
186C2:  SUBWF  03,W
186C4:  BNZ   186D4
186C6:  MOVLW  F7
186C8:  SUBWF  00,W
186CA:  MOVLB  0
186CC:  BTFSC  FD8.2
186CE:  GOTO   18EF0
186D2:  MOVLB  C
186D4:  MOVLW  C0
186D6:  SUBWF  03,W
186D8:  BNZ   186E8
186DA:  MOVLW  F8
186DC:  SUBWF  00,W
186DE:  MOVLB  0
186E0:  BTFSC  FD8.2
186E2:  GOTO   18F02
186E6:  MOVLB  C
186E8:  MOVLW  C0
186EA:  SUBWF  03,W
186EC:  BNZ   186FC
186EE:  MOVLW  F9
186F0:  SUBWF  00,W
186F2:  MOVLB  0
186F4:  BTFSC  FD8.2
186F6:  GOTO   18F14
186FA:  MOVLB  C
186FC:  MOVLW  C0
186FE:  SUBWF  03,W
18700:  BNZ   18710
18702:  MOVLW  FA
18704:  SUBWF  00,W
18706:  MOVLB  0
18708:  BTFSC  FD8.2
1870A:  GOTO   18F26
1870E:  MOVLB  C
18710:  MOVLW  C0
18712:  SUBWF  03,W
18714:  BNZ   18724
18716:  MOVLW  FB
18718:  SUBWF  00,W
1871A:  MOVLB  0
1871C:  BTFSC  FD8.2
1871E:  GOTO   18F38
18722:  MOVLB  C
18724:  MOVLW  C0
18726:  SUBWF  03,W
18728:  BNZ   18738
1872A:  MOVLW  FC
1872C:  SUBWF  00,W
1872E:  MOVLB  0
18730:  BTFSC  FD8.2
18732:  GOTO   18F4A
18736:  MOVLB  C
18738:  MOVLW  C0
1873A:  SUBWF  03,W
1873C:  BNZ   1874C
1873E:  MOVLW  FD
18740:  SUBWF  00,W
18742:  MOVLB  0
18744:  BTFSC  FD8.2
18746:  GOTO   18F5C
1874A:  MOVLB  C
1874C:  MOVLW  C0
1874E:  SUBWF  03,W
18750:  BNZ   18760
18752:  MOVLW  FE
18754:  SUBWF  00,W
18756:  MOVLB  0
18758:  BTFSC  FD8.2
1875A:  GOTO   18F6E
1875E:  MOVLB  C
18760:  MOVLW  C0
18762:  SUBWF  03,W
18764:  BNZ   18774
18766:  MOVLW  FF
18768:  SUBWF  00,W
1876A:  MOVLB  0
1876C:  BTFSC  FD8.2
1876E:  GOTO   18F80
18772:  MOVLB  C
18774:  MOVLW  CB
18776:  SUBWF  03,W
18778:  BNZ   18786
1877A:  MOVF   00,F
1877C:  MOVLB  0
1877E:  BTFSC  FD8.2
18780:  GOTO   18F92
18784:  MOVLB  C
18786:  MOVLW  DB
18788:  SUBWF  03,W
1878A:  BNZ   1879A
1878C:  MOVLW  FF
1878E:  SUBWF  00,W
18790:  MOVLB  0
18792:  BTFSC  FD8.2
18794:  GOTO   18FA4
18798:  MOVLB  C
1879A:  MOVLW  E0
1879C:  SUBWF  03,W
1879E:  BNZ   187AE
187A0:  MOVLW  33
187A2:  SUBWF  00,W
187A4:  MOVLB  0
187A6:  BTFSC  FD8.2
187A8:  GOTO   18FB6
187AC:  MOVLB  C
187AE:  GOTO   18FC8
....................  
....................         // Arranged in Alphanumeric 
....................         case 0x1CAA: error = command_tmcr1_telemetry(data); break; 
187B2:  MOVFF  C27,C39
187B6:  MOVFF  C26,C38
187BA:  GOTO   7AB2
187BE:  MOVFF  01,C2A
187C2:  GOTO   18FDA
....................         case 0x1DAA: error = command_tmcr2_telemetry(data); break; 
187C6:  MOVFF  C27,C39
187CA:  MOVFF  C26,C38
187CE:  GOTO   7AEC
187D2:  MOVFF  01,C2A
187D6:  GOTO   18FDA
....................         case 0xABAA: error = command_pcib_telemetry(data); break; 
187DA:  MOVFF  C27,C39
187DE:  MOVFF  C26,C38
187E2:  GOTO   7B26
187E6:  MOVFF  01,C2A
187EA:  GOTO   18FDA
....................         case 0xAB02: error = command_mux_lock_unlock(data); break; 
187EE:  MOVFF  C27,C39
187F2:  MOVFF  C26,C38
187F6:  CALL   7F58
187FA:  MOVFF  01,C2A
187FE:  GOTO   18FDA
....................         case 0xABF0: error = command_rpi_end_of_transmission(data); break; 
18802:  MOVFF  C27,C39
18806:  MOVFF  C26,C38
1880A:  GOTO   7FA8
1880E:  MOVFF  01,C2A
18812:  GOTO   18FDA
....................         case 0xAD90: error = command_adcs_telemetry(data); break; 
18816:  MOVFF  C27,C39
1881A:  MOVFF  C26,C38
1881E:  GOTO   8078
18822:  MOVFF  01,C2A
18826:  GOTO   18FDA
....................         case 0xADDA: error = command_adcs_gps_time(data); break; 
1882A:  MOVFF  C27,C39
1882E:  MOVFF  C26,C38
18832:  GOTO   82C0
18836:  MOVFF  01,C2A
1883A:  GOTO   18FDA
....................         case 0xB0A0: error = command_reset_telemetry(data); break; 
1883E:  MOVFF  C27,C39
18842:  MOVFF  C26,C38
18846:  CALL   87A4
1884A:  MOVFF  01,C2A
1884E:  GOTO   18FDA
....................         case 0xB0A2: error = command_reset_warning(data); break; 
18852:  MOVFF  C27,C39
18856:  MOVFF  C26,C38
1885A:  GOTO   8F9A
1885E:  MOVFF  01,C2A
18862:  GOTO   18FDA
....................         case 0xC000: error = command_print_memory_address(data); break; 
18866:  MOVFF  C27,C39
1886A:  MOVFF  C26,C38
1886E:  GOTO   90F0
18872:  MOVFF  01,C2A
18876:  GOTO   18FDA
....................         case 0xC001: error = command_set_clock(data); break; 
1887A:  MOVFF  C27,C39
1887E:  MOVFF  C26,C38
18882:  GOTO   91CA
18886:  MOVFF  01,C2A
1888A:  GOTO   18FDA
....................         case 0xC002: error = command_mux_lock_unlock(data); break; 
1888E:  MOVFF  C27,C39
18892:  MOVFF  C26,C38
18896:  CALL   7F58
1889A:  MOVFF  01,C2A
1889E:  GOTO   18FDA
....................         case 0xC003: error = command_set_obc_variable(data); break; 
188A2:  MOVFF  C27,C39
188A6:  MOVFF  C26,C38
188AA:  GOTO   960A
188AE:  MOVFF  01,C2A
188B2:  BRA    18FDA
....................         case 0xC008: error = command_xmodem_receive_sector(data); break; 
188B4:  MOVFF  C27,C39
188B8:  MOVFF  C26,C38
188BC:  GOTO   A07A
188C0:  MOVFF  01,C2A
188C4:  BRA    18FDA
....................         case 0xC009: error = command_xmodem_send_sector(data); break; 
188C6:  MOVFF  C27,C39
188CA:  MOVFF  C26,C38
188CE:  GOTO   A998
188D2:  MOVFF  01,C2A
188D6:  BRA    18FDA
....................         case 0xC00A: error = command_copy_memory_page(data); break; 
188D8:  MOVFF  C27,C39
188DC:  MOVFF  C26,C38
188E0:  GOTO   B26C
188E4:  MOVFF  01,C2A
188E8:  BRA    18FDA
....................         case 0xC00B: error = command_copy_memory_sector(data); break; 
188EA:  MOVFF  C27,C39
188EE:  MOVFF  C26,C38
188F2:  GOTO   B2F0
188F6:  MOVFF  01,C2A
188FA:  BRA    18FDA
....................         case 0xC00C: error = command_erase_memory_page(data); break; 
188FC:  MOVFF  C27,C39
18900:  MOVFF  C26,C38
18904:  GOTO   B378
18908:  MOVFF  01,C2A
1890C:  BRA    18FDA
....................         case 0xC00D: error = command_erase_memory_sector(data); break; 
1890E:  MOVFF  C27,C39
18912:  MOVFF  C26,C38
18916:  GOTO   B588
1891A:  MOVFF  01,C2A
1891E:  BRA    18FDA
....................         case 0xC00F: error = command_sel1_a(data); break; 
18920:  MOVFF  C27,C39
18924:  MOVFF  C26,C38
18928:  GOTO   B758
1892C:  MOVFF  01,C2A
18930:  BRA    18FDA
....................         // case 0xC010: reserved for COM 
....................         // case 0xC011: reserved for COM 
....................         case 0xC012: error = command_sel1_d(data); break; 
18932:  MOVFF  C27,C39
18936:  MOVFF  C26,C38
1893A:  GOTO   B8CE
1893E:  MOVFF  01,C2A
18942:  BRA    18FDA
....................         // case 0xC013: reserved for COM 
....................         // case 0xC014: reserved for COM 
....................         // case 0xC015: reserved for COM 
....................         // case 0xC016: reserved for COM 
....................         // case 0xC017: reserved for COM 
....................         case 0xC018: error = command_sel1_b(data); break; 
18944:  MOVFF  C27,C39
18948:  MOVFF  C26,C38
1894C:  GOTO   BBC0
18950:  MOVFF  01,C2A
18954:  BRA    18FDA
....................         case 0xC019: error = command_sel1_c(data); break; 
18956:  MOVFF  C27,C39
1895A:  MOVFF  C26,C38
1895E:  GOTO   BBD8
18962:  MOVFF  01,C2A
18966:  BRA    18FDA
....................         case 0xC01A: error = command_sel1_zes(data); break; // Reassigned from 0xC010 
18968:  MOVFF  C27,C39
1896C:  MOVFF  C26,C38
18970:  GOTO   BD4E
18974:  MOVFF  01,C2A
18978:  BRA    18FDA
....................         case 0xC01B: error = command_sel2_ref(data); break; // Reassigned from 0xC010 
1897A:  MOVFF  C27,C39
1897E:  MOVFF  C26,C38
18982:  GOTO   BE36
18986:  MOVFF  01,C2A
1898A:  BRA    18FDA
....................         case 0xC01F: error = command_sel2_a(data); break; 
1898C:  MOVFF  C27,C39
18990:  MOVFF  C26,C38
18994:  GOTO   BF1E
18998:  MOVFF  01,C2A
1899C:  BRA    18FDA
....................         // case 0xC020: reserved for COM 
....................         // case 0xC021: reserved for COM 
....................         // case 0xC022: reserved for COM 
....................         // case 0xC023: reserved for COM 
....................         // case 0xC024: reserved for COM 
....................         case 0xC02A: error = command_mcp(data); break; 
1899E:  MOVFF  C27,C39
189A2:  MOVFF  C26,C38
189A6:  GOTO   C0B2
189AA:  MOVFF  01,C2A
189AE:  BRA    18FDA
....................         case 0xC025: error = command_boot_cmd_clear_nth(data); break; 
189B0:  MOVFF  C27,C39
189B4:  MOVFF  C26,C38
189B8:  GOTO   C0F0
189BC:  MOVFF  01,C2A
189C0:  BRA    18FDA
....................         case 0xC026: error = command_boot_cmd_clear_all(data); break; 
189C2:  MOVFF  C27,C39
189C6:  MOVFF  C26,C38
189CA:  GOTO   C11C
189CE:  MOVFF  01,C2A
189D2:  BRA    18FDA
....................         // case 0xC027: reserved for COM 
....................         case 0xC028: error = command_boot_cmd_add(data); break; 
189D4:  MOVFF  C27,C39
189D8:  MOVFF  C26,C38
189DC:  GOTO   C1B6
189E0:  MOVFF  01,C2A
189E4:  BRA    18FDA
....................         // case 0xC02B: reserved for COM 
....................         // case 0xC02C: reserved for COM 
....................         // case 0xC02D: reserved for COM 
....................         // case 0xC02E: reserved for COM 
....................         // case 0xC02F: reserved for COM 
....................         case 0xC031: error = command_sel2_b(data); break; 
189E6:  MOVFF  C27,C39
189EA:  MOVFF  C26,C38
189EE:  GOTO   C29A
189F2:  MOVFF  01,C2A
189F6:  BRA    18FDA
....................         // case 0xC035: reserved for COM 
....................         case 0xC036: error = command_relay_data_downlink_from_flash(data); break; // From Mission FM 
189F8:  MOVFF  C27,C39
189FC:  MOVFF  C26,C38
18A00:  CALL   C2B2
18A04:  MOVFF  01,C2A
18A08:  BRA    18FDA
....................         case 0xC037: error = command_relay_data_downlink_from_flash(data); break; // From Local FM 
18A0A:  MOVFF  C27,C39
18A0E:  MOVFF  C26,C38
18A12:  CALL   C2B2
18A16:  MOVFF  01,C2A
18A1A:  BRA    18FDA
....................         case 0xC03A: error = command_adcs_raw_part_a(data); break; 
18A1C:  MOVFF  C27,C39
18A20:  MOVFF  C26,C38
18A24:  GOTO   C48A
18A28:  MOVFF  01,C2A
18A2C:  BRA    18FDA
....................         case 0xC03B: error = command_adcs_raw_part_b(data); break; 
18A2E:  MOVFF  C27,C39
18A32:  MOVFF  C26,C38
18A36:  GOTO   C4FC
18A3A:  MOVFF  01,C2A
18A3E:  BRA    18FDA
....................         case 0xC03C: error = command_adcs_raw_part_c(data); break; 
18A40:  MOVFF  C27,C39
18A44:  MOVFF  C26,C38
18A48:  GOTO   C6C2
18A4C:  MOVFF  01,C2A
18A50:  BRA    18FDA
....................         // case 0xC040: reserved for COM 
....................         // case 0xC041: reserved for COM 
....................         case 0xC042: error = command_uhf_message(data); break; 
18A52:  MOVFF  C27,C39
18A56:  MOVFF  C26,C38
18A5A:  GOTO   CA7A
18A5E:  MOVFF  01,C2A
18A62:  BRA    18FDA
....................         // case 0xC044: reserved for COM 
....................         case 0xC050: error = command_com_cw(data); break; 
18A64:  MOVFF  C27,C39
18A68:  MOVFF  C26,C38
18A6C:  GOTO   CEBC
18A70:  MOVFF  01,C2A
18A74:  BRA    18FDA
....................         case 0xC055: error = command_save_state(data); break; 
18A76:  MOVFF  C27,C39
18A7A:  MOVFF  C26,C38
18A7E:  GOTO   CFC8
18A82:  MOVFF  01,C2A
18A86:  BRA    18FDA
....................         case 0xC058: error = command_com_access_change(data); break; 
18A88:  MOVFF  C27,C39
18A8C:  MOVFF  C26,C38
18A90:  GOTO   CFEC
18A94:  MOVFF  01,C2A
18A98:  BRA    18FDA
....................         case 0xC059: error = command_com_access_request(data); break; 
18A9A:  MOVFF  C27,C39
18A9E:  MOVFF  C26,C38
18AA2:  GOTO   D034
18AA6:  MOVFF  01,C2A
18AAA:  BRA    18FDA
....................         case 0xC05E: error = command_enable_disable_sband(data); break; 
18AAC:  MOVFF  C27,C39
18AB0:  MOVFF  C26,C38
18AB4:  GOTO   D14A
18AB8:  MOVFF  01,C2A
18ABC:  BRA    18FDA
....................         case 0xC060: error = command_obc_kill_on(data); break; 
18ABE:  MOVFF  C27,C39
18AC2:  MOVFF  C26,C38
18AC6:  GOTO   D270
18ACA:  MOVFF  01,C2A
18ACE:  BRA    18FDA
....................         case 0xC061: error = command_obc_kill_off(data); break; 
18AD0:  MOVFF  C27,C39
18AD4:  MOVFF  C26,C38
18AD8:  GOTO   D316
18ADC:  MOVFF  01,C2A
18AE0:  BRA    18FDA
....................         case 0xC06C: error = command_send_data_to_eps(data); break; 
18AE2:  MOVFF  C27,C39
18AE6:  MOVFF  C26,C38
18AEA:  GOTO   D322
18AEE:  MOVFF  01,C2A
18AF2:  BRA    18FDA
....................         case 0xC06D: error = command_eps_set_heater_ref(data); break; 
18AF4:  MOVFF  C27,C39
18AF8:  MOVFF  C26,C38
18AFC:  GOTO   D3CA
18B00:  MOVFF  01,C2A
18B04:  BRA    18FDA
....................         case 0xC070: error = command_stm32_raw_8_16(data); break; 
18B06:  MOVFF  C27,C39
18B0A:  MOVFF  C26,C38
18B0E:  GOTO   D48E
18B12:  MOVFF  01,C2A
18B16:  BRA    18FDA
....................         case 0xC071: error = command_stm32_raw_uhf32(data); break; 
18B18:  MOVFF  C27,C39
18B1C:  MOVFF  C26,C38
18B20:  CALL   D550
18B24:  MOVFF  01,C2A
18B28:  BRA    18FDA
....................         case 0xC072: error = command_stm32_raw_uhf32(data); break; 
18B2A:  MOVFF  C27,C39
18B2E:  MOVFF  C26,C38
18B32:  CALL   D550
18B36:  MOVFF  01,C2A
18B3A:  BRA    18FDA
....................         case 0xC080: error = command_sel2_c(data); break; 
18B3C:  MOVFF  C27,C39
18B40:  MOVFF  C26,C38
18B44:  GOTO   D65E
18B48:  MOVFF  01,C2A
18B4C:  BRA    18FDA
....................         case 0xC081: error = command_sel2_d(data); break; 
18B4E:  MOVFF  C27,C39
18B52:  MOVFF  C26,C38
18B56:  GOTO   D7F2
18B5A:  MOVFF  01,C2A
18B5E:  BRA    18FDA
....................         case 0xC090: error = command_request_reset(data); break; 
18B60:  MOVFF  C27,C39
18B64:  MOVFF  C26,C38
18B68:  GOTO   D9FE
18B6C:  MOVFF  01,C2A
18B70:  BRA    18FDA
....................         case 0xC091: error = command_request_eps(data); break; 
18B72:  MOVFF  C27,C39
18B76:  MOVFF  C26,C38
18B7A:  GOTO   DA96
18B7E:  MOVFF  01,C2A
18B82:  BRA    18FDA
....................         case 0xC092: error = command_request_mission_control_PIC_status(data); break; 
18B84:  MOVFF  C27,C39
18B88:  MOVFF  C26,C38
18B8C:  GOTO   DB6A
18B90:  MOVFF  01,C2A
18B94:  BRA    18FDA
....................         case 0xC093: error = command_request_adcs(data); break; 
18B96:  MOVFF  C27,C39
18B9A:  MOVFF  C26,C38
18B9E:  GOTO   DC2E
18BA2:  MOVFF  01,C2A
18BA6:  BRA    18FDA
....................         case 0xC094: error = command_request_pcib(data); break; 
18BA8:  MOVFF  C27,C39
18BAC:  MOVFF  C26,C38
18BB0:  GOTO   DD96
18BB4:  MOVFF  01,C2A
18BB8:  BRA    18FDA
....................         case 0xC095: error = command_request_tmcr1(data); break; 
18BBA:  MOVFF  C27,C39
18BBE:  MOVFF  C26,C38
18BC2:  GOTO   DEBE
18BC6:  MOVFF  01,C2A
18BCA:  BRA    18FDA
....................         case 0xC096: error = command_request_tmcr2(data); break; 
18BCC:  MOVFF  C27,C39
18BD0:  MOVFF  C26,C38
18BD4:  GOTO   DFE6
18BD8:  MOVFF  01,C2A
18BDC:  BRA    18FDA
....................         case 0xC0A0: error = command_reset_telemetry(data); break; 
18BDE:  MOVFF  C27,C39
18BE2:  MOVFF  C26,C38
18BE6:  CALL   87A4
18BEA:  MOVFF  01,C2A
18BEE:  BRA    18FDA
....................         case 0xC0A1: error = command_stm32_raw_uhf32_tle(data); break; 
18BF0:  MOVFF  C27,C39
18BF4:  MOVFF  C26,C38
18BF8:  CALL   E10E
18BFC:  MOVFF  01,C2A
18C00:  BRA    18FDA
....................         case 0xC0A2: error = command_stm32_raw_uhf32_tle(data); break; 
18C02:  MOVFF  C27,C39
18C06:  MOVFF  C26,C38
18C0A:  CALL   E10E
18C0E:  MOVFF  01,C2A
18C12:  BRA    18FDA
....................         case 0xC0A6: error = command_adcs_default_mode(data); break; 
18C14:  MOVFF  C27,C39
18C18:  MOVFF  C26,C38
18C1C:  GOTO   E21E
18C20:  MOVFF  01,C2A
18C24:  BRA    18FDA
....................         case 0xC0AA: error = command_to_deploy_SAP(data); break; 
18C26:  MOVFF  C27,C39
18C2A:  MOVFF  C26,C38
18C2E:  GOTO   E2DA
18C32:  MOVFF  01,C2A
18C36:  BRA    18FDA
....................         case 0xC0AB: error = command_to_deploy_SMA(data); break; 
18C38:  MOVFF  C27,C39
18C3C:  MOVFF  C26,C38
18C40:  GOTO   E400
18C44:  MOVFF  01,C2A
18C48:  BRA    18FDA
....................         case 0xC0AC: error = command_adcs_comm_test(data); break; 
18C4A:  MOVFF  C27,C39
18C4E:  MOVFF  C26,C38
18C52:  GOTO   E52C
18C56:  MOVFF  01,C2A
18C5A:  BRA    18FDA
....................         case 0xC0AD: error = command_adcs_mode(data); break; 
18C5C:  MOVFF  C27,C39
18C60:  MOVFF  C26,C38
18C64:  GOTO   E766
18C68:  MOVFF  01,C2A
18C6C:  BRA    18FDA
....................         case 0xC0AE: error = command_ocp_state(data); break; 
18C6E:  MOVFF  C27,C39
18C72:  MOVFF  C26,C38
18C76:  GOTO   E7AC
18C7A:  MOVFF  01,C2A
18C7E:  BRA    18FDA
....................         case 0xC0AF: error = command_adcs_raw(data); break; 
18C80:  MOVFF  C27,C39
18C84:  MOVFF  C26,C38
18C88:  GOTO   E8BE
18C8C:  MOVFF  01,C2A
18C90:  BRA    18FDA
....................         case 0xC0B7: error = command_reset_all_power_lines(data); break; 
18C92:  MOVFF  C27,C39
18C96:  MOVFF  C26,C38
18C9A:  GOTO   E9E2
18C9E:  MOVFF  01,C2A
18CA2:  BRA    18FDA
....................         case 0xC0BE: error = command_enable_disable_rpi(data); break; 
18CA4:  MOVFF  C27,C39
18CA8:  MOVFF  C26,C38
18CAC:  GOTO   EA4C
18CB0:  MOVFF  01,C2A
18CB4:  BRA    18FDA
....................         case 0xC0C0: error = command_rpi_clean_up(data); break; 
18CB6:  MOVFF  C27,C39
18CBA:  MOVFF  C26,C38
18CBE:  GOTO   EB84
18CC2:  MOVFF  01,C2A
18CC6:  BRA    18FDA
....................         case 0xC0C1: error = command_rpi_clean_logfile(data); break; 
18CC8:  MOVFF  C27,C39
18CCC:  MOVFF  C26,C38
18CD0:  GOTO   ED02
18CD4:  MOVFF  01,C2A
18CD8:  BRA    18FDA
....................         case 0xC0C5: error = command_clear_state(data); break; 
18CDA:  MOVFF  C27,C39
18CDE:  MOVFF  C26,C38
18CE2:  GOTO   EE80
18CE6:  MOVFF  01,C2A
18CEA:  BRA    18FDA
....................         case 0xC0CA: error = command_camera_mission(data); break; 
18CEC:  MOVFF  C27,C39
18CF0:  MOVFF  C26,C38
18CF4:  GOTO   11192
18CF8:  MOVFF  01,C2A
18CFC:  BRA    18FDA
....................         case 0xC0CB: error = command_generic_mission(&camera, data); break; 
18CFE:  MOVLW  0A
18D00:  MOVLB  C
18D02:  MOVWF  x39
18D04:  MOVLW  DC
18D06:  MOVWF  x38
18D08:  MOVFF  C27,C3B
18D0C:  MOVFF  C26,C3A
18D10:  MOVLB  0
18D12:  GOTO   11622
18D16:  MOVFF  01,C2A
18D1A:  BRA    18FDA
....................         case 0xC0CC: error = command_raw_pcib(data); break; 
18D1C:  MOVFF  C27,C39
18D20:  MOVFF  C26,C38
18D24:  GOTO   11F3A
18D28:  MOVFF  01,C2A
18D2C:  BRA    18FDA
....................         case 0xC0CD: error = command_change_cw_mode_flags(data); break; 
18D2E:  MOVFF  C27,C39
18D32:  MOVFF  C26,C38
18D36:  GOTO   FF7C
18D3A:  MOVFF  01,C2A
18D3E:  BRA    18FDA
....................         case 0xC0CE: error = command_raw_tmcr(data); break; 
18D40:  MOVFF  C27,C39
18D44:  MOVFF  C26,C38
18D48:  CALL   12094
18D4C:  MOVFF  01,C2A
18D50:  BRA    18FDA
....................         case 0xC0CF: error = command_raw_tmcr(data); break; 
18D52:  MOVFF  C27,C39
18D56:  MOVFF  C26,C38
18D5A:  CALL   12094
18D5E:  MOVFF  01,C2A
18D62:  BRA    18FDA
....................         case 0xC0D0: error = command_xmodem_send(data); break; 
18D64:  MOVFF  C27,C39
18D68:  MOVFF  C26,C38
18D6C:  GOTO   1221A
18D70:  MOVFF  01,C2A
18D74:  BRA    18FDA
....................         case 0xC0D1: error = command_xmodem_receive(data); break; 
18D76:  MOVFF  C27,C39
18D7A:  MOVFF  C26,C38
18D7E:  GOTO   122A4
18D82:  MOVFF  01,C2A
18D86:  BRA    18FDA
....................         case 0xC0D2: error = command_iMTQ_Dipole_Actuation(data); break; 
18D88:  MOVFF  C27,C39
18D8C:  MOVFF  C26,C38
18D90:  GOTO   1232E
18D94:  MOVFF  01,C2A
18D98:  BRA    18FDA
....................         case 0xC0D3: error = command_iMTQ_No_Opeartion(data); break; 
18D9A:  MOVFF  C27,C39
18D9E:  MOVFF  C26,C38
18DA2:  GOTO   1239C
18DA6:  MOVFF  01,C2A
18DAA:  BRA    18FDA
....................         case 0xC0D4: error = command_3v3_Enable(data); break; 
18DAC:  MOVFF  C27,C39
18DB0:  MOVFF  C26,C38
18DB4:  GOTO   1240A
18DB8:  MOVFF  01,C2A
18DBC:  BRA    18FDA
....................         case 0xC0D5: error = command_RW_Motor_Enable(data); break; 
18DBE:  MOVFF  C27,C39
18DC2:  MOVFF  C26,C38
18DC6:  GOTO   12478
18DCA:  MOVFF  01,C2A
18DCE:  BRA    18FDA
....................         case 0xC0D6: error = command_RW_Enable(data); break; 
18DD0:  MOVFF  C27,C39
18DD4:  MOVFF  C26,C38
18DD8:  GOTO   124E6
18DDC:  MOVFF  01,C2A
18DE0:  BRA    18FDA
....................         case 0xC0D7: error = command_RW_Speed(data); break; 
18DE2:  MOVFF  C27,C39
18DE6:  MOVFF  C26,C38
18DEA:  GOTO   12554
18DEE:  MOVFF  01,C2A
18DF2:  BRA    18FDA
....................         case 0xC0D8: error = command_RW_Reset(data); break; 
18DF4:  MOVFF  C27,C39
18DF8:  MOVFF  C26,C38
18DFC:  GOTO   125C2
18E00:  MOVFF  01,C2A
18E04:  BRA    18FDA
....................         case 0xC0DA: error = command_deploy_antenna(data); break; 
18E06:  MOVFF  C27,C39
18E0A:  MOVFF  C26,C38
18E0E:  GOTO   12630
18E12:  MOVFF  01,C2A
18E16:  BRA    18FDA
....................         case 0xC0DB: error = command_debug(data); break; 
18E18:  MOVFF  C27,C39
18E1C:  MOVFF  C26,C38
18E20:  GOTO   FFB8
18E24:  MOVFF  01,C2A
18E28:  BRA    18FDA
....................         case 0xC0DD: error = command_dump_memory(data); break; 
18E2A:  MOVFF  C27,C39
18E2E:  MOVFF  C26,C38
18E32:  GOTO   12864
18E36:  MOVFF  01,C2A
18E3A:  BRA    18FDA
....................         case 0xC0DE: error = command_sband_defaults(data); break; 
18E3C:  MOVFF  C27,C39
18E40:  MOVFF  C26,C38
18E44:  GOTO   12AE4
18E48:  MOVFF  01,C2A
18E4C:  BRA    18FDA
....................         case 0xC0DF: error = command_get_tris(data); break; 
18E4E:  MOVFF  C27,C39
18E52:  MOVFF  C26,C38
18E56:  CALL   12C44
18E5A:  MOVFF  01,C2A
18E5E:  BRA    18FDA
....................         case 0xC0EA: error = command_copy_mission_to_com(data); break; 
18E60:  MOVFF  C27,C39
18E64:  MOVFF  C26,C38
18E68:  GOTO   12D3A
18E6C:  MOVFF  01,C2A
18E70:  BRA    18FDA
....................         case 0xC0EB: error = command_copy_opera_to_com(data); break; 
18E72:  MOVFF  C27,C39
18E76:  MOVFF  C26,C38
18E7A:  GOTO   1397C
18E7E:  MOVFF  01,C2A
18E82:  BRA    18FDA
....................         case 0xC0ED: error = command_sband_downlink(data); break; 
18E84:  MOVFF  C27,C39
18E88:  MOVFF  C26,C38
18E8C:  GOTO   13DB0
18E90:  MOVFF  01,C2A
18E94:  BRA    18FDA
....................         case 0xC0EE: error = command_sband_end_to_end(data); break; 
18E96:  MOVFF  C27,C39
18E9A:  MOVFF  C26,C38
18E9E:  GOTO   14472
18EA2:  MOVFF  01,C2A
18EA6:  BRA    18FDA
....................         case 0xC0EF: error = command_sband_test(data); break; 
18EA8:  MOVFF  C27,C39
18EAC:  MOVFF  C26,C38
18EB0:  GOTO   14C6A
18EB4:  MOVFF  01,C2A
18EB8:  BRA    18FDA
....................         case 0xC0F0: error = command_mux_sel_sfm(data); break; 
18EBA:  MOVFF  C27,C39
18EBE:  MOVFF  C26,C38
18EC2:  GOTO   14E76
18EC6:  MOVFF  01,C2A
18ECA:  BRA    18FDA
....................         case 0xC0F5: error = command_send_data_to_reset(data); break; 
18ECC:  MOVFF  C27,C39
18ED0:  MOVFF  C26,C38
18ED4:  GOTO   14ECC
18ED8:  MOVFF  01,C2A
18EDC:  BRA    18FDA
....................         case 0xC0F6: error = command_schedule_anything(data); break; 
18EDE:  MOVFF  C27,C39
18EE2:  MOVFF  C26,C38
18EE6:  GOTO   14FB6
18EEA:  MOVFF  01,C2A
18EEE:  BRA    18FDA
....................         case 0xC0F7: error = command_schedule_mode(data); break; 
18EF0:  MOVFF  C27,C39
18EF4:  MOVFF  C26,C38
18EF8:  GOTO   15002
18EFC:  MOVFF  01,C2A
18F00:  BRA    18FDA
....................         case 0xC0F8: error = command_save_telemetry(data); break; 
18F02:  MOVFF  C27,C39
18F06:  MOVFF  C26,C38
18F0A:  GOTO   165B8
18F0E:  MOVFF  01,C2A
18F12:  BRA    18FDA
....................         case 0xC0F9: error = command_clear_all_schedule_commands(data); break; 
18F14:  MOVFF  C27,C39
18F18:  MOVFF  C26,C38
18F1C:  GOTO   FFD0
18F20:  MOVFF  01,C2A
18F24:  BRA    18FDA
....................         case 0xC0FA: error = command_print_flags(data); break; 
18F26:  MOVFF  C27,C39
18F2A:  MOVFF  C26,C38
18F2E:  GOTO   FFDC
18F32:  MOVFF  01,C2A
18F36:  BRA    18FDA
....................         case 0xC0FB: error = command_opera_GA_part_a(data); break; 
18F38:  MOVFF  C27,C39
18F3C:  MOVFF  C26,C38
18F40:  GOTO   1696C
18F44:  MOVFF  01,C2A
18F48:  BRA    18FDA
....................         case 0xC0FC: error = command_opera_GA_part_b(data); break; 
18F4A:  MOVFF  C27,C39
18F4E:  MOVFF  C26,C38
18F52:  GOTO   169CC
18F56:  MOVFF  01,C2A
18F5A:  BRA    18FDA
....................         case 0xC0FD: error = command_opera_GA_single(data); break; 
18F5C:  MOVFF  C27,C39
18F60:  MOVFF  C26,C38
18F64:  GOTO   16CAC
18F68:  MOVFF  01,C2A
18F6C:  BRA    18FDA
....................         case 0xC0FE: error = command_boot_flag_set(data); break; 
18F6E:  MOVFF  C27,C39
18F72:  MOVFF  C26,C38
18F76:  GOTO   16F70
18F7A:  MOVFF  01,C2A
18F7E:  BRA    18FDA
....................         case 0xC0FF: error = command_opera_full(data); break; 
18F80:  MOVFF  C27,C39
18F84:  MOVFF  C26,C38
18F88:  GOTO   16FA0
18F8C:  MOVFF  01,C2A
18F90:  BRA    18FDA
....................         case 0xCB00: error = command_mission_control_PIC_status(data); break; 
18F92:  MOVFF  C27,C39
18F96:  MOVFF  C26,C38
18F9A:  GOTO   170C8
18F9E:  MOVFF  01,C2A
18FA2:  BRA    18FDA
....................         case 0xDBFF: error = command_reset_log(data); break; 
18FA4:  MOVFF  C27,C39
18FA8:  MOVFF  C26,C38
18FAC:  GOTO   FFE8
18FB0:  MOVFF  01,C2A
18FB4:  BRA    18FDA
....................         case 0xE033: error = command_eps_telemetry(data); break; 
18FB6:  MOVFF  C27,C39
18FBA:  MOVFF  C26,C38
18FBE:  GOTO   1768C
18FC2:  MOVFF  01,C2A
18FC6:  BRA    18FDA
....................  
....................         default: error = command_get_tris(data); break; 
18FC8:  MOVFF  C27,C39
18FCC:  MOVFF  C26,C38
18FD0:  MOVLB  0
18FD2:  CALL   12C44
18FD6:  MOVFF  01,C2A
....................         } 
....................  
....................         if (log_enabled) { 
18FDA:  MOVLB  C
18FDC:  MOVF   x29,F
18FDE:  BZ    1905E
....................             fprintf(PC, " (%s R:%02X)", mux_str_list[mux_cpld_position], error); 
18FE0:  CLRF   03
18FE2:  MOVLB  7
18FE4:  MOVFF  74F,02
18FE8:  BCF    FD8.0
18FEA:  RLCF   02,F
18FEC:  RLCF   03,F
18FEE:  MOVF   02,W
18FF0:  ADDLW  1F
18FF2:  MOVWF  FE9
18FF4:  MOVLW  07
18FF6:  ADDWFC 03,W
18FF8:  MOVWF  FEA
18FFA:  MOVFF  FEC,C39
18FFE:  MOVF   FED,F
19000:  MOVFF  FEF,C38
19004:  MOVLW  20
19006:  MOVLB  D
19008:  MOVWF  x6A
1900A:  MOVLB  0
1900C:  CALL   44EE
19010:  MOVLW  28
19012:  MOVLB  D
19014:  MOVWF  x6A
19016:  MOVLB  0
19018:  CALL   44EE
1901C:  MOVFF  C39,FEA
19020:  MOVFF  C38,FE9
19024:  CALL   52C2
19028:  MOVLW  E6
1902A:  MOVWF  FF6
1902C:  MOVLW  20
1902E:  MOVWF  FF7
19030:  MOVLW  00
19032:  MOVWF  FF8
19034:  MOVLW  03
19036:  MOVLB  C
19038:  MOVWF  xC1
1903A:  MOVLB  0
1903C:  CALL   5290
19040:  MOVFF  C2A,CBF
19044:  MOVLW  37
19046:  MOVLB  C
19048:  MOVWF  xC0
1904A:  MOVLB  0
1904C:  CALL   5A92
19050:  MOVLW  29
19052:  MOVLB  D
19054:  MOVWF  x6A
19056:  MOVLB  0
19058:  CALL   44EE
1905C:  MOVLB  C
....................         } 
....................  
....................         // Satellite log 
....................         log.time = current_time; 
1905E:  MOVFF  3E,C30
19062:  MOVFF  3D,C2F
19066:  MOVFF  3C,C2E
1906A:  MOVFF  3B,C2D
....................         log.return_value = error; 
1906E:  MOVFF  C2A,C33
....................  
....................         if ( 
....................             log_enabled 
....................             && command != 0x1CAA  // TMCR1 PIC 
....................             && command != 0x1DAA  // TMCR2 PIC 
....................             && command != 0xABAA  // RELAY PIC 
....................             && command != 0xB0A0  // Reset PIC 
....................             && command != 0xE033  // EPS PIC 
....................             && command != 0xCB00  // Mission control pic 
....................             && command != 0xAD90  // ADCS PIC 
....................             && command != 0xC050  // COM PIC 
....................             && command != 0xC0F8) // Telemetry record 
19072:  MOVF   x29,F
19074:  BZ    19104
19076:  MOVF   x36,W
19078:  SUBLW  AA
1907A:  BNZ   19082
1907C:  MOVF   x37,W
1907E:  SUBLW  1C
19080:  BZ    19104
19082:  MOVF   x36,W
19084:  SUBLW  AA
19086:  BNZ   1908E
19088:  MOVF   x37,W
1908A:  SUBLW  1D
1908C:  BZ    19104
1908E:  MOVF   x36,W
19090:  SUBLW  AA
19092:  BNZ   1909A
19094:  MOVF   x37,W
19096:  SUBLW  AB
19098:  BZ    19104
1909A:  MOVF   x36,W
1909C:  SUBLW  A0
1909E:  BNZ   190A6
190A0:  MOVF   x37,W
190A2:  SUBLW  B0
190A4:  BZ    19104
190A6:  MOVF   x36,W
190A8:  SUBLW  33
190AA:  BNZ   190B2
190AC:  MOVF   x37,W
190AE:  SUBLW  E0
190B0:  BZ    19104
190B2:  MOVF   x36,F
190B4:  BNZ   190BC
190B6:  MOVF   x37,W
190B8:  SUBLW  CB
190BA:  BZ    19104
190BC:  MOVF   x36,W
190BE:  SUBLW  90
190C0:  BNZ   190C8
190C2:  MOVF   x37,W
190C4:  SUBLW  AD
190C6:  BZ    19104
190C8:  MOVF   x36,W
190CA:  SUBLW  50
190CC:  BNZ   190D4
190CE:  MOVF   x37,W
190D0:  SUBLW  C0
190D2:  BZ    19104
190D4:  MOVF   x36,W
190D6:  SUBLW  F8
190D8:  BNZ   190E0
190DA:  MOVF   x37,W
190DC:  SUBLW  C0
190DE:  BZ    19104
....................             log_add(log); 
190E0:  MOVFF  C2D,C38
190E4:  MOVFF  C2E,C39
190E8:  MOVFF  C2F,C3A
190EC:  MOVFF  C30,C3B
190F0:  MOVFF  C31,C3C
190F4:  MOVFF  C32,C3D
190F8:  MOVFF  C33,C3E
190FC:  MOVLB  0
190FE:  GOTO   17BDA
19102:  MOVLB  C
....................  
....................         if (log_enabled) 
19104:  MOVF   x29,F
19106:  BZ    19122
....................             fprintf(PC, "\r\n"); 
19108:  MOVLW  0D
1910A:  MOVLB  D
1910C:  MOVWF  x6A
1910E:  MOVLB  0
19110:  CALL   44EE
19114:  MOVLW  0A
19116:  MOVLB  D
19118:  MOVWF  x6A
1911A:  MOVLB  0
1911C:  CALL   44EE
19120:  MOVLB  C
....................     } 
19122:  MOVLB  0
19124:  RETURN 0
.................... } 
....................  
.................... #endif /* INTERPRETER_H */ 
....................  
....................  
.................... void initialize_memory() 
*
0686A:  MOVLB  B
0686C:  CLRF   xE5
0686E:  SETF   xE4
06870:  MOVFF  BE5,BCF
06874:  MOVFF  BE4,BCE
06878:  MOVLW  01
0687A:  CLRF   xE6
0687C:  MOVWF  xD1
0687E:  MOVFF  BE6,BD0
.................... { 
....................     uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
....................  
....................     // Initialize flags 
....................     boot_flags.deployment_flag = 0; 
06882:  MOVLB  0
06884:  CLRF   xFF
....................     flash_initialize_flash_ctrl(FLASH_ADDR_START, FLASH_ADDR_END, FLASH_ADDR_START, FLASH_ADDR_DELTA, &addr_flags.flash_addr); 
06886:  MOVLB  C
06888:  CLRF   x6F
0688A:  CLRF   x6E
0688C:  MOVLW  20
0688E:  MOVWF  x6D
06890:  CLRF   x6C
06892:  CLRF   x73
06894:  CLRF   x72
06896:  MOVLW  30
06898:  MOVWF  x71
0689A:  CLRF   x70
0689C:  CLRF   x77
0689E:  CLRF   x76
068A0:  MOVLW  20
068A2:  MOVWF  x75
068A4:  CLRF   x74
068A6:  CLRF   x7B
068A8:  CLRF   x7A
068AA:  CLRF   x79
068AC:  MOVLW  10
068AE:  MOVWF  x78
068B0:  MOVLW  01
068B2:  MOVWF  x7D
068B4:  MOVLW  17
068B6:  MOVWF  x7C
068B8:  MOVLB  0
068BA:  CALL   58E6
....................     flash_initialize_flash_ctrl(FLASH_LOG_START, FLASH_LOG_END, FLASH_LOG_START, FLASH_LOG_DELTA, &addr_flags.flash_log); 
068BE:  MOVLB  C
068C0:  CLRF   x6F
068C2:  MOVLW  01
068C4:  MOVWF  x6E
068C6:  CLRF   x6D
068C8:  CLRF   x6C
068CA:  CLRF   x73
068CC:  MOVLW  11
068CE:  MOVWF  x72
068D0:  CLRF   x71
068D2:  CLRF   x70
068D4:  CLRF   x77
068D6:  MOVLW  01
068D8:  MOVWF  x76
068DA:  CLRF   x75
068DC:  CLRF   x74
068DE:  CLRF   x7B
068E0:  CLRF   x7A
068E2:  CLRF   x79
068E4:  MOVLW  07
068E6:  MOVWF  x78
068E8:  MOVLW  01
068EA:  MOVWF  x7D
068EC:  MOVLW  24
068EE:  MOVWF  x7C
068F0:  MOVLB  0
068F2:  CALL   58E6
....................     flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, 0xFFFFFFFF, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, false, &addr_flags.flash_telemetry); 
068F6:  MOVLW  02
068F8:  MOVLB  C
068FA:  MOVWF  x4F
068FC:  MOVFF  FF,C50
06900:  SETF   x54
06902:  SETF   x53
06904:  SETF   x52
06906:  SETF   x51
06908:  CLRF   x58
0690A:  MOVLW  11
0690C:  MOVWF  x57
0690E:  CLRF   x56
06910:  CLRF   x55
06912:  CLRF   x5C
06914:  CLRF   x5B
06916:  CLRF   x5A
06918:  MOVLW  98
0691A:  MOVWF  x59
0691C:  CLRF   x5D
0691E:  MOVLW  01
06920:  MOVWF  x5F
06922:  MOVLW  31
06924:  MOVWF  x5E
06926:  MOVLB  0
06928:  CALL   5B62
....................     flash_initialize_flash_ctrl(FLASH_SEL_ZES_START, FLASH_SEL_ZES_END, FLASH_SEL_ZES_START, FLASH_SEL_ZES_DELTA, &addr_flags.flash_sel_zes); 
0692C:  MOVLW  03
0692E:  MOVLB  C
06930:  MOVWF  x6F
06932:  MOVLW  ED
06934:  MOVWF  x6E
06936:  CLRF   x6D
06938:  CLRF   x6C
0693A:  MOVLW  04
0693C:  MOVWF  x73
0693E:  MOVLW  6D
06940:  MOVWF  x72
06942:  CLRF   x71
06944:  CLRF   x70
06946:  MOVLW  03
06948:  MOVWF  x77
0694A:  MOVLW  ED
0694C:  MOVWF  x76
0694E:  CLRF   x75
06950:  CLRF   x74
06952:  CLRF   x7B
06954:  CLRF   x7A
06956:  CLRF   x79
06958:  MOVLW  80
0695A:  MOVWF  x78
0695C:  MOVLW  01
0695E:  MOVWF  x7D
06960:  MOVLW  3E
06962:  MOVWF  x7C
06964:  MOVLB  0
06966:  CALL   58E6
....................     flash_initialize_flash_ctrl(FLASH_SEL_REF_START, FLASH_SEL_REF_END, FLASH_SEL_REF_START, FLASH_SEL_REF_DELTA, &addr_flags.flash_sel_ref); 
0696A:  MOVLW  04
0696C:  MOVLB  C
0696E:  MOVWF  x6F
06970:  MOVLW  6D
06972:  MOVWF  x6E
06974:  CLRF   x6D
06976:  CLRF   x6C
06978:  MOVLW  04
0697A:  MOVWF  x73
0697C:  MOVLW  ED
0697E:  MOVWF  x72
06980:  CLRF   x71
06982:  CLRF   x70
06984:  MOVLW  04
06986:  MOVWF  x77
06988:  MOVLW  6D
0698A:  MOVWF  x76
0698C:  CLRF   x75
0698E:  CLRF   x74
06990:  CLRF   x7B
06992:  CLRF   x7A
06994:  CLRF   x79
06996:  MOVLW  80
06998:  MOVWF  x78
0699A:  MOVLW  01
0699C:  MOVWF  x7D
0699E:  MOVLW  4B
069A0:  MOVWF  x7C
069A2:  MOVLB  0
069A4:  CALL   58E6
....................  
....................     // Save boot flags 
....................     flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
069A8:  MOVLW  0A
069AA:  MOVLB  C
069AC:  MOVWF  x67
069AE:  MOVLW  A3
069B0:  MOVWF  x66
069B2:  CLRF   x6B
069B4:  CLRF   x6A
069B6:  CLRF   x69
069B8:  CLRF   x68
069BA:  CLRF   x6F
069BC:  CLRF   x6E
069BE:  CLRF   x6D
069C0:  MOVLW  01
069C2:  MOVWF  x6C
069C4:  MOVLB  0
069C6:  RCALL  6292
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
069C8:  MOVLW  0A
069CA:  MOVLB  D
069CC:  MOVWF  x47
069CE:  MOVLW  A3
069D0:  MOVWF  x46
069D2:  CLRF   x4B
069D4:  CLRF   x4A
069D6:  CLRF   x49
069D8:  CLRF   x48
069DA:  MOVFF  BCF,D4D
069DE:  MOVFF  BCE,D4C
069E2:  CLRF   x51
069E4:  CLRF   x50
069E6:  CLRF   x4F
069E8:  MOVLW  01
069EA:  MOVWF  x4E
069EC:  MOVLB  0
069EE:  RCALL  653E
....................  
....................     // Save OBC flags 
....................     flash_erase_pages(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, OBC_FLAGS_ADDRESS + sizeof(obc_flags)); 
069F0:  MOVLW  0A
069F2:  MOVLB  C
069F4:  MOVWF  x67
069F6:  MOVLW  A3
069F8:  MOVWF  x66
069FA:  CLRF   x6B
069FC:  CLRF   x6A
069FE:  MOVLW  10
06A00:  MOVWF  x69
06A02:  CLRF   x68
06A04:  CLRF   x6F
06A06:  CLRF   x6E
06A08:  MOVWF  x6D
06A0A:  MOVLW  17
06A0C:  MOVWF  x6C
06A0E:  MOVLB  0
06A10:  RCALL  6292
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, obc_flag_ptr, sizeof(obc_flags)); 
06A12:  MOVLW  0A
06A14:  MOVLB  D
06A16:  MOVWF  x47
06A18:  MOVLW  A3
06A1A:  MOVWF  x46
06A1C:  CLRF   x4B
06A1E:  CLRF   x4A
06A20:  MOVLW  10
06A22:  MOVWF  x49
06A24:  CLRF   x48
06A26:  MOVFF  BD1,D4D
06A2A:  MOVFF  BD0,D4C
06A2E:  CLRF   x51
06A30:  CLRF   x50
06A32:  CLRF   x4F
06A34:  MOVLW  17
06A36:  MOVWF  x4E
06A38:  MOVLB  0
06A3A:  RCALL  653E
....................  
....................     // Initialize boot commands 
....................     boot_commands_clear_all(); 
06A3C:  RCALL  65E6
....................     boot_commands_write(); 
06A3E:  RCALL  6602
....................  
....................     // Save addresses 
....................     address_rotation addr; 
....................  
....................     uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
06A40:  MOVLW  0B
06A42:  MOVLB  B
06A44:  MOVWF  xE5
06A46:  MOVLW  D2
06A48:  MOVFF  BE5,BE3
06A4C:  MOVWF  xE2
....................     addr.flash_log_current = addr_flags.flash_log.current; 
06A4E:  MOVFF  12F,BD5
06A52:  MOVFF  12E,BD4
06A56:  MOVFF  12D,BD3
06A5A:  MOVFF  12C,BD2
....................     addr.flash_telemetry_current = addr_flags.flash_telemetry.current; 
06A5E:  MOVFF  13C,BD9
06A62:  MOVFF  13B,BD8
06A66:  MOVFF  13A,BD7
06A6A:  MOVFF  139,BD6
....................     addr.flash_sel_zes_current = addr_flags.flash_sel_zes.current; 
06A6E:  MOVFF  149,BDD
06A72:  MOVFF  148,BDC
06A76:  MOVFF  147,BDB
06A7A:  MOVFF  146,BDA
....................     addr.flash_sel_ref_current = addr_flags.flash_sel_ref.current; 
06A7E:  MOVFF  156,BE1
06A82:  MOVFF  155,BE0
06A86:  MOVFF  154,BDF
06A8A:  MOVFF  153,BDE
....................  
....................     flash_erase_pages(&spi_port_COM_FM, ADDR_FLAGS_ADDRESS, ADDR_FLAGS_ADDRESS + sizeof(addr)); 
06A8E:  MOVLW  0A
06A90:  MOVLB  C
06A92:  MOVWF  x67
06A94:  MOVLW  A3
06A96:  MOVWF  x66
06A98:  CLRF   x6B
06A9A:  CLRF   x6A
06A9C:  MOVLW  20
06A9E:  MOVWF  x69
06AA0:  CLRF   x68
06AA2:  CLRF   x6F
06AA4:  CLRF   x6E
06AA6:  MOVWF  x6D
06AA8:  MOVLW  10
06AAA:  MOVWF  x6C
06AAC:  MOVLB  0
06AAE:  CALL   6292
....................     flash_cycle_write(&spi_port_COM_FM, addr_flag_ptr, &addr_flags.flash_addr); 
06AB2:  MOVLW  0A
06AB4:  MOVLB  C
06AB6:  MOVWF  xBF
06AB8:  MOVLW  A3
06ABA:  MOVWF  xBE
06ABC:  MOVFF  BE3,CC1
06AC0:  MOVFF  BE2,CC0
06AC4:  MOVLW  01
06AC6:  MOVWF  xC3
06AC8:  MOVLW  17
06ACA:  MOVWF  xC2
06ACC:  MOVLB  0
06ACE:  RCALL  6658
06AD0:  GOTO   7382 (RETURN)
....................     // [!] Addresses are also saved in interpreter.h in command_save_telemetry 
.................... } 
....................  
.................... void retrieve_memory() 
*
06DBE:  MOVLW  01
06DC0:  MOVLB  B
06DC2:  CLRF   xE6
06DC4:  MOVWF  xCF
06DC6:  MOVFF  BE6,BCE
.................... { 
....................     // Load OBC flags 
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
....................     flash_transfer_data_to_ram( 
....................         &spi_port_COM_FM, 
....................         OBC_FLAGS_ADDRESS, 
....................         obc_flag_ptr, 
....................         sizeof(obc_flags)); 
06DCA:  MOVLW  0A
06DCC:  MOVLB  D
06DCE:  MOVWF  x4C
06DD0:  MOVLW  A3
06DD2:  MOVWF  x4B
06DD4:  CLRF   x50
06DD6:  CLRF   x4F
06DD8:  MOVLW  10
06DDA:  MOVWF  x4E
06DDC:  CLRF   x4D
06DDE:  MOVFF  BCF,D52
06DE2:  MOVFF  BCE,D51
06DE6:  CLRF   x56
06DE8:  CLRF   x55
06DEA:  CLRF   x54
06DEC:  MOVLW  17
06DEE:  MOVWF  x53
06DF0:  MOVLB  0
06DF2:  CALL   57C8
....................  
....................     // Load addresses of addresses 
....................     flash_initialize_flash_ctrl(FLASH_ADDR_START, FLASH_ADDR_END, FLASH_ADDR_START, FLASH_ADDR_DELTA, &addr_flags.flash_addr); 
06DF6:  MOVLB  C
06DF8:  CLRF   x6F
06DFA:  CLRF   x6E
06DFC:  MOVLW  20
06DFE:  MOVWF  x6D
06E00:  CLRF   x6C
06E02:  CLRF   x73
06E04:  CLRF   x72
06E06:  MOVLW  30
06E08:  MOVWF  x71
06E0A:  CLRF   x70
06E0C:  CLRF   x77
06E0E:  CLRF   x76
06E10:  MOVLW  20
06E12:  MOVWF  x75
06E14:  CLRF   x74
06E16:  CLRF   x7B
06E18:  CLRF   x7A
06E1A:  CLRF   x79
06E1C:  MOVLW  10
06E1E:  MOVWF  x78
06E20:  MOVLW  01
06E22:  MOVWF  x7D
06E24:  MOVLW  17
06E26:  MOVWF  x7C
06E28:  MOVLB  0
06E2A:  CALL   58E6
....................     flash_recover_last_addr(&spi_port_COM_FM, &addr_flags.flash_addr); 
06E2E:  MOVLW  0A
06E30:  MOVLB  B
06E32:  MOVWF  xE7
06E34:  MOVLW  A3
06E36:  MOVWF  xE6
06E38:  MOVLW  01
06E3A:  MOVWF  xE9
06E3C:  MOVLW  17
06E3E:  MOVWF  xE8
06E40:  MOVLB  0
06E42:  BRA    6AD4
....................     unsigned long long address_address; 
....................     if (addr_flags.flash_addr.current >= addr_flags.flash_addr.start + addr_flags.flash_addr.delta) { 
06E44:  MOVLB  1
06E46:  MOVF   x23,W
06E48:  ADDWF  x17,W
06E4A:  MOVWF  00
06E4C:  MOVLW  00
06E4E:  ADDWFC x18,W
06E50:  MOVWF  01
06E52:  MOVLW  00
06E54:  ADDWFC x19,W
06E56:  MOVWF  02
06E58:  MOVLW  00
06E5A:  ADDWFC x1A,W
06E5C:  MOVWF  03
06E5E:  SUBWF  x22,W
06E60:  BNC   6EA4
06E62:  BNZ   6E7A
06E64:  MOVF   02,W
06E66:  SUBWF  x21,W
06E68:  BNC   6EA4
06E6A:  BNZ   6E7A
06E6C:  MOVF   01,W
06E6E:  SUBWF  x20,W
06E70:  BNC   6EA4
06E72:  BNZ   6E7A
06E74:  MOVF   00,W
06E76:  SUBWF  x1F,W
06E78:  BNC   6EA4
....................         address_address = addr_flags.flash_addr.current - addr_flags.flash_addr.delta; 
06E7A:  MOVF   x23,W
06E7C:  SUBWF  x1F,W
06E7E:  MOVLB  B
06E80:  MOVWF  xD0
06E82:  MOVLW  00
06E84:  MOVLB  1
06E86:  SUBWFB x20,W
06E88:  MOVLB  B
06E8A:  MOVWF  xD1
06E8C:  MOVLW  00
06E8E:  MOVLB  1
06E90:  SUBWFB x21,W
06E92:  MOVLB  B
06E94:  MOVWF  xD2
06E96:  MOVLW  00
06E98:  MOVLB  1
06E9A:  SUBWFB x22,W
06E9C:  MOVLB  B
06E9E:  MOVWF  xD3
....................     } else { 
06EA0:  BRA    6ECA
06EA2:  MOVLB  1
....................         address_address = addr_flags.flash_addr.end - addr_flags.flash_addr.delta; 
06EA4:  MOVF   x23,W
06EA6:  SUBWF  x1B,W
06EA8:  MOVLB  B
06EAA:  MOVWF  xD0
06EAC:  MOVLW  00
06EAE:  MOVLB  1
06EB0:  SUBWFB x1C,W
06EB2:  MOVLB  B
06EB4:  MOVWF  xD1
06EB6:  MOVLW  00
06EB8:  MOVLB  1
06EBA:  SUBWFB x1D,W
06EBC:  MOVLB  B
06EBE:  MOVWF  xD2
06EC0:  MOVLW  00
06EC2:  MOVLB  1
06EC4:  SUBWFB x1E,W
06EC6:  MOVLB  B
06EC8:  MOVWF  xD3
....................     } 
....................  
....................     // Load addresses 
....................     address_rotation addr; 
....................  
....................     uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
06ECA:  MOVLW  0B
06ECC:  MOVWF  xE7
06ECE:  MOVLW  D4
06ED0:  MOVFF  BE7,BE5
06ED4:  MOVWF  xE4
....................     flash_transfer_data_to_ram( 
....................         &spi_port_COM_FM, 
....................         address_address, 
....................         addr_flag_ptr, 
....................         sizeof(addr)); 
06ED6:  MOVLW  0A
06ED8:  MOVLB  D
06EDA:  MOVWF  x4C
06EDC:  MOVLW  A3
06EDE:  MOVWF  x4B
06EE0:  MOVFF  BD3,D50
06EE4:  MOVFF  BD2,D4F
06EE8:  MOVFF  BD1,D4E
06EEC:  MOVFF  BD0,D4D
06EF0:  MOVFF  BE5,D52
06EF4:  MOVFF  BE4,D51
06EF8:  CLRF   x56
06EFA:  CLRF   x55
06EFC:  CLRF   x54
06EFE:  MOVLW  10
06F00:  MOVWF  x53
06F02:  MOVLB  0
06F04:  CALL   57C8
....................     flash_initialize_flash_ctrl(FLASH_LOG_START, FLASH_LOG_END, addr.flash_log_current, FLASH_LOG_DELTA, &addr_flags.flash_log); 
06F08:  MOVLB  C
06F0A:  CLRF   x6F
06F0C:  MOVLW  01
06F0E:  MOVWF  x6E
06F10:  CLRF   x6D
06F12:  CLRF   x6C
06F14:  CLRF   x73
06F16:  MOVLW  11
06F18:  MOVWF  x72
06F1A:  CLRF   x71
06F1C:  CLRF   x70
06F1E:  MOVFF  BD7,C77
06F22:  MOVFF  BD6,C76
06F26:  MOVFF  BD5,C75
06F2A:  MOVFF  BD4,C74
06F2E:  CLRF   x7B
06F30:  CLRF   x7A
06F32:  CLRF   x79
06F34:  MOVLW  07
06F36:  MOVWF  x78
06F38:  MOVLW  01
06F3A:  MOVWF  x7D
06F3C:  MOVLW  24
06F3E:  MOVWF  x7C
06F40:  MOVLB  0
06F42:  CALL   58E6
....................     flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr.flash_telemetry_current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, false, &addr_flags.flash_telemetry); 
06F46:  MOVLW  02
06F48:  MOVLB  C
06F4A:  MOVWF  x4F
06F4C:  MOVFF  FF,C50
06F50:  MOVFF  BDB,C54
06F54:  MOVFF  BDA,C53
06F58:  MOVFF  BD9,C52
06F5C:  MOVFF  BD8,C51
06F60:  CLRF   x58
06F62:  MOVLW  11
06F64:  MOVWF  x57
06F66:  CLRF   x56
06F68:  CLRF   x55
06F6A:  CLRF   x5C
06F6C:  CLRF   x5B
06F6E:  CLRF   x5A
06F70:  MOVLW  98
06F72:  MOVWF  x59
06F74:  CLRF   x5D
06F76:  MOVLW  01
06F78:  MOVWF  x5F
06F7A:  MOVLW  31
06F7C:  MOVWF  x5E
06F7E:  MOVLB  0
06F80:  CALL   5B62
....................     flash_initialize_flash_ctrl(FLASH_SEL_ZES_START, FLASH_SEL_ZES_END, addr.flash_sel_zes_current, FLASH_SEL_ZES_DELTA, &addr_flags.flash_sel_zes); 
06F84:  MOVLW  03
06F86:  MOVLB  C
06F88:  MOVWF  x6F
06F8A:  MOVLW  ED
06F8C:  MOVWF  x6E
06F8E:  CLRF   x6D
06F90:  CLRF   x6C
06F92:  MOVLW  04
06F94:  MOVWF  x73
06F96:  MOVLW  6D
06F98:  MOVWF  x72
06F9A:  CLRF   x71
06F9C:  CLRF   x70
06F9E:  MOVFF  BDF,C77
06FA2:  MOVFF  BDE,C76
06FA6:  MOVFF  BDD,C75
06FAA:  MOVFF  BDC,C74
06FAE:  CLRF   x7B
06FB0:  CLRF   x7A
06FB2:  CLRF   x79
06FB4:  MOVLW  80
06FB6:  MOVWF  x78
06FB8:  MOVLW  01
06FBA:  MOVWF  x7D
06FBC:  MOVLW  3E
06FBE:  MOVWF  x7C
06FC0:  MOVLB  0
06FC2:  CALL   58E6
....................     flash_initialize_flash_ctrl(FLASH_SEL_REF_START, FLASH_SEL_REF_END, addr.flash_sel_ref_current, FLASH_SEL_REF_DELTA, &addr_flags.flash_sel_ref); 
06FC6:  MOVLW  04
06FC8:  MOVLB  C
06FCA:  MOVWF  x6F
06FCC:  MOVLW  6D
06FCE:  MOVWF  x6E
06FD0:  CLRF   x6D
06FD2:  CLRF   x6C
06FD4:  MOVLW  04
06FD6:  MOVWF  x73
06FD8:  MOVLW  ED
06FDA:  MOVWF  x72
06FDC:  CLRF   x71
06FDE:  CLRF   x70
06FE0:  MOVFF  BE3,C77
06FE4:  MOVFF  BE2,C76
06FE8:  MOVFF  BE1,C75
06FEC:  MOVFF  BE0,C74
06FF0:  CLRF   x7B
06FF2:  CLRF   x7A
06FF4:  CLRF   x79
06FF6:  MOVLW  80
06FF8:  MOVWF  x78
06FFA:  MOVLW  01
06FFC:  MOVWF  x7D
06FFE:  MOVLW  4B
07000:  MOVWF  x7C
07002:  MOVLB  0
07004:  CALL   58E6
....................     boot_commands_read(); 
07008:  BRA    6D82
0700A:  GOTO   7396 (RETURN)
.................... } 
....................  
.................... void initial_deployment_setup() 
*
07124:  MOVLW  01
07126:  MOVLB  B
07128:  MOVWF  xD5
0712A:  MOVLW  5A
0712C:  MOVFF  BD5,BCF
07130:  MOVWF  xCE
.................... { 
....................     uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
....................     // Antenna deployment schedule 
....................     scheduler_initialize(); 
07132:  MOVLB  0
07134:  RCALL  700E
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, cmd_ptr, sizeof(scheduled_commands)); 
07136:  MOVLW  0A
07138:  MOVLB  D
0713A:  MOVWF  x47
0713C:  MOVLW  A3
0713E:  MOVWF  x46
07140:  CLRF   x4B
07142:  CLRF   x4A
07144:  MOVLW  30
07146:  MOVWF  x49
07148:  CLRF   x48
0714A:  MOVFF  BCF,D4D
0714E:  MOVFF  BCE,D4C
07152:  CLRF   x51
07154:  CLRF   x50
07156:  MOVLW  04
07158:  MOVWF  x4F
0715A:  CLRF   x4E
0715C:  MOVLB  0
0715E:  CALL   653E
....................     current_time = T0 + (time_t)boot_flags.deployment_flag * 24L * 60L * 60L; // Set clock to as early as possible (Jan 1st 2000, 00:00:00), increasing every day by the deployment flag; 
07162:  MOVLB  B
07164:  CLRF   xD7
07166:  CLRF   xD6
07168:  CLRF   xD5
0716A:  MOVFF  FF,BD4
0716E:  MOVFF  BD7,CB4
07172:  MOVFF  BD6,CB3
07176:  MOVFF  BD5,CB2
0717A:  MOVFF  FF,CB1
0717E:  MOVLB  C
07180:  CLRF   xB8
07182:  CLRF   xB7
07184:  CLRF   xB6
07186:  MOVLW  18
07188:  MOVWF  xB5
0718A:  MOVLB  0
0718C:  CALL   456E
07190:  MOVFF  03,BD7
07194:  MOVFF  02,BD6
07198:  MOVFF  01,BD5
0719C:  MOVFF  00,BD4
071A0:  MOVFF  03,CB4
071A4:  MOVFF  02,CB3
071A8:  MOVFF  01,CB2
071AC:  MOVFF  00,CB1
071B0:  MOVLB  C
071B2:  CLRF   xB8
071B4:  CLRF   xB7
071B6:  CLRF   xB6
071B8:  MOVLW  3C
071BA:  MOVWF  xB5
071BC:  MOVLB  0
071BE:  CALL   456E
071C2:  MOVFF  03,BD7
071C6:  MOVFF  02,BD6
071CA:  MOVFF  01,BD5
071CE:  MOVFF  00,BD4
071D2:  MOVFF  03,CB4
071D6:  MOVFF  02,CB3
071DA:  MOVFF  01,CB2
071DE:  MOVFF  00,CB1
071E2:  MOVLB  C
071E4:  CLRF   xB8
071E6:  CLRF   xB7
071E8:  CLRF   xB6
071EA:  MOVLW  3C
071EC:  MOVWF  xB5
071EE:  MOVLB  0
071F0:  CALL   456E
071F4:  MOVLW  80
071F6:  ADDWF  00,W
071F8:  MOVWF  3B
071FA:  MOVLW  43
071FC:  ADDWFC 01,W
071FE:  MOVWF  3C
07200:  MOVLW  6D
07202:  ADDWFC 02,W
07204:  MOVWF  3D
07206:  MOVLW  38
07208:  ADDWFC 03,W
0720A:  MOVWF  3E
....................     SetTimeSec(current_time); 
0720C:  MOVFF  3E,C52
07210:  MOVFF  3D,C51
07214:  MOVFF  3C,C50
07218:  MOVFF  3B,C4F
0721C:  CALL   5140
....................     previous_time = current_time; 
07220:  MOVFF  3E,42
07224:  MOVFF  3D,41
07228:  MOVFF  3C,40
0722C:  MOVFF  3B,3F
....................  
....................     struct antenna_deployment_command { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t duration; 
....................     } cmd; 
....................  
....................     uint8_t factor = boot_flags.deployment_flag > 3 ? 3 : boot_flags.deployment_flag; 
07230:  MOVF   xFF,W
07232:  SUBLW  03
07234:  BC    723A
07236:  MOVLW  03
07238:  BRA    723C
0723A:  MOVF   xFF,W
0723C:  MOVLB  B
0723E:  MOVWF  xD3
....................  
....................     cmd.origin = MSG_COMM; 
07240:  MOVLW  C0
07242:  MOVWF  xD0
....................     cmd.command = 0xDA; 
07244:  MOVLW  DA
07246:  MOVWF  xD1
....................     cmd.duration = 30 + 10 * factor; 
07248:  MOVF   xD3,W
0724A:  MULLW  0A
0724C:  MOVF   FF3,W
0724E:  ADDLW  1E
07250:  MOVWF  xD2
....................  
....................     vschedule(T_ANTENNA + (time_t)boot_flags.deployment_flag * 24L * 60L * 60L, (uint8_t*)&cmd); // Antenna deploy command (Jan 1st 2000, 00:30:30), 30s. 
07252:  CLRF   xD7
07254:  CLRF   xD6
07256:  CLRF   xD5
07258:  MOVFF  FF,BD4
0725C:  MOVFF  BD7,CB4
07260:  MOVFF  BD6,CB3
07264:  MOVFF  BD5,CB2
07268:  MOVFF  FF,CB1
0726C:  MOVLB  C
0726E:  CLRF   xB8
07270:  CLRF   xB7
07272:  CLRF   xB6
07274:  MOVLW  18
07276:  MOVWF  xB5
07278:  MOVLB  0
0727A:  CALL   456E
0727E:  MOVFF  03,BD7
07282:  MOVFF  02,BD6
07286:  MOVFF  01,BD5
0728A:  MOVFF  00,BD4
0728E:  MOVFF  03,CB4
07292:  MOVFF  02,CB3
07296:  MOVFF  01,CB2
0729A:  MOVFF  00,CB1
0729E:  MOVLB  C
072A0:  CLRF   xB8
072A2:  CLRF   xB7
072A4:  CLRF   xB6
072A6:  MOVLW  3C
072A8:  MOVWF  xB5
072AA:  MOVLB  0
072AC:  CALL   456E
072B0:  MOVFF  03,BD7
072B4:  MOVFF  02,BD6
072B8:  MOVFF  01,BD5
072BC:  MOVFF  00,BD4
072C0:  MOVFF  03,CB4
072C4:  MOVFF  02,CB3
072C8:  MOVFF  01,CB2
072CC:  MOVFF  00,CB1
072D0:  MOVLB  C
072D2:  CLRF   xB8
072D4:  CLRF   xB7
072D6:  CLRF   xB6
072D8:  MOVLW  3C
072DA:  MOVWF  xB5
072DC:  MOVLB  0
072DE:  CALL   456E
072E2:  MOVLW  A6
072E4:  ADDWF  00,W
072E6:  MOVLB  B
072E8:  MOVWF  xD4
072EA:  MOVLW  4A
072EC:  ADDWFC 01,W
072EE:  MOVWF  xD5
072F0:  MOVLW  6D
072F2:  ADDWFC 02,W
072F4:  MOVWF  xD6
072F6:  MOVLW  38
072F8:  ADDWFC 03,W
072FA:  MOVWF  xD7
072FC:  MOVLW  0B
072FE:  MOVWF  xD9
07300:  MOVLW  D0
07302:  MOVWF  xD8
07304:  MOVFF  BD7,C98
07308:  MOVFF  BD6,C97
0730C:  MOVFF  BD5,C96
07310:  MOVFF  BD4,C95
07314:  MOVFF  BD9,C9A
07318:  MOVFF  FE8,C99
0731C:  MOVLB  0
0731E:  RCALL  704C
07320:  GOTO   739E (RETURN)
.................... } 
....................  
.................... void nominal_setup() 
.................... { 
....................     // Normal boot. 
....................     rst_clock_update = 1;   // Update clock with reset pic 
07324:  MOVLW  01
07326:  MOVLB  7
07328:  MOVWF  x55
....................     scheduler_initialize(); // Needed if not loading from FM 
0732A:  MOVLB  0
0732C:  RCALL  700E
0732E:  GOTO   73A2 (RETURN)
....................     // scheduled commands are loaded after reset time sync instead of here 
.................... } 
....................  
.................... void adcs_setup() 
.................... { 
....................     // // Get ADCS memory addresses 
....................     // uint32_t adcs_ptr = get_adcs_pointer(); 
....................     // output_low(MUX_SEL_MSN_SHARED_FM); 
....................     // flash_transfer_data_to_ram( 
....................     //     MISSION_FM, 
....................     //     adcs_ptr, 
....................     //     obc_flags.adcs_addr, 
....................     //     sizeof(obc_flags.adcs_addr)); 
....................     // output_high(MUX_SEL_MSN_SHARED_FM); 
....................     adcs_mode = obc_flags.adcs_initial_value; 
07332:  MOVFF  104,757
07336:  GOTO   73A4 (RETURN)
.................... } 
....................  
.................... void memory_setup() 
.................... { 
....................     // Read boot flags from flash memory 
....................     flash_transfer_data_to_ram( 
....................         &spi_port_COM_FM, 
....................         BOOT_FLAGS_ADDRESS, 
....................         (uint8_t*)&boot_flags, 
....................         sizeof(boot_flags)); 
0733A:  MOVLB  B
0733C:  CLRF   xCF
0733E:  SETF   xCE
07340:  MOVLW  0A
07342:  MOVLB  D
07344:  MOVWF  x4C
07346:  MOVLW  A3
07348:  MOVWF  x4B
0734A:  CLRF   x50
0734C:  CLRF   x4F
0734E:  CLRF   x4E
07350:  CLRF   x4D
07352:  MOVFF  BCF,D52
07356:  MOVFF  BCE,D51
0735A:  CLRF   x56
0735C:  CLRF   x55
0735E:  CLRF   x54
07360:  MOVLW  01
07362:  MOVWF  x53
07364:  MOVLB  0
07366:  CALL   57C8
....................  
....................     if (boot_flags.deployment_flag == 0xFF) { // The memory has no data 
0736A:  INCFSZ xFF,W
0736C:  BRA    7384
....................         fprintf(PC, "Initializing flash memory...\r\n"); 
0736E:  MOVLW  F0
07370:  MOVWF  FF6
07372:  MOVLW  20
07374:  MOVWF  FF7
07376:  MOVLW  00
07378:  MOVWF  FF8
0737A:  CALL   4534
....................         initialize_memory(); 
0737E:  GOTO   686A
....................     } else { 
07382:  BRA    7396
....................         fprintf(PC, "Retrieving addresses from flash memory...\r\n"); 
07384:  MOVLW  10
07386:  MOVWF  FF6
07388:  MOVLW  21
0738A:  MOVWF  FF7
0738C:  MOVLW  00
0738E:  MOVWF  FF8
07390:  CALL   4534
....................         retrieve_memory(); 
07394:  BRA    6DBE
....................     } 
....................  
....................     if (boot_flags.deployment_flag < 5) { // Less than 5 deployment tries 
07396:  MOVF   xFF,W
07398:  SUBLW  04
0739A:  BNC   73A0
....................         initial_deployment_setup(); 
0739C:  BRA    7124
....................     } else { 
0739E:  BRA    73A2
....................         nominal_setup(); 
073A0:  BRA    7324
....................     } 
....................     adcs_setup(); 
073A2:  BRA    7332
073A4:  GOTO   1BAE8 (RETURN)
.................... } 
....................  
.................... #endif // !MEMORY_SETUP_H 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include <definitions.h> 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include "flash_memory_fn.h" 
.................... #ifndef FLASH_MEMORY_FN_H 
.................... #define FLASH_MEMORY_FN_H 
....................  
.................... #include "definitions.h" 
.................... #include "flash_memory.h" 
....................  
.................... // Erase all sectors from a given flash memory (spi_port). 
.................... void flash_erase_all_sectors(spi_fn* spi_functions) 
.................... { 
....................     uint32_t address = 0; 
....................     for (uint16_t i = 0; i < MEMORY_N_SECTORS; i++) { 
....................         flash_erase(spi_functions, address, ERASE_SECTOR); 
....................         address = address + MEMORY_SECTOR_SIZE; 
....................     } 
.................... } 
....................  
.................... // Transfer data from the flash memory (spi_port) to an uart device (uart_port), starting from a given 
.................... // address (page_address) and with a given total lenth (nbytes). 
.................... void flash_transfer_data_to_uart(spi_fn* from_spi_functions, uart_fn* to_uart_port, uint32_t page_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data = flash_read(from_spi_functions, page_address); 
....................         to_uart_port->put_char(data); 
....................         page_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data from one flash memory (from_spi_port) to another (to_spi_port), with different to and from page 
.................... // addresses and configurable length (nbytes). The same flash memory can be used as source and destination. 
.................... void flash_transfer_data_to_flash(spi_fn* from_spi_functions, uint32_t from_address, spi_fn* to_spi_functions, uint32_t to_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data = flash_read(from_spi_functions, from_address); 
....................         flash_write(to_spi_functions, to_address, data); 
....................         from_address++; 
....................         to_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data from ram to flash memory (to_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_from_ram(spi_fn* to_spi_functions, uint32_t to_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         flash_write(to_spi_functions, to_address, data[i]); 
....................         to_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data to ram from flash memory (from_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_to_ram(spi_fn* to_spi_functions, uint32_t from_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data[i] = flash_read(to_spi_functions, from_address); 
....................         from_address++; 
....................     } 
.................... } 
....................  
.................... // Erase memory pages around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to page allignment. 
....................  
.................... void flash_erase_pages(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_PAGE_SIZE) { 
....................         flash_erase(to_spi_functions, i, ERASE_PAGE); 
....................     } 
.................... } 
....................  
.................... // Erase memory sectors around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to sector allignment. 
.................... void flash_erase_sectors(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_SECTOR_SIZE) { 
....................         flash_erase(to_spi_functions, i, ERASE_SECTOR); 
....................     } 
.................... } 
....................  
.................... void flash_dump(spi_fn* spi_functions, uint32_t start, uint32_t end) 
.................... { 
....................     uint8_t data; 
....................     uint16_t empty_blocks = 0; 
....................     for (uint32_t i = start; i < end; i++) { 
....................         if (i % (TERMINAL_COLS / 2) == 0) 
....................             fprintf(PC, "\r\n"); 
....................         data = flash_read(spi_functions, i); 
....................         fprintf(PC, "%02X", data); 
....................         if (data == 0xFF) { 
....................             empty_blocks++; 
....................         } else { 
....................             empty_blocks = 0; 
....................         } 
....................         if (empty_blocks >= EMPTY_BLOCKS_LIMIT) { 
....................             break; 
....................         } 
....................     } 
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) 
.................... void flash_initialize_flash_ctrl(uint32_t start, 
....................     uint32_t end, 
....................     uint32_t current, 
....................     uint32_t packet_size, 
....................     flash_ctrl* fmem) 
.................... { 
....................     fmem->start = start; 
....................     fmem->end = end - (end - start) % packet_size; 
....................     fmem->current = current; 
....................     fmem->delta = packet_size; 
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) based on existing address information from flash 
.................... void flash_initialize_flash_ctrl_from_memory_date_based( 
....................     uint8_t sectors_per_day, 
....................     int8_t deployment_counter, 
....................     uint32_t candidate_address, 
....................     uint32_t first_address, 
....................     uint32_t telemetry_size, 
....................     uint8_t update_date, 
....................     flash_ctrl* fmem) 
.................... { 
....................      
....................     if(deployment_counter < 0) 
....................         deployment_counter = 0; 
....................  
....................     uint32_t addr_start; 
....................     uint16_t day_of_the_year; 
....................  
....................     if(deployment_counter < 5){ 
....................         day_of_the_year = deployment_counter; 
....................         addr_start = first_address + (uint32_t)deployment_counter * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     } 
....................     else{ 
....................         if(update_date){ 
....................             struct_tm* local_time = localtime(&current_time); 
....................             day_of_the_year = local_time->tm_yday; // struct_tm::tm_yday is the day of the year (from 0-365) 
....................         } else{ 
....................             day_of_the_year = (candidate_address - first_address) / ((uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE); 
....................         } 
....................         if (day_of_the_year > 366) 
....................             day_of_the_year = 0; 
....................         addr_start = first_address + (uint32_t)day_of_the_year * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     } 
....................     uint32_t addr_end = addr_start + (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     if(candidate_address >= addr_start && candidate_address < addr_end){ 
....................         flash_initialize_flash_ctrl(addr_start, addr_end, candidate_address, telemetry_size, fmem); 
....................     } else { 
....................         flash_initialize_flash_ctrl(addr_start, addr_end, addr_start, telemetry_size, fmem); 
....................     } 
....................     fprintf(PC, "\r\nDay of the year = %lu\r\n", day_of_the_year + 1); 
....................     fprintf(PC, "Candidate telemetry address = 0x%8lX\r\n", candidate_address); 
....................     fprintf(PC, "Initial telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.start); 
....................     fprintf(PC, "Current telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.current); 
....................     fprintf(PC, "Telemetry size = %u\r\n", addr_flags.flash_telemetry.delta); 
....................     fprintf(PC, "Last telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.end); 
.................... } 
....................  
.................... // Writes data according to a flash control structure (fctrl) to a flash memory in spi_port 
.................... void flash_cycle_write(spi_fn* spi_functions, uint8_t* data, flash_ctrl* fctrl) 
.................... { 
....................     if (fctrl->current < fctrl->start || fctrl->current >= fctrl->end) 
....................         fctrl->current = fctrl->start; 
....................     uint32_t remaining_addressess = (MEMORY_PAGE_SIZE - (fctrl->current % MEMORY_PAGE_SIZE)) % MEMORY_PAGE_SIZE; 
....................     if (remaining_addressess < fctrl->delta) { 
....................         flash_erase(spi_functions, fctrl->current + remaining_addressess, ERASE_PAGE); 
....................     } 
....................     for (int i = 0; i < fctrl->delta; i++) { 
....................         flash_write(spi_functions, fctrl->current, data[i]); 
....................         fctrl->current++; 
....................     } 
.................... } 
....................  
.................... // Recover last available address from a flash control structure (fctrl) 
.................... void flash_recover_last_addr(spi_fn* spi_functions, flash_ctrl* fctrl) 
.................... { 
....................     uint8_t data; 
....................     for (fctrl->current = fctrl->end - fctrl->delta; fctrl->current >= fctrl->start; fctrl->current -= fctrl->delta) { 
....................         for (uint8_t i = 0; i < fctrl->delta; i++) { 
....................             data = flash_read(spi_functions, fctrl->current + i); 
....................             if (data != 0xFF) { 
....................                 fctrl->current += fctrl->delta; 
....................                 goto loop_end; 
....................             } 
....................         } 
....................     } 
.................... loop_end: 
....................     if (fctrl->current >= fctrl->end) 
....................         fctrl->current = fctrl->start; 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_FN_H 
....................  
.................... #include "crc16.h" 
.................... #ifndef CRC16_H 
.................... #define CRC16_H 
....................  
.................... #include <stdint.h> 
....................  
.................... // CRC calculation function 
.................... uint16_t mk_crc(uint8_t* data, uint8_t size) 
.................... { 
....................     uint32_t crcreg = 0xffff; 
....................     uint32_t calc = 0x8408; 
....................     for (uint32_t k = 0; k < size; k++) { 
....................         uint8_t cal_data = data[k]; 
....................         for (uint32_t i = 0; i < 8; i++) { 
....................             uint8_t w = (crcreg ^ cal_data) & 0x0001; 
....................             crcreg = crcreg >> 1; 
....................             if (w == 1) { 
....................                 crcreg = crcreg ^ calc; 
....................             } 
....................             cal_data = cal_data >> 1; 
....................         } 
....................     } 
....................     crcreg = crcreg ^ 0xffff; 
....................     return crcreg; 
.................... } 
....................  
.................... #endif /* CRC16_H */ 
....................  
.................... #include "scheduler.h" 
.................... #ifndef SCHEDULER_H 
.................... #define SCHEDULER_H 
....................  
.................... #include <string.h> 
.................... #include <definitions.h> 
....................  
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled); 
....................  
.................... void scheduler_initialize() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... int scheduled_command_add(time_t time, uint8_t* command) 
.................... { 
....................     scheduled_command cmd; 
....................     cmd.time = time; 
....................     memcpy(cmd.command, command, BUFF_LENGTH); 
....................  
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&scheduled_commands[i], &cmd, sizeof(scheduled_command)); 
....................             return 0; 
....................         } 
....................     } 
....................  
....................     return -1; // Error signaling 
.................... } 
....................  
.................... int scheduled_command_count() 
.................... { 
....................     int count = 0; 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time != TIME_T_MAX) { 
....................             count++; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
.................... void scheduled_command_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... void scheduled_command_clear_specified_command(uint8_t source, uint8_t command) 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].command[0] == source && scheduled_commands[i].command[1] == command) { 
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
....................         } 
....................     } 
.................... } 
....................  
.................... void scheduled_command_check() 
.................... { 
....................     // time_t current_time = time(0); 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (current_time >= scheduled_commands[i].time) { 
....................             command_execute(scheduled_commands[i].command, MSG_COMM, 1); // scheduled commands can only be COMM commands 
....................             scheduled_commands[i].time = TIME_T_MAX;                     // Disable the command from executing again (== reschedule it at infinity). 
....................             i = 0; // Check the whole table again for changes 
....................         } 
....................     } 
.................... } 
....................  
.................... #ifndef PC_SIM 
.................... #define ZERO (0, 0) 
.................... #else 
.................... #define ZERO (0) 
.................... #endif 
....................  
.................... // Schedule a constant 
.................... #define schedule(time, ...)               \ 
....................     do {                                  \ 
....................         uint8_t cmd[] = __VA_ARGS__;      \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Schedule a variable 
.................... #define vschedule(time, cmd)              \ 
....................     do {                                  \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Execute a command immediately 
.................... #define execute(log, ...)                        \ 
....................     do {                                         \ 
....................         uint8_t cmd[] = __VA_ARGS__;             \ 
....................         command_execute(cmd, MSG_WILDCARD, log); \ 
....................     } while ZERO 
....................  
.................... #define periodic_command_clear_rx_flag(period, delta) \ 
....................     do {                                              \ 
....................         if ((current_time % period == delta)) {       \ 
....................             response_rx = 0;                          \ 
....................         }                                             \ 
....................     } while ZERO 
....................  
.................... #define periodic_command(period, delta, log, ...) \ 
....................     do {                                          \ 
....................         if ((current_time % period == delta)) {   \ 
....................             if (!response_rx)                     \ 
....................                 execute(log, __VA_ARGS__);        \ 
....................         }                                         \ 
....................     } while ZERO 
....................  
.................... #endif /* SCHEDULER_H */ 
....................  
.................... #include "log_control.h" 
.................... #ifndef LOG_CONTROL_H 
.................... #define LOG_CONTROL_H 
....................  
.................... #include <string.h> 
.................... #include <definitions.h> 
.................... #include <flash_memory.h> 
....................  
.................... // Adds a log entry to buffer in RAM 
.................... void log_add(log_entry e) 
.................... { 
....................     if (log_index < MAX_LOGS_IN_RAM) { 
....................         memcpy(&log_buffer[log_index], &e, sizeof(log_entry)); 
....................         log_index++; 
....................     } 
.................... } 
....................  
.................... // Clears buffer in RAM 
.................... void log_clear() 
.................... { 
....................     log_index = 0; 
.................... } 
....................  
.................... // Flushes RAM buffer to flash memory 
.................... void log_flush() 
.................... { 
....................     for(uint8_t i=0; i<log_index; i++){ 
....................         uint8_t *ptr = (uint8_t*)&log_buffer[i]; 
....................         flash_cycle_write(&spi_port_COM_FM, ptr, &addr_flags.flash_log); 
....................     } 
....................     fprintf(PC, "Log: 0x%08lX => 0x%08lX", addr_flags.flash_log.current - log_index*sizeof(log_entry), addr_flags.flash_log.current); 
....................     log_index = 0; 
.................... } 
....................  
.................... #endif /* LOG_CONTROL_H */ 
....................  
.................... #include "boot_command.h" 
.................... #ifndef BOOT_COMMAND_H 
.................... #define BOOT_COMMAND_H 
....................  
.................... #include <definitions.h> 
.................... #include <flash_memory.h> 
.................... #include <flash_memory_fn.h> 
.................... #include <scheduler.h> 
....................  
.................... void boot_commands_write() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_erase_pages(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, BOOT_COMMANDS_ADDR + sizeof(boot_commands)); 
....................     flash_transfer_data_from_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_read() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_transfer_data_to_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_clear_nth(uint8_t n) 
.................... { 
....................     if (n < BOOT_COMMANDS_MAX) 
....................         boot_commands[n].time = TIME_T_MAX; 
.................... } 
....................  
.................... void boot_commands_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         boot_commands_clear_nth(i); 
....................     } 
.................... } 
....................  
.................... uint8_t boot_commands_add(boot_command bc) 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if (boot_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&boot_commands[i], &bc, sizeof(boot_command)); 
....................             return i; 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... void boot_commands_schedule() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if(boot_commands[i].time > 0 && boot_commands[i].time < TIME_T_MAX) 
....................             vschedule(current_time + boot_commands[i].time, boot_commands[i].command); 
....................     } 
.................... } 
....................  
.................... #endif /* BOOT_COMMAND_H */ 
....................  
.................... #include "xmodem.h" 
.................... #ifndef XMODEM_H 
.................... #define XMODEM_H 
....................  
.................... // Based on: 
.................... // https://web.mit.edu/6.115/www/amulet/xmodem.htm 
.................... // https://pythonhosted.org/xmodem/xmodem.html#data-flow-example-including-error-recovery 
....................  
.................... #include <definitions.h> 
.................... #include <flash_memory.h> 
.................... #include <libuart_fn.h> 
....................  
.................... #define XMODEM_SOH 0x01                   // Start of Header 
.................... #define XMODEM_EOT 0x04                   // End of Transmission 
.................... #define XMODEM_ACK 0x06                   // Acknowledge 
.................... #define XMODEM_NAK 0x15                   // Not Acknowledge 
.................... #define XMODEM_DLENGTH 128                // Data length 
.................... #define XMODEM_PLENGTH XMODEM_DLENGTH + 4 // Packet length 
....................  
.................... typedef struct xmodem_packet { 
....................     uint8_t header; 
....................     uint8_t packet_no; 
....................     uint8_t packet_no_; 
....................     uint8_t packet_data[XMODEM_DLENGTH]; 
....................     uint8_t checksum; 
.................... } xmodem_packet; 
....................  
.................... uint8_t xmodem_calc_chksum(uint8_t* ptr, uint8_t count) 
.................... { 
....................     uint8_t result = 0; 
....................     for (uint8_t* i = ptr; i < ptr + count; i++) { 
....................         result += *i; 
....................     } 
....................     return result; 
.................... } 
....................  
.................... void xmodem_create_packet(spi_fn* spi_port, uint32_t fm_address, uint32_t packet_no, uint8_t* packet_data) 
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)packet_data; 
....................     packet->header = XMODEM_SOH; 
....................     packet->packet_no = packet_no & 0xFF; 
....................     packet->packet_no_ = 0xFF - packet->packet_no; 
....................     flash_transfer_data_to_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
....................     packet->checksum = xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH); 
.................... } 
....................  
.................... int8_t xmodem_send(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address, uint16_t n_packets) 
.................... { 
....................     const uint32_t timeout = 5000000; 
....................     uint16_t current_packet = 1; 
....................     uint8_t packet[XMODEM_PLENGTH]; 
....................     for (uint32_t t = 0; t < timeout; t++) { 
....................         if (uart_stream->bytes_available()) { 
....................             uint8_t command = uart_stream->get_char(); 
....................             t = 0; 
....................             switch (command) { 
....................             case XMODEM_ACK: 
....................                 current_packet++; 
....................                 fm_address += XMODEM_DLENGTH; 
....................                 if (current_packet > n_packets) { 
....................                     uart_stream->put_char(XMODEM_EOT); 
....................                     return 0; 
....................                 } 
....................             case XMODEM_NAK: 
....................                 xmodem_create_packet(spi_port, fm_address, current_packet, packet); 
....................                 uart_send_packet(uart_stream, packet, XMODEM_PLENGTH); 
....................                 break; 
....................             default: 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... uint8_t xmodem_validate(uint8_t* buffer, uint16_t packet_no) 
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uint8_t correct_header = (packet->header == XMODEM_SOH); 
....................     uint8_t correct_no = (packet->packet_no == (packet_no & 0xFF)); 
....................     uint8_t correct_no_ = (packet->packet_no_ == 0xFF - (packet_no & 0xFF)); 
....................     uint8_t correct_checksum = (packet->checksum == xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH)); 
....................     return correct_header && correct_no && correct_no_ && correct_checksum; 
.................... } 
....................  
.................... int16_t xmodem_receive(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address) 
.................... { 
....................     const uint32_t uart_timeout = 1000000; 
....................     uint16_t max_nak = 2; 
....................     uint16_t packet_no = 1; 
....................     uint16_t nak_count = 0; 
....................     uint8_t buffer[XMODEM_PLENGTH] = { 0 }; 
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uart_stream->put_char(XMODEM_NAK); // Request 1st packet 
....................     while (nak_count < max_nak) { 
....................         uart_download_packet(uart_stream, buffer, XMODEM_PLENGTH, uart_timeout); 
....................         if (buffer[0] == XMODEM_EOT) { 
....................             uart_stream->put_char(XMODEM_ACK); 
....................             return packet_no; 
....................         } 
....................         if (xmodem_validate(buffer, packet_no)) { 
....................             // uart_send_packet(uart_stream, packet->packet_data, XMODEM_DLENGTH); // for debug 
....................             uint32_t remaining_addressess = (MEMORY_SECTOR_SIZE - (fm_address % MEMORY_SECTOR_SIZE)) % MEMORY_SECTOR_SIZE; 
....................             if (remaining_addressess < XMODEM_DLENGTH) { 
....................                 flash_erase(spi_port, fm_address + remaining_addressess, ERASE_SECTOR); 
....................             } 
....................             flash_transfer_data_from_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
....................             packet_no++; 
....................             fm_address += XMODEM_DLENGTH; 
....................             nak_count = 0; 
....................             max_nak = 64; // Increase max number of nak once communication is established 
....................             uart_stream->put_char(XMODEM_ACK); 
....................         } else { 
....................             uart_stream->put_char(XMODEM_NAK); 
....................             nak_count++; 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... #endif /* XMODEM_H */ 
....................  
.................... #include "interpreter.h" 
.................... #ifndef INTERPRETER_H 
.................... #define INTERPRETER_H 
....................  
.................... #include <definitions.h> 
.................... #include <scheduler.h> 
.................... #include <crc16.h> 
.................... #include <libuart_fn.h> 
.................... #include <flash_memory.h> 
.................... #include <stdint.h> 
.................... #include <xmodem.h> 
.................... #include <log_control.h> 
.................... #include <boot_command.h> 
.................... #include <math.h> 
....................  
.................... // Interpreter: The procedures here are concerned with interpreting 
.................... // received commands and executing the appropriate commands. 
....................  
.................... // Definition of commands. Should follow the prototype: "uint8_t command_name(uint8_t *data)" 
.................... // Return value = 0 indicates that the command was successful 
.................... // Return value > 0 indicates that there was an error 
....................  
.................... // ============ Helper functions ============ 
....................  
.................... // Get access to shared FM 
.................... void get_com_shared_fm_access() 
.................... { 
....................     if (memory_busy) { 
....................         scheduled_command_clear_specified_command(0xC0, 0x58); // Disable scheduled command to regain access to memory in the future 
....................         output_low(MUX_SEL_COM_SHARED_FM);                     // Regain access to memory now 
....................         memory_busy = 0;                                       // Now memory is free 
....................     } 
.................... } 
....................  
.................... uint8_t mux_lock_unlock(uint8_t mux_state, time_t time) 
.................... { 
....................     if (time > 1800L) { // Maximum time that the mux can be reserved is 30 minutes 
....................         fprintf(PC, "Warning: mux reservation time too long!"); 
....................         time = 1800L; 
....................     } 
....................     if (mux_state) { 
....................         scheduled_command_clear_specified_command(0xC0, 0x02); // Disable scheduled command to regain access to memory in the future 
....................         schedule(current_time + time, { 0xC0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 }); // Release the lock in the future 
....................     } 
....................     mux_lock = mux_state; 
....................     return mux_state; 
.................... } 
....................  
.................... uint8_t command_mux_lock_unlock(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mux_state; // 0: unlock, 1: lock 
....................         time_t time;       // in seconds 
....................     }* packet = (struct packet*)data; 
....................  
....................     uart_print_pc_hex(data, 7); 
....................     return mux_lock_unlock(packet->mux_state, packet->time); 
.................... } 
....................  
.................... uint8_t command_mux_sel_sfm(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Changed MUX to position %d", data[2]); 
....................     return mux_sel(data[2]); 
.................... } 
....................  
.................... // Helper function to calculate OBC checksum 
.................... void checksum_obc(uint8_t* data, uint8_t size) 
.................... { 
....................     uint8_t checksum = 0; 
....................     for (uint8_t i = 1; i < size - 2; i++) { 
....................         checksum ^= data[i]; 
....................     } 
....................     data[size - 2] = checksum; 
....................     data[size - 1] = data[0] + 1; // Footer 
.................... } 
....................  
.................... // Helper function to check if uplink is valid 
.................... uint8_t uplink_valid(uint8_t* buffer) 
.................... { 
....................     const uint8_t cmd_length = 22;        // Extended packet length 
....................     const uint8_t cmd_legacy_length = 14; // Legacy packet length 
....................  
....................     struct packet { 
....................         uint8_t packet_format_id; 
....................         uint8_t satellite_id; 
....................         uint8_t cmd_format_id; 
....................     }* packet = (struct packet*)buffer; 
....................  
....................     uint16_t cr, pk;                                                                 // these are the crc check variables 
....................     if (packet->packet_format_id == 0x42 && packet->satellite_id == SPACECRAFT_ID) { // This packet is meant for CURTIS 
....................         if (packet->cmd_format_id == 0xCC) {                                         // Extended KITSUNE format (22 bytes) 
....................             cr = mk_crc(buffer, cmd_length - 2); 
....................             pk = make16(buffer[cmd_length - 1], buffer[cmd_length - 2]); 
....................         } else { // Herritage BIRDS format (14 bytes) 
....................             cr = mk_crc(buffer, cmd_legacy_length - 2); 
....................             pk = make16(buffer[cmd_legacy_length - 1], buffer[cmd_legacy_length - 2]); 
....................         } 
....................         if (cr == pk) { // CRC is good to go 
....................             return 1;   // Packet is valid 
....................         } 
....................     } 
....................     return 0; // Packet is invalid 
.................... } 
....................  
.................... // Helper function to send an acknowledge back to COM 
.................... void send_com_ack(uint8_t* data) 
.................... { 
....................     uint8_t cmd[24] = { 0 }; 
....................     cmd[0] = 0x0B; 
....................     cmd[1] = 0xAA; 
....................     cmd[2] = 0xCC; 
....................     memcpy(cmd + 3, data, 8); 
....................     cmd[12] = 0x66; 
....................     cmd[23] = 0x0C; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], COMM); 
....................     } 
.................... } 
....................  
.................... // Helper function to change reset time 
.................... void reset_pic_update_clock(time_t time) 
.................... { 
....................     struct_tm* tstr = localtime(&time); 
....................     struct rst_msg { 
....................         uint8_t rst_command; 
....................         uint8_t year; 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................     } msg; 
....................  
....................     msg.rst_command = 0x70; 
....................     msg.year = tstr->tm_year - 100; 
....................     msg.month = tstr->tm_mon + 1; 
....................     msg.day = tstr->tm_mday; 
....................     msg.hour = tstr->tm_hour; 
....................     msg.minute = tstr->tm_min; 
....................     msg.second = tstr->tm_sec; 
....................  
....................     uint8_t i; 
....................     uint8_t cmd[36] = { 0 }; 
....................     cmd[0] = 0xB0; 
....................     uint8_t* ptr = (uint8_t*)&msg; 
....................     for (i = 0; i < sizeof(msg); i++) { 
....................         cmd[i + 1] = ptr[i]; 
....................     } 
....................     cmd[35] = 0xB1; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
.................... } 
....................  
.................... // Helper function to print binary data 
.................... void print_binary16(uint16_t data) 
.................... { 
....................     const uint8_t size = 16; 
....................     for (uint8_t i = 1; i <= size; i++) { 
....................         fprintf(PC, "%Lu", ((data >> (size - i)) & 1)); 
....................     } 
.................... } 
....................  
.................... // Helper funtion to initialize the telemetry array. 
.................... void initialize_telemetry() 
.................... { 
....................     memset(&telemetry_time, 0, sizeof(telemetry_time)); 
....................     memset(&telemetry, 0, sizeof(telemetry)); 
....................     telemetry.master_footer[0] = 0xB0; 
....................     telemetry.master_footer[1] = 0x0B; 
.................... } 
....................  
.................... // Convert gyro data 16 -> 8 bits (-128 to 127 with LSB = 1deg/s, with overflow protection) 
.................... int8_t gyro_to_cw(uint8_t msb, uint8_t lsb) 
.................... { 
....................     int8_t gyro_cw; 
....................     float gyro = ((int16_t)make16(msb, lsb)) / 131.; 
....................     if (gyro > 127.) { 
....................         gyro_cw = 127; 
....................     } else if (gyro < -128.) { 
....................         gyro_cw = -128; 
....................     } else { 
....................         if (gyro > 0.) { 
....................             gyro_cw = (int8_t)(gyro + 0.5); 
....................         } else { 
....................             gyro_cw = (int8_t)(gyro - 0.5); 
....................         } 
....................     } 
....................     return gyro_cw; 
.................... } 
....................  
.................... // Conversion for CW beacon in the range 0-15 
.................... uint8_t get_adcs_mode_index(uint8_t adcs_mode) { 
....................     switch (adcs_mode) { 
....................         case 0: 
....................         case 1: 
....................         case 2: 
....................         case 3: 
....................         case 4: 
....................             return adcs_mode;  // Direct mapping for 0 to 4 
....................         case 10: 
....................         case 11: 
....................         case 12: 
....................         case 13: 
....................             return adcs_mode - 5;  // Adjust for 10 to 13 
....................         case 20: 
....................         case 21: 
....................             return adcs_mode - 11; // Adjust for 20 to 21 
....................         case 25: 
....................         case 26: 
....................         case 27: 
....................         case 28: 
....................         case 29: 
....................             return adcs_mode - 14; // Adjust for 25 to 28 
....................         default: 
....................             return 0; // Return 0 if the mode is out of range or not mapped 
....................     } 
.................... } 
....................  
.................... // Helper function for data serialization 
.................... void set_bits(uint8_t *data, uint32_t value, uint16_t *bit_offset, uint8_t bits) { 
....................     while (bits > 0) { 
....................         uint8_t byte_offset = *bit_offset / 8; 
....................         uint8_t bit_in_byte_offset = *bit_offset % 8; 
....................         uint8_t bits_to_write = (bits > 8 - bit_in_byte_offset) ? 8 - bit_in_byte_offset : bits; 
....................  
....................         data[byte_offset] |= ((value & ((1U << bits_to_write) - 1U)) << bit_in_byte_offset); 
....................  
....................         value >>= bits_to_write; 
....................         bits -= bits_to_write; 
....................         *bit_offset += bits_to_write; 
....................     } 
.................... } 
....................  
.................... // Helper function for data deserialization 
.................... uint32_t get_bits(uint8_t *data, uint16_t *bit_offset, uint8_t bits) { 
....................     uint32_t value = 0; 
....................     uint8_t value_offset = 0; 
....................  
....................     while (bits > 0) { 
....................         uint8_t byte_offset = *bit_offset / 8; 
....................         uint8_t bit_in_byte_offset = *bit_offset % 8; 
....................         uint8_t bits_to_read = (bits > 8 - bit_in_byte_offset) ? 8 - bit_in_byte_offset : bits; 
....................  
....................         value |= ((uint32_t)(data[byte_offset] >> bit_in_byte_offset) & ((1U << bits_to_read) - 1U)) << value_offset; 
....................  
....................         bits -= bits_to_read; 
....................         *bit_offset += bits_to_read; 
....................         value_offset += bits_to_read; 
....................     } 
....................  
....................     return value; 
.................... } 
....................  
.................... void deserialize_cw() 
.................... { 
....................     uint16_t bit_offset = 0; 
....................  
....................     // Page 0 Deserialization 
....................     uint8_t battery_voltage = get_bits(cw[0], &bit_offset, 8);                 // Battery Voltage (RST RAW voltage) 
....................     uint8_t battery_current = get_bits(cw[0], &bit_offset, 8);                 // Battery Current 
....................     uint8_t battery_temperature = get_bits(cw[0], &bit_offset, 8);             // Battery Temperature 
....................     uint8_t cpld_temperature = get_bits(cw[0], &bit_offset, 8);                // CPLD Temperature 
....................     uint8_t solar_cell_sap_z_plus_y_undepl = get_bits(cw[0], &bit_offset, 1);  // Solar Cell SAP +Z (+Y undepl.) 
....................     uint8_t solar_cell_y_plus = get_bits(cw[0], &bit_offset, 1);               // Solar Cell +Y 
....................     uint8_t solar_cell_x_plus = get_bits(cw[0], &bit_offset, 1);               // Solar Cell +X 
....................     uint8_t solar_cell_y_minus = get_bits(cw[0], &bit_offset, 1);              // Solar Cell -Y 
....................     uint8_t solar_cell_sap_z_minus_y_undepl = get_bits(cw[0], &bit_offset, 1); // Solar Cell SAP +Z (-Y undepl.) 
....................     uint8_t solar_cell_z_minus = get_bits(cw[0], &bit_offset, 1);              // Solar Cell -Z 
....................     uint8_t scheduled_commands = get_bits(cw[0], &bit_offset, 2);              // Scheduled commands in memory 
....................     uint8_t battery_heater_flag = get_bits(cw[0], &bit_offset, 1);             // Battery Heater Flag 
....................     uint8_t kill_switch_main_pic = get_bits(cw[0], &bit_offset, 1);            // Kill Switch Main PIC 
....................     uint8_t kill_switch_eps = get_bits(cw[0], &bit_offset, 1);                 // Kill Switch EPS 
....................     uint8_t adcs_mode = get_bits(cw[0], &bit_offset, 4);                       // ADCS mode 
....................     uint8_t format_identifier_0 = get_bits(cw[0], &bit_offset, 1);             // Format identifier 
....................  
....................     fprintf(PC, "Page 0 Deserialized Data:\r\n"); 
....................     fprintf(PC, "Battery Voltage (RST RAW voltage): %u\r\n", battery_voltage); 
....................     fprintf(PC, "Battery Current: %u\r\n", battery_current); 
....................     fprintf(PC, "Battery Temperature: %u\r\n", battery_temperature); 
....................     fprintf(PC, "CPLD Temperature: %u\r\n", cpld_temperature); 
....................     fprintf(PC, "Solar Cell SAP +Z (+Y undepl.): %u\r\n", solar_cell_sap_z_plus_y_undepl); 
....................     fprintf(PC, "Solar Cell +Y: %u\r\n", solar_cell_y_plus); 
....................     fprintf(PC, "Solar Cell +X: %u\r\n", solar_cell_x_plus); 
....................     fprintf(PC, "Solar Cell -Y: %u\r\n", solar_cell_y_minus); 
....................     fprintf(PC, "Solar Cell SAP +Z (-Y undepl.): %u\r\n", solar_cell_sap_z_minus_y_undepl); 
....................     fprintf(PC, "Solar Cell -Z: %u\r\n", solar_cell_z_minus); 
....................     fprintf(PC, "Scheduled commands in memory: %u\r\n", scheduled_commands); 
....................     fprintf(PC, "Battery Heater Flag: %u\r\n", battery_heater_flag); 
....................     fprintf(PC, "Kill Switch Main PIC: %u\r\n", kill_switch_main_pic); 
....................     fprintf(PC, "Kill Switch EPS: %u\r\n", kill_switch_eps); 
....................     fprintf(PC, "ADCS mode: %u\r\n", adcs_mode); 
....................     fprintf(PC, "Format identifier: %u\r\n", format_identifier_0); 
....................  
....................     bit_offset = 0; // Reset bit offset for page 1 
....................  
....................     // Page 1 Deserialization 
....................     uint8_t gyro_x = get_bits(cw[1], &bit_offset, 8);                   // Gyro X axis 
....................     uint8_t gyro_y_minus = get_bits(cw[1], &bit_offset, 8);             // Gyro -Y axis 
....................     uint8_t gyro_z_minus = get_bits(cw[1], &bit_offset, 8);             // Gyro -Z axis 
....................     uint8_t magnetometer_x = get_bits(cw[1], &bit_offset, 5);           // Magnetometer X 
....................     uint8_t magnetometer_y = get_bits(cw[1], &bit_offset, 5);           // Magnetometer Y 
....................     uint8_t magnetometer_z = get_bits(cw[1], &bit_offset, 5);           // Magnetometer Z 
....................     uint8_t subsystems_communicating = get_bits(cw[1], &bit_offset, 3); // Subsystems communicating 
....................     uint8_t time_after_reset = get_bits(cw[1], &bit_offset, 5);         // Time after last reset (hours) 
....................     uint8_t format_identifier_1 = get_bits(cw[1], &bit_offset, 1);      // Format identifier 
....................  
....................     fprintf(PC, "Page 1 Deserialized Data:\r\n"); 
....................     fprintf(PC, "Gyro X axis: %u\r\n", gyro_x); 
....................     fprintf(PC, "Gyro -Y axis: %u\r\n", gyro_y_minus); 
....................     fprintf(PC, "Gyro -Z axis: %u\r\n", gyro_z_minus); 
....................     fprintf(PC, "Magnetometer X: %u\r\n", magnetometer_x); 
....................     fprintf(PC, "Magnetometer Y: %u\r\n", magnetometer_y); 
....................     fprintf(PC, "Magnetometer Z: %u\r\n", magnetometer_z); 
....................     fprintf(PC, "Subsystems communicating: %u\r\n", subsystems_communicating); 
....................     fprintf(PC, "Time after last reset (hours): %u\r\n", time_after_reset); 
....................     fprintf(PC, "Format identifier: %u\r\n", format_identifier_1); 
.................... } 
....................  
.................... // Helper funtion to initialize the cw beacon array. 
.................... void build_cw() 
.................... { 
....................     uint8_t sc = scheduled_command_count(); 
....................  
....................     time_t time_after_reset_ = (current_time - reset_time) / 3600; 
....................     uint8_t time_after_reset = time_after_reset_ > 24 ? 0x1F : time_after_reset_; 
....................  
....................     uint8_t subsystems_communicating = 0; 
....................     time_t* t = (time_t*)&telemetry_time; 
....................     for (uint8_t i = 0; i < sizeof(telemetry_time) / sizeof(time_t); i++) { 
....................         subsystems_communicating += (t[i] > 0); 
....................     } 
....................     subsystems_communicating -= (telemetry_time.com_time > 0); // Remove COM pic from the report 
....................  
....................     memset(&cw, 0, sizeof(cw)); // Erase old data. 
....................  
....................     uint16_t bit_offset = 0; 
....................  
....................     // Page 0 
....................     set_bits(cw[0], make16(telemetry.reset_message[6], telemetry.reset_message[7]) >> 4, &bit_offset, 8);  // Battery Voltage (RST RAW voltage) 
....................     set_bits(cw[0], make16(telemetry.fab_message[52], telemetry.fab_message[43]) >> 4, &bit_offset, 8);    // Battery Current 
....................     set_bits(cw[0], make16(telemetry.fab_message[54], telemetry.fab_message[55]) >> 4, &bit_offset, 8);    // Battery Temperature 
....................     set_bits(cw[0], make16(telemetry.fab_message[10], telemetry.fab_message[11]) >> 4, &bit_offset, 8);    // CPLD Temperature 
....................     set_bits(cw[0], make16(telemetry.fab_message[30], telemetry.fab_message[31]) > 0x2F0, &bit_offset, 1); // Solar Cell SAP +Z (+Y undepl.) 
....................     set_bits(cw[0], make16(telemetry.fab_message[32], telemetry.fab_message[33]) > 0x2F0, &bit_offset, 1); // Solar Cell +Y 
....................     set_bits(cw[0], make16(telemetry.fab_message[34], telemetry.fab_message[35]) > 0x2F0, &bit_offset, 1); // Solar Cell +X 
....................     set_bits(cw[0], make16(telemetry.fab_message[36], telemetry.fab_message[37]) > 0x2F0, &bit_offset, 1); // Solar Cell -Y 
....................     set_bits(cw[0], make16(telemetry.fab_message[38], telemetry.fab_message[39]) > 0x2F0, &bit_offset, 1); // Solar Cell SAP +Z (-Y undepl.) 
....................     set_bits(cw[0], make16(telemetry.fab_message[40], telemetry.fab_message[41]) > 0x090, &bit_offset, 1); // Solar Cell -Z 
....................     set_bits(cw[0], sc > 3 ? 3 : sc, &bit_offset, 2);                                                      // Scheduled commands in memory 
....................     set_bits(cw[0], telemetry.fab_message[56] > 0, &bit_offset, 1);                                        // Battery Heater Flag 
....................     set_bits(cw[0], (telemetry.fab_message[57] & 0x01) > 0, &bit_offset, 1);                               // Kill Switch Main PIC 
....................     set_bits(cw[0], (telemetry.fab_message[57] & 0x10) > 0, &bit_offset, 1);                               // Kill Switch EPS 
....................     set_bits(cw[0], get_adcs_mode_index(telemetry.adcs_message[0]), &bit_offset, 4);                       // ADCS mode 
....................     set_bits(cw[0], 0, &bit_offset, 1);                                                                    // Format identifier 
....................  
....................     bit_offset = 0; 
....................  
....................     // Page 1 
....................     set_bits(cw[1], gyro_to_cw(telemetry.adcs_message[5], telemetry.adcs_message[6]), &bit_offset, 8);   // Gyro X axis 
....................     set_bits(cw[1], gyro_to_cw(telemetry.adcs_message[7], telemetry.adcs_message[8]), &bit_offset, 8);   // Gyro -Y axis 
....................     set_bits(cw[1], gyro_to_cw(telemetry.adcs_message[9], telemetry.adcs_message[10]), &bit_offset, 8);  // Gyro -Z axis 
....................     set_bits(cw[1], make16(telemetry.pcib_message[4], telemetry.pcib_message[5]) >> 11, &bit_offset, 5); // Magnetometer X 
....................     set_bits(cw[1], make16(telemetry.pcib_message[6], telemetry.pcib_message[7]) >> 11, &bit_offset, 5); // Magnetometer Y 
....................     set_bits(cw[1], make16(telemetry.pcib_message[8], telemetry.pcib_message[9]) >> 11, &bit_offset, 5); // Magnetometer Z 
....................     set_bits(cw[1], subsystems_communicating, &bit_offset, 3);                                           // Subsystems communicating 
....................     set_bits(cw[1], time_after_reset, &bit_offset, 5);                                                   // Time after last reset (hours) 
....................     set_bits(cw[1], 1, &bit_offset, 1);                                                                  // Format identifier 
....................  
....................     fprintf(PC, "CW: 0x"); 
....................     uart_print_pc_hex_short(cw[0], sizeof(cw[0])); 
....................     fprintf(PC, " 0x"); 
....................     uart_print_pc_hex_short(cw[1], sizeof(cw[1])); 
....................     fputc(' ', PC); 
.................... } 
....................  
.................... void save_flags() 
.................... { 
....................     uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
....................     flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
.................... } 
....................  
.................... // Helper function to save state to flash 
.................... void save_state(uint8_t current_command) 
.................... { 
....................     get_com_shared_fm_access(); 
....................  
....................     // Save state of obc_flags: 
....................     flash_erase_pages(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, OBC_FLAGS_ADDRESS + sizeof(obc_flags)); 
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
....................     flash_transfer_data_from_ram( 
....................         &spi_port_COM_FM, 
....................         OBC_FLAGS_ADDRESS, 
....................         obc_flag_ptr, 
....................         sizeof(obc_flags)); 
....................  
....................     // Disable the current command before saving 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].command[0] == MSG_COMM && scheduled_commands[i].command[1] == current_command && scheduled_commands[i].time <= current_time) { 
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
....................         } 
....................     } 
....................  
....................     // Save state of scheduled commands: 
....................     flash_erase_pages(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, SCHEDULED_CMD_ADDRESS + sizeof(scheduled_commands)); 
....................     uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, cmd_ptr, sizeof(scheduled_commands)); 
.................... } 
....................  
.................... void send_mcp_command(uint8_t mcp_command, uint16_t data, uint8_t silent) 
.................... { 
....................     if (mux_sel(mux_mcpic) != mux_mcpic) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return; 
....................     } 
....................  
....................     uint8_t cmd[MSG_LENGTH_MCPIC] = { 0 }; 
....................  
....................     struct mcp_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t data; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* mcp_packet = (struct mcp_packet*)cmd; 
....................  
....................     mcp_packet->origin = MSG_OBC; 
....................     mcp_packet->command = mcp_command; 
....................     mcp_packet->data = data; 
....................  
....................     checksum_obc(cmd, sizeof(cmd)); 
....................  
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], MCPIC); 
....................     } 
....................  
....................     if (!silent) { 
....................         fprintf(PC, "MCPIC cmd: "); 
....................         uart_print_pc_hex(cmd, sizeof(cmd)); 
....................     } 
.................... } 
....................  
.................... // ============ Commands for Telemetry request ============ 
....................  
.................... // Request for reset telemetry 
.................... uint8_t command_request_reset(uint8_t* data) 
.................... { 
....................     uart_clean(RST); 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Request for eps telemetry 
.................... uint8_t command_request_eps(uint8_t* data) 
.................... { 
....................     uart_clean(FAB); 
....................  
....................     uint8_t i; 
....................     enum { cmd_size = 6 }; 
....................  
....................     uint8_t cmd[cmd_size] = { 0 }; 
....................  
....................     cmd[0] = 0xE0; 
....................     cmd[1] = 0x61; 
....................     *(uint32_t*)&cmd[2] = current_time; 
....................  
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], FAB); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // request for adcs telemetry 
.................... uint8_t command_request_adcs(uint8_t* data) 
.................... { 
....................     uart_clean(ADCS); 
....................  
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B }; 
....................     adcs_command[1] = 0xAB; 
....................     *(time_t*)&adcs_command[2] = current_time; 
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
....................         fputc(adcs_command[i], ADCS); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Request for Mission Control PIC Status 
.................... uint8_t command_request_mission_control_PIC_status(uint8_t* data) 
.................... { 
....................     uart_clean(MCPIC); 
....................  
....................     if (mux_sel(mux_mcpic) != mux_mcpic) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     send_mcp_command(0x10, 0, true); 
....................     return 0; 
.................... } 
....................  
.................... // Request for pcib telemetry 
.................... uint8_t command_request_pcib(uint8_t* data) 
.................... { 
....................     uart_clean(PCIB); 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_PCIB - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
....................     memset(cmd, 0, sizeof(request)); 
....................  
....................     request.origin = 0x0B; 
....................     request.cmd = 0xAA; 
....................     request.obc_time = current_time; 
....................  
....................     checksum_obc(cmd, sizeof(request)); 
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
....................         fputc(cmd[i], PCIB); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Request for tmcr1 telemetry 
.................... uint8_t command_request_tmcr1(uint8_t* data) 
.................... { 
....................     uart_clean(TMCR1); 
....................  
....................     if (mux_sel(mux_tmcr1) != mux_tmcr1) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_TMCR1 - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
....................     memset(cmd, 0, sizeof(request)); 
....................  
....................     request.origin = 0x0B; 
....................     request.cmd = 0xAA; 
....................     request.obc_time = current_time; 
....................  
....................     checksum_obc(cmd, sizeof(request)); 
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
....................         fputc(cmd[i], TMCR1); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Request for tmcr2 telemetry 
.................... uint8_t command_request_tmcr2(uint8_t* data) 
.................... { 
....................     uart_clean(TMCR2); 
....................  
....................     if (mux_sel(mux_tmcr2) != mux_tmcr2) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_TMCR2 - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
....................     memset(cmd, 0, sizeof(request)); 
....................  
....................     request.origin = 0x0B; 
....................     request.cmd = 0xAA; 
....................     request.obc_time = current_time; 
....................  
....................     checksum_obc(cmd, sizeof(request)); 
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
....................         fputc(cmd[i], TMCR2); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // ============ ADCS Commands ============ 
....................  
.................... enum adcs_modes { // updated on 2023/05/01 
....................     adcs_mode_tumbling = 0, 
....................     adcs_mode_detumbling = 1, 
....................     adcs_mode_detumble_sun_tracking_auto = 2, 
....................     adcs_mode_sun_tracking = 3, 
....................     adcs_mode_nadir_sband = 4, 
....................     adcs_mode_nadir_camera = 5, 
....................     adcs_mode_target = 6, 
....................     adcs_mode_sun_tracking_quat = 7, 
....................     adcs_mode_target_camera = 8, 
....................     adcs_mode_horizon_camera = 9, 
....................     adcs_mode_nadir_sband_pz = 10, 
....................     adcs_mode_nadir_camera_pz = 11 
.................... }; 
....................  
.................... // Helper function to send STM32 commands (up to 32-bytes) 
.................... void stm32_raw_command(uint8_t* data, uint8_t length, uint8_t tle) 
.................... { 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B, 0x06 }; 
....................     if (tle) { 
....................         adcs_command[1] = 0x07; 
....................     } 
....................     memcpy(adcs_command + 2, data, length); 
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
....................         fputc(adcs_command[i], ADCS); 
....................     } 
....................     fprintf(PC, "STM RAW CMD: "); 
....................     uart_print_pc_hex(adcs_command, sizeof(adcs_command)); 
.................... } 
....................  
.................... // Change ADCS mode internally and externally (helper function) 
.................... void change_adcs_mode(uint8_t mode, uint8_t permanent) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................     } 
....................  
....................     uint8_t adcs_command[3] = { 0x01 }; 
....................     adcs_mode = mode; 
....................     adcs_command[1] = mode; 
....................     adcs_command[2] = permanent; 
....................     stm32_raw_command(adcs_command, sizeof(adcs_command), 0); 
.................... } 
....................  
.................... // Change ADCS mode internally and externally 
.................... uint8_t command_adcs_mode(uint8_t* data) 
.................... { 
....................     // Mux is changed in the helper function change_adcs_mode() 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; // when true, change mode permanently 
....................     }* packet = (struct packet*)data; 
....................     change_adcs_mode(packet->mode, packet->permanent); 
....................     return packet->mode; 
.................... } 
....................  
.................... // Change ADCS default mode 
.................... uint8_t command_adcs_default_mode(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t new_mode; 
....................     }* packet = (struct packet*)data; 
....................  
....................     // Change stored vale in OBC 
....................     obc_flags.adcs_initial_value = packet->new_mode; 
....................     adcs_mode = obc_flags.adcs_initial_value; 
....................     save_state(packet->command); 
....................  
....................     // Change stored value in ADCS 
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................     adcs_mode_st.origin = MSG_COMM; 
....................     adcs_mode_st.command = 0xAD; 
....................     adcs_mode_st.mode = packet->new_mode; 
....................     adcs_mode_st.permanent = true; 
....................     vschedule(current_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
....................  
....................     return adcs_mode; 
.................... } 
....................  
.................... // Schedule ADCS mode (without coordinates) 
.................... uint8_t command_schedule_mode(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_mode; 
....................         time_t mode_scheduled_time; 
....................         uint16_t total_duration; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (packet->mode_scheduled_time == 0) { // debug case 
....................         packet->mode_scheduled_time = current_time; 
....................     } 
....................  
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................  
....................     adcs_mode_st.origin = MSG_COMM; 
....................     adcs_mode_st.command = 0xAD; 
....................     adcs_mode_st.mode = packet->adcs_mode; 
....................     adcs_mode_st.permanent = false; 
....................     vschedule(packet->mode_scheduled_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
....................  
....................     adcs_mode_st.mode = obc_flags.adcs_initial_value; 
....................     vschedule(packet->mode_scheduled_time + packet->total_duration, (uint8_t*)&adcs_mode_st); // ADCS back to default mode 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Print the satellite flags to the debug line 
.................... uint8_t command_print_flags(uint8_t* data) 
.................... { 
....................     print_flags(); 
....................     return 0; 
.................... } 
....................  
.................... // Send a raw command to ADCS 
.................... uint8_t command_adcs_comm_test(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     enum { 
....................         adcs_cmd_size = 16, 
....................         repetitions = 100, 
....................         delay = 2100 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_command[adcs_cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     fprintf(PC, "Sending command %02X %d times to ADCS.\r\n", packet->adcs_command[0], repetitions); 
....................  
....................     uint8_t msg[MSG_LENGTH_ADCS] = { 0 }; 
....................     msg[0] = 0x0B; 
....................     memcpy(msg + 1, packet->adcs_command, adcs_cmd_size); 
....................     msg[MSG_LENGTH_ADCS - 1] = 0x0C; 
....................  
....................     for (uint8_t j = 0; j < repetitions; j++) { 
....................         uart_print_pc_hex(msg, sizeof(msg)); 
....................         fprintf(PC, " (attempt %d)\r\n", j); 
....................         for (uint8_t i = 0; i < sizeof(msg); i++) { 
....................             fputc(msg[i], ADCS); 
....................         } 
....................         delay_ms(delay); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Send a raw command to ADCS 
.................... uint8_t command_adcs_raw(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     enum { adcs_cmd_size = 16 }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_command[adcs_cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t msg[MSG_LENGTH_ADCS] = { 0 }; 
....................     msg[0] = 0x0B; 
....................     memcpy(msg + 1, packet->adcs_command, adcs_cmd_size); 
....................     checksum_obc(msg, sizeof(msg)); 
....................  
....................     uart_print_pc_hex(msg, sizeof(msg)); 
....................  
....................     for (uint8_t i = 0; i < sizeof(msg); i++) { 
....................         fputc(msg[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_stm32_raw_8_16(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
....................     memcpy(stm32_command_uhf, packet->part, length); 
....................     stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
....................  
....................     fprintf(PC, "STM32 command (8/16)"); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
....................  
....................     if (part == 1) { 
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32_tle(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
....................  
....................     if (part == 1) { 
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, true); 
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Receive ADCS telemetry 
.................... uint8_t command_adcs_telemetry(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     response_rx = 1; // Received a reply 
....................  
....................     fprintf(PC, "ADCS: "); 
....................     fprintf(PC, "Mode=%X | ", data[2]); 
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
....................  
....................     telemetry_time.adcs_time = current_time; 
....................     memcpy(telemetry.adcs_message, data + 2, sizeof(telemetry.adcs_message)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Receive GPS time from ADCS 
.................... uint8_t command_adcs_gps_time(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................         uint8_t day; 
....................         uint8_t month; 
....................         uint8_t year; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t valid_time = 0; 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
....................  
....................     if (packet->year == 0x00 || packet->year >= 38) { 
....................         valid_time = 2; 
....................     } else if (obc_flags.gps_time_sync_state == 1 && boot_flags.deployment_flag >= 5) { 
....................         struct_tm gps_time; 
....................         gps_time.tm_year = packet->year + 100; 
....................         gps_time.tm_mon = packet->month - 1; 
....................         gps_time.tm_mday = packet->day; 
....................         gps_time.tm_hour = packet->hour; 
....................         gps_time.tm_min = packet->minute; 
....................         gps_time.tm_sec = packet->second + obc_flags.leap_seconds; 
....................  
....................         time_t unix_time = mktime(&gps_time); 
....................  
....................         time_t delta = unix_time - current_time; 
....................         if (delta < 0) 
....................             delta = -delta; 
....................         if (delta > 30 * 60) { // Do not update time if the difference to the current time is larger than 30 minutes 
....................             valid_time = 3; 
....................         } else { 
....................             valid_time = 1; 
....................             SetTimeSec(unix_time); 
....................             current_time = time(0); 
....................             reset_pic_update_clock(current_time); 
....................             // Change memory location based on the new date 
....................             flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
....................             fprintf(PC, "\r\nNew time: %04ld/%02d/%02d %02d:%02d:%02d", gps_time.tm_year + 1900, 
....................                 (char)gps_time.tm_mon + 1, 
....................                 gps_time.tm_mday, 
....................                 gps_time.tm_hour, 
....................                 gps_time.tm_min, 
....................                 gps_time.tm_sec); 
....................         } 
....................     } 
....................     return valid_time; 
.................... } 
....................  
.................... // ============ COM Commands ============ 
....................  
.................... // Message from UHF 
.................... uint8_t command_uhf_message(uint8_t* data) 
.................... { 
....................     enum { length = 22 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t gs_message[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     static uint8_t last_upload[length] = { 0 }; // Stores the last uploaded command 
....................     static time_t last_upload_t = 0; 
....................  
....................     fprintf(PC, "Uplink: "); 
....................     uint8_t new_length = packet->gs_message[2] != 0xCC ? 14 : length; // Don't pass CRC onwards for short commands 
....................     uart_print_pc_hex(packet->gs_message, new_length); 
....................     uint8_t valid = uplink_valid(packet->gs_message); 
....................     uint8_t different = memcmp(last_upload, packet->gs_message, new_length) || (last_upload_t <= (current_time - 4 * 60)); // Commands are different within 4 min window 
....................     memcpy(last_upload, packet->gs_message, new_length); 
....................     last_upload_t = current_time; 
....................     if (valid && different) { 
....................         fprintf(PC, " Valid uplink"); 
....................         uint8_t cmd[BUFF_LENGTH] = { MSG_COMM }; 
....................         uint8_t copy_size = packet->gs_message[2] != 0xCC ? 9 : new_length; // Don't pass CRC onwards for short commands 
....................         memcpy(cmd + 1, packet->gs_message + 3, copy_size); 
....................         vschedule(current_time, cmd); 
....................     } else { 
....................         fprintf(PC, " Invalid (%d) or identical (%d) uplink.", !valid, !different); 
....................     } 
....................     return !(valid && different); 
.................... } 
....................  
.................... // Change CW mode flags 
.................... uint8_t command_change_cw_mode_flags(uint8_t* data) 
.................... { 
....................     obc_flags.cw_mode = data[2]; // data[2] is the new flag status 
....................     save_state(data[1]);         // data[1] is the current command ID 
....................     return obc_flags.cw_mode; 
.................... } 
....................  
.................... // Ask ADCS if satellite is over Japan 
.................... uint8_t over_japan_check() 
.................... { 
....................     uint8_t command[] = { 0xFC }; 
....................     stm32_raw_command(command, sizeof(command), false); // Send request to ADCS 
....................  
....................     uint8_t response[2] = { 0 }; 
....................     uart_download_packet(&uart_port_MSN, response, sizeof(response), 100000); // Try to get a response 
....................  
....................     if (response[1] == 0xA5) { 
....................         return ((int8_t)response[0] > 0); // Elevation > 0 degrees 
....................     } else { 
....................         return false; 
....................     } 
.................... } 
....................  
.................... // Decides if it is OK to send CW or not based on flags and ADCS 
.................... uint8_t ok_to_send_cw() 
.................... { 
....................     switch (obc_flags.cw_mode) { 
....................     case 0: return false; 
....................     case 1: return over_japan_check(); 
....................     case 2: return true; 
....................     default: return false; 
....................     } 
.................... } 
....................  
.................... // COM CW request 
.................... uint8_t command_com_cw(uint8_t* data) 
.................... { 
....................     enum { com_to_main_size = 25 }; 
....................  
....................     static uint8_t current_cw = 0; 
....................     telemetry.com_rssi = *(uint16_t*)&data[2]; 
....................     telemetry_time.com_time = current_time; 
....................  
....................     // Generate CW reply 
....................     uint8_t cmd[24] = { 0 }; 
....................     cmd[0] = 0x0B; 
....................     cmd[1] = 0x50; 
....................     memcpy(cmd + 2, cw[current_cw], sizeof(cw[0])); 
....................     cmd[sizeof(cw[0]) + 2] = ok_to_send_cw(); 
....................     cmd[23] = 0x0C; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], COMM); 
....................     } 
....................     current_cw++; 
....................     if (current_cw >= sizeof(cw) / sizeof(cw[0])) 
....................         current_cw = 0; 
....................     fprintf(PC, "COM: "); 
....................     uart_print_pc_hex(data, com_to_main_size); 
....................     return 0; 
.................... } 
....................  
.................... // COM Access request 
.................... uint8_t command_com_access_request(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x59 
....................         uint8_t time;    // in minutes 
....................     }* packet = (struct packet*)data; 
....................  
....................     time_t disable_time = current_time + (60 * (time_t)packet->time); 
....................     scheduled_command_clear_specified_command(0xC0, 0x58); 
....................     schedule(current_time, { 0xC0, 0x58, 0x01 }); 
....................     schedule(disable_time, { 0xC0, 0x58, 0x00 }); 
....................  
....................     uint8_t reply[8] = { 0 }; 
....................     send_com_ack(reply); 
....................  
....................     return packet->time; 
.................... } 
....................  
.................... // Change COM access 
.................... uint8_t command_com_access_change(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x58 
....................         uint8_t state;   // 0: OBC side; 1: COM side 
....................     }* packet = (struct packet*)data; 
....................  
....................     output_bit(MUX_SEL_COM_SHARED_FM, packet->state); 
....................     memory_busy = packet->state; 
....................  
....................     return packet->state; 
.................... } 
....................  
.................... // ============ OBC/PCIB Commands ============ 
....................  
.................... // Schedule any command 
.................... uint8_t command_schedule_anything(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;       // C0 
....................         uint8_t command;      // F6 
....................         time_t schedule_time; // Time_T 4 bytes 
....................         uint8_t schedule_command[12]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     vschedule(packet->schedule_time, packet->schedule_command); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Set the clock to a given value (UNIX time, seconds after Jan 1st 1970) 
.................... uint8_t command_set_clock(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t current_time; 
....................         int8_t leap_seconds; 
....................         uint8_t gps_time_sync_state; // Not set here, kept for backward compatibility 
....................         uint8_t skip_telemetry_config; 
....................     }* packet = (struct packet*)data; 
....................     obc_flags.leap_seconds = packet->leap_seconds; 
....................     // obc_flags.gps_time_sync_state = packet->gps_time_sync_state; 
....................  
....................     uint8_t time_updated = 0; 
....................  
....................     if (packet->current_time < T0) { 
....................         time_updated = 1; 
....................         SetTimeSec(T0); // Set clock to as early as possible (Jan 1st 2000, 00:00:00); 
....................         // mai_400_update_clock(T0); 
....................         reset_pic_update_clock(T0); 
....................     } else { 
....................         SetTimeSec(packet->current_time + obc_flags.leap_seconds); 
....................         reset_pic_update_clock(packet->current_time + obc_flags.leap_seconds); 
....................     } 
....................     current_time = time(0); 
....................  
....................     if(!packet->skip_telemetry_config) { // Useful for clock manipulation without disturbing telemetry collection 
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
....................     } 
....................  
....................     struct_tm* local_time = localtime(&current_time); 
....................  
....................     fprintf(PC, " New time: %04ld/%02d/%02d %02d:%02d:%02d(0x%08lX) ", 
....................         local_time->tm_year + 1900, 
....................         (uint8_t)local_time->tm_mon + 1, 
....................         local_time->tm_mday, 
....................         local_time->tm_hour, 
....................         local_time->tm_min, 
....................         local_time->tm_sec, 
....................         current_time); 
....................  
....................     fprintf(PC, "Leap: %d GPS sync: 0x%02X", obc_flags.leap_seconds, obc_flags.gps_time_sync_state); 
....................     return time_updated; 
.................... } 
....................  
.................... // Display the TRIS status to debug port 
.................... uint8_t command_get_tris(uint8_t* data) 
.................... { 
....................     fprintf(PC, "\r\n         fedcba9876543210"); 
....................     fprintf(PC, "\r\ntris_a = "); 
....................     print_binary16(get_tris_a()); 
....................     fprintf(PC, "\r\ntris_b = "); 
....................     print_binary16(get_tris_b()); 
....................     fprintf(PC, "\r\ntris_c = "); 
....................     print_binary16(get_tris_c()); 
....................     fprintf(PC, "\r\ntris_d = "); 
....................     print_binary16(get_tris_d()); 
....................     fprintf(PC, "\r\ntris_e = "); 
....................     print_binary16(get_tris_e()); 
....................     fprintf(PC, "\r\ntris_f = "); 
....................     print_binary16(get_tris_f()); 
....................     fprintf(PC, "\r\ntris_g = "); 
....................     print_binary16(get_tris_g()); 
....................     return 0xEE; 
.................... } 
....................  
.................... // Prints a memory address relative to satellite time (if ptr = 0x0000, prints satellite time). 
.................... uint8_t command_print_memory_address(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t ptr; 
....................     }* packet = (struct packet*)data; 
.................... #ifndef PC_SIM 
....................     uint32_t* addr = (uint32_t*)packet->ptr + &current_time; 
....................     fprintf(PC, "*%04lX = %08lX", addr, *addr); 
.................... #endif 
....................     return 0; 
.................... } 
....................  
.................... // Sets the value of a memory address relative to satellite time 
.................... uint8_t command_set_obc_variable(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t offset; 
....................         uint8_t size; 
....................         uint8_t data[sizeof(uint32_t)]; 
....................         uint8_t save_state; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t* dst = (uint8_t*)&current_time + packet->offset; 
....................     uint8_t* src = packet->data; 
....................  
....................     fprintf(PC, "Changing variable at 0x%04X, size %d to 0x%08LX", dst, packet->size, *(uint32_t*)&packet->data[0]); 
....................     for (uint8_t i = 0; i < packet->size; i++) { 
....................         *(dst + i) = *(src + i); 
....................     } 
....................  
....................     if (packet->save_state == 1) { 
....................         save_state(data[1]); // data[1] is the current command id 
....................     } else if (packet->save_state == 2) { 
....................         save_flags(); 
....................         scheduled_command_clear_all(); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Sends the antenna deployment command to relay pic 
.................... uint8_t command_deploy_antenna(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
....................         // Increment deployment flag and save state 
....................         boot_flags.deployment_flag++; 
....................         get_com_shared_fm_access(); 
....................         save_flags(); 
....................  
....................         uint8_t time = 30;    // in seconds 
....................         if (packet->time_s) { // if specified time is not zero, then use specified value 
....................             time = packet->time_s; 
....................         } 
....................         fprintf(PC, "Deploying UHF Antenna for %ds... ", time); 
....................         output_high(DIO_BURNER_ANTENNA); 
....................         delay_ms((uint32_t)time * 1000); 
....................         output_low(DIO_BURNER_ANTENNA); 
....................         fprintf(PC, "Done!\r\n"); 
....................         return 0; 
....................     } else { 
....................         return 1; 
....................     } 
.................... } 
....................  
.................... // Clear completely the main memory. 
.................... uint8_t command_clear_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
....................     flash_erase(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, ERASE_SECTOR); 
....................     fprintf(PC, "Waiting 10s for reset...\r\n"); 
....................     delay_ms(10000); 
....................     reset_cpu(); 
....................     return 0; 
.................... } 
....................  
.................... // Save state to memory. 
.................... uint8_t command_save_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
....................     save_state(data[1]); // data[1] is the current command id 
....................     return 0; 
.................... } 
....................  
.................... // Dump state. 
.................... uint8_t command_dump_memory(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t start; 
....................         uint32_t size; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................     fprintf(PC, "\r\nHex dump start"); 
....................     switch (packet->source) { 
....................     case 0: 
....................         get_com_shared_fm_access(); 
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
....................         break; 
....................     case 1: 
....................         flash_dump(&spi_port_MAIN_FM, packet->start, packet->start + packet->size); 
....................         break; 
....................     case 2: 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_dump(&spi_port_MISSION_FM, packet->start, packet->start + packet->size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................         break; 
....................     default: 
....................         get_com_shared_fm_access(); 
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
....................         break; 
....................     } 
....................     fprintf(PC, "\r\nHex dump end\r\n"); 
....................     return packet->source; 
.................... } 
....................  
.................... // Helper function to copy data from flash memory to flash memory 
.................... uint8_t copy( 
....................     uint8_t origin, // 0:COM, 1:MAIN, 2:MISSION 
....................     uint8_t dest,   // 0:COM, 1:MAIN, 2:MISSION 
....................     uint32_t to_page_or_sector_or_address, 
....................     uint32_t from_page_or_sector_or_address, 
....................     uint32_t size, // in page or sectors or sectors 
....................     uint8_t mode   // mode: 0 = pages, 1 = sectors, 2 = addressed by byte, size as pages 
.................... ) 
.................... { 
....................     get_com_shared_fm_access(); 
....................  
....................     uint8_t erase_mode; 
....................     uint32_t increment; 
....................  
....................     if (mode == 0 || mode == 2) { 
....................         erase_mode = ERASE_PAGE; 
....................         increment = MEMORY_PAGE_SIZE; 
....................     } else { 
....................         erase_mode = ERASE_SECTOR; 
....................         increment = MEMORY_SECTOR_SIZE; 
....................     } 
....................  
....................     uint32_t to_address = 0; 
....................     uint32_t from_address = 0; 
....................     if (mode == 2) { 
....................         to_address = to_page_or_sector_or_address; 
....................         from_address = from_page_or_sector_or_address; 
....................     } else { 
....................         to_address = to_page_or_sector_or_address * increment; 
....................         from_address = from_page_or_sector_or_address * increment; 
....................     } 
....................  
....................     size *= increment; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX,mode=%d", origin, dest, to_address, from_address, size, mode); 
....................  
....................     // Erase the pages before copying 
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += increment) { 
....................             flash_erase(&spi_port_COM_FM, to_address + i, erase_mode); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += increment) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, erase_mode); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += increment) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, erase_mode); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     if (origin == 0x00 && dest == 0x00) { 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address, &spi_port_COM_FM, to_address, size); 
....................  
....................     } else if (origin == 0x00 && dest == 0x01) { 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address, &spi_port_MAIN_FM, to_address, size); 
....................  
....................     } else if (origin == 0x00 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address, &spi_port_MISSION_FM, to_address, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x01 && dest == 0x00) { 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address, &spi_port_COM_FM, to_address, size); 
....................  
....................     } else if (origin == 0x01 && dest == 0x01) { 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address, &spi_port_MAIN_FM, to_address, size); 
....................  
....................     } else if (origin == 0x01 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address, &spi_port_MISSION_FM, to_address, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x00) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address, &spi_port_COM_FM, to_address, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x01) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address, &spi_port_MAIN_FM, to_address, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address, &spi_port_MISSION_FM, to_address, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else { 
....................         return 1; 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Copy data sectors between flash memories 
.................... uint8_t command_copy_memory_sector(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     return copy(packet->origin_port, packet->destination_port, packet->destination_sector, packet->source_sector, packet->n_sectors, 1); // 1 -> sector copy 
.................... } 
....................  
.................... // Copy data pages between flash memories 
.................... uint8_t command_copy_memory_page(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t source_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     return copy(packet->origin_port, packet->destination_port, packet->destination_page, packet->source_page, packet->n_pages, 0); // 0 -> page copy 
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_page(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_page * MEMORY_PAGE_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_pages * MEMORY_PAGE_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
....................  
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_PAGE); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_PAGE); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_PAGE); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_sector(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_sectors * MEMORY_SECTOR_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
....................  
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_SECTOR); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_SECTOR); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_SECTOR); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t xmodem_send_fn( 
....................     uint32_t source_address, 
....................     uint32_t n_packets, 
....................     uint8_t source, 
....................     uint8_t destination, 
....................     uint32_t destination_address) 
.................... { 
....................     fprintf(PC, "Waiting for xmodem transfer..."); 
....................     uart_fn* destination_uart = NULL; 
....................  
....................     const uint8_t max_tries = 5; 
....................     uint8_t current_try = 0; 
....................     int8_t error = 0; 
....................  
....................     while (current_try < max_tries) { 
....................         switch (destination) { 
....................         case 0: 
....................             destination_uart = &uart_port_PC; 
....................             break; // For PC 
....................         case 1: 
....................             if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................                 if (verbose) { 
....................                     fprintf(PC, "MUX change failed!"); 
....................                 } 
....................                 return 1; 
....................             } 
....................             destination_uart = &uart_port_MSN; 
....................             break; // For PCIB 
....................         case 2: 
....................             if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................                 if (verbose) { 
....................                     fprintf(PC, "MUX change failed!"); 
....................                 } 
....................                 return 1; 
....................             } 
....................             destination_uart = &uart_port_MSN; 
....................             break; // For Rpi 
....................         default: destination_uart = &uart_port_PC; break; 
....................         } 
....................  
....................         if (destination == 2) {                                                            // Rpi 
....................             uint8_t message_pcib[MSG_LENGTH_PCIB] = { 0x0B, 0xCD };                        // Array with request for direct copy relay -> rpi = 0xCD 
....................             checksum_obc(message_pcib, MSG_LENGTH_PCIB);                                   // Add checksum 
....................             uart_send_packet_repeat(&uart_port_MSN, message_pcib, MSG_LENGTH_PCIB, 5, 10); // Send request 5 times, 100ms spaced 
....................             delay_ms(1000); 
....................             fprintf(PCIB, "\nrx,%05lu\n", destination_address); 
....................         } 
....................  
....................         if (destination == 1) { // PCIB 
....................             struct req { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint8_t source; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 9]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req; 
....................             req.origin = MSG_OBC; 
....................             req.command = 0xD1; // X-modem receive; 
....................             req.address = destination_address; 
....................             req.source = 1; // OBC 
....................             checksum_obc((uint8_t*)&req, sizeof(req)); 
....................             uart_send_packet_repeat(&uart_port_MSN, (uint8_t*)&req, sizeof(req), 5, 10); 
....................         } 
....................  
....................         switch (source) { 
....................         case 0: 
....................             get_com_shared_fm_access(); 
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, source_address, n_packets); 
....................             break; 
....................         case 1: 
....................             error = xmodem_send(destination_uart, &spi_port_MAIN_FM, source_address, n_packets); 
....................             break; 
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             error = xmodem_send(destination_uart, &spi_port_MISSION_FM, source_address, n_packets); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................             break; 
....................         default: 
....................             get_com_shared_fm_access(); 
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, source_address, n_packets); 
....................             break; 
....................         } 
....................         current_try++; 
....................         delay_ms(1000); 
....................         if (error != -1) 
....................             break; 
....................     } 
....................     return error; 
.................... } 
....................  
.................... // Send data through xmodem protocol 
.................... uint8_t command_xmodem_send(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D0 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t destination_address; 
....................     }* packet = (struct packet*)data; 
....................  
....................     return xmodem_send_fn(packet->source_address, packet->n_packets, packet->source, packet->destination, packet->destination_address); 
.................... } 
....................  
.................... // Short version of XMODEM send command, similar to flash copy command 
.................... uint8_t command_xmodem_send_sector(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t destination_address = packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t source_address = packet->source_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t n_packets = packet->n_sectors * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     return xmodem_send_fn(source_address, n_packets, packet->source, packet->destination, destination_address); 
.................... } 
....................  
.................... uint8_t xmodem_receive_fn( 
....................     uint32_t destination_address, 
....................     uint8_t source, 
....................     uint8_t destination, 
....................     uint32_t source_address, 
....................     uint32_t n_packets) 
.................... { 
....................     int8_t total_packets = 0; 
....................     fprintf(PC, "Receiving xmodem data..."); 
....................  
....................     uart_fn* source_uart = NULL; 
....................     const uint8_t max_tries = 5; 
....................  
....................     uint8_t current_try = 0; 
....................  
....................     switch (source) { 
....................     case 0: source_uart = &uart_port_PC; break; 
....................     case 1: 
....................         if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................             if (verbose) { 
....................                 fprintf(PC, "MUX change failed!"); 
....................             } 
....................             return 1; 
....................         } 
....................         source_uart = &uart_port_MSN; 
....................         break; 
....................     // case 2: reserved (thermal mission) 
....................     case 3: 
....................         if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................             if (verbose) { 
....................                 fprintf(PC, "MUX change failed!"); 
....................             } 
....................             return 1; 
....................         } 
....................         source_uart = &uart_port_MSN; 
....................         break; 
....................     case 4: 
....................         if (mux_sel(mux_tmcr1) != mux_tmcr1) { // If MUX did not change 
....................             if (verbose) { 
....................                 fprintf(PC, "MUX change failed!"); 
....................             } 
....................             return 1; 
....................         } 
....................         source_uart = &uart_port_MSN; 
....................         break; 
....................     case 5: 
....................         if (mux_sel(mux_tmcr2) != mux_tmcr2) { // If MUX did not change 
....................             if (verbose) { 
....................                 fprintf(PC, "MUX change failed!"); 
....................             } 
....................             return 1; 
....................         } 
....................         source_uart = &uart_port_MSN; 
....................         break; 
....................     default: source_uart = &uart_port_PC; break; 
....................     } 
....................  
....................     while (current_try < max_tries) { 
....................         if (source == 1 || source == 4 || source == 5) { // PCIB, TMCR1 or TMCR2 
....................             struct req_pcib { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint32_t n_packets; 
....................                 uint8_t destination; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 13]; // the lenght is the same for the 3 subsystems 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req_pcib; 
....................             req_pcib.origin = MSG_OBC; 
....................             req_pcib.command = 0xD0; // X-modem send; 
....................             req_pcib.address = source_address; 
....................             req_pcib.n_packets = n_packets; 
....................             req_pcib.destination = 1; // OBC 
....................             checksum_obc((uint8_t*)&req_pcib, sizeof(req_pcib)); 
....................             uart_send_packet_repeat(source_uart, (uint8_t*)&req_pcib, sizeof(req_pcib), 1, 10); 
....................             delay_ms(100); 
....................         } else if (source == 2 || source == 3) { // Thermal or ADCS 
....................             struct req_adcs { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint32_t n_packets; 
....................                 uint8_t destination; 
....................                 uint8_t padding[MSG_LENGTH_ADCS - 13]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req_adcs; 
....................             req_adcs.origin = MSG_OBC; 
....................             req_adcs.command = 0xD0; // X-modem send; 
....................             req_adcs.address = source_address; 
....................             req_adcs.n_packets = n_packets; 
....................             req_adcs.destination = 1; // OBC 
....................             checksum_obc((uint8_t*)&req_adcs, sizeof(req_adcs)); 
....................             uart_send_packet_repeat(source_uart, (uint8_t*)&req_adcs, sizeof(req_adcs), 1, 10); 
....................             delay_ms(100); 
....................         } 
....................         if (source == 2 || source == 3) { 
....................             delay_ms(5000); 
....................         } 
....................  
....................         switch (destination) { 
....................         case 0: 
....................             get_com_shared_fm_access(); 
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, destination_address); 
....................             break; 
....................         case 1: 
....................             total_packets = xmodem_receive(source_uart, &spi_port_MAIN_FM, destination_address); 
....................             break; 
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             total_packets = xmodem_receive(source_uart, &spi_port_MISSION_FM, destination_address); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................             break; 
....................         default: 
....................             get_com_shared_fm_access(); 
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, destination_address); 
....................             break; 
....................         } 
....................         current_try++; 
....................         delay_ms(1000); 
....................         if (total_packets != -1) 
....................             break; 
....................     } 
....................     return total_packets; 
.................... } 
....................  
.................... // Receive data through xmodem protocol 
.................... uint8_t command_xmodem_receive(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     }* packet = (struct packet*)data; 
....................     return (xmodem_receive_fn(packet->destination_address, packet->source, packet->destination, packet->source_address, packet->n_packets)); 
.................... } 
....................  
.................... // Short version of XMODEM receive command, similar to flash copy command 
.................... uint8_t command_xmodem_receive_sector(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t destination_address = packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t source_address = packet->source_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t n_packets = packet->n_sectors * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX\r\n", packet->source, packet->destination, destination_address, source_address, n_packets); 
....................  
....................     return xmodem_receive_fn(destination_address, packet->source, packet->destination, source_address, n_packets); 
.................... } 
....................  
.................... uint8_t command_clear_all_schedule_commands(uint8_t* data) 
.................... { 
....................     scheduled_command_clear_all(); 
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_boot_flag_set(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
....................     uint8_t value = data[2]; 
....................     boot_flags.deployment_flag = value; 
....................     save_flags(); 
....................     scheduled_command_clear_all(); 
....................     return value; 
.................... } 
....................  
.................... // Reset log command 
.................... uint8_t command_reset_log(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Main PIC reset detected."); 
....................     return boot_flags.deployment_flag; 
.................... } 
....................  
.................... // Telemetry keeping function 
.................... uint8_t command_save_telemetry(uint8_t* data) 
.................... { 
....................     if (!memory_busy) { 
....................         // Write the obc timestamp to telemetry and relative collection times 
....................         telemetry.obc_time = current_time; 
....................         telemetry.reset_time = current_time - telemetry_time.reset_time > 255 ? 255 : current_time - telemetry_time.reset_time; 
....................         telemetry.fab_time = current_time - telemetry_time.fab_time > 255 ? 255 : current_time - telemetry_time.fab_time; 
....................         telemetry.msn_time = current_time - telemetry_time.msn_time > 255 ? 255 : current_time - telemetry_time.msn_time; 
....................         telemetry.pcib_time = current_time - telemetry_time.pcib_time > 255 ? 255 : current_time - telemetry_time.pcib_time; 
....................         telemetry.adcs_time = current_time - telemetry_time.adcs_time > 255 ? 255 : current_time - telemetry_time.adcs_time; 
....................         telemetry.com_time = current_time - telemetry_time.com_time > 255 ? 255 : current_time - telemetry_time.com_time; 
....................  
....................         // Save telemetry to flash 
....................         uint8_t* telemetry_data = (uint8_t*)&telemetry; 
....................         flash_cycle_write(&spi_port_COM_FM, telemetry_data, &addr_flags.flash_telemetry); 
....................         fprintf(PC, "Saving telemetry data: "); 
....................         fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_telemetry.current - sizeof(telemetry)); 
....................  
....................         build_cw(); // Prepare CW strings 
....................         if (verbose) 
....................             deserialize_cw();   // For debug only 
....................         initialize_telemetry(); // Reset for next iteration 
....................  
....................         // Save satellite log to flash 
....................         log_flush(); 
....................  
....................         // Save addresses to flash 
....................         address_rotation addr; 
....................  
....................         uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
....................  
....................         addr.flash_log_current = addr_flags.flash_log.current; 
....................         addr.flash_telemetry_current = addr_flags.flash_telemetry.current; 
....................         addr.flash_sel_zes_current = addr_flags.flash_sel_zes.current; 
....................         addr.flash_sel_ref_current = addr_flags.flash_sel_ref.current; 
....................  
....................         flash_cycle_write(&spi_port_COM_FM, addr_flag_ptr, &addr_flags.flash_addr); 
....................         return 0; 
....................     } else { 
....................         fprintf(PC, "Skipping saving telemetry data."); 
....................         return 1; 
....................     } 
.................... } 
....................  
.................... // Change OCP's default state 
.................... uint8_t command_ocp_state(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;     // 0xC0 
....................         uint8_t command;    // 0xAE 
....................         uint8_t on_off;     // 0: off; 1: on 
....................         uint8_t ocp_number; // 0: adcs; 1: MCP; 2: pcib 
....................     }* packet = (struct packet*)data; 
....................  
....................     enum { 
....................         ocp_adcs = 0, 
....................         ocp_MCP = 1, 
....................         ocp_relay = 2 
....................     }; 
....................  
....................     switch (packet->ocp_number) { 
....................     case ocp_adcs: 
....................         output_bit(OCP_EN_ADCS, packet->on_off); 
....................         obc_flags.adcs_on_off = packet->on_off; 
....................         save_state(data[1]); // data[1] is the current command id 
....................         return obc_flags.adcs_on_off; 
....................     case ocp_MCP: 
....................         output_bit(OCP_EN_MCP, packet->on_off); 
....................         obc_flags.MCP_on_off = packet->on_off; 
....................         save_state(data[1]); // data[1] is the current command id 
....................         return obc_flags.MCP_on_off; 
....................     case ocp_relay: 
....................         output_bit(OCP_EN_RELAY, packet->on_off); 
....................         obc_flags.relay_on_off = packet->on_off; 
....................         save_state(data[1]); // data[1] is the current command id 
....................         return obc_flags.relay_on_off; 
....................     } 
....................  
....................     return -1; 
.................... } 
....................  
.................... // void boot_commands_clear_nth(uint8_t n) 
.................... uint8_t command_boot_cmd_clear_nth(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t n; 
....................     }* packet = (struct packet*)data; 
....................     boot_commands_clear_nth(packet->n); 
....................     boot_commands_write(); 
....................     return 0; 
.................... } 
....................  
.................... // void boot_commands_clear_all() 
.................... uint8_t command_boot_cmd_clear_all(uint8_t* data) 
.................... { 
....................     boot_commands_clear_all(); 
....................     boot_commands_write(); 
....................     return 0; 
.................... } 
....................  
.................... // Add a boot command 
.................... uint8_t command_boot_cmd_add(uint8_t* data) 
.................... { 
....................     enum { length = MSG_LENGTH_COMM - 13 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t delay_from_boot; 
....................         uint8_t new_boot_cmd[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     boot_command bc; 
....................     bc.time = packet->delay_from_boot; 
....................     memcpy(bc.command, packet->new_boot_cmd, length); 
....................     boot_commands_add(bc); 
....................     boot_commands_write(); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // ============ Reset Commands ============ 
....................  
.................... // Reset pic telemetry data 
.................... uint8_t command_reset_telemetry(uint8_t* data) 
.................... { 
....................     response_rx = 1; // Received a reply 
....................     struct packet { 
....................         uint8_t message[MSG_LENGTH_RST - 10]; 
....................         uint8_t padding[9]; // empty part 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     fprintf(PC, "RESET: "); 
....................     uart_print_pc_hex(data, MSG_LENGTH_RST); 
....................  
....................     if (rst_clock_update) { 
....................         rst_clock_updated = 1; 
....................         rst_clock_update = 0; 
....................         struct_tm rst_time; 
....................         rst_time.tm_year = (unsigned long)packet->message[2] + 100; 
....................         rst_time.tm_mon = (unsigned long)packet->message[3] - 1; 
....................         rst_time.tm_mday = (unsigned long)packet->message[4]; 
....................         rst_time.tm_hour = (unsigned long)packet->message[5]; 
....................         rst_time.tm_min = (unsigned long)packet->message[6]; 
....................         rst_time.tm_sec = (unsigned long)packet->message[7] + 1; 
....................         SetTime(&rst_time); 
....................         time_t new_time = mktime(&rst_time); 
....................         // mai_400_update_clock(new_time); 
....................         current_time = new_time; 
....................         previous_time = new_time; 
....................         reset_time = new_time; 
....................         // Read stored commands from memory 
....................         get_com_shared_fm_access(); 
....................         uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
....................         flash_transfer_data_to_ram( 
....................             &spi_port_COM_FM, 
....................             SCHEDULED_CMD_ADDRESS, 
....................             cmd_ptr, 
....................             sizeof(scheduled_commands)); 
....................         // Remove scheduled commads that are scheduled to run in the past 
....................         for(uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................             if(scheduled_commands[i].time < current_time + 1800L) { 
....................                 scheduled_commands[i].time = TIME_T_MAX; 
....................                 fprintf(PC, "\r\nWarning: a scheduled command (%02X %02X) in flash memory was scheduled to run in a past date/time and was marked as complete.\r\n", scheduled_commands[i].command[0], scheduled_commands[i].command[1]); 
....................             } 
....................         } 
....................         // Read and schedule boot commands 
....................         boot_commands_schedule(); 
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
....................  
....................         struct_tm* local_time = localtime(&current_time); 
....................         fprintf(PC, " New time: %04ld/%02d/%02d %02d:%02d:%02d (0x%08lX)", 
....................             local_time->tm_year + 1900, 
....................             (uint8_t)local_time->tm_mon + 1, 
....................             local_time->tm_mday, 
....................             local_time->tm_hour, 
....................             local_time->tm_min, 
....................             local_time->tm_sec, 
....................             current_time); 
....................     } 
....................  
....................     telemetry_time.reset_time = current_time; 
....................     memcpy(telemetry.reset_message, packet->message + 2, sizeof(telemetry.reset_message)); 
....................     return rst_clock_updated; 
.................... } 
....................  
.................... // Warn that 24-hour reset is about to happen 
.................... uint8_t command_reset_warning(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................  
....................     // uint8_t adcs_cmd[] = { 0x22 }; 
....................     // mai_400_command(adcs_cmd, sizeof(adcs_cmd)); 
....................  
....................     save_state(data[1]); // data[1] is the current command id 
....................  
....................     // Reply: 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t relay_warning[MSG_LENGTH_PCIB] = { 0 }; 
....................     relay_warning[0] = MSG_OBC; 
....................     relay_warning[1] = 0xFF; // Reset warning 
....................     checksum_obc(relay_warning, sizeof(relay_warning)); 
....................     uart_send_packet_repeat(&uart_port_MSN, relay_warning, sizeof(relay_warning), 5, 100000); 
....................  
....................     fprintf(PC, "Waiting for 24h reset...\r\n"); 
....................     delay_ms(60000); 
....................     delay_ms(60000); 
....................  
....................     fprintf(PC, "No 24h reset happened, doing soft reset instead.\r\n"); 
....................     reset_cpu(); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Reset pic acknowledge of time change 
.................... uint8_t command_time_change_ack(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Reset PIC time change ACK."); 
....................     return 0; 
.................... } 
....................  
.................... // Passes a command from ground-station to reset pic 
.................... uint8_t command_send_data_to_reset(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................     struct packet { 
....................         uint8_t command;     // C0: comm pic message 
....................         uint8_t reset_cmd;   // F5: reset message 
....................         uint8_t data[8];     // data to be passed to reset pic 
....................         uint8_t silent_mode; // if equals to 1, do not print debug message 
....................     }* packet = (struct packet*)data; 
....................     uint8_t cmd[36] = { 0 }; 
....................     cmd[0] = 0xB0; 
....................     for (i = 0; i < 8; i++) { 
....................         cmd[i + 1] = packet->data[i]; 
....................     } 
....................     cmd[35] = 0xB1; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     if (packet->silent_mode != 1) 
....................         uart_print_pc_hex(cmd, sizeof(cmd)); 
....................     return 0; 
.................... } 
....................  
.................... // ============ EPS Commands ============ 
....................  
.................... uint8_t command_eps_telemetry(uint8_t* data) 
.................... { 
....................     enum { cmd_len = 7 }; 
....................     response_rx = 1; // Received a reply 
....................     fprintf(PC, "EPS: "); 
....................  
....................     uint16_t voltage_hex = make16(data[50], data[51]); 
....................     uint16_t current_hex = make16(data[54], data[55]); 
....................     uint16_t temperature_hex = make16(data[56], data[57]); 
....................  
....................     float voltage = voltage_hex * 3.3 * 3 / 4096; 
....................     float current = (3952.5 * current_hex * 3.28 / 4096) - 6479.5; 
....................     float temperature = 75 - temperature_hex * 3.256 * 30 / 4096; 
....................     fprintf(PC, "V=%f, C=%f, T=%f | ", voltage, current, temperature); 
....................  
....................     uint16_t heater_ref_temperature = make16(data[60], data[61]); 
....................     uint16_t heater_ref_voltage = make16(data[62], data[63]); 
....................  
....................     if ((heater_ref_temperature != obc_flags.heater_ref_temperature) || (heater_ref_voltage != obc_flags.heater_ref_voltage)) { 
....................         // E0 66 TH TL VH VL 
....................         fprintf(PC, " New T=0x%04lX, V=0x%04lX | ", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
....................         uint8_t cmd_temp[cmd_len]; 
....................         cmd_temp[0] = 0xC0;                                      // COM_MSG 
....................         cmd_temp[1] = 0x6C;                                      // OBC_CMD 
....................         cmd_temp[2] = 0x66;                                      // EPS_CMD 
....................         cmd_temp[3] = (obc_flags.heater_ref_temperature >> 8);   // TEMP_HIGH 
....................         cmd_temp[4] = (obc_flags.heater_ref_temperature & 0xFF); // TEMP_LOW 
....................         cmd_temp[5] = (obc_flags.heater_ref_voltage >> 8);       // V_HIGH 
....................         cmd_temp[6] = (obc_flags.heater_ref_voltage & 0xFF);     // V_LOW 
....................         vschedule(current_time + 5, cmd_temp); 
....................     } 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_FAB); 
....................     telemetry_time.fab_time = current_time; 
....................     memcpy(telemetry.fab_message, data + 2, sizeof(telemetry.fab_message)); 
....................     return 0; 
.................... } 
....................  
.................... // Passes a command from ground-station to eps pic 
.................... uint8_t command_send_data_to_eps(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................     enum { data_size = 5 }; 
....................     struct packet { 
....................         uint8_t command;         // C0: com pic message 
....................         uint8_t eps_cmd;         // 6C: eps message 
....................         uint8_t data[data_size]; // data to be passed to reset pic 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t cmd[data_size + 1] = { 0 }; 
....................     cmd[0] = 0xE0; 
....................     for (i = 0; i < data_size; i++) { 
....................         cmd[i + 1] = packet->data[i]; 
....................     } 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], FAB); 
....................     } 
....................  
....................     fprintf(PC, "EPS cmd: "); 
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... typedef enum { 
....................     mcp_cmd_telemetry_req = 0x10, 
....................     mcp_cmd_opera_on = 0x20, 
....................     mcp_cmd_opera_off = 0x2F, 
....................     mcp_cmd_zes_reset = 0x30, 
....................     mcp_cmd_ref_status = 0x35, 
....................     mcp_cmd_tmcr1_on = 0x40, 
....................     mcp_cmd_tmcr1_off = 0x4F, 
....................     mcp_cmd_tmcr2_on = 0x50, 
....................     mcp_cmd_tmcr2_off = 0x5F 
.................... } mcp_command; 
....................  
.................... // Turn on/off OCPs in MCP 
.................... uint8_t command_mcp(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // 2A for MCP OCP control 
....................         uint8_t mcp_command; 
....................         uint16_t data; 
....................     }* packet = (struct packet*)data; 
....................  
....................     send_mcp_command(packet->mcp_command, packet->data, false); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_eps_set_heater_ref(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t command;   // C0: com pic message 
....................         uint8_t eps_cmd;   // 6D: heater ref settings 
....................         uint16_t temp_ref; // temperature reference 
....................         uint16_t v_ref;    // voltage reference 
....................     }* packet = (struct packet*)data; 
....................  
....................     obc_flags.heater_ref_temperature = packet->temp_ref; 
....................     obc_flags.heater_ref_voltage = packet->v_ref; 
....................     save_state(packet->eps_cmd); 
....................  
....................     fprintf(PC, "New T=0x%04lX, V=0x%04lX", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_obc_kill_on(uint8_t* data) 
.................... { 
....................     uint8_t kill_sw_status = 0; 
....................     if (data[2] == 0x55 && data[4] == 0x55 && data[6] == 0x55 && data[8] == 0x55 && data[3] == 0xAA && data[5] == 0xAA && data[7] == 0xAA && data[9] == 0xAA) { 
....................         kill_sw_status = 1; 
....................         output_high(OBC_KILL_DIO); 
....................     } 
....................     return kill_sw_status; 
.................... } 
....................  
.................... uint8_t command_obc_kill_off(uint8_t* data) 
.................... { 
....................     output_low(OBC_KILL_DIO); 
....................     return 0; 
.................... } 
....................  
.................... // ADCS RAW command part a 
.................... uint8_t command_adcs_raw_part_a(uint8_t* data) 
.................... { 
....................     enum { raw_a_size = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_a[raw_a_size]; 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memcpy(adcs_raw_part_a, packet->part_a, raw_a_size); 
....................     adcs_raw_part_a_crc0 = packet->crc0; 
....................  
....................     uart_print_pc_hex(adcs_raw_part_a, sizeof(adcs_raw_part_a)); 
....................     fprintf(PC, "Received adcs raw command part a."); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // ADCS RAW command part b 
.................... uint8_t command_adcs_raw_part_b(uint8_t* data) 
.................... { 
....................     enum { raw_b_size = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_b[raw_b_size]; 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memcpy(adcs_raw_part_b, packet->part_b, raw_b_size); 
....................     adcs_raw_part_b_crc0 = packet->crc0; 
....................  
....................     uart_print_pc_hex(adcs_raw_part_b, sizeof(adcs_raw_part_b)); 
....................     fprintf(PC, "Received adcs raw command part b."); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Helper function to calculate ADCS checksum 
.................... void checksum_adcs(uint8_t* data, int size) 
.................... { 
....................     uint16_t result = 0; 
....................     for (int i = 0; i < (size - 2); i++) { 
....................         result += data[i]; 
....................     } 
....................     unsigned char* ptr = (unsigned char*)&result; 
....................     data[size - 1] = ptr[1]; 
....................     data[size - 2] = ptr[0]; 
.................... } 
....................  
.................... // Send MAI-400 command (max 40-bytes) 
.................... void mai_400_command(uint8_t* data, int length) 
.................... { 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B }; 
....................     memcpy(adcs_command + 1, data, length); 
....................     checksum_adcs(adcs_command + 1, 40); 
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
....................     for (int i = 0; i < sizeof(adcs_command); i++) { 
....................         fputc(adcs_command[i], ADCS); 
....................     } 
.................... } 
....................  
.................... // ADCS RAW command part c 
.................... uint8_t command_adcs_raw_part_c(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     enum { raw_c_size = 6, 
....................         padding_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_c[raw_c_size]; 
....................         uint8_t padding[padding_size]; 
....................         uint8_t crc0_part_a; 
....................         uint8_t crc0_part_b; 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (adcs_raw_part_a_crc0 != packet->crc0_part_a) { 
....................         uart_print_pc_hex(packet->part_c, raw_c_size); 
....................         fprintf(PC, "Received adcs raw part c. Part a pairing error."); 
....................     } else if (adcs_raw_part_b_crc0 != packet->crc0_part_b) { 
....................         uart_print_pc_hex(packet->part_c, raw_c_size); 
....................         fprintf(PC, "Received adcs raw part c. Part b pairing error."); 
....................     } else { 
....................         uint8_t adcs_cmd[40]; 
....................         memcpy(adcs_cmd, adcs_raw_part_a, sizeof(adcs_raw_part_a)); 
....................         memcpy(adcs_cmd + sizeof(adcs_raw_part_a), adcs_raw_part_b, sizeof(adcs_raw_part_b)); 
....................         memcpy(adcs_cmd + sizeof(adcs_raw_part_a) + sizeof(adcs_raw_part_b), packet->part_c, raw_c_size); 
....................         mai_400_command(adcs_cmd, sizeof(adcs_cmd)); 
....................         uart_print_pc_hex(adcs_cmd, sizeof(adcs_cmd)); 
....................         fprintf(PC, "Received adcs raw part c. Pairing ok."); 
....................     } 
....................     memset(&adcs_raw_part_a, 0, sizeof(adcs_raw_part_a)); // Erase old data. 
....................     memset(&adcs_raw_part_b, 0, sizeof(adcs_raw_part_b)); // Erase old data. 
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_to_deploy_SAP(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
....................         uint8_t time = 30;           // in seconds 
....................         if (packet->time_s) {        // if specified time is not zero, then use specified value 
....................             time = packet->time_s; 
....................         } 
....................         fprintf(PC, "Deploying SAP for %ds... ", time); 
....................         output_high(DIO_BURNER_SAP); 
....................         delay_ms((uint32_t)time * 1000); 
....................         output_low(DIO_BURNER_SAP); 
....................         fprintf(PC, "Done!\r\n"); 
....................         return 0; 
....................     } else { 
....................         return 1; 
....................     } 
.................... } 
....................  
.................... uint8_t command_to_deploy_SMA(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
....................         uint8_t time = 60;           // in seconds 
....................         if (packet->time_s) {        // if specified time is not zero, then use specified value 
....................             time = packet->time_s; 
....................         } 
....................         fprintf(PC, "Deploying SMA for %ds... ", time); 
....................         output_high(DIO_BURNER_SMA); 
....................         delay_ms((uint32_t)time * 1000); 
....................         output_low(DIO_BURNER_SMA); 
....................         fprintf(PC, "Done!\r\n"); 
....................         return 0; 
....................     } else { 
....................         return 1; 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // General command for ZES SEL mission (sub-function 1) 
.................... uint8_t command_sel1_zes(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     schedule(current_time, { 0xC0, 0x0F });      // Check UART 
....................     schedule(current_time + 15, { 0xC0, 0x19 }); // Data initialization 
....................  
....................     struct new_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     } new_packet; 
....................  
....................     new_packet.origin = MSG_COMM; 
....................     new_packet.command = 0x12; 
....................     new_packet.repetitions = packet->repetitions;                             // Number of times to do the copy command to main bus 
....................     new_packet.delay_between_repetitions = packet->delay_between_repetitions; // time between copies 
....................  
....................     vschedule(current_time + 30, (uint8_t*)&new_packet); // Data copy 
....................     return 0; 
.................... } 
....................  
.................... // General command for REF SEL mission (sub-function 2) 
.................... uint8_t command_sel2_ref(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     schedule(current_time, { 0xC0, 0x1F });      // Check UART 
....................     schedule(current_time + 15, { 0xC0, 0x80 }); // Data initialization 
....................  
....................     struct new_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     } new_packet; 
....................  
....................     new_packet.origin = MSG_COMM; 
....................     new_packet.command = 0x81; 
....................     new_packet.repetitions = packet->repetitions;                             // Number of times to do the copy command to main bus 
....................     new_packet.delay_between_repetitions = packet->delay_between_repetitions; // time between copies 
....................  
....................     vschedule(current_time + 30, (uint8_t*)&new_packet); // Data copy 
....................     return 0; 
.................... } 
....................  
.................... // Send 0x3A to ZES 
.................... // Send CMD 1 of SEL 1 ZES (0x3A) to ZES_RX, and ZES_TX will send back hex number 5A (0x5A) as acknowledgement. 
.................... uint8_t command_sel1_a(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_zes) != mux_sel_zes) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
....................         fprintf(PC, "\r\nAttempt %d\r\n", attempt); 
....................         fputc(0x3A, SEL_ZES); 
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
....................         while (++timeout < 5) { 
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
....................             if (kbhit(SEL_ZES)) { 
....................                 uint8_t r = fgetc(SEL_ZES); 
....................                 if (r == 0x5A) { 
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
....................                     return r; 
....................                 } 
....................             } 
....................             delay_ms(1000); 
....................         } 
....................         timeout = 0; 
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
....................     return 0xFF; 
.................... } 
....................  
.................... // Send reset function (Initialization of SEL Board) 
.................... uint8_t command_sel1_b(uint8_t* data) 
.................... { 
....................     send_mcp_command(mcp_cmd_zes_reset, 0, 0); 
....................     return 0; 
.................... } 
....................  
.................... // Send 0x2A to ZES 
.................... // Send CMD 3 of SEL 1 ZES (0x2A) to ZES_RX, and ZES_TX will send back hex number A2 (0xA2) as data initialization. 
.................... uint8_t command_sel1_c(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_zes) != mux_sel_zes) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
....................         fprintf(PC, "\r\n\r\nAttempt %d\r\n", attempt); 
....................         fputc(0x2A, SEL_ZES); // Prepare Data from ZES board 
....................  
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
....................         while (++timeout < 5) { 
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
....................             if (kbhit(SEL_ZES)) { 
....................                 uint8_t r = fgetc(SEL_ZES); 
....................                 if (r == 0xA2) { 
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
....................                     return r; 
....................                 } 
....................             } 
....................             delay_ms(1000); 
....................         } 
....................         timeout = 0; 
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
....................     return 0xFF; 
.................... } 
....................  
.................... // Send 0x2E to ZES (revised) 
.................... // Send CMD 4 of (0x2E) to ZES_RX, and ZES_TX will send back a first data stream. 
.................... uint8_t command_sel1_d(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (mux_sel(mux_sel_zes) != mux_sel_zes) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t sel1_d_buffer[128]; 
....................  
....................     for (uint8_t i = 0; i < packet->repetitions; i++) { 
....................         fprintf(PC, "Part no. %d: ", i); 
....................         fputc(0x2E, SEL_ZES); 
....................  
....................         uart_download_packet(&uart_port_MSN, sel1_d_buffer, sizeof(sel1_d_buffer), 100000); 
....................  
....................         if (sel1_d_buffer[0] == 0x2A && sel1_d_buffer[127] == 0x89) { 
....................             for (uint8_t k = 0; k < 128; k++) { 
....................                 fprintf(PC, "%X ", sel1_d_buffer[k]); 
....................             } 
....................             get_com_shared_fm_access(); 
....................             fprintf(PC, "\r\nSaving SEL ZES data: "); 
....................             fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_sel_zes.current); 
....................             flash_cycle_write(&spi_port_COM_FM, sel1_d_buffer, &addr_flags.flash_sel_zes); 
....................         } else { 
....................             fprintf(PC, "Failed to get data from SEL.\r\n"); 
....................         } 
....................         delay_ms(packet->delay_between_repetitions); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Send 0x26 to REF 
.................... // Send CMD 1 of SEL 1 REF (0x26) to REF_RX, and REF_TX will send back hex number A9 (0xA9) as acknowledgement. 
.................... uint8_t command_sel2_a(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_ref) != mux_sel_ref) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
....................         fprintf(PC, "\r\nAttempt %d\r\n", attempt); 
....................         fputc(0x26, SEL_REF); 
....................         delay_ms(1000); // TODO test with and without this delay and see if it is needed 
....................  
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
....................         while (++timeout < 5) { 
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
....................             if (kbhit(SEL_REF)) { 
....................                 uint8_t r = fgetc(SEL_REF); 
....................                 if (r == 0xA9) { 
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
....................                     return r; 
....................                 } 
....................             } 
....................             delay_ms(1000); 
....................         } 
....................         timeout = 0; 
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
....................     return 0xFF; 
.................... } 
....................  
.................... // Fifteen minutes status check 
.................... uint8_t command_sel2_b(uint8_t* data) 
.................... { 
....................     send_mcp_command(mcp_cmd_ref_status, 0, 0); 
....................     return 0; 
.................... } 
....................  
.................... // Send 0x5E to REF 
.................... // Send CMD 3 of SEL 1 REF (0x5E) to REF_RX, and REF_TX will send back hex number A7 (0xA7) as data initialization. 
.................... uint8_t command_sel2_c(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_sel_ref) != mux_sel_ref) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t timeout = 0; 
....................  
....................     const uint8_t n_tries = 3; // Number of total tries for the procedure 
....................  
....................     for (uint8_t attempt = 0; attempt < n_tries; attempt++) { 
....................         fprintf(PC, "\r\nAttempt %d\r\n", attempt); 
....................         fputc(0x5E, SEL_REF); 
....................         delay_ms(700); 
....................  
....................         fprintf(PC, "Ready to receive acknowledgement from SEL... \r\n"); 
....................         while (++timeout < 5) { 
....................             fprintf(PC, "Waiting for acknowledgement... \r\n"); 
....................             if (kbhit(SEL_REF)) { 
....................                 uint8_t r = fgetc(SEL_REF); 
....................                 if (r == 0xA7) { 
....................                     fprintf(PC, "Ack = %X | \r\n", r); 
....................                     return r; 
....................                 } 
....................             } 
....................             delay_ms(1000); 
....................         } 
....................         timeout = 0; 
....................     } 
....................  
....................     fprintf(PC, "Failed to get an ack after %d tries.\r\n", n_tries); 
....................     return 0xFF; 
.................... } 
....................  
.................... // Send 0x7E to REF 
.................... // Send CMD 4 of (0x7E) to REF_RX, and REF_TX will send back a first data stream. 
.................... uint8_t command_sel2_d(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t repetitions; 
....................         uint32_t delay_between_repetitions; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (mux_sel(mux_sel_ref) != mux_sel_ref) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t sel2_d_buffer[128]; 
....................  
....................     for (uint8_t i = 0; i < packet->repetitions; i++) { 
....................         fprintf(PC, "Part no. %d: ", i); 
....................         // Sending command to the SEL_REF 
....................         fputc(0x7E, SEL_REF); 
....................  
....................         uart_download_packet(&uart_port_MSN, sel2_d_buffer, sizeof(sel2_d_buffer), 100000); 
....................  
....................         if (sel2_d_buffer[0] == 0x2A && sel2_d_buffer[127] == 0x89) { 
....................             for (uint8_t k = 0; k < 128; k++) { 
....................                 fprintf(PC, "%X ", sel2_d_buffer[k]); 
....................             } 
....................             get_com_shared_fm_access(); 
....................             fprintf(PC, "\r\nSaving SEL REF data: "); 
....................             fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_sel_ref.current); 
....................             flash_cycle_write(&spi_port_COM_FM, sel2_d_buffer, &addr_flags.flash_sel_ref); 
....................         } else { 
....................             fprintf(PC, "Failed to get data from SEL.\r\n"); 
....................         } 
....................         delay_ms(packet->delay_between_repetitions); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_iMTQ_Dipole_Actuation(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "iMTQ Dipole Activation.......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x1D, 0x06, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0x10, 0x27, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_iMTQ_No_Opeartion(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "iMTQ No Opeartion.......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x1D, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_3v3_Enable(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "RW 3v3 Enable.......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_RW_Motor_Enable(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "RW Motor Enable.......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_RW_Enable(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "RW Enable......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_RW_Speed(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "RW Speed.......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x3A, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_RW_Reset(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_adcs) != mux_adcs) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "RW Reset.......\r\n"); 
....................     const unsigned char cmd[44] = { 0x0B, 0x06, 0x3A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x41, 0x00, 0x0C }; 
....................     for (int i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], ADCS); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Receive Mission Control PIC Status 
.................... uint8_t command_mission_control_PIC_status(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t status; 
....................     }* packet = (struct packet*)data; 
....................  
....................     response_rx = 1; // Received a reply 
....................  
....................     uint16_t status = packet->status; 
....................  
....................     // Print each bit with its corresponding shorthand and value 
....................     fprintf(PC, "MCP: "); 
....................     fprintf(PC, "opera_5v5_dc_dc = %u, ", (uint8_t)((status & (1 << 0)) ? 1 : 0)); 
....................     fprintf(PC, "opera_ocp1 = %u, ", (uint8_t)((status & (1 << 1)) ? 1 : 0)); 
....................     fprintf(PC, "opera_ocp2 = %u, ", (uint8_t)((status & (1 << 2)) ? 1 : 0)); 
....................     fprintf(PC, "sel_com_pr = %u, ", (uint8_t)((status & (1 << 3)) ? 1 : 0)); 
....................     fprintf(PC, "sel_com_res = %u, ", (uint8_t)((status & (1 << 4)) ? 1 : 0)); 
....................     fprintf(PC, "sel_com_pg = %u, ", (uint8_t)((status & (1 << 5)) ? 1 : 0)); 
....................     fprintf(PC, "sel_com_flag = %u, ", (uint8_t)((status & (1 << 6)) ? 1 : 0)); 
....................     fprintf(PC, "tmcr1_ocp = %u, ", (uint8_t)((status & (1 << 7)) ? 1 : 0)); 
....................     fprintf(PC, "tmcr2_ocp = %u, ", (uint8_t)((status & (1 << 8)) ? 1 : 0)); 
....................     fprintf(PC, "sel_status = %u | ", (uint8_t)((status & (1 << 9)) ? 1 : 0)); 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_MCPIC); 
....................  
....................     telemetry_time.msn_time = current_time; 
....................     memcpy(telemetry.msn_message, data + 2, sizeof(telemetry.msn_message)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Used to stop the simulation 
.................... uint8_t command_debug(uint8_t* data) 
.................... { 
.................... #ifdef PC_SIM 
....................     fprintf(PC, "Exiting simulation"); 
....................     continue_program = 0; 
.................... #else 
....................     verbose = !verbose; 
.................... #endif // !PC_SIM 
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_opera_full(uint8_t* data) 
.................... { 
....................     enum { packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 }; 
....................  
....................     if (mux_sel(mux_opera) != mux_opera) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     uart_print_pc_hex(data, BUFF_LENGTH); 
....................  
....................     uint8_t opera_cmd[packet_size] = { 0 }; 
....................  
....................     opera_cmd[0] = 0x2A; 
....................     memcpy(opera_cmd + 1, data + 2, packet_size - 2); 
....................     opera_cmd[packet_size - 1] = 0x80; 
....................  
....................     uart_send_packet(&uart_port_MSN, opera_cmd, sizeof(opera_cmd)); 
....................     uint8_t ack[1] = { 0 }; 
....................     uart_download_packet(&uart_port_MSN, ack, sizeof(ack), 100000); // Try to get the ACK 
....................     memset(&opera_GA_part_a, 0, sizeof(opera_GA_part_a));           // Erase old data. 
....................     return ack[0]; 
.................... } 
....................  
.................... uint8_t command_opera_GA_part_a(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_a_parameters[GA_part_a_size]; 
....................         // No padding is required 
....................         uint8_t crc0; 
....................         uint8_t crc1; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memcpy(opera_GA_part_a, packet->part_a_parameters, GA_part_a_size); 
....................  
....................     fprintf(PC, "Received OPERA GA part a: "); 
....................     uart_print_pc_hex(opera_GA_part_a, sizeof(opera_GA_part_a)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_opera_GA_part_b(uint8_t* data) 
.................... { 
....................     enum { packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part_b_parameters[GA_part_b_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t opera_cmd[packet_size] = { 0xC0, 0xFF }; 
....................     uint8_t opera_off[packet_size] = { 0xC0, 0xFF, 0xFF }; 
....................  
....................     time_t* opera_turn_on_time = (time_t*)opera_GA_part_a;                            // The first part in the command is time information 
....................     uint16_t* opera_mission_duration = (uint16_t*)(opera_GA_part_a + sizeof(time_t)); // The second part in the command is the mission duration 
....................  
....................     uint8_t scheduled = !!*opera_turn_on_time; 
....................  
....................     if (!*opera_turn_on_time) { 
....................         *opera_turn_on_time = current_time; 
....................     } 
....................  
....................     memcpy(opera_cmd + 2, opera_GA_part_a + sizeof(time_t) + sizeof(uint16_t), sizeof(opera_GA_part_a) - sizeof(time_t)); 
....................     memcpy(opera_cmd + 2 + sizeof(opera_GA_part_a) - sizeof(time_t) - sizeof(uint16_t), packet->part_b_parameters, GA_part_b_size); 
....................  
....................     fprintf(PC, "Received OPERA part b: "); 
....................     uart_print_pc_hex(opera_cmd + 2, sizeof(opera_cmd) - sizeof(time_t) - 2); 
....................  
....................     fprintf(PC, " Scheduling commands..."); 
....................  
....................     schedule(*opera_turn_on_time, { 0xC0, 0x2A, mcp_cmd_opera_on, 0x00, 0x00 }); 
....................     vschedule(*opera_turn_on_time + obc_flags.opera_boot_duration, opera_cmd); 
....................     vschedule(*opera_turn_on_time + obc_flags.opera_boot_duration + *opera_mission_duration, opera_off); 
....................     schedule(*opera_turn_on_time + obc_flags.opera_boot_duration + *opera_mission_duration + 40, { 0xC0, 0x2A, mcp_cmd_opera_off, 0x00, 0x00 }); 
....................  
....................     return scheduled; 
.................... } 
....................  
.................... uint8_t command_opera_GA_single(uint8_t* data) 
.................... { 
....................     enum { 
....................         length = 16 - sizeof(time_t) - sizeof(uint16_t), 
....................         packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t opera_turn_on_time; 
....................         uint16_t opera_mission_duration; 
....................         uint8_t opera_command[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t opera_cmd[packet_size] = { 0xC0, 0xFF }; 
....................     uint8_t opera_off[packet_size] = { 0xC0, 0xFF, 0xFF }; 
....................  
....................     uint8_t scheduled = !!packet->opera_turn_on_time; 
....................  
....................     if (!packet->opera_turn_on_time) { 
....................         packet->opera_turn_on_time = current_time; 
....................     } 
....................  
....................     memcpy(opera_cmd + 2, packet->opera_command, length); 
....................  
....................     fprintf(PC, "Received OPERA command: "); 
....................     uart_print_pc_hex(opera_cmd, sizeof(opera_cmd)); 
....................  
....................     fprintf(PC, " Scheduling commands..."); 
....................  
....................     schedule(packet->opera_turn_on_time, { 0xC0, 0x2A, mcp_cmd_opera_on, 0x00, 0x00 }); 
....................     vschedule(packet->opera_turn_on_time + obc_flags.opera_boot_duration, opera_cmd); 
....................     vschedule(packet->opera_turn_on_time + obc_flags.opera_boot_duration + packet->opera_mission_duration, opera_off); 
....................     schedule(packet->opera_turn_on_time + obc_flags.opera_boot_duration + packet->opera_mission_duration + 40, { 0xC0, 0x2A, mcp_cmd_opera_off, 0x00, 0x00 }); 
....................  
....................     return scheduled; 
.................... } 
....................  
.................... uint32_t swap32(uint32_t k) 
.................... { 
....................     return ((k << 24) | ((k & 0x0000FF00) << 8) | ((k & 0x00FF0000) >> 8) | (k >> 24)); 
.................... } 
....................  
.................... // Ask OPERA to copy data to mission shared FM, then copy data to COM shared FM 
.................... uint8_t command_copy_opera_to_com(uint8_t* data) 
.................... { 
....................     enum { 
....................         packet_lenght = 10, 
....................         packet_size = GA_part_a_size + GA_part_b_size - sizeof(time_t) - sizeof(uint16_t) + 2 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xEB 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t mission_number; 
....................         uint32_t address; 
....................         uint8_t n_pages; 
....................         uint8_t state; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t cpacket[MSG_LENGTH_OPERA] = { 0 }; 
....................  
....................     struct copy_packet { 
....................         uint8_t origin;  // 0x2A 
....................         uint8_t command; // 0x2C 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t mission_number; 
....................         uint32_t address; 
....................         uint8_t n_pages; 
....................     }* copy_packet = (struct copy_packet*)cpacket; 
....................  
....................     uint8_t ack[1] = { 0 }; 
....................     time_t scheduled_time = current_time; 
....................     fprintf(PC, "OPERA copy command: "); 
....................     uint8_t state = packet->state; 
....................  
....................     time_t opera_copy_delay = 17L * packet->n_pages; 
....................  
....................     enum state_machine { 
....................         state_turn_on = 0, 
....................         state_copy_opera_mission = 1, 
....................         state_turn_off_opera = 2, 
....................         state_copy_mission_com = 3 
....................     }; 
....................  
....................     uint8_t opera_off[packet_size] = { 0xC0, 0xFF, 0xFF }; 
....................  
....................     switch (state) { 
....................     case state_turn_on: 
....................         fprintf(PC, "Turning on OPERA..."); 
....................         send_mcp_command(mcp_cmd_opera_on, 0, true); 
....................         scheduled_time += obc_flags.opera_boot_duration; 
....................         packet->state = state_copy_opera_mission; 
....................         vschedule(scheduled_time, data); 
....................         return state; 
....................     case state_copy_opera_mission: 
....................         fprintf(PC, "Copying data from OPERA to Mission SFM..."); 
....................         memcpy(cpacket, data, packet_lenght); 
....................         copy_packet->origin = 0x2A; 
....................         copy_packet->command = 0x2C; 
....................         copy_packet->address = swap32(packet->address); // Convert from little endian to big endian 
....................         cpacket[sizeof(cpacket) - 1] = 0x80;            // Footer 
....................         if (mux_sel(mux_opera) == mux_opera) {          // Try to change mission shared FM mux position to OPERA 
....................             mux_lock_unlock(true, opera_copy_delay);    // Get exclusive access for some time 
....................         } else { 
....................             fprintf(PC, "Error: mux did not change!"); 
....................             ack[0] = 0xDE; 
....................         } 
....................         delay_ms(100); 
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_OPERA, 1, 100); // Send 1 times with 100ms delay 
....................         uart_download_packet(&uart_port_MSN, ack, sizeof(ack), 100000);             // Try to get a response 
....................         scheduled_time += opera_copy_delay;                                         // OPERA copy time 
....................         packet->state = state_turn_off_opera; 
....................         vschedule(scheduled_time, data); 
....................         return ack[0]; 
....................     case state_turn_off_opera: 
....................         fprintf(PC, "Sending OPERA turn off command...\r\n"); 
....................         vschedule(current_time, opera_off); 
....................         scheduled_time += 40; 
....................         packet->state = state_copy_mission_com; 
....................         vschedule(scheduled_time, data); 
....................         return state; 
....................     case state_copy_mission_com: 
....................         fprintf(PC, "Turning off OPERA and copying data from Mission SFM to COM SFM..."); 
....................         send_mcp_command(mcp_cmd_opera_off, 0, true); 
....................         copy(2, 0, packet->address, packet->address, packet->n_pages, 2); // Copy from mission shared FM (2) to com shared FM (0), in byte address mode (2) 
....................         return state; 
....................     default: 
....................         fprintf(PC, "Invalid state!"); 
....................         return state; 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Ask subsystem to copy data to mission shared FM, then copy data to COM shared FM 
.................... uint8_t command_copy_mission_to_com(uint8_t* data) 
.................... { 
....................     enum { 
....................         adcs_copy_delay = 54,  // seconds for one sector copy 
....................         pcib_copy_delay = 6,   // seconds for one sector copy 
....................         tmcr1_copy_delay = 54, // seconds for one sector copy 
....................         tmcr2_copy_delay = 54, // seconds for one sector copy 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xEA 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t size;       // in sectors 
....................         uint8_t data_source; // 0: OBC 
....................     }* packet = (struct packet*)data; 
....................  
....................     enum { 
....................         dsource_obc = 0, 
....................         dsource_adcs = 1, 
....................         dsource_relay = 2, 
....................         dsource_tmcr_n = 3, 
....................         dsource_tmcr_b4 = 4 
....................         // OPERA has a separate command 
....................     }; 
....................  
....................     uint8_t cpacket[MAX_LENGTH] = { 0 }; 
....................  
....................     struct copy_packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t size; 
....................         uint8_t data_destination; 
....................         uint8_t data_source; 
....................     }* copy_packet = (struct copy_packet*)cpacket; 
....................  
....................     switch (packet->data_source) { 
....................     case dsource_obc: 
....................         copy(2, 0, packet->destination_sector, packet->source_sector, packet->size, 1); // Source and destination: 0=COM, 1=MAIN, 2=MISSION ; mode = 1 -> sector copy; get access to memory 
....................         break; 
....................     case dsource_adcs: 
....................         fprintf(PC, "Waiting for ADCS copy..."); 
....................         if (mux_sel(mux_adcs) == mux_adcs) {                                 // Try to change mission shared FM mux position to ADCS 
....................             mux_lock_unlock(true, ((time_t)adcs_copy_delay) * packet->size); // Get exclusive access for some time 
....................         } else { 
....................             return 2; // Mux did not change 
....................         } 
....................         delay_ms(100); 
....................         copy_packet->origin = MSG_OBC; 
....................         copy_packet->command = 0xCB; // Copy sectors command on ADCS pic 
....................         copy_packet->destination_sector = packet->destination_sector; 
....................         copy_packet->source_sector = packet->source_sector; 
....................         copy_packet->size = packet->size; 
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
....................         checksum_obc(cpacket, MSG_LENGTH_ADCS); 
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_ADCS, 5, 100); // Send 5 times with 100ms delay 
....................         packet->data_source = 0; 
....................         packet->source_sector = packet->destination_sector; 
....................         vschedule(current_time + (time_t)adcs_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
....................         break; 
....................     case dsource_relay: 
....................         fprintf(PC, "Waiting for RELAY copy..."); 
....................         if (mux_sel(mux_pcib) == mux_pcib) {                                 // Try to change mission shared FM mux position to PCIB 
....................             mux_lock_unlock(true, ((time_t)pcib_copy_delay) * packet->size); // Get exclusive access for some time 
....................         } else { 
....................             return 2; // Mux did not change 
....................         } 
....................         delay_ms(100); 
....................         copy_packet->origin = MSG_OBC; 
....................         copy_packet->command = 0x0B; // Copy sectors command on RELAY PIC 
....................         copy_packet->destination_sector = packet->destination_sector; 
....................         copy_packet->source_sector = packet->source_sector; 
....................         copy_packet->size = packet->size; 
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
....................         checksum_obc(cpacket, MSG_LENGTH_PCIB); 
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_PCIB, 1, 10); // Send 1 time 
....................         packet->data_source = 0; 
....................         packet->source_sector = packet->destination_sector; 
....................         vschedule(current_time + (time_t)pcib_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
....................         break; 
....................     case dsource_tmcr_b4: 
....................         fprintf(PC, "Waiting for TMCR B4 copy..."); 
....................         if (mux_sel(mux_tmcr1) == mux_tmcr1) {                                 // Try to change mission shared FM mux position to TMCR1 
....................             mux_lock_unlock(true, ((time_t)tmcr1_copy_delay) * packet->size); // Get exclusive access for some time 
....................         } else { 
....................             return 2; // Mux did not change 
....................         } 
....................         delay_ms(100); 
....................         copy_packet->origin = MSG_OBC; 
....................         copy_packet->command = 0x0B; // Copy sectors command on RELAY PIC 
....................         copy_packet->destination_sector = packet->destination_sector; 
....................         copy_packet->source_sector = packet->source_sector; 
....................         copy_packet->size = packet->size; 
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
....................         checksum_obc(cpacket, MSG_LENGTH_TMCR1); 
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_TMCR1, 1, 10); // Send 1 time 
....................         packet->data_source = 0; 
....................         packet->source_sector = packet->destination_sector; 
....................         vschedule(current_time + (time_t)tmcr1_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
....................         break; 
....................     case dsource_tmcr_n: 
....................         fprintf(PC, "Waiting for TMCR N copy..."); 
....................         if (mux_sel(mux_tmcr2) == mux_tmcr2) {                                 // Try to change mission shared FM mux position to TMCR2 
....................             mux_lock_unlock(true, ((time_t)tmcr2_copy_delay) * packet->size); // Get exclusive access for some time 
....................         } else { 
....................             return 2; // Mux did not change 
....................         } 
....................         delay_ms(100); 
....................         copy_packet->origin = MSG_OBC; 
....................         copy_packet->command = 0x0B; // Copy sectors command on RELAY PIC 
....................         copy_packet->destination_sector = packet->destination_sector; 
....................         copy_packet->source_sector = packet->source_sector; 
....................         copy_packet->size = packet->size; 
....................         copy_packet->data_destination = 1; // 0:LOCAL, 1:SHARED 
....................         copy_packet->data_source = 0;      // 0:LOCAL, 1:SHARED 
....................         checksum_obc(cpacket, MSG_LENGTH_TMCR2); 
....................         uart_send_packet_repeat(&uart_port_MSN, cpacket, MSG_LENGTH_TMCR2, 1, 10); // Send 1 time 
....................         packet->data_source = 0; 
....................         packet->source_sector = packet->destination_sector; 
....................         vschedule(current_time + (time_t)tmcr2_copy_delay * (time_t)packet->size, (uint8_t*)packet); 
....................         break; 
....................     default: 
....................         return 1; 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Resetting satellite (all powera lines) any time 
.................... uint8_t command_reset_all_power_lines(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................  
....................     save_state(data[1]); // data[1] is the current command id 
....................  
....................     // Reply: 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................  
....................     fprintf(PC, "Waiting for resetting all power lines...\r\n"); 
....................     delay_ms(30000); 
....................     // delay_ms(60000); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_rpi_end_of_transmission(uint8_t* data) 
.................... { 
....................     scheduled_command_clear_specified_command(0xC0, 0x5E); // Remove all S-band turn off commands 
....................     scheduled_command_clear_specified_command(0xC0, 0xBE); // Remove all RPi turn off commands 
....................     schedule(current_time, { 0xC0, 0x5E, 0x00 });          // Turn off S-band TX now 
....................     schedule(current_time + 1, { 0xC0, 0xBE, 0x02 });      // Rpi off (soft) after 1s 
....................     schedule(current_time + 20, { 0xC0, 0xBE, 0x00 });     // Rpi off (hard) after 20s 
....................     return 0; 
.................... } 
....................  
.................... // Enable / disable S-band TX 
.................... uint8_t command_enable_disable_sband(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t enable_disable; // 0 = disabled, 1 = enabled 
....................         uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
....................     memcpy(ptr, data, 3); 
....................     pcib_pkg.origin = MSG_OBC; 
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
....................  
....................     fprintf(PC, "TX "); 
....................     if (pcib_pkg.enable_disable == 0x00) { 
....................         fprintf(PC, "OFF | "); 
....................     } else if (pcib_pkg.enable_disable == 0x01) { 
....................         fprintf(PC, "ON | "); 
....................     } 
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
....................  
....................     sband_tx_status = pcib_pkg.enable_disable; 
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); // PCIB -> MSN for structures 
....................  
....................     return (pcib_pkg.enable_disable & 0x01); 
.................... } 
....................  
.................... // Enable / disable raspberry pi 
.................... uint8_t command_enable_disable_rpi(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t enable_disable; // 0 = disable, 1 = enable, 2 = warn 
....................         uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
....................     memcpy(ptr, data, 3); 
....................     pcib_pkg.origin = MSG_OBC; 
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
....................  
....................     if (pcib_pkg.enable_disable == 0x00) { 
....................         fprintf(PC, "RPI OFF | "); 
....................         rpi_status = pcib_pkg.enable_disable; 
....................     } else if (pcib_pkg.enable_disable == 0x01) { 
....................         fprintf(PC, "RPI ON | "); 
....................         rpi_status = pcib_pkg.enable_disable; 
....................     } else if (pcib_pkg.enable_disable == 0x02) { 
....................         fprintf(PC, "RPI SOFT | "); 
....................         rpi_status = pcib_pkg.enable_disable; 
....................     } 
....................  
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); 
....................  
....................     return pcib_pkg.enable_disable; 
.................... } 
....................  
.................... uint8_t command_rpi_clean_up(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     const uint8_t packet_erase_time = 60; // in seconds 
....................     const uint8_t rpi_turn_on_time = 60;  // in seconds 
....................  
....................     fprintf(PC, "\r\nRPi command: clean_up\r\n"); 
....................  
....................     schedule(current_time + 2, { 0xC0, 0xBE, 0x01 });                                         // Turn on Rpi 
....................     schedule(current_time + rpi_turn_on_time, { 0xC0, 0xCC, 0xC0 });                          // Clean up command 
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time, { 0xC0, 0xBE, 0x02 });      // Turn off Rpi (soft) 
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time + 20, { 0xC0, 0xBE, 0x00 }); // Turn off Rpi (hard) 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_rpi_clean_logfile(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     const uint8_t packet_erase_time = 60; // in seconds 
....................     const uint8_t rpi_turn_on_time = 60;  // in seconds 
....................  
....................     fprintf(PC, "\r\nRPi command: clean_logfile\r\n"); 
....................  
....................     schedule(current_time + 2, { 0xC0, 0xBE, 0x01 });                                         // Turn on Rpi 
....................     schedule(current_time + rpi_turn_on_time, { 0xC0, 0xCC, 0xC1 });                          // Clean logfile command 
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time, { 0xC0, 0xBE, 0x02 });      // Turn off Rpi (soft) 
....................     schedule(current_time + rpi_turn_on_time + packet_erase_time + 20, { 0xC0, 0xBE, 0x00 }); // Turn off Rpi (hard) 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_pcib_telemetry(uint8_t* data) 
.................... { 
....................     uint8_t i = 1; 
....................  
....................     enum { 
....................         length = MSG_LENGTH_PCIB, 
....................         magnetometer_size = 6 
....................     }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         uint16_t sband_temperature; 
....................         uint8_t sband_tx_status; 
....................         uint8_t rpi_status; 
....................         uint8_t magnetometer[magnetometer_size]; 
....................         uint8_t fill[length - 8 - magnetometer_size]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     response_rx = 1; // Received a reply 
....................  
....................     // Pruint8_t for debug: 
....................     fprintf(PC, "RELAY: Ts=%lX, Stx=%d, Rp=%d | ", packet->sband_temperature, packet->sband_tx_status, packet->rpi_status); 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_PCIB); 
....................  
....................     // PCIB telemetry -> OBC telemetry: 
....................     struct pcib_telemetry { 
....................         uint16_t sband_temperature; 
....................         uint8_t sband_tx_status; 
....................         uint8_t rpi_status; 
....................         uint8_t magnetometer[magnetometer_size]; 
....................     } pcib_telemetry; 
....................  
....................     pcib_telemetry.sband_temperature = packet->sband_temperature; 
....................     pcib_telemetry.sband_tx_status = packet->sband_tx_status; 
....................     pcib_telemetry.rpi_status = packet->rpi_status; 
....................     memcpy(pcib_telemetry.magnetometer, packet->magnetometer, magnetometer_size); 
....................  
....................     telemetry_time.pcib_time = current_time; 
....................     memcpy(telemetry.pcib_message, &pcib_telemetry, sizeof(telemetry.pcib_message)); 
....................  
....................     // Monitor and fix on/off status: 
....................     if (sband_tx_status != packet->sband_tx_status) { 
....................         fprintf(PC, " Stx -> %d", sband_tx_status); 
....................         struct packet_s_tx { 
....................             uint8_t origin;         // 0xC0 
....................             uint8_t command;        // 0x5E 
....................             uint8_t enable_disable; // 0 = disabled, 1 = enabled 
....................             uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................         } packet_s_tx; 
....................         packet_s_tx.origin = 0xC0; 
....................         packet_s_tx.command = 0x5E; 
....................         packet_s_tx.enable_disable = sband_tx_status; 
....................         memset(packet_s_tx.padding, 0, sizeof(packet_s_tx.padding)); 
....................         vschedule(current_time + i++, (uint8_t*)&packet_s_tx); 
....................     } 
....................     if (rpi_status != packet->rpi_status) { 
....................         fprintf(PC, " Rpi -> %d", rpi_status); 
....................         struct packet_rpi { 
....................             uint8_t origin; 
....................             uint8_t command; 
....................             uint8_t enable_disable; // 0 = disable, 1 = enable, 2 = warn 
....................             uint8_t padding[MSG_LENGTH_PCIB - 3]; 
....................         } packet_rpi; 
....................         packet_rpi.origin = 0xC0; 
....................         packet_rpi.command = 0xBE; 
....................         packet_rpi.enable_disable = rpi_status; 
....................         memset(packet_rpi.padding, 0, sizeof(packet_rpi.padding)); 
....................         vschedule(current_time + i++, (uint8_t*)&packet_rpi); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_tmcr1_telemetry(uint8_t* data) 
.................... { 
....................     enum { length = MSG_LENGTH_TMCR1 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         uint8_t fill[length - 4]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     (void)packet; // TODO remove 
....................  
....................     response_rx = 1; // Received a reply 
....................  
....................     fprintf(PC, "TMCR1: "); 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_TMCR1); 
....................  
....................     // TODO write TMCR1 data to telemetry 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_tmcr2_telemetry(uint8_t* data) 
.................... { 
....................     enum { length = MSG_LENGTH_TMCR2 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         uint8_t fill[length - 4]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     (void)packet; // TODO remove 
....................  
....................     response_rx = 1; // Received a reply 
....................  
....................     fprintf(PC, "TMCR2: "); 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_TMCR2); 
....................  
....................     // TODO write TMCR2 data to telemetry 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_raw_pcib(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     enum { cmd_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t pcib_command[cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (packet->pcib_command[0] == 0xBE) { 
....................         rpi_status = packet->pcib_command[1]; 
....................     } else if (packet->pcib_command[0] == 0x5E) { 
....................         sband_tx_status = packet->pcib_command[1]; 
....................     } 
....................  
....................     uint8_t pcib_cmd[MSG_LENGTH_PCIB] = { 0 }; 
....................     pcib_cmd[0] = 0x0B; 
....................     memcpy(pcib_cmd + 1, packet->pcib_command, cmd_size); 
....................     checksum_obc(pcib_cmd, MSG_LENGTH_PCIB); 
....................     uart_send_packet_repeat(&uart_port_MSN, pcib_cmd, MSG_LENGTH_PCIB, 5, 10); 
....................     return packet->pcib_command[0]; 
.................... } 
....................  
.................... uint8_t command_raw_tmcr(uint8_t* data) 
.................... { 
....................     enum { cmd_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t tmcr_command[cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if(packet->command == 0xCE) { 
....................         if (mux_sel(mux_tmcr1) != mux_tmcr1) { // If MUX did not change 
....................             if (verbose) { 
....................                 fprintf(PC, "MUX change failed!"); 
....................             } 
....................             return 1; 
....................         } 
....................     } else if(packet->command == 0xCF) { 
....................         if (mux_sel(mux_tmcr2) != mux_tmcr2) { // If MUX did not change 
....................             if (verbose) { 
....................                 fprintf(PC, "MUX change failed!"); 
....................             } 
....................             return 1; 
....................         } 
....................     } else { 
....................         fprintf(PC, "Unexpected command ID!"); 
....................         return -1; 
....................     } 
....................  
....................     uint8_t tmcr_cmd[MSG_LENGTH_TMCR1] = { 0 }; 
....................     tmcr_cmd[0] = 0x0B; 
....................     memcpy(tmcr_cmd + 1, packet->tmcr_command, cmd_size); 
....................     checksum_obc(tmcr_cmd, MSG_LENGTH_TMCR1); 
....................     uart_send_packet_repeat(&uart_port_MSN, tmcr_cmd, MSG_LENGTH_TMCR1, 5, 10); 
....................     return packet->tmcr_command[0]; 
.................... } 
....................  
.................... // Revert s-band configuration command 
.................... uint8_t command_sband_defaults(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................     fprintf(PC, "Reverting s-band configuration... "); 
....................     uint8_t pcib_pkg[MSG_LENGTH_PCIB] = { 0 }; 
....................     memset(pcib_pkg, 0, MSG_LENGTH_PCIB); 
....................     memcpy(pcib_pkg, data, 10); 
....................     pcib_pkg[0] = MSG_OBC; 
....................     checksum_obc(pcib_pkg, MSG_LENGTH_PCIB); 
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, pcib_pkg, MSG_LENGTH_PCIB, 5, 10); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_sband_downlink(uint8_t* data) 
.................... { 
....................     enum { param_size = 12 }; 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xED 
....................         time_t scheduled_time; 
....................         uint8_t mission_parameters[param_size]; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 18]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     const uint8_t rpi_turn_on_time = 60;  // in seconds 
....................     const uint8_t sband_warm_up_time = 1; // in seconds 
....................  
....................     uint16_t bit_offset = 0; 
....................  
....................     uint16_t downlink_timeout = get_bits(packet->mission_parameters, &bit_offset, 10); 
....................     uint8_t adcs_mode = get_bits(packet->mission_parameters, &bit_offset, 5); 
....................  
....................     downlink_timeout = downlink_timeout ? downlink_timeout : 300; // in seconds; if zero, 300 seconds 
....................  
....................     // If not zero, convert and print the scheduled time 
....................     if(packet->scheduled_time) { 
....................         fprintf(PC, "\r\n"); 
....................  
....................         struct tm* local_time = localtime(&packet->scheduled_time); 
....................         fprintf(PC, "Scheduled Time: %04ld/%02d/%02d %02d:%02d:%02d (0x%08lX)\r\n", 
....................             local_time->tm_year + 1900, 
....................             local_time->tm_mon + 1, 
....................             local_time->tm_mday, 
....................             local_time->tm_hour, 
....................             local_time->tm_min, 
....................             local_time->tm_sec, 
....................             (uint32_t)packet->scheduled_time); // 32 bits 
....................  
....................         // Print the deserialized values for verification 
....................         fprintf(PC, "Downlink Timeout: %lu\r\n", downlink_timeout); // 16 bits 
....................         fprintf(PC, "ADCS Mode: %u\r\n", adcs_mode);                // 8 bits 
....................     } else { 
....................         fprintf(PC, "Starting s-band downlink routine.\r\n"); 
....................     } 
....................  
....................     if (packet->scheduled_time != 0) { 
....................         time_t scheduled_time = packet->scheduled_time - rpi_turn_on_time - sband_warm_up_time; 
....................         packet->scheduled_time = 0; 
....................         vschedule(scheduled_time, data); // Scheduling itself with time set as zero 
....................         if (adcs_mode) { 
....................             struct adcs_mode_st { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint8_t mode; 
....................                 uint8_t permanent; 
....................             } adcs_mode_st; 
....................             adcs_mode_st.origin = MSG_COMM; 
....................             adcs_mode_st.command = 0xAD; 
....................             adcs_mode_st.mode = adcs_mode; 
....................             adcs_mode_st.permanent = false; 
....................             vschedule(scheduled_time - 3 * 60 * 60, (uint8_t*)&adcs_mode_st); // ADCS nadir camera 3 hours before 
....................             adcs_mode_st.mode = obc_flags.adcs_initial_value; 
....................             vschedule(scheduled_time + 10 * 60, (uint8_t*)&adcs_mode_st); // ADCS back to default mode after 10m 
....................         } 
....................         fprintf(PC, "Scheduling s-band DL command."); 
....................         return 0; 
....................     } 
....................  
....................     packet->command = 0xEE; 
....................  
....................     schedule(current_time + 2, { 0xC0, 0xBE, 0x01 });                                                             // Turn on Rpi 
....................     schedule(current_time + rpi_turn_on_time, { 0xC0, 0x5E, 0x01 });                                              // Turn on S-band TX 
....................     vschedule(current_time + rpi_turn_on_time + sband_warm_up_time, data);                                        // Downlink command 
....................     schedule(current_time + rpi_turn_on_time + sband_warm_up_time + downlink_timeout, { 0xC0, 0x5E, 0x00 });      // Turn off S-band TX 
....................     schedule(current_time + rpi_turn_on_time + sband_warm_up_time + downlink_timeout + 1, { 0xC0, 0xBE, 0x02 });  // Turn off Rpi (soft) 
....................     schedule(current_time + rpi_turn_on_time + sband_warm_up_time + downlink_timeout + 21, { 0xC0, 0xBE, 0x00 }); // Turn off Rpi (hard) 
....................  
....................     return 0; 
.................... } 
....................  
.................... // End to end test command 
.................... uint8_t command_sband_end_to_end(uint8_t* data) 
.................... { 
....................     enum { param_size = 12 }; 
....................  
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0xEE 
....................         time_t scheduled_time; 
....................         uint8_t mission_parameters[param_size]; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 18]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint16_t bit_offset = 0; 
....................  
....................     uint16_t downlink_timeout = get_bits(packet->mission_parameters, &bit_offset, 10); 
....................     uint8_t adcs_mode = get_bits(packet->mission_parameters, &bit_offset, 5); 
....................     uint16_t file_number = get_bits(packet->mission_parameters, &bit_offset, 16); 
....................     uint16_t first_packet = get_bits(packet->mission_parameters, &bit_offset, 16); 
....................     uint16_t end_packet = get_bits(packet->mission_parameters, &bit_offset, 16); 
....................     uint8_t number_of_repetitions = get_bits(packet->mission_parameters, &bit_offset, 5); 
....................     uint8_t bitrate = get_bits(packet->mission_parameters, &bit_offset, 3); 
....................     uint8_t power = get_bits(packet->mission_parameters, &bit_offset, 1); 
....................     uint8_t delay_before_tx = get_bits(packet->mission_parameters, &bit_offset, 6); 
....................     uint8_t image_seq_start = get_bits(packet->mission_parameters, &bit_offset, 6); 
....................     uint8_t image_seq_end = get_bits(packet->mission_parameters, &bit_offset, 6); 
....................     uint8_t type = get_bits(packet->mission_parameters, &bit_offset, 3); 
....................     uint8_t camera_selection = get_bits(packet->mission_parameters, &bit_offset, 3); 
....................  
....................     downlink_timeout = downlink_timeout ? downlink_timeout : 300; // in seconds; if zero, 300 seconds 
....................  
....................     fprintf(PC, "\r\n"); 
....................  
....................     // Print the deserialized values for verification 
....................     fprintf(PC, "Downlink Timeout: %lu\r\n", downlink_timeout);          // 16 bits 
....................     fprintf(PC, "ADCS Mode: %u\r\n", adcs_mode);                         // 8 bits 
....................     fprintf(PC, "File Number: %lu\r\n", file_number);                    // 16 bits 
....................     fprintf(PC, "First Packet: %lu\r\n", first_packet);                  // 16 bits 
....................     fprintf(PC, "End Packet: %lu\r\n", end_packet);                      // 16 bits 
....................     fprintf(PC, "Number of Repetitions: %u\r\n", number_of_repetitions); // 8 bits 
....................  
....................     fprintf(PC, "Bitrate: "); 
....................     switch (bitrate) { 
....................     case 0: fprintf(PC, "10kbps\r\n"); break; 
....................     case 1: fprintf(PC, "20kbps\r\n"); break; 
....................     case 2: fprintf(PC, "25kbps\r\n"); break; 
....................     case 3: fprintf(PC, "50kbps\r\n"); break; 
....................     case 4: fprintf(PC, "64kbps\r\n"); break; 
....................     case 5: fprintf(PC, "100kbps\r\n"); break; 
....................     case 6: fprintf(PC, "250kbps\r\n"); break; 
....................     case 7: fprintf(PC, "500kbps\r\n"); break; 
....................     } 
....................  
....................     fprintf(PC, "Power: %u\r\n", power);                      // 8 bits 
....................     fprintf(PC, "Delay Before Tx: %u\r\n", delay_before_tx);  // 8 bits 
....................     fprintf(PC, "Image seq. start: %u\r\n", image_seq_start); // 8 bits 
....................     fprintf(PC, "Image seq. end: %u\r\n", image_seq_end);     // 8 bits 
....................     fprintf(PC, "Type: %u\r\n", type);                        // 8 bits 
....................     fprintf(PC, "Camera Selection: %u%u%u\r\n", 
....................         (camera_selection >> 2) & 0x1, 
....................         (camera_selection >> 1) & 0x1, 
....................         camera_selection & 0x1); // 3 bits 
....................  
....................     struct sband_command { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mission_parameters[param_size]; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 14]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
....................     pcib_pkg.origin = MSG_OBC; 
....................     pcib_pkg.command = 0xEE; 
....................     memcpy(pcib_pkg.mission_parameters, packet->mission_parameters, param_size); 
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
....................  
....................     mux_lock_unlock(true, downlink_timeout); 
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // S-band test command for anechoic chamber 
.................... uint8_t command_sband_test(uint8_t* data) 
.................... { 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     struct cband_test { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t bitrate; 
....................         uint8_t low_high_power; 
....................         uint8_t padding[MSG_LENGTH_PCIB - 4]; 
....................     } pcib_pkg; 
....................  
....................     uint8_t* ptr = (uint8_t*)&pcib_pkg; 
....................     memset(ptr, 0, MSG_LENGTH_PCIB); 
....................     memcpy(ptr, data, 10); 
....................     pcib_pkg.origin = MSG_OBC; 
....................     checksum_obc(ptr, MSG_LENGTH_PCIB); 
....................     uart_print_pc_hex(ptr, MSG_LENGTH_PCIB); 
....................  
....................     fprintf(PC, " S-band test command: "); 
....................  
....................     switch (pcib_pkg.bitrate) { 
....................     case 0: fprintf(PC, "10kbps, "); break; 
....................     case 1: fprintf(PC, "20kbps, "); break; 
....................     case 2: fprintf(PC, "25kbps, "); break; 
....................     case 3: fprintf(PC, "50kbps, "); break; 
....................     case 4: fprintf(PC, "64kbps, "); break; 
....................     case 5: fprintf(PC, "100kbps, "); break; 
....................     case 6: fprintf(PC, "250kbps, "); break; 
....................     case 7: fprintf(PC, "500kbps, "); break; 
....................     default: fprintf(PC, "invalid bitrate."); return 1; 
....................     } 
....................  
....................     switch (pcib_pkg.low_high_power) { 
....................     case 0: fprintf(PC, "low power."); break; 
....................     case 1: fprintf(PC, "high power."); break; 
....................     default: fprintf(PC, "invalid power."); return 2; 
....................     } 
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, ptr, MSG_LENGTH_PCIB, 5, 10); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Data downlink from S-band through Relay PIC 
.................... uint8_t command_relay_data_downlink_from_flash(uint8_t* data) 
.................... { 
....................     enum { data_size = 16 }; 
....................     if (mux_sel(mux_pcib) != mux_pcib) { // If MUX did not change 
....................         if (verbose) { 
....................             fprintf(PC, "MUX change failed!"); 
....................         } 
....................         return 1; 
....................     } 
....................  
....................     uint8_t cmd[MSG_LENGTH_PCIB] = {0}; 
....................  
....................     struct relay_command { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[data_size]; 
....................     }* relay_command = (struct relay_command*)cmd; 
....................  
....................     relay_command->origin = MSG_OBC; 
....................     relay_command->command = data[1]; 
....................     memcpy(relay_command->data, data + 2, data_size); 
....................     checksum_obc(cmd, MSG_LENGTH_PCIB); 
....................     uart_print_pc_hex(cmd, MSG_LENGTH_PCIB); 
....................  
....................     uint8_t duration = data[6]; 
....................  
....................     uint8_t mux_status = 0; 
....................  
....................     if(relay_command->command == 0x36) { 
....................         mux_status = mux_lock_unlock(true, ((time_t)duration) * 60); 
....................     } 
....................  
....................     uart_send_packet_repeat(&uart_port_MSN, cmd, MSG_LENGTH_PCIB, 5, 10); 
....................  
....................     return mux_status; 
.................... } 
....................  
.................... // ===================================================== 
....................  
.................... typedef struct mission { 
....................     time_t mission_time;                            // time when the command is sent to the mission (Unix time) 
....................     uint16_t mission_duration;                      // how long does it take to execute the mission in seconds; 0 = do not turn off 
....................     uint8_t adcs_mode;                              // adcs mode during mission 
....................     uint16_t adcs_maneuver_duration;                // how early to change the ADCS before sending the mission command (in seconds); 0 = never 
....................     uint16_t mission_on_time;                       // how early to turn on the mission before sending the mission command (in seconds) 
....................     uint8_t turn_on_value;                          // active high will turn on the subsystem 
....................     uint16_t pin_number;                            // pin number to turn on/off the subsystem; 0 = do not change 
....................     uart_fn* command_port;                          // UART port to send the command 
....................     uart_fn* on_off_command_port;                   // UART port to send on/off commands 
....................     uint8_t mux_position_command;                   // mux position when sending mission commands 
....................     uint8_t mux_position_on_off;                    // mux position when sending on/off commands 
....................     uint8_t command[MSG_LENGTH_PCIB];               // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t command_size;                           // the size of the command above; 0 = do not send 
....................     uint8_t turn_on_command[MSG_LENGTH_PCIB];       // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t turn_on_command_size;                   // the size of the command above; 0 = do not send 
....................     uint8_t turn_off_soft_command[MSG_LENGTH_PCIB]; // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t turn_off_soft_command_size;             // the size of the command above; 0 = do not send 
....................     uint8_t turn_off_hard_command[MSG_LENGTH_PCIB]; // the command to be sent to the subsystem; checksum and footer is calculated automatically 
....................     uint8_t turn_off_hard_command_size;             // the size of the command above; 0 = do not send 
....................     uint16_t turn_off_duration;                     // time it takes between sending the turn off warning and mission power off (in seconds); 0 = never turn off 
....................     uint8_t mux_lock;                               // if true, the mux position is locked for mux_lock_duration seconds 
....................     uint16_t mux_lock_duration;                     // duration to lock the mux seconds 
.................... } mission; 
....................  
.................... mission camera = { 
....................     0,                        // mission_time 
....................     65,                       // mission_duration 
....................     adcs_mode_horizon_camera, // adcs_mode 
....................     3 * 60 * 60,              // adcs_maneuver_duration (3 hours) 
....................     60,                       // mission_on_time 
....................     true,                     // turn_on_value 
....................     0,                        // pin_number 
....................     &uart_port_MSN,           // command_port 
....................     &uart_port_MSN,           // on_off_port 
....................     mux_pcib,                 // mux_position_command 
....................     mux_pcib,                 // mux_position_on_off 
....................     { 0 },                    // command 
....................     MSG_LENGTH_PCIB,          // command_size 
....................     { MSG_OBC, 0xBE, 0x01 },  // turn_on_command 
....................     MSG_LENGTH_PCIB,          // turn_on_command_size 
....................     { MSG_OBC, 0xBE, 0x02 },  // turn_off_soft_command 
....................     MSG_LENGTH_PCIB,          // turn_off_soft_command_size 
....................     { MSG_OBC, 0xBE, 0x00 },  // turn_off_hard_command 
....................     MSG_LENGTH_PCIB,          // turn_off_hard_command_size 
....................     20,                       // turn_off_duration 
....................     false,                    // mux_lock 
....................     65                        // mux_lock_duration 
.................... }; 
....................  
.................... // TODO: Add copy command at the end of the mission 
....................  
.................... // Controls the mission execution 
.................... uint8_t command_generic_mission(mission *m, uint8_t data[]) 
.................... { 
....................     uint8_t* state = &data[2];        // The state is kept in the command 
....................     uint8_t* adcs_enabled = &data[3]; // ADCS enabled flag is also kept in the command 
....................  
....................     enum state_machine { 
....................         state_schedule = 0, 
....................         state_initial_adcs_mode = 1, 
....................         state_turn_on_subsystem = 2, 
....................         state_send_uplink_command = 3, 
....................         state_turn_off_subsystem_soft = 4, 
....................         state_turn_off_subsystem_hard = 5, 
....................         state_end = 6 
....................     }; 
....................  
....................     // Print the current state 
....................     switch (*state) { 
....................     case state_schedule: fprintf(PC, "State: schedule\n"); break; 
....................     case state_initial_adcs_mode: fprintf(PC, "State: initial adcs mode\n"); break; 
....................     case state_turn_on_subsystem: fprintf(PC, "State: turn on subsystem\n"); break; 
....................     case state_send_uplink_command: fprintf(PC, "State: send uplink command\n"); break; 
....................     case state_turn_off_subsystem_soft: fprintf(PC, "State: turn off subsystem soft\n"); break; 
....................     case state_turn_off_subsystem_hard: fprintf(PC, "State: turn off subsystem hard\n"); break; 
....................     case state_end: fprintf(PC, "State: end\n"); break; 
....................     default: fprintf(PC, "Unknown state\n"); break; 
....................     } 
....................  
....................     // Execute the actions for the current state 
....................     switch (*state) { 
....................     case state_schedule: 
....................         break; 
....................     case state_initial_adcs_mode: 
....................         change_adcs_mode(m->adcs_mode, false); 
....................         break; 
....................     case state_turn_on_subsystem: 
....................         if (m->pin_number) { 
....................             output_bit(m->pin_number, m->turn_on_value); 
....................         } 
....................         if (m->turn_on_command_size) { 
....................             checksum_obc(m->turn_on_command, m->turn_on_command_size); 
....................             mux_sel(m->mux_position_on_off); 
....................             uart_send_packet(m->on_off_command_port, m->turn_on_command, m->turn_on_command_size); 
....................             if(m->turn_on_command[1] == 0xBE) { // Workaround to set the monitor byte 
....................                 rpi_status = m->turn_on_command[2]; 
....................             } 
....................         } 
....................         break; 
....................     case state_send_uplink_command: 
....................         checksum_obc(m->command, m->command_size); 
....................         mux_sel(m->mux_position_command); 
....................         if(m->mux_lock) { 
....................             mux_lock_unlock(true, m->mux_lock_duration); 
....................         } 
....................         uart_send_packet(m->command_port, m->command, m->command_size); 
....................         break; 
....................     case state_turn_off_subsystem_soft: 
....................         if (*adcs_enabled && m->adcs_maneuver_duration) { 
....................             change_adcs_mode(obc_flags.adcs_initial_value, false); 
....................         } 
....................         if (m->turn_off_soft_command_size) { 
....................             checksum_obc(m->turn_off_soft_command, m->turn_off_soft_command_size); 
....................             mux_sel(m->mux_position_on_off); 
....................             uart_send_packet(m->on_off_command_port, m->turn_off_soft_command, m->turn_off_soft_command_size); 
....................             if(m->turn_off_soft_command[1] == 0xBE){ // Workaround to set the monitor byte 
....................                 rpi_status = m->turn_off_soft_command[2]; 
....................             } 
....................         } 
....................         break; 
....................     case state_turn_off_subsystem_hard: 
....................         if (m->pin_number) { 
....................             output_bit(m->pin_number, !m->turn_on_value); 
....................         } 
....................         if (m->turn_off_hard_command_size) { 
....................             checksum_obc(m->turn_off_hard_command, m->turn_off_hard_command_size); 
....................             mux_sel(m->mux_position_on_off); 
....................             uart_send_packet(m->on_off_command_port, m->turn_off_hard_command, m->turn_off_hard_command_size); 
....................             if(m->turn_off_hard_command[1] == 0xBE){ // Workaround to set the monitor byte 
....................                 rpi_status = m->turn_off_hard_command[2]; 
....................             } 
....................         } 
....................         break; 
....................     default: 
....................         fprintf(PC, "Invalid state!"); 
....................         return *state; 
....................     } 
....................  
....................     // Determine the next state 
....................     switch (*state) { 
....................     case state_schedule: 
....................         *adcs_enabled = m->mission_time ? true : false; // Disable the ADCS maneuvers if not a scheduled command 
....................         if(m->mission_time == 0){ 
....................             if(m->mission_on_time == 0) { 
....................                 m->mission_time = current_time; 
....................             } else { 
....................                 m->mission_time = current_time + m->mission_on_time; 
....................             } 
....................         } 
....................         if (*adcs_enabled) { 
....................             *state = state_initial_adcs_mode; 
....................             vschedule(m->mission_time - m->adcs_maneuver_duration, data); 
....................             break; 
....................         } 
....................     case state_initial_adcs_mode: 
....................         if (m->mission_on_time) { 
....................             *state = state_turn_on_subsystem; 
....................             vschedule(m->mission_time - m->mission_on_time, data); 
....................             break; 
....................         } 
....................     case state_turn_on_subsystem: 
....................         *state = state_send_uplink_command; 
....................         vschedule(m->mission_time, data); 
....................         break; 
....................     case state_send_uplink_command: 
....................         if (m->mission_duration) { 
....................             *state = state_turn_off_subsystem_soft; 
....................             vschedule(m->mission_time + m->mission_duration, data); 
....................             break; 
....................         } 
....................     case state_turn_off_subsystem_soft: 
....................         if (m->turn_off_duration) { 
....................             *state = state_turn_off_subsystem_hard; 
....................             vschedule(m->mission_time + m->mission_duration + m->turn_off_duration, data); 
....................             break; 
....................         } 
....................     case state_turn_off_subsystem_hard: 
....................     default: 
....................         *state = state_end; 
....................         break; 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint16_t camera_still_duration(uint8_t* data) 
.................... { 
....................     enum constants { 
....................         camera_config_length = 11, 
....................         camera_capture_length = 4, 
....................         a = 1, 
....................         b = 60 
....................     }; 
....................  
....................     struct rpi_camera_still { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[camera_config_length + camera_capture_length]; 
....................     }* packet = (struct rpi_camera_still*)data; 
....................  
....................     uint16_t bitOffset = 0; 
....................  
....................     // Camera capture configuration command 
....................     uint32_t shutterSpeed[3]; 
....................  
....................     for (int i = 0; i < 3; ++i) { 
....................         uint8_t shutterSpeedMantissa = get_bits(packet->data, &bitOffset, 4); 
....................         uint8_t shutterSpeedExponent = get_bits(packet->data, &bitOffset, 3); 
....................         shutterSpeed[i] = (double)shutterSpeedMantissa * pow(10, shutterSpeedExponent) + 0.5; // Using base 10 exponentiation 
....................  
....................         bitOffset += 20; 
....................     } 
....................  
....................     bitOffset += 7; 
....................  
....................     // Camera capture command 
....................     uint8_t cameraSelection[3]; 
....................     cameraSelection[0] = get_bits(packet->data, &bitOffset, 1); 
....................     cameraSelection[1] = get_bits(packet->data, &bitOffset, 1); 
....................     cameraSelection[2] = get_bits(packet->data, &bitOffset, 1); 
....................  
....................     bitOffset += 16; 
....................     uint8_t sequentialPictures = get_bits(packet->data, &bitOffset, 6); 
....................     uint8_t intervalBetweenPictures = get_bits(packet->data, &bitOffset, 7); 
....................  
....................     // Print human-readable output to PC 
....................     if (verbose) { 
....................         fprintf(PC, 
....................             "Camera capture configuration:\r\n" 
....................             "Camera Selection: %u, %u, %u\r\n" 
....................             "Sequential Pictures: %u\r\n" 
....................             "Interval Between Pictures: %u seconds\r\n" 
....................             "Shutter Speeds: %lu, %lu, %lu (microseconds)\r\n", 
....................             cameraSelection[0],                               // 8-bit value 
....................             cameraSelection[1],                               // 8-bit value 
....................             cameraSelection[2],                               // 8-bit value 
....................             sequentialPictures,                               // 8-bit value 
....................             intervalBetweenPictures,                          // 8-bit value 
....................             shutterSpeed[0], shutterSpeed[1], shutterSpeed[2] // 32-bit values 
....................         ); 
....................     } 
....................  
....................     uint16_t delay = (uint16_t)sequentialPictures * ((uint16_t)intervalBetweenPictures + (a * cameraSelection[0] * shutterSpeed[0] / 1000000L + a * cameraSelection[1] * shutterSpeed[1] / 1000000L + a * cameraSelection[2] * shutterSpeed[2] / 1000000L)) + b; 
....................  
....................     if (verbose) { 
....................         fprintf(PC, "Delay: %lu\r\n", delay); 
....................     } 
....................  
....................     return delay; 
.................... } 
....................  
.................... uint16_t camera_image_transform_duration(uint8_t* data) 
.................... { 
....................     enum constants { 
....................         camera_image_transform_length = 11, 
....................         a = 20, 
....................         b = 20 
....................     }; 
....................  
....................     struct rpi_camera_transform { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[camera_image_transform_length]; 
....................     }* packet = (struct rpi_camera_transform*)data; 
....................  
....................     uint16_t bitOffset = 85; 
....................  
....................     uint8_t cameraSelection[3]; 
....................     cameraSelection[0] = get_bits(packet->data, &bitOffset, 1); 
....................     cameraSelection[1] = get_bits(packet->data, &bitOffset, 1); 
....................     cameraSelection[2] = get_bits(packet->data, &bitOffset, 1); 
....................  
....................     // Print human-readable output to PC 
....................     if (verbose) { 
....................         fprintf(PC, 
....................             "Camera Selection: %u%u%u\r\n", 
....................             cameraSelection[0], 
....................             cameraSelection[1], 
....................             cameraSelection[2]); 
....................     } 
....................  
....................     uint16_t delay = (uint16_t)cameraSelection[0] * a + (uint16_t)cameraSelection[1] * a + (uint16_t)cameraSelection[2] * a + b; 
....................  
....................     if (verbose) { 
....................         fprintf(PC, "Delay: %lu\r\n", delay); 
....................     } 
....................  
....................     return delay; 
.................... } 
....................  
.................... uint16_t camera_video_duration(uint8_t* data) 
.................... { 
....................     enum constants { 
....................         camera_video_length = 11, 
....................         a = 20 
....................     }; 
....................  
....................     struct rpi_camera_video { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t data[camera_video_length]; 
....................     }* packet = (struct rpi_camera_video*)data; 
....................  
....................     uint16_t bitOffset = 21; // Skip ADCS mode and ADCS maneuver duration 
....................  
....................     uint8_t cameraSelection[3]; 
....................     cameraSelection[0] = get_bits(packet->data, &bitOffset, 1); 
....................     cameraSelection[1] = get_bits(packet->data, &bitOffset, 1); 
....................     cameraSelection[2] = get_bits(packet->data, &bitOffset, 1); 
....................  
....................     bitOffset += 16; 
....................  
....................     uint8_t timeout[3]; 
....................  
....................     for (int i = 0; i < 3; ++i) { 
....................         bitOffset += 10; 
....................         timeout[i] = get_bits(packet->data, &bitOffset, 6); 
....................     } 
....................  
....................     // Print human-readable output to PC 
....................     if (verbose) { 
....................         fprintf(PC, 
....................             "Video capture command:\r\n" 
....................             "Camera Selection: %u%u%u\r\n" 
....................             "Timeout: %u, %u, %u seconds\r\n", 
....................             cameraSelection[0], 
....................             cameraSelection[1], 
....................             cameraSelection[2], 
....................             timeout[0], timeout[1], timeout[2]); 
....................     } 
....................  
....................     uint16_t delay = (uint16_t)cameraSelection[0] * timeout[0] + (uint16_t)cameraSelection[1] * timeout[1] + (uint16_t)cameraSelection[2] * timeout[2] + a; 
....................  
....................     if (verbose) { 
....................         fprintf(PC, "Delay: %lu\r\n", delay); 
....................     } 
....................  
....................     return delay; 
.................... } 
....................  
.................... uint8_t command_camera_mission(uint8_t* data) 
.................... { 
....................     enum constants { 
....................         camera_config_length = 11, 
....................         camera_capture_length = 4, 
....................         camera_image_transform_length = 11, 
....................         camera_video_length = 11, 
....................         xmodem_rpi_to_bus_length = 4, 
....................     }; 
....................  
....................     enum inner_commands { 
....................         camera_capture_configuration = 0, 
....................         camera_capture = 1, 
....................         image_transformation = 2, 
....................         video_capture = 3, 
....................         xmodem_rpi_to_bus = 4 
....................     }; 
....................  
....................     uint8_t inner_command = data[2]; 
....................  
....................     if (inner_command == camera_capture_configuration) { 
....................  
....................         struct packet_0 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             uint8_t data[camera_config_length]; 
....................         }* packet_0 = (struct packet_0*)data; 
....................  
....................         fprintf(PC, "Camera capture configuration command, saving configuration..."); 
....................         memcpy(obc_flags.camera_parameters, packet_0->data, camera_config_length); 
....................         save_state(packet_0->cmd); 
....................         fprintf(PC, " done!"); 
....................  
....................     } else if (inner_command == camera_capture) { 
....................  
....................         struct packet_1 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint8_t data[camera_capture_length]; 
....................             uint8_t adcs_mode; 
....................             uint16_t adcs_maneuver_duration; 
....................         }* packet_1 = (struct packet_1*)data; 
....................  
....................         fprintf(PC, "Camera capture command, starting state machine..."); 
....................  
....................         camera.mission_time = packet_1->start_time; 
....................         camera.adcs_maneuver_duration = packet_1->adcs_maneuver_duration; 
....................         camera.mux_lock = false; 
....................         camera.adcs_mode = packet_1->adcs_mode; 
....................  
....................         camera.command[0] = MSG_OBC; 
....................         camera.command[1] = 0xCA; 
....................         memcpy(&camera.command[2], obc_flags.camera_parameters, camera_config_length);            // first part of the config comes from the obc flags 
....................         memcpy(&camera.command[2 + camera_config_length], packet_1->data, camera_capture_length); // second part comes from this command 
....................         camera.mission_duration = camera_still_duration(camera.command); 
....................         camera.mux_lock_duration = camera.mission_duration; 
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
....................  
....................     } else if (inner_command == image_transformation) { 
....................  
....................         struct packet_2 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint8_t data[camera_image_transform_length]; 
....................         }* packet_2 = (struct packet_2*)data; 
....................  
....................         fprintf(PC, "Camera image transformation command, starting state machine..."); 
....................  
....................         camera.mission_time = packet_2->start_time; 
....................         camera.adcs_maneuver_duration = 0; 
....................         camera.mux_lock = false; 
....................  
....................         camera.command[0] = MSG_OBC; 
....................         camera.command[1] = 0xCB; 
....................         memcpy(&camera.command[2], packet_2->data, camera_image_transform_length); 
....................         camera.mission_duration = camera_image_transform_duration(camera.command); 
....................         camera.mux_lock_duration = camera.mission_duration; 
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
....................  
....................     } else if (inner_command == video_capture) { 
....................  
....................         struct packet_3 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint8_t data[camera_video_length]; 
....................         }* packet_3 = (struct packet_3*)data; 
....................  
....................         fprintf(PC, "Camera image video command, starting state machine..."); 
....................  
....................         camera.mission_time = packet_3->start_time; 
....................         camera.adcs_maneuver_duration = ((packet_3->data[0] & 0xE0) >> 5); 
....................         camera.adcs_maneuver_duration |= ((uint16_t)packet_3->data[1] << 3); 
....................         camera.adcs_maneuver_duration |= ((uint16_t)(packet_3->data[2] & 0x1F) << 11); 
....................         camera.mux_lock = false; 
....................         camera.adcs_mode = packet_3->data[0] & 0x1F; 
....................  
....................         camera.command[0] = MSG_OBC; 
....................         camera.command[1] = 0xCC; 
....................         memcpy(&camera.command[2], packet_3->data, camera_video_length); 
....................         camera.mission_duration = camera_video_duration(camera.command); 
....................         camera.mux_lock_duration = camera.mission_duration; 
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
....................  
....................     } else if (inner_command == xmodem_rpi_to_bus) { 
....................  
....................         struct packet_4 { 
....................             uint8_t origin; 
....................             uint8_t cmd; 
....................             uint8_t inner_command; 
....................             time_t start_time; 
....................             uint16_t timeout; 
....................             uint8_t data[xmodem_rpi_to_bus_length]; 
....................         }* packet_4 = (struct packet_4*)data; 
....................  
....................         fprintf(PC, "XMODEM copy command RPi to bus, starting state machine..."); 
....................  
....................         camera.mission_time = packet_4->start_time; 
....................         camera.mission_duration = packet_4->timeout; 
....................         camera.adcs_maneuver_duration = 0; 
....................         camera.mux_lock = true; 
....................         camera.mux_lock_duration = camera.mission_duration; 
....................  
....................         camera.command[0] = MSG_OBC; 
....................         camera.command[1] = 0xC2; 
....................         memcpy(&camera.command[2], packet_4->data, xmodem_rpi_to_bus_length); 
....................  
....................         schedule(current_time, { MSG_COMM, 0xCB, 0x00 }); // Start the state machine 
....................  
....................     } else { 
....................         fprintf(PC, "Inner command not implemented."); 
....................     } 
....................  
....................     return inner_command; 
.................... } 
....................  
.................... // ===================================================== 
....................  
.................... // Function that executes a command, by looking up on the table of available commands. 
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled) 
.................... { 
....................     uint8_t error = 0; 
....................  
....................     if (origin == data[0] || origin == MSG_WILDCARD) { 
....................  
....................         // COM reply 
....................         if (data[0] == 0xC0) { 
....................             if (data[1] == 0x42) { 
....................                 if (data[4] != 0x00) { // 0x00 is a request for memory dump 
....................                     send_com_ack(data + 2); 
....................                 } else { 
.................... #ifndef PC_SIM 
....................                     uint32_t* ptr = *(uint32_t*)&data[5]; 
....................                     send_com_ack(ptr + &current_time); 
.................... #endif 
....................                 } 
....................             } 
....................         } 
....................  
....................         // Satellite log 
....................         log_entry log; 
....................         log.origin = data[0]; 
....................         log.command = data[1]; 
....................  
....................         struct_tm* local_time = localtime(&current_time); 
....................  
....................         // Execute command 
....................         if (log_enabled) 
....................             fprintf(PC, "%04ld/%02d/%02d %02d:%02d:%02d | %02d | %02X %02X | ", local_time->tm_year + 1900, 
....................                 (uint8_t)local_time->tm_mon + 1, 
....................                 local_time->tm_mday, 
....................                 local_time->tm_hour, 
....................                 local_time->tm_min, 
....................                 local_time->tm_sec, 
....................                 scheduled_command_count(), 
....................                 data[0], 
....................                 data[1]); 
....................  
....................         uint16_t command = make16(data[0], data[1]); 
....................  
....................         // The table of available commands. 
....................         switch (command) { 
....................  
....................         // Arranged in Alphanumeric 
....................         case 0x1CAA: error = command_tmcr1_telemetry(data); break; 
....................         case 0x1DAA: error = command_tmcr2_telemetry(data); break; 
....................         case 0xABAA: error = command_pcib_telemetry(data); break; 
....................         case 0xAB02: error = command_mux_lock_unlock(data); break; 
....................         case 0xABF0: error = command_rpi_end_of_transmission(data); break; 
....................         case 0xAD90: error = command_adcs_telemetry(data); break; 
....................         case 0xADDA: error = command_adcs_gps_time(data); break; 
....................         case 0xB0A0: error = command_reset_telemetry(data); break; 
....................         case 0xB0A2: error = command_reset_warning(data); break; 
....................         case 0xC000: error = command_print_memory_address(data); break; 
....................         case 0xC001: error = command_set_clock(data); break; 
....................         case 0xC002: error = command_mux_lock_unlock(data); break; 
....................         case 0xC003: error = command_set_obc_variable(data); break; 
....................         case 0xC008: error = command_xmodem_receive_sector(data); break; 
....................         case 0xC009: error = command_xmodem_send_sector(data); break; 
....................         case 0xC00A: error = command_copy_memory_page(data); break; 
....................         case 0xC00B: error = command_copy_memory_sector(data); break; 
....................         case 0xC00C: error = command_erase_memory_page(data); break; 
....................         case 0xC00D: error = command_erase_memory_sector(data); break; 
....................         case 0xC00F: error = command_sel1_a(data); break; 
....................         // case 0xC010: reserved for COM 
....................         // case 0xC011: reserved for COM 
....................         case 0xC012: error = command_sel1_d(data); break; 
....................         // case 0xC013: reserved for COM 
....................         // case 0xC014: reserved for COM 
....................         // case 0xC015: reserved for COM 
....................         // case 0xC016: reserved for COM 
....................         // case 0xC017: reserved for COM 
....................         case 0xC018: error = command_sel1_b(data); break; 
....................         case 0xC019: error = command_sel1_c(data); break; 
....................         case 0xC01A: error = command_sel1_zes(data); break; // Reassigned from 0xC010 
....................         case 0xC01B: error = command_sel2_ref(data); break; // Reassigned from 0xC010 
....................         case 0xC01F: error = command_sel2_a(data); break; 
....................         // case 0xC020: reserved for COM 
....................         // case 0xC021: reserved for COM 
....................         // case 0xC022: reserved for COM 
....................         // case 0xC023: reserved for COM 
....................         // case 0xC024: reserved for COM 
....................         case 0xC02A: error = command_mcp(data); break; 
....................         case 0xC025: error = command_boot_cmd_clear_nth(data); break; 
....................         case 0xC026: error = command_boot_cmd_clear_all(data); break; 
....................         // case 0xC027: reserved for COM 
....................         case 0xC028: error = command_boot_cmd_add(data); break; 
....................         // case 0xC02B: reserved for COM 
....................         // case 0xC02C: reserved for COM 
....................         // case 0xC02D: reserved for COM 
....................         // case 0xC02E: reserved for COM 
....................         // case 0xC02F: reserved for COM 
....................         case 0xC031: error = command_sel2_b(data); break; 
....................         // case 0xC035: reserved for COM 
....................         case 0xC036: error = command_relay_data_downlink_from_flash(data); break; // From Mission FM 
....................         case 0xC037: error = command_relay_data_downlink_from_flash(data); break; // From Local FM 
....................         case 0xC03A: error = command_adcs_raw_part_a(data); break; 
....................         case 0xC03B: error = command_adcs_raw_part_b(data); break; 
....................         case 0xC03C: error = command_adcs_raw_part_c(data); break; 
....................         // case 0xC040: reserved for COM 
....................         // case 0xC041: reserved for COM 
....................         case 0xC042: error = command_uhf_message(data); break; 
....................         // case 0xC044: reserved for COM 
....................         case 0xC050: error = command_com_cw(data); break; 
....................         case 0xC055: error = command_save_state(data); break; 
....................         case 0xC058: error = command_com_access_change(data); break; 
....................         case 0xC059: error = command_com_access_request(data); break; 
....................         case 0xC05E: error = command_enable_disable_sband(data); break; 
....................         case 0xC060: error = command_obc_kill_on(data); break; 
....................         case 0xC061: error = command_obc_kill_off(data); break; 
....................         case 0xC06C: error = command_send_data_to_eps(data); break; 
....................         case 0xC06D: error = command_eps_set_heater_ref(data); break; 
....................         case 0xC070: error = command_stm32_raw_8_16(data); break; 
....................         case 0xC071: error = command_stm32_raw_uhf32(data); break; 
....................         case 0xC072: error = command_stm32_raw_uhf32(data); break; 
....................         case 0xC080: error = command_sel2_c(data); break; 
....................         case 0xC081: error = command_sel2_d(data); break; 
....................         case 0xC090: error = command_request_reset(data); break; 
....................         case 0xC091: error = command_request_eps(data); break; 
....................         case 0xC092: error = command_request_mission_control_PIC_status(data); break; 
....................         case 0xC093: error = command_request_adcs(data); break; 
....................         case 0xC094: error = command_request_pcib(data); break; 
....................         case 0xC095: error = command_request_tmcr1(data); break; 
....................         case 0xC096: error = command_request_tmcr2(data); break; 
....................         case 0xC0A0: error = command_reset_telemetry(data); break; 
....................         case 0xC0A1: error = command_stm32_raw_uhf32_tle(data); break; 
....................         case 0xC0A2: error = command_stm32_raw_uhf32_tle(data); break; 
....................         case 0xC0A6: error = command_adcs_default_mode(data); break; 
....................         case 0xC0AA: error = command_to_deploy_SAP(data); break; 
....................         case 0xC0AB: error = command_to_deploy_SMA(data); break; 
....................         case 0xC0AC: error = command_adcs_comm_test(data); break; 
....................         case 0xC0AD: error = command_adcs_mode(data); break; 
....................         case 0xC0AE: error = command_ocp_state(data); break; 
....................         case 0xC0AF: error = command_adcs_raw(data); break; 
....................         case 0xC0B7: error = command_reset_all_power_lines(data); break; 
....................         case 0xC0BE: error = command_enable_disable_rpi(data); break; 
....................         case 0xC0C0: error = command_rpi_clean_up(data); break; 
....................         case 0xC0C1: error = command_rpi_clean_logfile(data); break; 
....................         case 0xC0C5: error = command_clear_state(data); break; 
....................         case 0xC0CA: error = command_camera_mission(data); break; 
....................         case 0xC0CB: error = command_generic_mission(&camera, data); break; 
....................         case 0xC0CC: error = command_raw_pcib(data); break; 
....................         case 0xC0CD: error = command_change_cw_mode_flags(data); break; 
....................         case 0xC0CE: error = command_raw_tmcr(data); break; 
....................         case 0xC0CF: error = command_raw_tmcr(data); break; 
....................         case 0xC0D0: error = command_xmodem_send(data); break; 
....................         case 0xC0D1: error = command_xmodem_receive(data); break; 
....................         case 0xC0D2: error = command_iMTQ_Dipole_Actuation(data); break; 
....................         case 0xC0D3: error = command_iMTQ_No_Opeartion(data); break; 
....................         case 0xC0D4: error = command_3v3_Enable(data); break; 
....................         case 0xC0D5: error = command_RW_Motor_Enable(data); break; 
....................         case 0xC0D6: error = command_RW_Enable(data); break; 
....................         case 0xC0D7: error = command_RW_Speed(data); break; 
....................         case 0xC0D8: error = command_RW_Reset(data); break; 
....................         case 0xC0DA: error = command_deploy_antenna(data); break; 
....................         case 0xC0DB: error = command_debug(data); break; 
....................         case 0xC0DD: error = command_dump_memory(data); break; 
....................         case 0xC0DE: error = command_sband_defaults(data); break; 
....................         case 0xC0DF: error = command_get_tris(data); break; 
....................         case 0xC0EA: error = command_copy_mission_to_com(data); break; 
....................         case 0xC0EB: error = command_copy_opera_to_com(data); break; 
....................         case 0xC0ED: error = command_sband_downlink(data); break; 
....................         case 0xC0EE: error = command_sband_end_to_end(data); break; 
....................         case 0xC0EF: error = command_sband_test(data); break; 
....................         case 0xC0F0: error = command_mux_sel_sfm(data); break; 
....................         case 0xC0F5: error = command_send_data_to_reset(data); break; 
....................         case 0xC0F6: error = command_schedule_anything(data); break; 
....................         case 0xC0F7: error = command_schedule_mode(data); break; 
....................         case 0xC0F8: error = command_save_telemetry(data); break; 
....................         case 0xC0F9: error = command_clear_all_schedule_commands(data); break; 
....................         case 0xC0FA: error = command_print_flags(data); break; 
....................         case 0xC0FB: error = command_opera_GA_part_a(data); break; 
....................         case 0xC0FC: error = command_opera_GA_part_b(data); break; 
....................         case 0xC0FD: error = command_opera_GA_single(data); break; 
....................         case 0xC0FE: error = command_boot_flag_set(data); break; 
....................         case 0xC0FF: error = command_opera_full(data); break; 
....................         case 0xCB00: error = command_mission_control_PIC_status(data); break; 
....................         case 0xDBFF: error = command_reset_log(data); break; 
....................         case 0xE033: error = command_eps_telemetry(data); break; 
....................  
....................         default: error = command_get_tris(data); break; 
....................         } 
....................  
....................         if (log_enabled) { 
....................             fprintf(PC, " (%s R:%02X)", mux_str_list[mux_cpld_position], error); 
....................         } 
....................  
....................         // Satellite log 
....................         log.time = current_time; 
....................         log.return_value = error; 
....................  
....................         if ( 
....................             log_enabled 
....................             && command != 0x1CAA  // TMCR1 PIC 
....................             && command != 0x1DAA  // TMCR2 PIC 
....................             && command != 0xABAA  // RELAY PIC 
....................             && command != 0xB0A0  // Reset PIC 
....................             && command != 0xE033  // EPS PIC 
....................             && command != 0xCB00  // Mission control pic 
....................             && command != 0xAD90  // ADCS PIC 
....................             && command != 0xC050  // COM PIC 
....................             && command != 0xC0F8) // Telemetry record 
....................             log_add(log); 
....................  
....................         if (log_enabled) 
....................             fprintf(PC, "\r\n"); 
....................     } 
.................... } 
....................  
.................... #endif /* INTERPRETER_H */ 
....................  
....................  
.................... #INT_RDA // MSN 
.................... void interrupt_rda() 
.................... { 
....................     switch (mux_cpld_position) { 
*
02152:  MOVLB  7
02154:  MOVF   x4F,W
02156:  XORLW  02
02158:  MOVLB  0
0215A:  BZ    217E
0215C:  XORLW  07
0215E:  BTFSC  FD8.2
02160:  BRA    2530
02162:  XORLW  03
02164:  BTFSC  FD8.2
02166:  GOTO   28E2
0216A:  XORLW  07
0216C:  BTFSC  FD8.2
0216E:  GOTO   2C94
02172:  XORLW  02
02174:  BTFSC  FD8.2
02176:  GOTO   3048
0217A:  GOTO   33FC
....................     case mux_adcs: 
....................         uart_update(ADCS, message_ADCS); // Receive data 
0217E:  RCALL  213C
02180:  MOVFF  01,D6F
02184:  MOVLW  09
02186:  MOVLB  D
02188:  MOVWF  x80
0218A:  MOVLW  9C
0218C:  MOVWF  x7F
0218E:  MOVFF  8CF,D82
02192:  MOVFF  8CE,D81
02196:  MOVFF  D6F,D83
....................         break; 
*
0252C:  GOTO   37AC
....................     case mux_mcpic: 
....................         uart_update(MCPIC, message_MCPIC); // Receive data 
02530:  RCALL  213C
02532:  MOVFF  01,D6F
02536:  MOVLW  09
02538:  MOVLB  D
0253A:  MOVWF  x80
0253C:  MOVLW  D1
0253E:  MOVWF  x7F
02540:  MOVFF  8C9,D82
02544:  MOVFF  8C8,D81
02548:  MOVFF  D6F,D83
....................         break; 
*
028DE:  GOTO   37AC
....................     case mux_pcib: 
....................         uart_update(PCIB, message_PCIB); // Receive data 
028E2:  RCALL  213C
028E4:  MOVFF  01,D6F
028E8:  MOVLW  09
028EA:  MOVLB  D
028EC:  MOVWF  x80
028EE:  MOVLW  E0
028F0:  MOVWF  x7F
028F2:  MOVFF  8C7,D82
028F6:  MOVFF  8C6,D81
028FA:  MOVFF  D6F,D83
....................         break; 
*
02C90:  GOTO   37AC
....................     case mux_tmcr1: 
....................         uart_update(TMCR1, message_TMCR1); // Receive data 
02C94:  CALL   213C
02C98:  MOVFF  01,D6F
02C9C:  MOVLW  0A
02C9E:  MOVLB  D
02CA0:  MOVWF  x80
02CA2:  MOVLW  0D
02CA4:  MOVWF  x7F
02CA6:  MOVFF  8D1,D82
02CAA:  MOVFF  8D0,D81
02CAE:  MOVFF  D6F,D83
....................         break; 
*
03044:  GOTO   37AC
....................     case mux_tmcr2: 
....................         uart_update(TMCR2, message_TMCR2); // Receive data 
03048:  CALL   213C
0304C:  MOVFF  01,D6F
03050:  MOVLW  0A
03052:  MOVLB  D
03054:  MOVWF  x80
03056:  MOVLW  3A
03058:  MOVWF  x7F
0305A:  MOVFF  8D3,D82
0305E:  MOVFF  8D2,D81
03062:  MOVFF  D6F,D83
....................         break; 
*
033F8:  BRA    37AC
033FA:  MOVLB  0
....................     default: 
....................         uart_update(ADCS, message_ADCS); // Receive data 
033FC:  CALL   213C
03400:  MOVFF  01,D6F
03404:  MOVLW  09
03406:  MOVLB  D
03408:  MOVWF  x80
0340A:  MOVLW  9C
0340C:  MOVWF  x7F
0340E:  MOVFF  8CF,D82
03412:  MOVFF  8CE,D81
03416:  MOVFF  D6F,D83
....................         break; 
....................     } 
.................... } 
....................  
*
037AC:  BCF    F9E.5
037AE:  MOVLB  0
037B0:  GOTO   009C
.................... #INT_RDA2 HIGH // COM 
.................... void interrupt_rda2() 
.................... { 
....................     uart_update(COMM, message_COMM); // Receive data 
*
037CE:  RCALL  37B4
037D0:  MOVFF  01,D7E
037D4:  MOVLW  09
037D6:  MOVLB  D
037D8:  MOVWF  x80
037DA:  MOVLW  04
037DC:  MOVWF  x7F
037DE:  MOVFF  8C5,D82
037E2:  MOVFF  8C4,D81
037E6:  MOVFF  D7E,D83
....................     if (uart_ready(COMM)) {          // If ready, execute imediately 
*
03B7C:  MOVLB  9
03B7E:  MOVF   x0B,W
03B80:  SUBLW  02
03B82:  BNZ   3B8A
....................         set_timer0(1); 
03B84:  CLRF   FD7
03B86:  MOVLW  01
03B88:  MOVWF  FD6
....................     } 
.................... } 
....................  
03B8A:  BCF    FA4.5
03B8C:  MOVLB  0
03B8E:  GOTO   0148
.................... #INT_RDA3 // FAB 
.................... void interrupt_rda3() 
.................... { 
....................     uart_update(FAB, message_FAB); // Receive data 
*
03BAC:  RCALL  3B92
03BAE:  MOVFF  01,D6F
03BB2:  MOVLW  09
03BB4:  MOVLB  D
03BB6:  MOVWF  x80
03BB8:  MOVLW  26
03BBA:  MOVWF  x7F
03BBC:  MOVFF  8CD,D82
03BC0:  MOVFF  8CC,D81
03BC4:  MOVFF  D6F,D83
.................... } 
....................  
*
03F5A:  BCF    FA6.5
03F5C:  MOVLB  0
03F5E:  GOTO   009C
.................... #INT_RDA4 // RST 
.................... void interrupt_rda4() 
.................... { 
....................     uart_update(RST, message_RST); // Receive data 
*
03F7C:  RCALL  3F62
03F7E:  MOVFF  01,D6F
03F82:  MOVLW  09
03F84:  MOVLB  D
03F86:  MOVWF  x80
03F88:  MOVLW  6F
03F8A:  MOVWF  x7F
03F8C:  MOVFF  8CB,D82
03F90:  MOVFF  8CA,D81
03F94:  MOVFF  D6F,D83
.................... } 
....................  
*
0432A:  BCF    FA6.7
0432C:  MOVLB  0
0432E:  GOTO   009C
.................... #INT_TIMER0 
.................... void interrupt_timer0() 
.................... { 
....................     clock_update = 1; 
04332:  MOVLW  01
04334:  MOVLB  7
04336:  MOVWF  x1E
04338:  BCF    FF2.2
0433A:  MOVLB  0
0433C:  GOTO   009C
.................... } 
....................  
.................... void schedule_new_commands() 
.................... { 
....................     static uint8_t buffer[MAX_LENGTH]; 
....................     if (uart_ready(COMM)) { 
*
19126:  MOVLB  9
19128:  MOVF   x0B,W
1912A:  SUBLW  02
1912C:  BNZ   191D4
....................         memcpy(buffer, uart_message(COMM), MSG_LENGTH_COMM); 
1912E:  MOVLW  0B
19130:  MOVWF  FEA
19132:  MOVLW  89
19134:  MOVWF  FE9
19136:  MOVFF  905,FE2
1913A:  MOVFF  904,FE1
1913E:  MOVLW  19
19140:  MOVWF  01
19142:  MOVFF  FE6,FEE
19146:  DECFSZ 01,F
19148:  BRA    19142
....................         command_execute(buffer, MSG_COMM, 1); 
1914A:  MOVLW  0B
1914C:  MOVLB  C
1914E:  MOVWF  x27
19150:  MOVLW  89
19152:  MOVWF  x26
19154:  MOVLW  C0
19156:  MOVWF  x28
19158:  MOVLW  01
1915A:  MOVWF  x29
1915C:  MOVLB  0
1915E:  CALL   17C34
....................         uart_clean(COMM); 
19162:  MOVLW  09
19164:  MOVLB  D
19166:  MOVWF  x85
19168:  MOVLW  04
1916A:  MOVWF  x84
....................     } 
....................     if (uart_ready(MCPIC)) { 
*
191D4:  MOVF   xD8,W
191D6:  SUBLW  02
191D8:  BNZ   19280
....................         memcpy(buffer, uart_message(MCPIC), MSG_LENGTH_MCPIC); 
191DA:  MOVLW  0B
191DC:  MOVWF  FEA
191DE:  MOVLW  89
191E0:  MOVWF  FE9
191E2:  MOVFF  9D2,FE2
191E6:  MOVFF  9D1,FE1
191EA:  MOVLW  06
191EC:  MOVWF  01
191EE:  MOVFF  FE6,FEE
191F2:  DECFSZ 01,F
191F4:  BRA    191EE
....................         command_execute(buffer, MSG_MCPIC, 1); 
191F6:  MOVLW  0B
191F8:  MOVLB  C
191FA:  MOVWF  x27
191FC:  MOVLW  89
191FE:  MOVWF  x26
19200:  MOVLW  CB
19202:  MOVWF  x28
19204:  MOVLW  01
19206:  MOVWF  x29
19208:  MOVLB  0
1920A:  CALL   17C34
....................         uart_clean(MCPIC); 
1920E:  MOVLW  09
19210:  MOVLB  D
19212:  MOVWF  x85
19214:  MOVLW  D1
19216:  MOVWF  x84
....................     } 
....................     if (uart_ready(ADCS)) { 
*
19280:  MOVF   xA3,W
19282:  SUBLW  02
19284:  BNZ   1932C
....................         memcpy(buffer, uart_message(ADCS), MSG_LENGTH_ADCS); 
19286:  MOVLW  0B
19288:  MOVWF  FEA
1928A:  MOVLW  89
1928C:  MOVWF  FE9
1928E:  MOVFF  99D,FE2
19292:  MOVFF  99C,FE1
19296:  MOVLW  2C
19298:  MOVWF  01
1929A:  MOVFF  FE6,FEE
1929E:  DECFSZ 01,F
192A0:  BRA    1929A
....................         command_execute(buffer, MSG_ADCS, 1); 
192A2:  MOVLW  0B
192A4:  MOVLB  C
192A6:  MOVWF  x27
192A8:  MOVLW  89
192AA:  MOVWF  x26
192AC:  MOVLW  AD
192AE:  MOVWF  x28
192B0:  MOVLW  01
192B2:  MOVWF  x29
192B4:  MOVLB  0
192B6:  CALL   17C34
....................         uart_clean(ADCS); 
192BA:  MOVLW  09
192BC:  MOVLB  D
192BE:  MOVWF  x85
192C0:  MOVLW  9C
192C2:  MOVWF  x84
....................     } 
....................     if (uart_ready(PCIB)) { 
*
1932C:  MOVF   xE7,W
1932E:  SUBLW  02
19330:  BNZ   193D8
....................         memcpy(buffer, uart_message(PCIB), MSG_LENGTH_PCIB); 
19332:  MOVLW  0B
19334:  MOVWF  FEA
19336:  MOVLW  89
19338:  MOVWF  FE9
1933A:  MOVFF  9E1,FE2
1933E:  MOVFF  9E0,FE1
19342:  MOVLW  24
19344:  MOVWF  01
19346:  MOVFF  FE6,FEE
1934A:  DECFSZ 01,F
1934C:  BRA    19346
....................         command_execute(buffer, MSG_PCIB, 1); 
1934E:  MOVLW  0B
19350:  MOVLB  C
19352:  MOVWF  x27
19354:  MOVLW  89
19356:  MOVWF  x26
19358:  MOVLW  AB
1935A:  MOVWF  x28
1935C:  MOVLW  01
1935E:  MOVWF  x29
19360:  MOVLB  0
19362:  CALL   17C34
....................         uart_clean(PCIB); 
19366:  MOVLW  09
19368:  MOVLB  D
1936A:  MOVWF  x85
1936C:  MOVLW  E0
1936E:  MOVWF  x84
....................     } 
....................     if (uart_ready(TMCR1)) { 
*
193D8:  MOVLB  A
193DA:  MOVF   x14,W
193DC:  SUBLW  02
193DE:  BNZ   19486
....................         memcpy(buffer, uart_message(TMCR1), MSG_LENGTH_TMCR1); 
193E0:  MOVLW  0B
193E2:  MOVWF  FEA
193E4:  MOVLW  89
193E6:  MOVWF  FE9
193E8:  MOVFF  A0E,FE2
193EC:  MOVFF  A0D,FE1
193F0:  MOVLW  24
193F2:  MOVWF  01
193F4:  MOVFF  FE6,FEE
193F8:  DECFSZ 01,F
193FA:  BRA    193F4
....................         command_execute(buffer, MSG_TMCR1, 1); 
193FC:  MOVLW  0B
193FE:  MOVLB  C
19400:  MOVWF  x27
19402:  MOVLW  89
19404:  MOVWF  x26
19406:  MOVLW  1C
19408:  MOVWF  x28
1940A:  MOVLW  01
1940C:  MOVWF  x29
1940E:  MOVLB  0
19410:  CALL   17C34
....................         uart_clean(TMCR1); 
19414:  MOVLW  0A
19416:  MOVLB  D
19418:  MOVWF  x85
1941A:  MOVLW  0D
1941C:  MOVWF  x84
....................     } 
....................     if (uart_ready(TMCR2)) { 
*
19486:  MOVF   x41,W
19488:  SUBLW  02
1948A:  BNZ   19532
....................         memcpy(buffer, uart_message(TMCR2), MSG_LENGTH_TMCR2); 
1948C:  MOVLW  0B
1948E:  MOVWF  FEA
19490:  MOVLW  89
19492:  MOVWF  FE9
19494:  MOVFF  A3B,FE2
19498:  MOVFF  A3A,FE1
1949C:  MOVLW  24
1949E:  MOVWF  01
194A0:  MOVFF  FE6,FEE
194A4:  DECFSZ 01,F
194A6:  BRA    194A0
....................         command_execute(buffer, MSG_TMCR2, 1); 
194A8:  MOVLW  0B
194AA:  MOVLB  C
194AC:  MOVWF  x27
194AE:  MOVLW  89
194B0:  MOVWF  x26
194B2:  MOVLW  1D
194B4:  MOVWF  x28
194B6:  MOVLW  01
194B8:  MOVWF  x29
194BA:  MOVLB  0
194BC:  CALL   17C34
....................         uart_clean(TMCR2); 
194C0:  MOVLW  0A
194C2:  MOVLB  D
194C4:  MOVWF  x85
194C6:  MOVLW  3A
194C8:  MOVWF  x84
....................     } 
....................     if (uart_ready(FAB)) { 
*
19532:  MOVLB  9
19534:  MOVF   x2D,W
19536:  SUBLW  02
19538:  BNZ   195E0
....................         memcpy(buffer, uart_message(FAB), MSG_LENGTH_FAB); 
1953A:  MOVLW  0B
1953C:  MOVWF  FEA
1953E:  MOVLW  89
19540:  MOVWF  FE9
19542:  MOVFF  927,FE2
19546:  MOVFF  926,FE1
1954A:  MOVLW  40
1954C:  MOVWF  01
1954E:  MOVFF  FE6,FEE
19552:  DECFSZ 01,F
19554:  BRA    1954E
....................         command_execute(buffer, MSG_FAB, 1); 
19556:  MOVLW  0B
19558:  MOVLB  C
1955A:  MOVWF  x27
1955C:  MOVLW  89
1955E:  MOVWF  x26
19560:  MOVLW  E0
19562:  MOVWF  x28
19564:  MOVLW  01
19566:  MOVWF  x29
19568:  MOVLB  0
1956A:  CALL   17C34
....................         uart_clean(FAB); 
1956E:  MOVLW  09
19570:  MOVLB  D
19572:  MOVWF  x85
19574:  MOVLW  26
19576:  MOVWF  x84
....................     } 
....................     if (uart_ready(RST)) { 
*
195E0:  MOVF   x76,W
195E2:  SUBLW  02
195E4:  BNZ   1968C
....................         memcpy(buffer, uart_message(RST), MSG_LENGTH_RST); 
195E6:  MOVLW  0B
195E8:  MOVWF  FEA
195EA:  MOVLW  89
195EC:  MOVWF  FE9
195EE:  MOVFF  970,FE2
195F2:  MOVFF  96F,FE1
195F6:  MOVLW  24
195F8:  MOVWF  01
195FA:  MOVFF  FE6,FEE
195FE:  DECFSZ 01,F
19600:  BRA    195FA
....................         command_execute(buffer, MSG_RST, 1); 
19602:  MOVLW  0B
19604:  MOVLB  C
19606:  MOVWF  x27
19608:  MOVLW  89
1960A:  MOVWF  x26
1960C:  MOVLW  B0
1960E:  MOVWF  x28
19610:  MOVLW  01
19612:  MOVWF  x29
19614:  MOVLB  0
19616:  CALL   17C34
....................         uart_clean(RST); 
1961A:  MOVLW  09
1961C:  MOVLB  D
1961E:  MOVWF  x85
19620:  MOVLW  6F
19622:  MOVWF  x84
....................     } 
....................     if (uart_ready(PC)) { 
*
1968C:  MOVLB  8
1968E:  MOVF   xE9,W
19690:  SUBLW  02
19692:  BNZ   19738
....................         memcpy(buffer, uart_message(PC), MSG_LENGTH_PC); 
19694:  MOVLW  0B
19696:  MOVWF  FEA
19698:  MOVLW  89
1969A:  MOVWF  FE9
1969C:  MOVFF  8E3,FE2
196A0:  MOVFF  8E2,FE1
196A4:  MOVLW  19
196A6:  MOVWF  01
196A8:  MOVFF  FE6,FEE
196AC:  DECFSZ 01,F
196AE:  BRA    196A8
....................         command_execute(buffer, MSG_WILDCARD, 1); 
196B0:  MOVLW  0B
196B2:  MOVLB  C
196B4:  MOVWF  x27
196B6:  MOVLW  89
196B8:  MOVWF  x26
196BA:  SETF   x28
196BC:  MOVLW  01
196BE:  MOVWF  x29
196C0:  MOVLB  0
196C2:  CALL   17C34
....................         uart_clean(PC); 
196C6:  MOVLW  08
196C8:  MOVLB  D
196CA:  MOVWF  x85
196CC:  MOVLW  E2
196CE:  MOVWF  x84
....................     } 
*
19738:  MOVLB  0
1973A:  GOTO   1AD0C (RETURN)
.................... } 
....................  
.................... void periodic_requests_commands() 
.................... { 
....................     const uint8_t period = 120; 
....................     periodic_command_clear_rx_flag(period, 0);                 // Reset 
*
19838:  BSF    FD8.1
1983A:  MOVLW  0C
1983C:  MOVWF  FEA
1983E:  MOVLW  26
19840:  MOVWF  FE9
19842:  MOVFF  3E,C95
19846:  MOVFF  3D,C94
1984A:  MOVFF  3C,C93
1984E:  MOVFF  3B,C92
19852:  MOVLB  C
19854:  CLRF   x99
19856:  CLRF   x98
19858:  CLRF   x97
1985A:  MOVLW  78
1985C:  MOVWF  x96
1985E:  MOVLB  0
19860:  CALL   4726
19864:  MOVFF  C29,C2D
19868:  MOVFF  C28,C2C
1986C:  MOVFF  C27,C2B
19870:  MOVFF  C26,C2A
19874:  MOVLB  C
19876:  MOVF   x2A,F
19878:  BNZ   1988C
1987A:  MOVF   x2B,F
1987C:  BNZ   1988C
1987E:  MOVF   x2C,F
19880:  BNZ   1988C
19882:  MOVF   x2D,F
19884:  BNZ   1988C
19886:  MOVLB  7
19888:  CLRF   x50
1988A:  MOVLB  C
....................     periodic_command(period, 0, verbose, { MSG_COMM, 0x90 });  // Reset 
1988C:  BSF    FD8.1
1988E:  MOVLW  0C
19890:  MOVWF  FEA
19892:  MOVLW  26
19894:  MOVWF  FE9
19896:  MOVFF  3E,C95
1989A:  MOVFF  3D,C94
1989E:  MOVFF  3C,C93
198A2:  MOVFF  3B,C92
198A6:  CLRF   x99
198A8:  CLRF   x98
198AA:  CLRF   x97
198AC:  MOVLW  78
198AE:  MOVWF  x96
198B0:  MOVLB  0
198B2:  CALL   4726
198B6:  MOVFF  C29,C2D
198BA:  MOVFF  C28,C2C
198BE:  MOVFF  C27,C2B
198C2:  MOVFF  C26,C2A
198C6:  MOVLB  C
198C8:  MOVF   x2A,F
198CA:  BNZ   19900
198CC:  MOVF   x2B,F
198CE:  BNZ   19900
198D0:  MOVF   x2C,F
198D2:  BNZ   19900
198D4:  MOVF   x2D,F
198D6:  BNZ   19900
198D8:  MOVLB  7
198DA:  MOVF   x50,F
198DC:  BNZ   198FE
198DE:  MOVLW  C0
198E0:  MOVLB  B
198E2:  MOVWF  xD2
198E4:  MOVLW  90
198E6:  MOVWF  xD3
198E8:  MOVLW  0B
198EA:  MOVLB  C
198EC:  MOVWF  x27
198EE:  MOVLW  D2
198F0:  MOVWF  x26
198F2:  SETF   x28
198F4:  MOVFF  55A,C29
198F8:  MOVLB  0
198FA:  CALL   17C34
198FE:  MOVLB  C
....................     periodic_command(period, 3, verbose, { MSG_COMM, 0x90 });  // Reset 
19900:  BSF    FD8.1
19902:  MOVLW  0C
19904:  MOVWF  FEA
19906:  MOVLW  26
19908:  MOVWF  FE9
1990A:  MOVFF  3E,C95
1990E:  MOVFF  3D,C94
19912:  MOVFF  3C,C93
19916:  MOVFF  3B,C92
1991A:  CLRF   x99
1991C:  CLRF   x98
1991E:  CLRF   x97
19920:  MOVLW  78
19922:  MOVWF  x96
19924:  MOVLB  0
19926:  CALL   4726
1992A:  MOVFF  C29,C2D
1992E:  MOVFF  C28,C2C
19932:  MOVFF  C27,C2B
19936:  MOVFF  C26,C2A
1993A:  MOVLB  C
1993C:  MOVF   x26,W
1993E:  SUBLW  03
19940:  BNZ   19976
19942:  MOVF   x2B,F
19944:  BNZ   19976
19946:  MOVF   x2C,F
19948:  BNZ   19976
1994A:  MOVF   x2D,F
1994C:  BNZ   19976
1994E:  MOVLB  7
19950:  MOVF   x50,F
19952:  BNZ   19974
19954:  MOVLW  C0
19956:  MOVLB  B
19958:  MOVWF  xD4
1995A:  MOVLW  90
1995C:  MOVWF  xD5
1995E:  MOVLW  0B
19960:  MOVLB  C
19962:  MOVWF  x27
19964:  MOVLW  D4
19966:  MOVWF  x26
19968:  SETF   x28
1996A:  MOVFF  55A,C29
1996E:  MOVLB  0
19970:  CALL   17C34
19974:  MOVLB  C
....................     periodic_command(period, 6, verbose, { MSG_COMM, 0x90 });  // Reset 
19976:  BSF    FD8.1
19978:  MOVLW  0C
1997A:  MOVWF  FEA
1997C:  MOVLW  26
1997E:  MOVWF  FE9
19980:  MOVFF  3E,C95
19984:  MOVFF  3D,C94
19988:  MOVFF  3C,C93
1998C:  MOVFF  3B,C92
19990:  CLRF   x99
19992:  CLRF   x98
19994:  CLRF   x97
19996:  MOVLW  78
19998:  MOVWF  x96
1999A:  MOVLB  0
1999C:  CALL   4726
199A0:  MOVFF  C29,C2D
199A4:  MOVFF  C28,C2C
199A8:  MOVFF  C27,C2B
199AC:  MOVFF  C26,C2A
199B0:  MOVLB  C
199B2:  MOVF   x26,W
199B4:  SUBLW  06
199B6:  BNZ   199EC
199B8:  MOVF   x2B,F
199BA:  BNZ   199EC
199BC:  MOVF   x2C,F
199BE:  BNZ   199EC
199C0:  MOVF   x2D,F
199C2:  BNZ   199EC
199C4:  MOVLB  7
199C6:  MOVF   x50,F
199C8:  BNZ   199EA
199CA:  MOVLW  C0
199CC:  MOVLB  B
199CE:  MOVWF  xD6
199D0:  MOVLW  90
199D2:  MOVWF  xD7
199D4:  MOVLW  0B
199D6:  MOVLB  C
199D8:  MOVWF  x27
199DA:  MOVLW  D6
199DC:  MOVWF  x26
199DE:  SETF   x28
199E0:  MOVFF  55A,C29
199E4:  MOVLB  0
199E6:  CALL   17C34
199EA:  MOVLB  C
....................     periodic_command(period, 9, verbose, { MSG_COMM, 0x90 });  // Reset 
199EC:  BSF    FD8.1
199EE:  MOVLW  0C
199F0:  MOVWF  FEA
199F2:  MOVLW  26
199F4:  MOVWF  FE9
199F6:  MOVFF  3E,C95
199FA:  MOVFF  3D,C94
199FE:  MOVFF  3C,C93
19A02:  MOVFF  3B,C92
19A06:  CLRF   x99
19A08:  CLRF   x98
19A0A:  CLRF   x97
19A0C:  MOVLW  78
19A0E:  MOVWF  x96
19A10:  MOVLB  0
19A12:  CALL   4726
19A16:  MOVFF  C29,C2D
19A1A:  MOVFF  C28,C2C
19A1E:  MOVFF  C27,C2B
19A22:  MOVFF  C26,C2A
19A26:  MOVLB  C
19A28:  MOVF   x26,W
19A2A:  SUBLW  09
19A2C:  BNZ   19A62
19A2E:  MOVF   x2B,F
19A30:  BNZ   19A62
19A32:  MOVF   x2C,F
19A34:  BNZ   19A62
19A36:  MOVF   x2D,F
19A38:  BNZ   19A62
19A3A:  MOVLB  7
19A3C:  MOVF   x50,F
19A3E:  BNZ   19A60
19A40:  MOVLW  C0
19A42:  MOVLB  B
19A44:  MOVWF  xD8
19A46:  MOVLW  90
19A48:  MOVWF  xD9
19A4A:  MOVLW  0B
19A4C:  MOVLB  C
19A4E:  MOVWF  x27
19A50:  MOVLW  D8
19A52:  MOVWF  x26
19A54:  SETF   x28
19A56:  MOVFF  55A,C29
19A5A:  MOVLB  0
19A5C:  CALL   17C34
19A60:  MOVLB  C
....................     periodic_command(period, 12, verbose, { MSG_COMM, 0x90 }); // Reset 
19A62:  BSF    FD8.1
19A64:  MOVLW  0C
19A66:  MOVWF  FEA
19A68:  MOVLW  26
19A6A:  MOVWF  FE9
19A6C:  MOVFF  3E,C95
19A70:  MOVFF  3D,C94
19A74:  MOVFF  3C,C93
19A78:  MOVFF  3B,C92
19A7C:  CLRF   x99
19A7E:  CLRF   x98
19A80:  CLRF   x97
19A82:  MOVLW  78
19A84:  MOVWF  x96
19A86:  MOVLB  0
19A88:  CALL   4726
19A8C:  MOVFF  C29,C2D
19A90:  MOVFF  C28,C2C
19A94:  MOVFF  C27,C2B
19A98:  MOVFF  C26,C2A
19A9C:  MOVLB  C
19A9E:  MOVF   x26,W
19AA0:  SUBLW  0C
19AA2:  BNZ   19AD8
19AA4:  MOVF   x2B,F
19AA6:  BNZ   19AD8
19AA8:  MOVF   x2C,F
19AAA:  BNZ   19AD8
19AAC:  MOVF   x2D,F
19AAE:  BNZ   19AD8
19AB0:  MOVLB  7
19AB2:  MOVF   x50,F
19AB4:  BNZ   19AD6
19AB6:  MOVLW  C0
19AB8:  MOVLB  B
19ABA:  MOVWF  xDA
19ABC:  MOVLW  90
19ABE:  MOVWF  xDB
19AC0:  MOVLW  0B
19AC2:  MOVLB  C
19AC4:  MOVWF  x27
19AC6:  MOVLW  DA
19AC8:  MOVWF  x26
19ACA:  SETF   x28
19ACC:  MOVFF  55A,C29
19AD0:  MOVLB  0
19AD2:  CALL   17C34
19AD6:  MOVLB  C
....................  
....................     periodic_command_clear_rx_flag(period, 15);                // EPS 
19AD8:  BSF    FD8.1
19ADA:  MOVLW  0C
19ADC:  MOVWF  FEA
19ADE:  MOVLW  26
19AE0:  MOVWF  FE9
19AE2:  MOVFF  3E,C95
19AE6:  MOVFF  3D,C94
19AEA:  MOVFF  3C,C93
19AEE:  MOVFF  3B,C92
19AF2:  CLRF   x99
19AF4:  CLRF   x98
19AF6:  CLRF   x97
19AF8:  MOVLW  78
19AFA:  MOVWF  x96
19AFC:  MOVLB  0
19AFE:  CALL   4726
19B02:  MOVFF  C29,C2D
19B06:  MOVFF  C28,C2C
19B0A:  MOVFF  C27,C2B
19B0E:  MOVFF  C26,C2A
19B12:  MOVLB  C
19B14:  MOVF   x26,W
19B16:  SUBLW  0F
19B18:  BNZ   19B2C
19B1A:  MOVF   x2B,F
19B1C:  BNZ   19B2C
19B1E:  MOVF   x2C,F
19B20:  BNZ   19B2C
19B22:  MOVF   x2D,F
19B24:  BNZ   19B2C
19B26:  MOVLB  7
19B28:  CLRF   x50
19B2A:  MOVLB  C
....................     periodic_command(period, 15, verbose, { MSG_COMM, 0x91 }); // EPS 
19B2C:  BSF    FD8.1
19B2E:  MOVLW  0C
19B30:  MOVWF  FEA
19B32:  MOVLW  26
19B34:  MOVWF  FE9
19B36:  MOVFF  3E,C95
19B3A:  MOVFF  3D,C94
19B3E:  MOVFF  3C,C93
19B42:  MOVFF  3B,C92
19B46:  CLRF   x99
19B48:  CLRF   x98
19B4A:  CLRF   x97
19B4C:  MOVLW  78
19B4E:  MOVWF  x96
19B50:  MOVLB  0
19B52:  CALL   4726
19B56:  MOVFF  C29,C2D
19B5A:  MOVFF  C28,C2C
19B5E:  MOVFF  C27,C2B
19B62:  MOVFF  C26,C2A
19B66:  MOVLB  C
19B68:  MOVF   x26,W
19B6A:  SUBLW  0F
19B6C:  BNZ   19BA2
19B6E:  MOVF   x2B,F
19B70:  BNZ   19BA2
19B72:  MOVF   x2C,F
19B74:  BNZ   19BA2
19B76:  MOVF   x2D,F
19B78:  BNZ   19BA2
19B7A:  MOVLB  7
19B7C:  MOVF   x50,F
19B7E:  BNZ   19BA0
19B80:  MOVLW  C0
19B82:  MOVLB  B
19B84:  MOVWF  xDC
19B86:  MOVLW  91
19B88:  MOVWF  xDD
19B8A:  MOVLW  0B
19B8C:  MOVLB  C
19B8E:  MOVWF  x27
19B90:  MOVLW  DC
19B92:  MOVWF  x26
19B94:  SETF   x28
19B96:  MOVFF  55A,C29
19B9A:  MOVLB  0
19B9C:  CALL   17C34
19BA0:  MOVLB  C
....................     periodic_command(period, 18, verbose, { MSG_COMM, 0x91 }); // EPS 
19BA2:  BSF    FD8.1
19BA4:  MOVLW  0C
19BA6:  MOVWF  FEA
19BA8:  MOVLW  26
19BAA:  MOVWF  FE9
19BAC:  MOVFF  3E,C95
19BB0:  MOVFF  3D,C94
19BB4:  MOVFF  3C,C93
19BB8:  MOVFF  3B,C92
19BBC:  CLRF   x99
19BBE:  CLRF   x98
19BC0:  CLRF   x97
19BC2:  MOVLW  78
19BC4:  MOVWF  x96
19BC6:  MOVLB  0
19BC8:  CALL   4726
19BCC:  MOVFF  C29,C2D
19BD0:  MOVFF  C28,C2C
19BD4:  MOVFF  C27,C2B
19BD8:  MOVFF  C26,C2A
19BDC:  MOVLB  C
19BDE:  MOVF   x26,W
19BE0:  SUBLW  12
19BE2:  BNZ   19C18
19BE4:  MOVF   x2B,F
19BE6:  BNZ   19C18
19BE8:  MOVF   x2C,F
19BEA:  BNZ   19C18
19BEC:  MOVF   x2D,F
19BEE:  BNZ   19C18
19BF0:  MOVLB  7
19BF2:  MOVF   x50,F
19BF4:  BNZ   19C16
19BF6:  MOVLW  C0
19BF8:  MOVLB  B
19BFA:  MOVWF  xDE
19BFC:  MOVLW  91
19BFE:  MOVWF  xDF
19C00:  MOVLW  0B
19C02:  MOVLB  C
19C04:  MOVWF  x27
19C06:  MOVLW  DE
19C08:  MOVWF  x26
19C0A:  SETF   x28
19C0C:  MOVFF  55A,C29
19C10:  MOVLB  0
19C12:  CALL   17C34
19C16:  MOVLB  C
....................     periodic_command(period, 21, verbose, { MSG_COMM, 0x91 }); // EPS 
19C18:  BSF    FD8.1
19C1A:  MOVLW  0C
19C1C:  MOVWF  FEA
19C1E:  MOVLW  26
19C20:  MOVWF  FE9
19C22:  MOVFF  3E,C95
19C26:  MOVFF  3D,C94
19C2A:  MOVFF  3C,C93
19C2E:  MOVFF  3B,C92
19C32:  CLRF   x99
19C34:  CLRF   x98
19C36:  CLRF   x97
19C38:  MOVLW  78
19C3A:  MOVWF  x96
19C3C:  MOVLB  0
19C3E:  CALL   4726
19C42:  MOVFF  C29,C2D
19C46:  MOVFF  C28,C2C
19C4A:  MOVFF  C27,C2B
19C4E:  MOVFF  C26,C2A
19C52:  MOVLB  C
19C54:  MOVF   x26,W
19C56:  SUBLW  15
19C58:  BNZ   19C8E
19C5A:  MOVF   x2B,F
19C5C:  BNZ   19C8E
19C5E:  MOVF   x2C,F
19C60:  BNZ   19C8E
19C62:  MOVF   x2D,F
19C64:  BNZ   19C8E
19C66:  MOVLB  7
19C68:  MOVF   x50,F
19C6A:  BNZ   19C8C
19C6C:  MOVLW  C0
19C6E:  MOVLB  B
19C70:  MOVWF  xE0
19C72:  MOVLW  91
19C74:  MOVWF  xE1
19C76:  MOVLW  0B
19C78:  MOVLB  C
19C7A:  MOVWF  x27
19C7C:  MOVLW  E0
19C7E:  MOVWF  x26
19C80:  SETF   x28
19C82:  MOVFF  55A,C29
19C86:  MOVLB  0
19C88:  CALL   17C34
19C8C:  MOVLB  C
....................     periodic_command(period, 24, verbose, { MSG_COMM, 0x91 }); // EPS 
19C8E:  BSF    FD8.1
19C90:  MOVLW  0C
19C92:  MOVWF  FEA
19C94:  MOVLW  26
19C96:  MOVWF  FE9
19C98:  MOVFF  3E,C95
19C9C:  MOVFF  3D,C94
19CA0:  MOVFF  3C,C93
19CA4:  MOVFF  3B,C92
19CA8:  CLRF   x99
19CAA:  CLRF   x98
19CAC:  CLRF   x97
19CAE:  MOVLW  78
19CB0:  MOVWF  x96
19CB2:  MOVLB  0
19CB4:  CALL   4726
19CB8:  MOVFF  C29,C2D
19CBC:  MOVFF  C28,C2C
19CC0:  MOVFF  C27,C2B
19CC4:  MOVFF  C26,C2A
19CC8:  MOVLB  C
19CCA:  MOVF   x26,W
19CCC:  SUBLW  18
19CCE:  BNZ   19D04
19CD0:  MOVF   x2B,F
19CD2:  BNZ   19D04
19CD4:  MOVF   x2C,F
19CD6:  BNZ   19D04
19CD8:  MOVF   x2D,F
19CDA:  BNZ   19D04
19CDC:  MOVLB  7
19CDE:  MOVF   x50,F
19CE0:  BNZ   19D02
19CE2:  MOVLW  C0
19CE4:  MOVLB  B
19CE6:  MOVWF  xE2
19CE8:  MOVLW  91
19CEA:  MOVWF  xE3
19CEC:  MOVLW  0B
19CEE:  MOVLB  C
19CF0:  MOVWF  x27
19CF2:  MOVLW  E2
19CF4:  MOVWF  x26
19CF6:  SETF   x28
19CF8:  MOVFF  55A,C29
19CFC:  MOVLB  0
19CFE:  CALL   17C34
19D02:  MOVLB  C
....................     periodic_command(period, 27, verbose, { MSG_COMM, 0x91 }); // EPS 
19D04:  BSF    FD8.1
19D06:  MOVLW  0C
19D08:  MOVWF  FEA
19D0A:  MOVLW  26
19D0C:  MOVWF  FE9
19D0E:  MOVFF  3E,C95
19D12:  MOVFF  3D,C94
19D16:  MOVFF  3C,C93
19D1A:  MOVFF  3B,C92
19D1E:  CLRF   x99
19D20:  CLRF   x98
19D22:  CLRF   x97
19D24:  MOVLW  78
19D26:  MOVWF  x96
19D28:  MOVLB  0
19D2A:  CALL   4726
19D2E:  MOVFF  C29,C2D
19D32:  MOVFF  C28,C2C
19D36:  MOVFF  C27,C2B
19D3A:  MOVFF  C26,C2A
19D3E:  MOVLB  C
19D40:  MOVF   x26,W
19D42:  SUBLW  1B
19D44:  BNZ   19D7A
19D46:  MOVF   x2B,F
19D48:  BNZ   19D7A
19D4A:  MOVF   x2C,F
19D4C:  BNZ   19D7A
19D4E:  MOVF   x2D,F
19D50:  BNZ   19D7A
19D52:  MOVLB  7
19D54:  MOVF   x50,F
19D56:  BNZ   19D78
19D58:  MOVLW  C0
19D5A:  MOVLB  B
19D5C:  MOVWF  xE4
19D5E:  MOVLW  91
19D60:  MOVWF  xE5
19D62:  MOVLW  0B
19D64:  MOVLB  C
19D66:  MOVWF  x27
19D68:  MOVLW  E4
19D6A:  MOVWF  x26
19D6C:  SETF   x28
19D6E:  MOVFF  55A,C29
19D72:  MOVLB  0
19D74:  CALL   17C34
19D78:  MOVLB  C
....................  
....................     periodic_command_clear_rx_flag(period, 30);                // MSN 
19D7A:  BSF    FD8.1
19D7C:  MOVLW  0C
19D7E:  MOVWF  FEA
19D80:  MOVLW  26
19D82:  MOVWF  FE9
19D84:  MOVFF  3E,C95
19D88:  MOVFF  3D,C94
19D8C:  MOVFF  3C,C93
19D90:  MOVFF  3B,C92
19D94:  CLRF   x99
19D96:  CLRF   x98
19D98:  CLRF   x97
19D9A:  MOVLW  78
19D9C:  MOVWF  x96
19D9E:  MOVLB  0
19DA0:  CALL   4726
19DA4:  MOVFF  C29,C2D
19DA8:  MOVFF  C28,C2C
19DAC:  MOVFF  C27,C2B
19DB0:  MOVFF  C26,C2A
19DB4:  MOVLB  C
19DB6:  MOVF   x26,W
19DB8:  SUBLW  1E
19DBA:  BNZ   19DCE
19DBC:  MOVF   x2B,F
19DBE:  BNZ   19DCE
19DC0:  MOVF   x2C,F
19DC2:  BNZ   19DCE
19DC4:  MOVF   x2D,F
19DC6:  BNZ   19DCE
19DC8:  MOVLB  7
19DCA:  CLRF   x50
19DCC:  MOVLB  C
....................     periodic_command(period, 30, verbose, { MSG_COMM, 0x92 }); // MSN 
19DCE:  BSF    FD8.1
19DD0:  MOVLW  0C
19DD2:  MOVWF  FEA
19DD4:  MOVLW  26
19DD6:  MOVWF  FE9
19DD8:  MOVFF  3E,C95
19DDC:  MOVFF  3D,C94
19DE0:  MOVFF  3C,C93
19DE4:  MOVFF  3B,C92
19DE8:  CLRF   x99
19DEA:  CLRF   x98
19DEC:  CLRF   x97
19DEE:  MOVLW  78
19DF0:  MOVWF  x96
19DF2:  MOVLB  0
19DF4:  CALL   4726
19DF8:  MOVFF  C29,C2D
19DFC:  MOVFF  C28,C2C
19E00:  MOVFF  C27,C2B
19E04:  MOVFF  C26,C2A
19E08:  MOVLB  C
19E0A:  MOVF   x26,W
19E0C:  SUBLW  1E
19E0E:  BNZ   19E44
19E10:  MOVF   x2B,F
19E12:  BNZ   19E44
19E14:  MOVF   x2C,F
19E16:  BNZ   19E44
19E18:  MOVF   x2D,F
19E1A:  BNZ   19E44
19E1C:  MOVLB  7
19E1E:  MOVF   x50,F
19E20:  BNZ   19E42
19E22:  MOVLW  C0
19E24:  MOVLB  B
19E26:  MOVWF  xE6
19E28:  MOVLW  92
19E2A:  MOVWF  xE7
19E2C:  MOVLW  0B
19E2E:  MOVLB  C
19E30:  MOVWF  x27
19E32:  MOVLW  E6
19E34:  MOVWF  x26
19E36:  SETF   x28
19E38:  MOVFF  55A,C29
19E3C:  MOVLB  0
19E3E:  CALL   17C34
19E42:  MOVLB  C
....................     periodic_command(period, 33, verbose, { MSG_COMM, 0x92 }); // MSN 
19E44:  BSF    FD8.1
19E46:  MOVLW  0C
19E48:  MOVWF  FEA
19E4A:  MOVLW  26
19E4C:  MOVWF  FE9
19E4E:  MOVFF  3E,C95
19E52:  MOVFF  3D,C94
19E56:  MOVFF  3C,C93
19E5A:  MOVFF  3B,C92
19E5E:  CLRF   x99
19E60:  CLRF   x98
19E62:  CLRF   x97
19E64:  MOVLW  78
19E66:  MOVWF  x96
19E68:  MOVLB  0
19E6A:  CALL   4726
19E6E:  MOVFF  C29,C2D
19E72:  MOVFF  C28,C2C
19E76:  MOVFF  C27,C2B
19E7A:  MOVFF  C26,C2A
19E7E:  MOVLB  C
19E80:  MOVF   x26,W
19E82:  SUBLW  21
19E84:  BNZ   19EBA
19E86:  MOVF   x2B,F
19E88:  BNZ   19EBA
19E8A:  MOVF   x2C,F
19E8C:  BNZ   19EBA
19E8E:  MOVF   x2D,F
19E90:  BNZ   19EBA
19E92:  MOVLB  7
19E94:  MOVF   x50,F
19E96:  BNZ   19EB8
19E98:  MOVLW  C0
19E9A:  MOVLB  B
19E9C:  MOVWF  xE8
19E9E:  MOVLW  92
19EA0:  MOVWF  xE9
19EA2:  MOVLW  0B
19EA4:  MOVLB  C
19EA6:  MOVWF  x27
19EA8:  MOVLW  E8
19EAA:  MOVWF  x26
19EAC:  SETF   x28
19EAE:  MOVFF  55A,C29
19EB2:  MOVLB  0
19EB4:  CALL   17C34
19EB8:  MOVLB  C
....................     periodic_command(period, 36, verbose, { MSG_COMM, 0x92 }); // MSN 
19EBA:  BSF    FD8.1
19EBC:  MOVLW  0C
19EBE:  MOVWF  FEA
19EC0:  MOVLW  26
19EC2:  MOVWF  FE9
19EC4:  MOVFF  3E,C95
19EC8:  MOVFF  3D,C94
19ECC:  MOVFF  3C,C93
19ED0:  MOVFF  3B,C92
19ED4:  CLRF   x99
19ED6:  CLRF   x98
19ED8:  CLRF   x97
19EDA:  MOVLW  78
19EDC:  MOVWF  x96
19EDE:  MOVLB  0
19EE0:  CALL   4726
19EE4:  MOVFF  C29,C2D
19EE8:  MOVFF  C28,C2C
19EEC:  MOVFF  C27,C2B
19EF0:  MOVFF  C26,C2A
19EF4:  MOVLB  C
19EF6:  MOVF   x26,W
19EF8:  SUBLW  24
19EFA:  BNZ   19F30
19EFC:  MOVF   x2B,F
19EFE:  BNZ   19F30
19F00:  MOVF   x2C,F
19F02:  BNZ   19F30
19F04:  MOVF   x2D,F
19F06:  BNZ   19F30
19F08:  MOVLB  7
19F0A:  MOVF   x50,F
19F0C:  BNZ   19F2E
19F0E:  MOVLW  C0
19F10:  MOVLB  B
19F12:  MOVWF  xEA
19F14:  MOVLW  92
19F16:  MOVWF  xEB
19F18:  MOVLW  0B
19F1A:  MOVLB  C
19F1C:  MOVWF  x27
19F1E:  MOVLW  EA
19F20:  MOVWF  x26
19F22:  SETF   x28
19F24:  MOVFF  55A,C29
19F28:  MOVLB  0
19F2A:  CALL   17C34
19F2E:  MOVLB  C
....................     periodic_command(period, 39, verbose, { MSG_COMM, 0x92 }); // MSN 
19F30:  BSF    FD8.1
19F32:  MOVLW  0C
19F34:  MOVWF  FEA
19F36:  MOVLW  26
19F38:  MOVWF  FE9
19F3A:  MOVFF  3E,C95
19F3E:  MOVFF  3D,C94
19F42:  MOVFF  3C,C93
19F46:  MOVFF  3B,C92
19F4A:  CLRF   x99
19F4C:  CLRF   x98
19F4E:  CLRF   x97
19F50:  MOVLW  78
19F52:  MOVWF  x96
19F54:  MOVLB  0
19F56:  CALL   4726
19F5A:  MOVFF  C29,C2D
19F5E:  MOVFF  C28,C2C
19F62:  MOVFF  C27,C2B
19F66:  MOVFF  C26,C2A
19F6A:  MOVLB  C
19F6C:  MOVF   x26,W
19F6E:  SUBLW  27
19F70:  BNZ   19FA6
19F72:  MOVF   x2B,F
19F74:  BNZ   19FA6
19F76:  MOVF   x2C,F
19F78:  BNZ   19FA6
19F7A:  MOVF   x2D,F
19F7C:  BNZ   19FA6
19F7E:  MOVLB  7
19F80:  MOVF   x50,F
19F82:  BNZ   19FA4
19F84:  MOVLW  C0
19F86:  MOVLB  B
19F88:  MOVWF  xEC
19F8A:  MOVLW  92
19F8C:  MOVWF  xED
19F8E:  MOVLW  0B
19F90:  MOVLB  C
19F92:  MOVWF  x27
19F94:  MOVLW  EC
19F96:  MOVWF  x26
19F98:  SETF   x28
19F9A:  MOVFF  55A,C29
19F9E:  MOVLB  0
19FA0:  CALL   17C34
19FA4:  MOVLB  C
....................     periodic_command(period, 42, verbose, { MSG_COMM, 0x92 }); // MSN 
19FA6:  BSF    FD8.1
19FA8:  MOVLW  0C
19FAA:  MOVWF  FEA
19FAC:  MOVLW  26
19FAE:  MOVWF  FE9
19FB0:  MOVFF  3E,C95
19FB4:  MOVFF  3D,C94
19FB8:  MOVFF  3C,C93
19FBC:  MOVFF  3B,C92
19FC0:  CLRF   x99
19FC2:  CLRF   x98
19FC4:  CLRF   x97
19FC6:  MOVLW  78
19FC8:  MOVWF  x96
19FCA:  MOVLB  0
19FCC:  CALL   4726
19FD0:  MOVFF  C29,C2D
19FD4:  MOVFF  C28,C2C
19FD8:  MOVFF  C27,C2B
19FDC:  MOVFF  C26,C2A
19FE0:  MOVLB  C
19FE2:  MOVF   x26,W
19FE4:  SUBLW  2A
19FE6:  BNZ   1A01C
19FE8:  MOVF   x2B,F
19FEA:  BNZ   1A01C
19FEC:  MOVF   x2C,F
19FEE:  BNZ   1A01C
19FF0:  MOVF   x2D,F
19FF2:  BNZ   1A01C
19FF4:  MOVLB  7
19FF6:  MOVF   x50,F
19FF8:  BNZ   1A01A
19FFA:  MOVLW  C0
19FFC:  MOVLB  B
19FFE:  MOVWF  xEE
1A000:  MOVLW  92
1A002:  MOVWF  xEF
1A004:  MOVLW  0B
1A006:  MOVLB  C
1A008:  MOVWF  x27
1A00A:  MOVLW  EE
1A00C:  MOVWF  x26
1A00E:  SETF   x28
1A010:  MOVFF  55A,C29
1A014:  MOVLB  0
1A016:  CALL   17C34
1A01A:  MOVLB  C
....................  
....................     periodic_command_clear_rx_flag(period, 45);                // ADCS 
1A01C:  BSF    FD8.1
1A01E:  MOVLW  0C
1A020:  MOVWF  FEA
1A022:  MOVLW  26
1A024:  MOVWF  FE9
1A026:  MOVFF  3E,C95
1A02A:  MOVFF  3D,C94
1A02E:  MOVFF  3C,C93
1A032:  MOVFF  3B,C92
1A036:  CLRF   x99
1A038:  CLRF   x98
1A03A:  CLRF   x97
1A03C:  MOVLW  78
1A03E:  MOVWF  x96
1A040:  MOVLB  0
1A042:  CALL   4726
1A046:  MOVFF  C29,C2D
1A04A:  MOVFF  C28,C2C
1A04E:  MOVFF  C27,C2B
1A052:  MOVFF  C26,C2A
1A056:  MOVLB  C
1A058:  MOVF   x26,W
1A05A:  SUBLW  2D
1A05C:  BNZ   1A070
1A05E:  MOVF   x2B,F
1A060:  BNZ   1A070
1A062:  MOVF   x2C,F
1A064:  BNZ   1A070
1A066:  MOVF   x2D,F
1A068:  BNZ   1A070
1A06A:  MOVLB  7
1A06C:  CLRF   x50
1A06E:  MOVLB  C
....................     periodic_command(period, 45, verbose, { MSG_COMM, 0x93 }); // ADCS 
1A070:  BSF    FD8.1
1A072:  MOVLW  0C
1A074:  MOVWF  FEA
1A076:  MOVLW  26
1A078:  MOVWF  FE9
1A07A:  MOVFF  3E,C95
1A07E:  MOVFF  3D,C94
1A082:  MOVFF  3C,C93
1A086:  MOVFF  3B,C92
1A08A:  CLRF   x99
1A08C:  CLRF   x98
1A08E:  CLRF   x97
1A090:  MOVLW  78
1A092:  MOVWF  x96
1A094:  MOVLB  0
1A096:  CALL   4726
1A09A:  MOVFF  C29,C2D
1A09E:  MOVFF  C28,C2C
1A0A2:  MOVFF  C27,C2B
1A0A6:  MOVFF  C26,C2A
1A0AA:  MOVLB  C
1A0AC:  MOVF   x26,W
1A0AE:  SUBLW  2D
1A0B0:  BNZ   1A0E6
1A0B2:  MOVF   x2B,F
1A0B4:  BNZ   1A0E6
1A0B6:  MOVF   x2C,F
1A0B8:  BNZ   1A0E6
1A0BA:  MOVF   x2D,F
1A0BC:  BNZ   1A0E6
1A0BE:  MOVLB  7
1A0C0:  MOVF   x50,F
1A0C2:  BNZ   1A0E4
1A0C4:  MOVLW  C0
1A0C6:  MOVLB  B
1A0C8:  MOVWF  xF0
1A0CA:  MOVLW  93
1A0CC:  MOVWF  xF1
1A0CE:  MOVLW  0B
1A0D0:  MOVLB  C
1A0D2:  MOVWF  x27
1A0D4:  MOVLW  F0
1A0D6:  MOVWF  x26
1A0D8:  SETF   x28
1A0DA:  MOVFF  55A,C29
1A0DE:  MOVLB  0
1A0E0:  CALL   17C34
1A0E4:  MOVLB  C
....................     periodic_command(period, 48, verbose, { MSG_COMM, 0x93 }); // ADCS 
1A0E6:  BSF    FD8.1
1A0E8:  MOVLW  0C
1A0EA:  MOVWF  FEA
1A0EC:  MOVLW  26
1A0EE:  MOVWF  FE9
1A0F0:  MOVFF  3E,C95
1A0F4:  MOVFF  3D,C94
1A0F8:  MOVFF  3C,C93
1A0FC:  MOVFF  3B,C92
1A100:  CLRF   x99
1A102:  CLRF   x98
1A104:  CLRF   x97
1A106:  MOVLW  78
1A108:  MOVWF  x96
1A10A:  MOVLB  0
1A10C:  CALL   4726
1A110:  MOVFF  C29,C2D
1A114:  MOVFF  C28,C2C
1A118:  MOVFF  C27,C2B
1A11C:  MOVFF  C26,C2A
1A120:  MOVLB  C
1A122:  MOVF   x26,W
1A124:  SUBLW  30
1A126:  BNZ   1A15C
1A128:  MOVF   x2B,F
1A12A:  BNZ   1A15C
1A12C:  MOVF   x2C,F
1A12E:  BNZ   1A15C
1A130:  MOVF   x2D,F
1A132:  BNZ   1A15C
1A134:  MOVLB  7
1A136:  MOVF   x50,F
1A138:  BNZ   1A15A
1A13A:  MOVLW  C0
1A13C:  MOVLB  B
1A13E:  MOVWF  xF2
1A140:  MOVLW  93
1A142:  MOVWF  xF3
1A144:  MOVLW  0B
1A146:  MOVLB  C
1A148:  MOVWF  x27
1A14A:  MOVLW  F2
1A14C:  MOVWF  x26
1A14E:  SETF   x28
1A150:  MOVFF  55A,C29
1A154:  MOVLB  0
1A156:  CALL   17C34
1A15A:  MOVLB  C
....................     periodic_command(period, 51, verbose, { MSG_COMM, 0x93 }); // ADCS 
1A15C:  BSF    FD8.1
1A15E:  MOVLW  0C
1A160:  MOVWF  FEA
1A162:  MOVLW  26
1A164:  MOVWF  FE9
1A166:  MOVFF  3E,C95
1A16A:  MOVFF  3D,C94
1A16E:  MOVFF  3C,C93
1A172:  MOVFF  3B,C92
1A176:  CLRF   x99
1A178:  CLRF   x98
1A17A:  CLRF   x97
1A17C:  MOVLW  78
1A17E:  MOVWF  x96
1A180:  MOVLB  0
1A182:  CALL   4726
1A186:  MOVFF  C29,C2D
1A18A:  MOVFF  C28,C2C
1A18E:  MOVFF  C27,C2B
1A192:  MOVFF  C26,C2A
1A196:  MOVLB  C
1A198:  MOVF   x26,W
1A19A:  SUBLW  33
1A19C:  BNZ   1A1D2
1A19E:  MOVF   x2B,F
1A1A0:  BNZ   1A1D2
1A1A2:  MOVF   x2C,F
1A1A4:  BNZ   1A1D2
1A1A6:  MOVF   x2D,F
1A1A8:  BNZ   1A1D2
1A1AA:  MOVLB  7
1A1AC:  MOVF   x50,F
1A1AE:  BNZ   1A1D0
1A1B0:  MOVLW  C0
1A1B2:  MOVLB  B
1A1B4:  MOVWF  xF4
1A1B6:  MOVLW  93
1A1B8:  MOVWF  xF5
1A1BA:  MOVLW  0B
1A1BC:  MOVLB  C
1A1BE:  MOVWF  x27
1A1C0:  MOVLW  F4
1A1C2:  MOVWF  x26
1A1C4:  SETF   x28
1A1C6:  MOVFF  55A,C29
1A1CA:  MOVLB  0
1A1CC:  CALL   17C34
1A1D0:  MOVLB  C
....................     periodic_command(period, 54, verbose, { MSG_COMM, 0x93 }); // ADCS 
1A1D2:  BSF    FD8.1
1A1D4:  MOVLW  0C
1A1D6:  MOVWF  FEA
1A1D8:  MOVLW  26
1A1DA:  MOVWF  FE9
1A1DC:  MOVFF  3E,C95
1A1E0:  MOVFF  3D,C94
1A1E4:  MOVFF  3C,C93
1A1E8:  MOVFF  3B,C92
1A1EC:  CLRF   x99
1A1EE:  CLRF   x98
1A1F0:  CLRF   x97
1A1F2:  MOVLW  78
1A1F4:  MOVWF  x96
1A1F6:  MOVLB  0
1A1F8:  CALL   4726
1A1FC:  MOVFF  C29,C2D
1A200:  MOVFF  C28,C2C
1A204:  MOVFF  C27,C2B
1A208:  MOVFF  C26,C2A
1A20C:  MOVLB  C
1A20E:  MOVF   x26,W
1A210:  SUBLW  36
1A212:  BNZ   1A248
1A214:  MOVF   x2B,F
1A216:  BNZ   1A248
1A218:  MOVF   x2C,F
1A21A:  BNZ   1A248
1A21C:  MOVF   x2D,F
1A21E:  BNZ   1A248
1A220:  MOVLB  7
1A222:  MOVF   x50,F
1A224:  BNZ   1A246
1A226:  MOVLW  C0
1A228:  MOVLB  B
1A22A:  MOVWF  xF6
1A22C:  MOVLW  93
1A22E:  MOVWF  xF7
1A230:  MOVLW  0B
1A232:  MOVLB  C
1A234:  MOVWF  x27
1A236:  MOVLW  F6
1A238:  MOVWF  x26
1A23A:  SETF   x28
1A23C:  MOVFF  55A,C29
1A240:  MOVLB  0
1A242:  CALL   17C34
1A246:  MOVLB  C
....................     periodic_command(period, 57, verbose, { MSG_COMM, 0x93 }); // ADCS 
1A248:  BSF    FD8.1
1A24A:  MOVLW  0C
1A24C:  MOVWF  FEA
1A24E:  MOVLW  26
1A250:  MOVWF  FE9
1A252:  MOVFF  3E,C95
1A256:  MOVFF  3D,C94
1A25A:  MOVFF  3C,C93
1A25E:  MOVFF  3B,C92
1A262:  CLRF   x99
1A264:  CLRF   x98
1A266:  CLRF   x97
1A268:  MOVLW  78
1A26A:  MOVWF  x96
1A26C:  MOVLB  0
1A26E:  CALL   4726
1A272:  MOVFF  C29,C2D
1A276:  MOVFF  C28,C2C
1A27A:  MOVFF  C27,C2B
1A27E:  MOVFF  C26,C2A
1A282:  MOVLB  C
1A284:  MOVF   x26,W
1A286:  SUBLW  39
1A288:  BNZ   1A2BE
1A28A:  MOVF   x2B,F
1A28C:  BNZ   1A2BE
1A28E:  MOVF   x2C,F
1A290:  BNZ   1A2BE
1A292:  MOVF   x2D,F
1A294:  BNZ   1A2BE
1A296:  MOVLB  7
1A298:  MOVF   x50,F
1A29A:  BNZ   1A2BC
1A29C:  MOVLW  C0
1A29E:  MOVLB  B
1A2A0:  MOVWF  xF8
1A2A2:  MOVLW  93
1A2A4:  MOVWF  xF9
1A2A6:  MOVLW  0B
1A2A8:  MOVLB  C
1A2AA:  MOVWF  x27
1A2AC:  MOVLW  F8
1A2AE:  MOVWF  x26
1A2B0:  SETF   x28
1A2B2:  MOVFF  55A,C29
1A2B6:  MOVLB  0
1A2B8:  CALL   17C34
1A2BC:  MOVLB  C
....................  
....................     periodic_command_clear_rx_flag(period, 60);                // RELAY 
1A2BE:  BSF    FD8.1
1A2C0:  MOVLW  0C
1A2C2:  MOVWF  FEA
1A2C4:  MOVLW  26
1A2C6:  MOVWF  FE9
1A2C8:  MOVFF  3E,C95
1A2CC:  MOVFF  3D,C94
1A2D0:  MOVFF  3C,C93
1A2D4:  MOVFF  3B,C92
1A2D8:  CLRF   x99
1A2DA:  CLRF   x98
1A2DC:  CLRF   x97
1A2DE:  MOVLW  78
1A2E0:  MOVWF  x96
1A2E2:  MOVLB  0
1A2E4:  CALL   4726
1A2E8:  MOVFF  C29,C2D
1A2EC:  MOVFF  C28,C2C
1A2F0:  MOVFF  C27,C2B
1A2F4:  MOVFF  C26,C2A
1A2F8:  MOVLB  C
1A2FA:  MOVF   x26,W
1A2FC:  SUBLW  3C
1A2FE:  BNZ   1A312
1A300:  MOVF   x2B,F
1A302:  BNZ   1A312
1A304:  MOVF   x2C,F
1A306:  BNZ   1A312
1A308:  MOVF   x2D,F
1A30A:  BNZ   1A312
1A30C:  MOVLB  7
1A30E:  CLRF   x50
1A310:  MOVLB  C
....................     periodic_command(period, 60, verbose, { MSG_COMM, 0x94 }); // RELAY 
1A312:  BSF    FD8.1
1A314:  MOVLW  0C
1A316:  MOVWF  FEA
1A318:  MOVLW  26
1A31A:  MOVWF  FE9
1A31C:  MOVFF  3E,C95
1A320:  MOVFF  3D,C94
1A324:  MOVFF  3C,C93
1A328:  MOVFF  3B,C92
1A32C:  CLRF   x99
1A32E:  CLRF   x98
1A330:  CLRF   x97
1A332:  MOVLW  78
1A334:  MOVWF  x96
1A336:  MOVLB  0
1A338:  CALL   4726
1A33C:  MOVFF  C29,C2D
1A340:  MOVFF  C28,C2C
1A344:  MOVFF  C27,C2B
1A348:  MOVFF  C26,C2A
1A34C:  MOVLB  C
1A34E:  MOVF   x26,W
1A350:  SUBLW  3C
1A352:  BNZ   1A388
1A354:  MOVF   x2B,F
1A356:  BNZ   1A388
1A358:  MOVF   x2C,F
1A35A:  BNZ   1A388
1A35C:  MOVF   x2D,F
1A35E:  BNZ   1A388
1A360:  MOVLB  7
1A362:  MOVF   x50,F
1A364:  BNZ   1A386
1A366:  MOVLW  C0
1A368:  MOVLB  B
1A36A:  MOVWF  xFA
1A36C:  MOVLW  94
1A36E:  MOVWF  xFB
1A370:  MOVLW  0B
1A372:  MOVLB  C
1A374:  MOVWF  x27
1A376:  MOVLW  FA
1A378:  MOVWF  x26
1A37A:  SETF   x28
1A37C:  MOVFF  55A,C29
1A380:  MOVLB  0
1A382:  CALL   17C34
1A386:  MOVLB  C
....................     periodic_command(period, 63, verbose, { MSG_COMM, 0x94 }); // RELAY 
1A388:  BSF    FD8.1
1A38A:  MOVLW  0C
1A38C:  MOVWF  FEA
1A38E:  MOVLW  26
1A390:  MOVWF  FE9
1A392:  MOVFF  3E,C95
1A396:  MOVFF  3D,C94
1A39A:  MOVFF  3C,C93
1A39E:  MOVFF  3B,C92
1A3A2:  CLRF   x99
1A3A4:  CLRF   x98
1A3A6:  CLRF   x97
1A3A8:  MOVLW  78
1A3AA:  MOVWF  x96
1A3AC:  MOVLB  0
1A3AE:  CALL   4726
1A3B2:  MOVFF  C29,C2D
1A3B6:  MOVFF  C28,C2C
1A3BA:  MOVFF  C27,C2B
1A3BE:  MOVFF  C26,C2A
1A3C2:  MOVLB  C
1A3C4:  MOVF   x26,W
1A3C6:  SUBLW  3F
1A3C8:  BNZ   1A3FE
1A3CA:  MOVF   x2B,F
1A3CC:  BNZ   1A3FE
1A3CE:  MOVF   x2C,F
1A3D0:  BNZ   1A3FE
1A3D2:  MOVF   x2D,F
1A3D4:  BNZ   1A3FE
1A3D6:  MOVLB  7
1A3D8:  MOVF   x50,F
1A3DA:  BNZ   1A3FC
1A3DC:  MOVLW  C0
1A3DE:  MOVLB  B
1A3E0:  MOVWF  xFC
1A3E2:  MOVLW  94
1A3E4:  MOVWF  xFD
1A3E6:  MOVLW  0B
1A3E8:  MOVLB  C
1A3EA:  MOVWF  x27
1A3EC:  MOVLW  FC
1A3EE:  MOVWF  x26
1A3F0:  SETF   x28
1A3F2:  MOVFF  55A,C29
1A3F6:  MOVLB  0
1A3F8:  CALL   17C34
1A3FC:  MOVLB  C
....................     periodic_command(period, 66, verbose, { MSG_COMM, 0x94 }); // RELAY 
1A3FE:  BSF    FD8.1
1A400:  MOVLW  0C
1A402:  MOVWF  FEA
1A404:  MOVLW  26
1A406:  MOVWF  FE9
1A408:  MOVFF  3E,C95
1A40C:  MOVFF  3D,C94
1A410:  MOVFF  3C,C93
1A414:  MOVFF  3B,C92
1A418:  CLRF   x99
1A41A:  CLRF   x98
1A41C:  CLRF   x97
1A41E:  MOVLW  78
1A420:  MOVWF  x96
1A422:  MOVLB  0
1A424:  CALL   4726
1A428:  MOVFF  C29,C2D
1A42C:  MOVFF  C28,C2C
1A430:  MOVFF  C27,C2B
1A434:  MOVFF  C26,C2A
1A438:  MOVLB  C
1A43A:  MOVF   x26,W
1A43C:  SUBLW  42
1A43E:  BNZ   1A474
1A440:  MOVF   x2B,F
1A442:  BNZ   1A474
1A444:  MOVF   x2C,F
1A446:  BNZ   1A474
1A448:  MOVF   x2D,F
1A44A:  BNZ   1A474
1A44C:  MOVLB  7
1A44E:  MOVF   x50,F
1A450:  BNZ   1A472
1A452:  MOVLW  C0
1A454:  MOVLB  B
1A456:  MOVWF  xFE
1A458:  MOVLW  94
1A45A:  MOVWF  xFF
1A45C:  MOVLW  0B
1A45E:  MOVLB  C
1A460:  MOVWF  x27
1A462:  MOVLW  FE
1A464:  MOVWF  x26
1A466:  SETF   x28
1A468:  MOVFF  55A,C29
1A46C:  MOVLB  0
1A46E:  CALL   17C34
1A472:  MOVLB  C
....................     periodic_command(period, 69, verbose, { MSG_COMM, 0x94 }); // RELAY 
1A474:  BSF    FD8.1
1A476:  MOVLW  0C
1A478:  MOVWF  FEA
1A47A:  MOVLW  26
1A47C:  MOVWF  FE9
1A47E:  MOVFF  3E,C95
1A482:  MOVFF  3D,C94
1A486:  MOVFF  3C,C93
1A48A:  MOVFF  3B,C92
1A48E:  CLRF   x99
1A490:  CLRF   x98
1A492:  CLRF   x97
1A494:  MOVLW  78
1A496:  MOVWF  x96
1A498:  MOVLB  0
1A49A:  CALL   4726
1A49E:  MOVFF  C29,C2D
1A4A2:  MOVFF  C28,C2C
1A4A6:  MOVFF  C27,C2B
1A4AA:  MOVFF  C26,C2A
1A4AE:  MOVLB  C
1A4B0:  MOVF   x26,W
1A4B2:  SUBLW  45
1A4B4:  BNZ   1A4E6
1A4B6:  MOVF   x2B,F
1A4B8:  BNZ   1A4E6
1A4BA:  MOVF   x2C,F
1A4BC:  BNZ   1A4E6
1A4BE:  MOVF   x2D,F
1A4C0:  BNZ   1A4E6
1A4C2:  MOVLB  7
1A4C4:  MOVF   x50,F
1A4C6:  BNZ   1A4E4
1A4C8:  MOVLW  C0
1A4CA:  MOVLB  C
1A4CC:  MOVWF  x00
1A4CE:  MOVLW  94
1A4D0:  MOVWF  x01
1A4D2:  MOVLW  0C
1A4D4:  MOVWF  x27
1A4D6:  CLRF   x26
1A4D8:  SETF   x28
1A4DA:  MOVFF  55A,C29
1A4DE:  MOVLB  0
1A4E0:  CALL   17C34
1A4E4:  MOVLB  C
....................     periodic_command(period, 72, verbose, { MSG_COMM, 0x94 }); // RELAY 
1A4E6:  BSF    FD8.1
1A4E8:  MOVLW  0C
1A4EA:  MOVWF  FEA
1A4EC:  MOVLW  26
1A4EE:  MOVWF  FE9
1A4F0:  MOVFF  3E,C95
1A4F4:  MOVFF  3D,C94
1A4F8:  MOVFF  3C,C93
1A4FC:  MOVFF  3B,C92
1A500:  CLRF   x99
1A502:  CLRF   x98
1A504:  CLRF   x97
1A506:  MOVLW  78
1A508:  MOVWF  x96
1A50A:  MOVLB  0
1A50C:  CALL   4726
1A510:  MOVFF  C29,C2D
1A514:  MOVFF  C28,C2C
1A518:  MOVFF  C27,C2B
1A51C:  MOVFF  C26,C2A
1A520:  MOVLB  C
1A522:  MOVF   x26,W
1A524:  SUBLW  48
1A526:  BNZ   1A55A
1A528:  MOVF   x2B,F
1A52A:  BNZ   1A55A
1A52C:  MOVF   x2C,F
1A52E:  BNZ   1A55A
1A530:  MOVF   x2D,F
1A532:  BNZ   1A55A
1A534:  MOVLB  7
1A536:  MOVF   x50,F
1A538:  BNZ   1A558
1A53A:  MOVLW  C0
1A53C:  MOVLB  C
1A53E:  MOVWF  x02
1A540:  MOVLW  94
1A542:  MOVWF  x03
1A544:  MOVLW  0C
1A546:  MOVWF  x27
1A548:  MOVLW  02
1A54A:  MOVWF  x26
1A54C:  SETF   x28
1A54E:  MOVFF  55A,C29
1A552:  MOVLB  0
1A554:  CALL   17C34
1A558:  MOVLB  C
....................  
....................     periodic_command_clear_rx_flag(period, 75);                // TMCR1 
1A55A:  BSF    FD8.1
1A55C:  MOVLW  0C
1A55E:  MOVWF  FEA
1A560:  MOVLW  26
1A562:  MOVWF  FE9
1A564:  MOVFF  3E,C95
1A568:  MOVFF  3D,C94
1A56C:  MOVFF  3C,C93
1A570:  MOVFF  3B,C92
1A574:  CLRF   x99
1A576:  CLRF   x98
1A578:  CLRF   x97
1A57A:  MOVLW  78
1A57C:  MOVWF  x96
1A57E:  MOVLB  0
1A580:  CALL   4726
1A584:  MOVFF  C29,C2D
1A588:  MOVFF  C28,C2C
1A58C:  MOVFF  C27,C2B
1A590:  MOVFF  C26,C2A
1A594:  MOVLB  C
1A596:  MOVF   x26,W
1A598:  SUBLW  4B
1A59A:  BNZ   1A5AE
1A59C:  MOVF   x2B,F
1A59E:  BNZ   1A5AE
1A5A0:  MOVF   x2C,F
1A5A2:  BNZ   1A5AE
1A5A4:  MOVF   x2D,F
1A5A6:  BNZ   1A5AE
1A5A8:  MOVLB  7
1A5AA:  CLRF   x50
1A5AC:  MOVLB  C
....................     periodic_command(period, 75, verbose, { MSG_COMM, 0x95 }); // TMCR1 
1A5AE:  BSF    FD8.1
1A5B0:  MOVLW  0C
1A5B2:  MOVWF  FEA
1A5B4:  MOVLW  26
1A5B6:  MOVWF  FE9
1A5B8:  MOVFF  3E,C95
1A5BC:  MOVFF  3D,C94
1A5C0:  MOVFF  3C,C93
1A5C4:  MOVFF  3B,C92
1A5C8:  CLRF   x99
1A5CA:  CLRF   x98
1A5CC:  CLRF   x97
1A5CE:  MOVLW  78
1A5D0:  MOVWF  x96
1A5D2:  MOVLB  0
1A5D4:  CALL   4726
1A5D8:  MOVFF  C29,C2D
1A5DC:  MOVFF  C28,C2C
1A5E0:  MOVFF  C27,C2B
1A5E4:  MOVFF  C26,C2A
1A5E8:  MOVLB  C
1A5EA:  MOVF   x26,W
1A5EC:  SUBLW  4B
1A5EE:  BNZ   1A622
1A5F0:  MOVF   x2B,F
1A5F2:  BNZ   1A622
1A5F4:  MOVF   x2C,F
1A5F6:  BNZ   1A622
1A5F8:  MOVF   x2D,F
1A5FA:  BNZ   1A622
1A5FC:  MOVLB  7
1A5FE:  MOVF   x50,F
1A600:  BNZ   1A620
1A602:  MOVLW  C0
1A604:  MOVLB  C
1A606:  MOVWF  x04
1A608:  MOVLW  95
1A60A:  MOVWF  x05
1A60C:  MOVLW  0C
1A60E:  MOVWF  x27
1A610:  MOVLW  04
1A612:  MOVWF  x26
1A614:  SETF   x28
1A616:  MOVFF  55A,C29
1A61A:  MOVLB  0
1A61C:  CALL   17C34
1A620:  MOVLB  C
....................     periodic_command(period, 78, verbose, { MSG_COMM, 0x95 }); // TMCR1 
1A622:  BSF    FD8.1
1A624:  MOVLW  0C
1A626:  MOVWF  FEA
1A628:  MOVLW  26
1A62A:  MOVWF  FE9
1A62C:  MOVFF  3E,C95
1A630:  MOVFF  3D,C94
1A634:  MOVFF  3C,C93
1A638:  MOVFF  3B,C92
1A63C:  CLRF   x99
1A63E:  CLRF   x98
1A640:  CLRF   x97
1A642:  MOVLW  78
1A644:  MOVWF  x96
1A646:  MOVLB  0
1A648:  CALL   4726
1A64C:  MOVFF  C29,C2D
1A650:  MOVFF  C28,C2C
1A654:  MOVFF  C27,C2B
1A658:  MOVFF  C26,C2A
1A65C:  MOVLB  C
1A65E:  MOVF   x26,W
1A660:  SUBLW  4E
1A662:  BNZ   1A696
1A664:  MOVF   x2B,F
1A666:  BNZ   1A696
1A668:  MOVF   x2C,F
1A66A:  BNZ   1A696
1A66C:  MOVF   x2D,F
1A66E:  BNZ   1A696
1A670:  MOVLB  7
1A672:  MOVF   x50,F
1A674:  BNZ   1A694
1A676:  MOVLW  C0
1A678:  MOVLB  C
1A67A:  MOVWF  x06
1A67C:  MOVLW  95
1A67E:  MOVWF  x07
1A680:  MOVLW  0C
1A682:  MOVWF  x27
1A684:  MOVLW  06
1A686:  MOVWF  x26
1A688:  SETF   x28
1A68A:  MOVFF  55A,C29
1A68E:  MOVLB  0
1A690:  CALL   17C34
1A694:  MOVLB  C
....................     periodic_command(period, 81, verbose, { MSG_COMM, 0x95 }); // TMCR1 
1A696:  BSF    FD8.1
1A698:  MOVLW  0C
1A69A:  MOVWF  FEA
1A69C:  MOVLW  26
1A69E:  MOVWF  FE9
1A6A0:  MOVFF  3E,C95
1A6A4:  MOVFF  3D,C94
1A6A8:  MOVFF  3C,C93
1A6AC:  MOVFF  3B,C92
1A6B0:  CLRF   x99
1A6B2:  CLRF   x98
1A6B4:  CLRF   x97
1A6B6:  MOVLW  78
1A6B8:  MOVWF  x96
1A6BA:  MOVLB  0
1A6BC:  CALL   4726
1A6C0:  MOVFF  C29,C2D
1A6C4:  MOVFF  C28,C2C
1A6C8:  MOVFF  C27,C2B
1A6CC:  MOVFF  C26,C2A
1A6D0:  MOVLB  C
1A6D2:  MOVF   x26,W
1A6D4:  SUBLW  51
1A6D6:  BNZ   1A70A
1A6D8:  MOVF   x2B,F
1A6DA:  BNZ   1A70A
1A6DC:  MOVF   x2C,F
1A6DE:  BNZ   1A70A
1A6E0:  MOVF   x2D,F
1A6E2:  BNZ   1A70A
1A6E4:  MOVLB  7
1A6E6:  MOVF   x50,F
1A6E8:  BNZ   1A708
1A6EA:  MOVLW  C0
1A6EC:  MOVLB  C
1A6EE:  MOVWF  x08
1A6F0:  MOVLW  95
1A6F2:  MOVWF  x09
1A6F4:  MOVLW  0C
1A6F6:  MOVWF  x27
1A6F8:  MOVLW  08
1A6FA:  MOVWF  x26
1A6FC:  SETF   x28
1A6FE:  MOVFF  55A,C29
1A702:  MOVLB  0
1A704:  CALL   17C34
1A708:  MOVLB  C
....................     periodic_command(period, 84, verbose, { MSG_COMM, 0x95 }); // TMCR1 
1A70A:  BSF    FD8.1
1A70C:  MOVLW  0C
1A70E:  MOVWF  FEA
1A710:  MOVLW  26
1A712:  MOVWF  FE9
1A714:  MOVFF  3E,C95
1A718:  MOVFF  3D,C94
1A71C:  MOVFF  3C,C93
1A720:  MOVFF  3B,C92
1A724:  CLRF   x99
1A726:  CLRF   x98
1A728:  CLRF   x97
1A72A:  MOVLW  78
1A72C:  MOVWF  x96
1A72E:  MOVLB  0
1A730:  CALL   4726
1A734:  MOVFF  C29,C2D
1A738:  MOVFF  C28,C2C
1A73C:  MOVFF  C27,C2B
1A740:  MOVFF  C26,C2A
1A744:  MOVLB  C
1A746:  MOVF   x26,W
1A748:  SUBLW  54
1A74A:  BNZ   1A77E
1A74C:  MOVF   x2B,F
1A74E:  BNZ   1A77E
1A750:  MOVF   x2C,F
1A752:  BNZ   1A77E
1A754:  MOVF   x2D,F
1A756:  BNZ   1A77E
1A758:  MOVLB  7
1A75A:  MOVF   x50,F
1A75C:  BNZ   1A77C
1A75E:  MOVLW  C0
1A760:  MOVLB  C
1A762:  MOVWF  x0A
1A764:  MOVLW  95
1A766:  MOVWF  x0B
1A768:  MOVLW  0C
1A76A:  MOVWF  x27
1A76C:  MOVLW  0A
1A76E:  MOVWF  x26
1A770:  SETF   x28
1A772:  MOVFF  55A,C29
1A776:  MOVLB  0
1A778:  CALL   17C34
1A77C:  MOVLB  C
....................     periodic_command(period, 87, verbose, { MSG_COMM, 0x95 }); // TMCR1 
1A77E:  BSF    FD8.1
1A780:  MOVLW  0C
1A782:  MOVWF  FEA
1A784:  MOVLW  26
1A786:  MOVWF  FE9
1A788:  MOVFF  3E,C95
1A78C:  MOVFF  3D,C94
1A790:  MOVFF  3C,C93
1A794:  MOVFF  3B,C92
1A798:  CLRF   x99
1A79A:  CLRF   x98
1A79C:  CLRF   x97
1A79E:  MOVLW  78
1A7A0:  MOVWF  x96
1A7A2:  MOVLB  0
1A7A4:  CALL   4726
1A7A8:  MOVFF  C29,C2D
1A7AC:  MOVFF  C28,C2C
1A7B0:  MOVFF  C27,C2B
1A7B4:  MOVFF  C26,C2A
1A7B8:  MOVLB  C
1A7BA:  MOVF   x26,W
1A7BC:  SUBLW  57
1A7BE:  BNZ   1A7F0
1A7C0:  MOVF   x2B,F
1A7C2:  BNZ   1A7F0
1A7C4:  MOVF   x2C,F
1A7C6:  BNZ   1A7F0
1A7C8:  MOVF   x2D,F
1A7CA:  BNZ   1A7F0
1A7CC:  MOVLB  7
1A7CE:  MOVF   x50,F
1A7D0:  BNZ   1A7EE
1A7D2:  MOVLW  C0
1A7D4:  MOVLB  C
1A7D6:  MOVWF  x0C
1A7D8:  MOVLW  95
1A7DA:  MOVWF  x0D
1A7DC:  MOVLW  0C
1A7DE:  MOVWF  x27
1A7E0:  MOVWF  x26
1A7E2:  SETF   x28
1A7E4:  MOVFF  55A,C29
1A7E8:  MOVLB  0
1A7EA:  CALL   17C34
1A7EE:  MOVLB  C
....................  
....................     periodic_command_clear_rx_flag(period, 90);                 // TMCR2 
1A7F0:  BSF    FD8.1
1A7F2:  MOVLW  0C
1A7F4:  MOVWF  FEA
1A7F6:  MOVLW  26
1A7F8:  MOVWF  FE9
1A7FA:  MOVFF  3E,C95
1A7FE:  MOVFF  3D,C94
1A802:  MOVFF  3C,C93
1A806:  MOVFF  3B,C92
1A80A:  CLRF   x99
1A80C:  CLRF   x98
1A80E:  CLRF   x97
1A810:  MOVLW  78
1A812:  MOVWF  x96
1A814:  MOVLB  0
1A816:  CALL   4726
1A81A:  MOVFF  C29,C2D
1A81E:  MOVFF  C28,C2C
1A822:  MOVFF  C27,C2B
1A826:  MOVFF  C26,C2A
1A82A:  MOVLB  C
1A82C:  MOVF   x26,W
1A82E:  SUBLW  5A
1A830:  BNZ   1A844
1A832:  MOVF   x2B,F
1A834:  BNZ   1A844
1A836:  MOVF   x2C,F
1A838:  BNZ   1A844
1A83A:  MOVF   x2D,F
1A83C:  BNZ   1A844
1A83E:  MOVLB  7
1A840:  CLRF   x50
1A842:  MOVLB  C
....................     periodic_command(period, 90, verbose, { MSG_COMM, 0x96 });  // TMCR2 
1A844:  BSF    FD8.1
1A846:  MOVLW  0C
1A848:  MOVWF  FEA
1A84A:  MOVLW  26
1A84C:  MOVWF  FE9
1A84E:  MOVFF  3E,C95
1A852:  MOVFF  3D,C94
1A856:  MOVFF  3C,C93
1A85A:  MOVFF  3B,C92
1A85E:  CLRF   x99
1A860:  CLRF   x98
1A862:  CLRF   x97
1A864:  MOVLW  78
1A866:  MOVWF  x96
1A868:  MOVLB  0
1A86A:  CALL   4726
1A86E:  MOVFF  C29,C2D
1A872:  MOVFF  C28,C2C
1A876:  MOVFF  C27,C2B
1A87A:  MOVFF  C26,C2A
1A87E:  MOVLB  C
1A880:  MOVF   x26,W
1A882:  SUBLW  5A
1A884:  BNZ   1A8B8
1A886:  MOVF   x2B,F
1A888:  BNZ   1A8B8
1A88A:  MOVF   x2C,F
1A88C:  BNZ   1A8B8
1A88E:  MOVF   x2D,F
1A890:  BNZ   1A8B8
1A892:  MOVLB  7
1A894:  MOVF   x50,F
1A896:  BNZ   1A8B6
1A898:  MOVLW  C0
1A89A:  MOVLB  C
1A89C:  MOVWF  x0E
1A89E:  MOVLW  96
1A8A0:  MOVWF  x0F
1A8A2:  MOVLW  0C
1A8A4:  MOVWF  x27
1A8A6:  MOVLW  0E
1A8A8:  MOVWF  x26
1A8AA:  SETF   x28
1A8AC:  MOVFF  55A,C29
1A8B0:  MOVLB  0
1A8B2:  CALL   17C34
1A8B6:  MOVLB  C
....................     periodic_command(period, 93, verbose, { MSG_COMM, 0x96 });  // TMCR2 
1A8B8:  BSF    FD8.1
1A8BA:  MOVLW  0C
1A8BC:  MOVWF  FEA
1A8BE:  MOVLW  26
1A8C0:  MOVWF  FE9
1A8C2:  MOVFF  3E,C95
1A8C6:  MOVFF  3D,C94
1A8CA:  MOVFF  3C,C93
1A8CE:  MOVFF  3B,C92
1A8D2:  CLRF   x99
1A8D4:  CLRF   x98
1A8D6:  CLRF   x97
1A8D8:  MOVLW  78
1A8DA:  MOVWF  x96
1A8DC:  MOVLB  0
1A8DE:  CALL   4726
1A8E2:  MOVFF  C29,C2D
1A8E6:  MOVFF  C28,C2C
1A8EA:  MOVFF  C27,C2B
1A8EE:  MOVFF  C26,C2A
1A8F2:  MOVLB  C
1A8F4:  MOVF   x26,W
1A8F6:  SUBLW  5D
1A8F8:  BNZ   1A92C
1A8FA:  MOVF   x2B,F
1A8FC:  BNZ   1A92C
1A8FE:  MOVF   x2C,F
1A900:  BNZ   1A92C
1A902:  MOVF   x2D,F
1A904:  BNZ   1A92C
1A906:  MOVLB  7
1A908:  MOVF   x50,F
1A90A:  BNZ   1A92A
1A90C:  MOVLW  C0
1A90E:  MOVLB  C
1A910:  MOVWF  x10
1A912:  MOVLW  96
1A914:  MOVWF  x11
1A916:  MOVLW  0C
1A918:  MOVWF  x27
1A91A:  MOVLW  10
1A91C:  MOVWF  x26
1A91E:  SETF   x28
1A920:  MOVFF  55A,C29
1A924:  MOVLB  0
1A926:  CALL   17C34
1A92A:  MOVLB  C
....................     periodic_command(period, 96, verbose, { MSG_COMM, 0x96 });  // TMCR2 
1A92C:  BSF    FD8.1
1A92E:  MOVLW  0C
1A930:  MOVWF  FEA
1A932:  MOVLW  26
1A934:  MOVWF  FE9
1A936:  MOVFF  3E,C95
1A93A:  MOVFF  3D,C94
1A93E:  MOVFF  3C,C93
1A942:  MOVFF  3B,C92
1A946:  CLRF   x99
1A948:  CLRF   x98
1A94A:  CLRF   x97
1A94C:  MOVLW  78
1A94E:  MOVWF  x96
1A950:  MOVLB  0
1A952:  CALL   4726
1A956:  MOVFF  C29,C2D
1A95A:  MOVFF  C28,C2C
1A95E:  MOVFF  C27,C2B
1A962:  MOVFF  C26,C2A
1A966:  MOVLB  C
1A968:  MOVF   x26,W
1A96A:  SUBLW  60
1A96C:  BNZ   1A9A0
1A96E:  MOVF   x2B,F
1A970:  BNZ   1A9A0
1A972:  MOVF   x2C,F
1A974:  BNZ   1A9A0
1A976:  MOVF   x2D,F
1A978:  BNZ   1A9A0
1A97A:  MOVLB  7
1A97C:  MOVF   x50,F
1A97E:  BNZ   1A99E
1A980:  MOVLW  C0
1A982:  MOVLB  C
1A984:  MOVWF  x12
1A986:  MOVLW  96
1A988:  MOVWF  x13
1A98A:  MOVLW  0C
1A98C:  MOVWF  x27
1A98E:  MOVLW  12
1A990:  MOVWF  x26
1A992:  SETF   x28
1A994:  MOVFF  55A,C29
1A998:  MOVLB  0
1A99A:  CALL   17C34
1A99E:  MOVLB  C
....................     periodic_command(period, 99, verbose, { MSG_COMM, 0x96 });  // TMCR2 
1A9A0:  BSF    FD8.1
1A9A2:  MOVLW  0C
1A9A4:  MOVWF  FEA
1A9A6:  MOVLW  26
1A9A8:  MOVWF  FE9
1A9AA:  MOVFF  3E,C95
1A9AE:  MOVFF  3D,C94
1A9B2:  MOVFF  3C,C93
1A9B6:  MOVFF  3B,C92
1A9BA:  CLRF   x99
1A9BC:  CLRF   x98
1A9BE:  CLRF   x97
1A9C0:  MOVLW  78
1A9C2:  MOVWF  x96
1A9C4:  MOVLB  0
1A9C6:  CALL   4726
1A9CA:  MOVFF  C29,C2D
1A9CE:  MOVFF  C28,C2C
1A9D2:  MOVFF  C27,C2B
1A9D6:  MOVFF  C26,C2A
1A9DA:  MOVLB  C
1A9DC:  MOVF   x26,W
1A9DE:  SUBLW  63
1A9E0:  BNZ   1AA14
1A9E2:  MOVF   x2B,F
1A9E4:  BNZ   1AA14
1A9E6:  MOVF   x2C,F
1A9E8:  BNZ   1AA14
1A9EA:  MOVF   x2D,F
1A9EC:  BNZ   1AA14
1A9EE:  MOVLB  7
1A9F0:  MOVF   x50,F
1A9F2:  BNZ   1AA12
1A9F4:  MOVLW  C0
1A9F6:  MOVLB  C
1A9F8:  MOVWF  x14
1A9FA:  MOVLW  96
1A9FC:  MOVWF  x15
1A9FE:  MOVLW  0C
1AA00:  MOVWF  x27
1AA02:  MOVLW  14
1AA04:  MOVWF  x26
1AA06:  SETF   x28
1AA08:  MOVFF  55A,C29
1AA0C:  MOVLB  0
1AA0E:  CALL   17C34
1AA12:  MOVLB  C
....................     periodic_command(period, 102, verbose, { MSG_COMM, 0x96 }); // TMCR2 
1AA14:  BSF    FD8.1
1AA16:  MOVLW  0C
1AA18:  MOVWF  FEA
1AA1A:  MOVLW  26
1AA1C:  MOVWF  FE9
1AA1E:  MOVFF  3E,C95
1AA22:  MOVFF  3D,C94
1AA26:  MOVFF  3C,C93
1AA2A:  MOVFF  3B,C92
1AA2E:  CLRF   x99
1AA30:  CLRF   x98
1AA32:  CLRF   x97
1AA34:  MOVLW  78
1AA36:  MOVWF  x96
1AA38:  MOVLB  0
1AA3A:  CALL   4726
1AA3E:  MOVFF  C29,C2D
1AA42:  MOVFF  C28,C2C
1AA46:  MOVFF  C27,C2B
1AA4A:  MOVFF  C26,C2A
1AA4E:  MOVLB  C
1AA50:  MOVF   x26,W
1AA52:  SUBLW  66
1AA54:  BNZ   1AA88
1AA56:  MOVF   x2B,F
1AA58:  BNZ   1AA88
1AA5A:  MOVF   x2C,F
1AA5C:  BNZ   1AA88
1AA5E:  MOVF   x2D,F
1AA60:  BNZ   1AA88
1AA62:  MOVLB  7
1AA64:  MOVF   x50,F
1AA66:  BNZ   1AA86
1AA68:  MOVLW  C0
1AA6A:  MOVLB  C
1AA6C:  MOVWF  x16
1AA6E:  MOVLW  96
1AA70:  MOVWF  x17
1AA72:  MOVLW  0C
1AA74:  MOVWF  x27
1AA76:  MOVLW  16
1AA78:  MOVWF  x26
1AA7A:  SETF   x28
1AA7C:  MOVFF  55A,C29
1AA80:  MOVLB  0
1AA82:  CALL   17C34
1AA86:  MOVLB  C
....................     periodic_command_clear_rx_flag(period, 105);                // TMCR2 
1AA88:  BSF    FD8.1
1AA8A:  MOVLW  0C
1AA8C:  MOVWF  FEA
1AA8E:  MOVLW  26
1AA90:  MOVWF  FE9
1AA92:  MOVFF  3E,C95
1AA96:  MOVFF  3D,C94
1AA9A:  MOVFF  3C,C93
1AA9E:  MOVFF  3B,C92
1AAA2:  CLRF   x99
1AAA4:  CLRF   x98
1AAA6:  CLRF   x97
1AAA8:  MOVLW  78
1AAAA:  MOVWF  x96
1AAAC:  MOVLB  0
1AAAE:  CALL   4726
1AAB2:  MOVFF  C29,C2D
1AAB6:  MOVFF  C28,C2C
1AABA:  MOVFF  C27,C2B
1AABE:  MOVFF  C26,C2A
1AAC2:  MOVLB  C
1AAC4:  MOVF   x26,W
1AAC6:  SUBLW  69
1AAC8:  BNZ   1AADC
1AACA:  MOVF   x2B,F
1AACC:  BNZ   1AADC
1AACE:  MOVF   x2C,F
1AAD0:  BNZ   1AADC
1AAD2:  MOVF   x2D,F
1AAD4:  BNZ   1AADC
1AAD6:  MOVLB  7
1AAD8:  CLRF   x50
1AADA:  MOVLB  C
....................  
....................     periodic_command(period, 105, true, { MSG_COMM, 0xF8 }); // Telemetry generation 
1AADC:  BSF    FD8.1
1AADE:  MOVLW  0C
1AAE0:  MOVWF  FEA
1AAE2:  MOVLW  26
1AAE4:  MOVWF  FE9
1AAE6:  MOVFF  3E,C95
1AAEA:  MOVFF  3D,C94
1AAEE:  MOVFF  3C,C93
1AAF2:  MOVFF  3B,C92
1AAF6:  CLRF   x99
1AAF8:  CLRF   x98
1AAFA:  CLRF   x97
1AAFC:  MOVLW  78
1AAFE:  MOVWF  x96
1AB00:  MOVLB  0
1AB02:  CALL   4726
1AB06:  MOVFF  C29,C2D
1AB0A:  MOVFF  C28,C2C
1AB0E:  MOVFF  C27,C2B
1AB12:  MOVFF  C26,C2A
1AB16:  MOVLB  C
1AB18:  MOVF   x26,W
1AB1A:  SUBLW  69
1AB1C:  BNZ   1AB50
1AB1E:  MOVF   x2B,F
1AB20:  BNZ   1AB50
1AB22:  MOVF   x2C,F
1AB24:  BNZ   1AB50
1AB26:  MOVF   x2D,F
1AB28:  BNZ   1AB50
1AB2A:  MOVLB  7
1AB2C:  MOVF   x50,F
1AB2E:  BNZ   1AB4E
1AB30:  MOVLW  C0
1AB32:  MOVLB  C
1AB34:  MOVWF  x18
1AB36:  MOVLW  F8
1AB38:  MOVWF  x19
1AB3A:  MOVLW  0C
1AB3C:  MOVWF  x27
1AB3E:  MOVLW  18
1AB40:  MOVWF  x26
1AB42:  SETF   x28
1AB44:  MOVLW  01
1AB46:  MOVWF  x29
1AB48:  MOVLB  0
1AB4A:  CALL   17C34
1AB4E:  MOVLB  C
....................  
....................     // Automatic SEL mission: 
....................     const time_t sel_period = 24 * 60 * 60;                                               // SEL period is 24h 
....................     const time_t sel_delta_zes = sel_period - 3 * 60 * 60;                                // Start 3h before midnight 
....................     const time_t sel_delta_ref = sel_delta_zes + 6 * 60;                                  // Start 6m after SEL ZES 
....................     periodic_command(sel_period, sel_delta_zes, 1, { MSG_COMM, 0x1A, 0x15, 0xD0, 0x07 }); // SEL mission ZES 
1AB50:  BSF    FD8.1
1AB52:  MOVLW  0C
1AB54:  MOVWF  FEA
1AB56:  MOVLW  26
1AB58:  MOVWF  FE9
1AB5A:  MOVFF  3E,C95
1AB5E:  MOVFF  3D,C94
1AB62:  MOVFF  3C,C93
1AB66:  MOVFF  3B,C92
1AB6A:  CLRF   x99
1AB6C:  MOVLW  01
1AB6E:  MOVWF  x98
1AB70:  MOVLW  51
1AB72:  MOVWF  x97
1AB74:  MOVLW  80
1AB76:  MOVWF  x96
1AB78:  MOVLB  0
1AB7A:  CALL   4726
1AB7E:  MOVFF  C29,C2D
1AB82:  MOVFF  C28,C2C
1AB86:  MOVFF  C27,C2B
1AB8A:  MOVFF  C26,C2A
1AB8E:  MOVLB  C
1AB90:  MOVF   x26,W
1AB92:  SUBLW  50
1AB94:  BNZ   1ABD6
1AB96:  MOVF   x2B,W
1AB98:  SUBLW  27
1AB9A:  BNZ   1ABD6
1AB9C:  DECFSZ x2C,W
1AB9E:  BRA    1ABD6
1ABA0:  MOVF   x2D,F
1ABA2:  BNZ   1ABD6
1ABA4:  MOVLB  7
1ABA6:  MOVF   x50,F
1ABA8:  BNZ   1ABD4
1ABAA:  MOVLW  C0
1ABAC:  MOVLB  C
1ABAE:  MOVWF  x1A
1ABB0:  MOVLW  1A
1ABB2:  MOVWF  x1B
1ABB4:  MOVLW  15
1ABB6:  MOVWF  x1C
1ABB8:  MOVLW  D0
1ABBA:  MOVWF  x1D
1ABBC:  MOVLW  07
1ABBE:  MOVWF  x1E
1ABC0:  MOVLW  0C
1ABC2:  MOVWF  x27
1ABC4:  MOVLW  1A
1ABC6:  MOVWF  x26
1ABC8:  SETF   x28
1ABCA:  MOVLW  01
1ABCC:  MOVWF  x29
1ABCE:  MOVLB  0
1ABD0:  CALL   17C34
1ABD4:  MOVLB  C
....................     periodic_command(sel_period, sel_delta_ref, 1, { MSG_COMM, 0x1B, 0x0B, 0xD0, 0x07 }); // SEL mission REF 
1ABD6:  BSF    FD8.1
1ABD8:  MOVLW  0C
1ABDA:  MOVWF  FEA
1ABDC:  MOVLW  26
1ABDE:  MOVWF  FE9
1ABE0:  MOVFF  3E,C95
1ABE4:  MOVFF  3D,C94
1ABE8:  MOVFF  3C,C93
1ABEC:  MOVFF  3B,C92
1ABF0:  CLRF   x99
1ABF2:  MOVLW  01
1ABF4:  MOVWF  x98
1ABF6:  MOVLW  51
1ABF8:  MOVWF  x97
1ABFA:  MOVLW  80
1ABFC:  MOVWF  x96
1ABFE:  MOVLB  0
1AC00:  CALL   4726
1AC04:  MOVFF  C29,C2D
1AC08:  MOVFF  C28,C2C
1AC0C:  MOVFF  C27,C2B
1AC10:  MOVFF  C26,C2A
1AC14:  MOVLB  C
1AC16:  MOVF   x26,W
1AC18:  SUBLW  B8
1AC1A:  BNZ   1AC5C
1AC1C:  MOVF   x2B,W
1AC1E:  SUBLW  28
1AC20:  BNZ   1AC5C
1AC22:  DECFSZ x2C,W
1AC24:  BRA    1AC5C
1AC26:  MOVF   x2D,F
1AC28:  BNZ   1AC5C
1AC2A:  MOVLB  7
1AC2C:  MOVF   x50,F
1AC2E:  BNZ   1AC5A
1AC30:  MOVLW  C0
1AC32:  MOVLB  C
1AC34:  MOVWF  x1F
1AC36:  MOVLW  1B
1AC38:  MOVWF  x20
1AC3A:  MOVLW  0B
1AC3C:  MOVWF  x21
1AC3E:  MOVLW  D0
1AC40:  MOVWF  x22
1AC42:  MOVLW  07
1AC44:  MOVWF  x23
1AC46:  MOVLW  0C
1AC48:  MOVWF  x27
1AC4A:  MOVLW  1F
1AC4C:  MOVWF  x26
1AC4E:  SETF   x28
1AC50:  MOVLW  01
1AC52:  MOVWF  x29
1AC54:  MOVLB  0
1AC56:  CALL   17C34
1AC5A:  MOVLB  C
....................     const time_t sel_flag_period = 15 * 60;                                               // SEL period for checking flags is 15 minutes 
....................     const time_t sel_flag_delta = sel_flag_period - 5 * 60;                               // SEL delta for checking flags: 5m earlier to avoid conflict with 24h operation 
....................     periodic_command(sel_flag_period, sel_flag_delta, 1, { MSG_COMM, 0x31 });             // SEL mission for checking flags 
1AC5C:  BSF    FD8.1
1AC5E:  MOVLW  0C
1AC60:  MOVWF  FEA
1AC62:  MOVLW  26
1AC64:  MOVWF  FE9
1AC66:  MOVFF  3E,C95
1AC6A:  MOVFF  3D,C94
1AC6E:  MOVFF  3C,C93
1AC72:  MOVFF  3B,C92
1AC76:  CLRF   x99
1AC78:  CLRF   x98
1AC7A:  MOVLW  03
1AC7C:  MOVWF  x97
1AC7E:  MOVLW  84
1AC80:  MOVWF  x96
1AC82:  MOVLB  0
1AC84:  CALL   4726
1AC88:  MOVFF  C29,C2D
1AC8C:  MOVFF  C28,C2C
1AC90:  MOVFF  C27,C2B
1AC94:  MOVFF  C26,C2A
1AC98:  MOVLB  C
1AC9A:  MOVF   x26,W
1AC9C:  SUBLW  58
1AC9E:  BNZ   1ACD4
1ACA0:  MOVF   x2B,W
1ACA2:  SUBLW  02
1ACA4:  BNZ   1ACD4
1ACA6:  MOVF   x2C,F
1ACA8:  BNZ   1ACD4
1ACAA:  MOVF   x2D,F
1ACAC:  BNZ   1ACD4
1ACAE:  MOVLB  7
1ACB0:  MOVF   x50,F
1ACB2:  BNZ   1ACD2
1ACB4:  MOVLW  C0
1ACB6:  MOVLB  C
1ACB8:  MOVWF  x24
1ACBA:  MOVLW  31
1ACBC:  MOVWF  x25
1ACBE:  MOVLW  0C
1ACC0:  MOVWF  x27
1ACC2:  MOVLW  24
1ACC4:  MOVWF  x26
1ACC6:  SETF   x28
1ACC8:  MOVLW  01
1ACCA:  MOVWF  x29
1ACCC:  MOVLB  0
1ACCE:  CALL   17C34
1ACD2:  MOVLB  C
1ACD4:  MOVLB  0
1ACD6:  GOTO   1AD2C (RETURN)
.................... } 
....................  
.................... void periodic_tasks() 
.................... { 
....................     if (clock_update) { 
1ACDA:  MOVLB  7
1ACDC:  MOVF   x1E,F
1ACDE:  BTFSC  FD8.2
1ACE0:  BRA    1B19E
....................         disable_interrupts(GLOBAL); 
1ACE2:  BCF    FF2.6
1ACE4:  BCF    FF2.7
1ACE6:  BTFSC  FF2.7
1ACE8:  BRA    1ACE4
....................         clock_update = 0; 
1ACEA:  CLRF   x1E
....................         current_time = time(0); 
1ACEC:  MOVLB  C
1ACEE:  CLRF   x50
1ACF0:  CLRF   x4F
1ACF2:  MOVLB  0
1ACF4:  CALL   4C60
1ACF8:  MOVFF  03,3E
1ACFC:  MOVFF  02,3D
1AD00:  MOVFF  01,3C
1AD04:  MOVFF  00,3B
....................         // ctime(&current_time, &current_time_str); 
....................         schedule_new_commands(); 
1AD08:  GOTO   19126
....................         if (current_time != previous_time) { 
1AD0C:  MOVF   3F,W
1AD0E:  SUBWF  3B,W
1AD10:  BNZ   1AD24
1AD12:  MOVF   40,W
1AD14:  SUBWF  3C,W
1AD16:  BNZ   1AD24
1AD18:  MOVF   41,W
1AD1A:  SUBWF  3D,W
1AD1C:  BNZ   1AD24
1AD1E:  MOVF   42,W
1AD20:  SUBWF  3E,W
1AD22:  BZ    1AD2C
....................             scheduled_command_check(); 
1AD24:  GOTO   1973E
....................             periodic_requests_commands(); 
1AD28:  GOTO   19838
....................         } 
....................         struct_tm* local_time = localtime(&current_time); 
1AD2C:  MOVLB  C
1AD2E:  CLRF   x84
1AD30:  MOVLW  3B
1AD32:  MOVWF  x83
1AD34:  MOVLB  0
1AD36:  CALL   4D28
1AD3A:  MOVFF  02,BCF
1AD3E:  MOVFF  01,BCE
....................         if (local_time->tm_hour == 23 && local_time->tm_min == 59 && local_time->tm_sec == 59) { 
1AD42:  MOVLW  02
1AD44:  MOVLB  B
1AD46:  ADDWF  xCE,W
1AD48:  MOVWF  FE9
1AD4A:  MOVLW  00
1AD4C:  ADDWFC xCF,W
1AD4E:  MOVWF  FEA
1AD50:  MOVF   FEF,W
1AD52:  SUBLW  17
1AD54:  BNZ   1ADA8
1AD56:  MOVLW  01
1AD58:  ADDWF  xCE,W
1AD5A:  MOVWF  FE9
1AD5C:  MOVLW  00
1AD5E:  ADDWFC xCF,W
1AD60:  MOVWF  FEA
1AD62:  MOVF   FEF,W
1AD64:  SUBLW  3B
1AD66:  BNZ   1ADA8
1AD68:  MOVFF  BCE,FE9
1AD6C:  MOVFF  BCF,FEA
1AD70:  MOVF   FEF,W
1AD72:  SUBLW  3B
1AD74:  BNZ   1ADA8
....................             execute(1, { MSG_COMM, 0x55 }); // Save state 
1AD76:  MOVLW  C0
1AD78:  MOVWF  xD0
1AD7A:  MOVLW  55
1AD7C:  MOVWF  xD1
1AD7E:  MOVLW  0B
1AD80:  MOVLB  C
1AD82:  MOVWF  x27
1AD84:  MOVLW  D0
1AD86:  MOVWF  x26
1AD88:  SETF   x28
1AD8A:  MOVLW  01
1AD8C:  MOVWF  x29
1AD8E:  MOVLB  0
1AD90:  CALL   17C34
....................             fprintf(PC, "No 24h reset happened, doing soft reset instead.\r\n"); 
1AD94:  MOVLW  40
1AD96:  MOVWF  FF6
1AD98:  MOVLW  43
1AD9A:  MOVWF  FF7
1AD9C:  MOVLW  00
1AD9E:  MOVWF  FF8
1ADA0:  CALL   4534
....................             reset_cpu(); 
1ADA4:  RESET
1ADA6:  MOVLB  B
....................         } 
....................         previous_time = current_time; 
1ADA8:  MOVFF  3E,42
1ADAC:  MOVFF  3D,41
1ADB0:  MOVFF  3C,40
1ADB4:  MOVFF  3B,3F
....................         // clean HW uart: 
....................         uart_clean(PC); 
1ADB8:  MOVLW  08
1ADBA:  MOVLB  D
1ADBC:  MOVWF  x85
1ADBE:  MOVLW  E2
1ADC0:  MOVWF  x84
....................         uart_clean(COMM); 
*
1AE28:  MOVLW  09
1AE2A:  MOVWF  x85
1AE2C:  MOVLW  04
1AE2E:  MOVWF  x84
....................         uart_clean(FAB); 
*
1AE96:  MOVLW  09
1AE98:  MOVWF  x85
1AE9A:  MOVLW  26
1AE9C:  MOVWF  x84
....................         uart_clean(RST); 
*
1AF04:  MOVLW  09
1AF06:  MOVWF  x85
1AF08:  MOVLW  6F
1AF0A:  MOVWF  x84
....................         uart_clean(ADCS); 
*
1AF72:  MOVLW  09
1AF74:  MOVWF  x85
1AF76:  MOVLW  9C
1AF78:  MOVWF  x84
....................         uart_clean(MCPIC); 
*
1AFE0:  MOVLW  09
1AFE2:  MOVWF  x85
1AFE4:  MOVLW  D1
1AFE6:  MOVWF  x84
....................         uart_clean(PCIB); 
*
1B04E:  MOVLW  09
1B050:  MOVWF  x85
1B052:  MOVLW  E0
1B054:  MOVWF  x84
....................         uart_clean(TMCR1); 
*
1B0BC:  MOVLW  0A
1B0BE:  MOVWF  x85
1B0C0:  MOVLW  0D
1B0C2:  MOVWF  x84
....................         uart_clean(TMCR2); 
*
1B12A:  MOVLW  0A
1B12C:  MOVWF  x85
1B12E:  MOVLW  3A
1B130:  MOVWF  x84
....................         enable_interrupts(GLOBAL); 
*
1B198:  MOVLW  C0
1B19A:  IORWF  FF2,F
1B19C:  MOVLB  7
....................     } 
1B19E:  MOVLB  0
1B1A0:  GOTO   1BB4E (RETURN)
.................... } 
....................  
.................... int main(int argc, char** argv) 
1B1A4:  CLRF   FF8
1B1A6:  BCF    FF1.2
1B1A8:  BCF    F9F.5
1B1AA:  BSF    FA5.5
1B1AC:  BCF    FA9.5
1B1AE:  BCF    FA9.7
1B1B0:  BSF    FD0.7
1B1B2:  BSF    07.7
1B1B4:  MOVLB  E
1B1B6:  MOVLW  55
1B1B8:  MOVWF  F7E
1B1BA:  MOVLW  AA
1B1BC:  MOVWF  F7E
1B1BE:  BCF    F66.6
1B1C0:  MOVLW  FA
1B1C2:  MOVWF  x2A
1B1C4:  MOVLW  F5
1B1C6:  MOVWF  x2B
1B1C8:  MOVLW  F8
1B1CA:  MOVWF  x2C
1B1CC:  MOVLW  F9
1B1CE:  MOVWF  x2D
1B1D0:  MOVLW  20
1B1D2:  MOVWF  x1D
1B1D4:  MOVLW  30
1B1D6:  MOVWF  x22
1B1D8:  MOVLW  20
1B1DA:  MOVWF  x24
1B1DC:  MOVLW  01
1B1DE:  MOVWF  x27
1B1E0:  MOVLW  55
1B1E2:  MOVWF  F7E
1B1E4:  MOVLW  AA
1B1E6:  MOVWF  F7E
1B1E8:  BSF    F66.6
1B1EA:  CLRF   F9B
1B1EC:  CLRF   F64
1B1EE:  CLRF   F65
1B1F0:  CLRF   F66
1B1F2:  MOVLW  02
1B1F4:  MOVWF  FD3
1B1F6:  CLRF   30
1B1F8:  BSF    F67.3
1B1FA:  MOVLW  22
1B1FC:  MOVWF  FAF
1B1FE:  MOVLW  00
1B200:  MOVLB  F
1B202:  MOVWF  x30
1B204:  MOVLW  A6
1B206:  MOVWF  FAC
1B208:  MOVLW  90
1B20A:  MOVWF  FAB
1B20C:  BSF    x31.3
1B20E:  MOVLW  A0
1B210:  MOVWF  x1F
1B212:  MOVLW  01
1B214:  MOVWF  x20
1B216:  MOVLW  A6
1B218:  MOVWF  x32
1B21A:  MOVLW  90
1B21C:  MOVWF  x33
1B21E:  BSF    x2D.3
1B220:  MOVLW  A0
1B222:  MOVWF  x2B
1B224:  MOVLW  01
1B226:  MOVWF  x2C
1B228:  MOVLW  A6
1B22A:  MOVWF  x2E
1B22C:  MOVLW  90
1B22E:  MOVWF  x2F
1B230:  MOVLB  E
1B232:  BCF    xFD.3
1B234:  MOVLW  0C
1B236:  MOVWF  xFB
1B238:  MOVLW  A2
1B23A:  MOVWF  xFE
1B23C:  MOVLW  90
1B23E:  MOVWF  xFF
1B240:  BCF    F94.6
1B242:  BSF    F8B.6
1B244:  BCF    F98.0
1B246:  BSF    F8F.0
1B248:  BSF    F96.0
1B24A:  BCF    F96.6
1B24C:  BCF    F96.1
1B24E:  BCF    F8D.1
1B250:  BSF    F93.5
1B252:  BCF    F93.4
1B254:  BCF    F93.2
1B256:  BCF    F8A.2
1B258:  BSF    F92.0
1B25A:  BCF    F92.1
1B25C:  BCF    F92.3
1B25E:  BCF    F89.3
1B260:  CLRF   32
1B262:  CLRF   31
1B264:  MOVLW  35
1B266:  MOVWF  FCD
1B268:  CLRF   FAA
1B26A:  CLRF   FCF
1B26C:  CLRF   FCE
1B26E:  BCF    F9E.0
1B270:  MOVLB  1
1B272:  CLRF   x59
1B274:  CLRF   x58
1B276:  MOVLB  5
1B278:  CLRF   x5A
1B27A:  CLRF   x5B
1B27C:  CLRF   x5C
1B27E:  MOVLB  7
1B280:  CLRF   x1D
1B282:  CLRF   x1E
1B284:  MOVLW  05
1B286:  MOVWF  x4F
1B288:  CLRF   x50
1B28A:  MOVLW  38
1B28C:  MOVWF  x54
1B28E:  MOVLW  6D
1B290:  MOVWF  x53
1B292:  MOVLW  43
1B294:  MOVWF  x52
1B296:  MOVLW  80
1B298:  MOVWF  x51
1B29A:  CLRF   x55
1B29C:  CLRF   x56
1B29E:  MOVLW  0C
1B2A0:  MOVWF  x57
1B2A2:  MOVLB  8
1B2A4:  SETF   x98
1B2A6:  SETF   x99
1B2A8:  CLRF   xAA
1B2AA:  CLRF   xAB
1B2AC:  MOVLW  08
1B2AE:  MOVWF  xC5
1B2B0:  MOVLW  AC
1B2B2:  MOVWF  xC4
1B2B4:  MOVLW  08
1B2B6:  MOVWF  xC7
1B2B8:  MOVLW  AF
1B2BA:  MOVWF  xC6
1B2BC:  MOVLW  08
1B2BE:  MOVWF  xC9
1B2C0:  MOVLW  B2
1B2C2:  MOVWF  xC8
1B2C4:  MOVLW  08
1B2C6:  MOVWF  xCB
1B2C8:  MOVLW  B5
1B2CA:  MOVWF  xCA
1B2CC:  MOVLW  08
1B2CE:  MOVWF  xCD
1B2D0:  MOVLW  B8
1B2D2:  MOVWF  xCC
1B2D4:  MOVLW  08
1B2D6:  MOVWF  xCF
1B2D8:  MOVLW  BB
1B2DA:  MOVWF  xCE
1B2DC:  MOVLW  08
1B2DE:  MOVWF  xD1
1B2E0:  MOVLW  BE
1B2E2:  MOVWF  xD0
1B2E4:  MOVLW  08
1B2E6:  MOVWF  xD3
1B2E8:  MOVLW  C1
1B2EA:  MOVWF  xD2
1B2EC:  MOVLB  A
1B2EE:  CLRF   xDA
1B2F0:  CLRF   xD9
1B2F2:  CLRF   xD8
1B2F4:  CLRF   xD7
1B2F6:  CLRF   xDB
1B2F8:  MOVLB  E
1B2FA:  CLRF   xD9
1B2FC:  CLRF   xDA
1B2FE:  CLRF   x45
1B300:  CLRF   x46
1B302:  CLRF   x47
1B304:  BCF    x8D.7
1B306:  BCF    x8D.6
1B308:  BCF    x8D.5
1B30A:  MOVLB  1
1B30C:  CLRF   x88
1B30E:  MOVLB  F
1B310:  CLRF   x53
1B312:  CLRF   x38
1B314:  CLRF   x37
1B316:  MOVLW  0D
1B318:  MOVWF  3A
1B31A:  MOVLW  8D
1B31C:  MOVWF  39
1B31E:  MOVLB  D
1B320:  CLRF   x8E
1B322:  MOVLW  69
1B324:  MOVWF  x8D
1B326:  CLRF   x90
1B328:  CLRF   x8F
1B32A:  MOVLB  0
1B32C:  MOVLB  A
1B32E:  CLRF   x6A
1B330:  CLRF   x69
1B332:  MOVLW  55
1B334:  MOVWF  x68
1B336:  MOVLW  5A
1B338:  MOVWF  x67
1B33A:  CLRF   x6E
1B33C:  CLRF   x6D
1B33E:  MOVLW  55
1B340:  MOVWF  x6C
1B342:  MOVLW  AE
1B344:  MOVWF  x6B
1B346:  CLRF   x72
1B348:  CLRF   x71
1B34A:  MOVLW  54
1B34C:  MOVWF  x70
1B34E:  MOVLW  18
1B350:  MOVWF  x6F
1B352:  CLRF   x76
1B354:  CLRF   x75
1B356:  MOVLW  55
1B358:  MOVWF  x74
1B35A:  MOVLW  B4
1B35C:  MOVWF  x73
1B35E:  CLRF   x7A
1B360:  CLRF   x79
1B362:  MOVLW  55
1B364:  MOVWF  x78
1B366:  MOVLW  BE
1B368:  MOVWF  x77
1B36A:  CLRF   x7E
1B36C:  CLRF   x7D
1B36E:  MOVLW  54
1B370:  MOVWF  x7C
1B372:  MOVLW  2E
1B374:  MOVWF  x7B
1B376:  CLRF   x82
1B378:  CLRF   x81
1B37A:  MOVLW  55
1B37C:  MOVWF  x80
1B37E:  MOVLW  C6
1B380:  MOVWF  x7F
1B382:  CLRF   x86
1B384:  CLRF   x85
1B386:  MOVLW  55
1B388:  MOVWF  x84
1B38A:  MOVLW  D0
1B38C:  MOVWF  x83
1B38E:  CLRF   x8A
1B390:  CLRF   x89
1B392:  MOVLW  54
1B394:  MOVWF  x88
1B396:  MOVLW  44
1B398:  MOVWF  x87
1B39A:  CLRF   x8E
1B39C:  CLRF   x8D
1B39E:  MOVLW  55
1B3A0:  MOVWF  x8C
1B3A2:  MOVLW  D8
1B3A4:  MOVWF  x8B
1B3A6:  CLRF   x92
1B3A8:  CLRF   x91
1B3AA:  MOVLW  55
1B3AC:  MOVWF  x90
1B3AE:  MOVLW  E2
1B3B0:  MOVWF  x8F
1B3B2:  CLRF   x96
1B3B4:  CLRF   x95
1B3B6:  MOVLW  54
1B3B8:  MOVWF  x94
1B3BA:  MOVLW  5A
1B3BC:  MOVWF  x93
1B3BE:  CLRF   x9A
1B3C0:  CLRF   x99
1B3C2:  MOVLW  55
1B3C4:  MOVWF  x98
1B3C6:  MOVLW  EA
1B3C8:  MOVWF  x97
1B3CA:  CLRF   x9E
1B3CC:  CLRF   x9D
1B3CE:  MOVLW  55
1B3D0:  MOVWF  x9C
1B3D2:  MOVLW  F4
1B3D4:  MOVWF  x9B
1B3D6:  CLRF   xA2
1B3D8:  CLRF   xA1
1B3DA:  MOVLW  54
1B3DC:  MOVWF  xA0
1B3DE:  MOVLW  6C
1B3E0:  MOVWF  x9F
1B3E2:  CLRF   xA6
1B3E4:  CLRF   xA5
1B3E6:  MOVLW  54
1B3E8:  MOVWF  xA4
1B3EA:  MOVLW  B2
1B3EC:  MOVWF  xA3
1B3EE:  CLRF   xAA
1B3F0:  CLRF   xA9
1B3F2:  MOVLW  55
1B3F4:  MOVWF  xA8
1B3F6:  MOVLW  FC
1B3F8:  MOVWF  xA7
1B3FA:  CLRF   xB0
1B3FC:  CLRF   xAF
1B3FE:  MOVLW  54
1B400:  MOVWF  xAE
1B402:  MOVLW  FE
1B404:  MOVWF  xAD
1B406:  CLRF   xB4
1B408:  CLRF   xB3
1B40A:  MOVLW  56
1B40C:  MOVWF  xB2
1B40E:  MOVLW  0E
1B410:  MOVWF  xB1
1B412:  CLRF   xBA
1B414:  CLRF   xB9
1B416:  MOVLW  55
1B418:  MOVWF  xB8
1B41A:  MOVLW  4A
1B41C:  MOVWF  xB7
1B41E:  CLRF   xBE
1B420:  CLRF   xBD
1B422:  MOVLW  56
1B424:  MOVWF  xBC
1B426:  MOVLW  20
1B428:  MOVWF  xBB
1B42A:  BRA    1B4F4
1B42C:  DATA 02,00
1B42E:  DATA 33,00
1B430:  DATA 00,0D
1B432:  DATA 00,FF
1B434:  DATA FF,00
1B436:  DATA 01,01
1B438:  DATA 00,00
1B43A:  DATA 02,3F
1B43C:  DATA 0C,48
1B43E:  DATA 0C,78
1B440:  DATA 01,4C
1B442:  DATA C0,00
1B444:  DATA 20,07
1B446:  DATA 2F,5A
1B448:  DATA 45,53
1B44A:  DATA 00,54
1B44C:  DATA 4D,31
1B44E:  DATA 00,41
1B450:  DATA 44,43
1B452:  DATA 00,54
1B454:  DATA 4D,32
1B456:  DATA 00,4F
1B458:  DATA 50,45
1B45A:  DATA 00,4D
1B45C:  DATA 43,50
1B45E:  DATA 00,43
1B460:  DATA 41,4D
1B462:  DATA 00,52
1B464:  DATA 45,46
1B466:  DATA 00,10
1B468:  DATA 07,1F
1B46A:  DATA 2F,07
1B46C:  DATA 33,07
1B46E:  DATA 37,07
1B470:  DATA 3B,07
1B472:  DATA 3F,07
1B474:  DATA 43,07
1B476:  DATA 47,07
1B478:  DATA 4B,07
1B47A:  DATA 20,48
1B47C:  DATA 78,00
1B47E:  DATA 10,48
1B480:  DATA 9A,00
1B482:  DATA 18,08
1B484:  DATA AC,C0
1B486:  DATA 19,01
1B488:  DATA AB,24
1B48A:  DATA 01,CB
1B48C:  DATA 06,01
1B48E:  DATA B0,24
1B490:  DATA 00,E0
1B492:  DATA 40,00
1B494:  DATA AD,2C
1B496:  DATA 01,1C
1B498:  DATA 24,01
1B49A:  DATA 1D,24
1B49C:  DATA 01,04
1B49E:  DATA 08,DE
1B4A0:  DATA 00,00
1B4A2:  DATA 00,00
1B4A4:  DATA 02,0A
1B4A6:  DATA AB,0B
1B4A8:  DATA 7C,02
1B4AA:  DATA 0A,B5
1B4AC:  DATA 22,7C
1B4AE:  DATA 02,0A
1B4B0:  DATA BF,02
1B4B2:  DATA 7C,16
1B4B4:  DATA C0,00
1B4B6:  DATA 04,4A
1B4B8:  DATA DC,00
1B4BA:  DATA 10,80
1B4BC:  DATA 41,00
1B4BE:  DATA 09,30
1B4C0:  DATA 2A,3C
1B4C2:  DATA 00,01
1B4C4:  DATA 00,00
1B4C6:  DATA 97,0A
1B4C8:  DATA 97,0A
1B4CA:  DATA 06,06
1B4CC:  DATA 24,C0
1B4CE:  DATA 00,04
1B4D0:  DATA 80,24
1B4D2:  DATA 0B,BE
1B4D4:  DATA 01,21
1B4D6:  DATA C0,00
1B4D8:  DATA 04,80
1B4DA:  DATA 24,0B
1B4DC:  DATA BE,02
1B4DE:  DATA 21,C0
1B4E0:  DATA 00,03
1B4E2:  DATA 80,24
1B4E4:  DATA 0B,BE
1B4E6:  DATA 22,C0
1B4E8:  DATA 00,05
1B4EA:  DATA 80,24
1B4EC:  DATA 14,00
1B4EE:  DATA 00,41
1B4F0:  DATA 41,C0
1B4F2:  DATA 00,00
1B4F4:  MOVLW  01
1B4F6:  MOVWF  FF8
1B4F8:  MOVLW  B4
1B4FA:  MOVWF  FF7
1B4FC:  MOVLW  2C
1B4FE:  MOVWF  FF6
1B500:  TBLRD*+
1B502:  MOVF   FF5,W
1B504:  MOVWF  00
1B506:  XORLW  00
1B508:  BZ    1B530
1B50A:  TBLRD*+
1B50C:  MOVF   FF5,W
1B50E:  MOVWF  01
1B510:  BTFSC  FE8.7
1B512:  BRA    1B51E
1B514:  ANDLW  0F
1B516:  MOVWF  FEA
1B518:  TBLRD*+
1B51A:  MOVF   FF5,W
1B51C:  MOVWF  FE9
1B51E:  BTFSC  01.6
1B520:  TBLRD*+
1B522:  BTFSS  01.6
1B524:  TBLRD*+
1B526:  MOVF   FF5,W
1B528:  MOVWF  FEE
1B52A:  DCFSNZ 00,F
1B52C:  BRA    1B500
1B52E:  BRA    1B522
1B530:  CLRF   FF8
.................... { 
....................     // Ensure OCPs are off as soon as possible 
....................     output_bit(OCP_EN_ADCS, false);  // ADCS 
1B532:  BCF    F8E.7
1B534:  BCF    F97.7
....................     output_bit(OCP_EN_MCP, false);   // Mission Control PIC 
1B536:  BCF    F8C.6
1B538:  BCF    F95.6
....................     output_bit(OCP_EN_RELAY, false); // Relay PIC 
1B53A:  BCF    F8F.0
1B53C:  BCF    F98.0
....................  
....................     // UART configuration 
....................     uart_init(PC); 
1B53E:  MOVLW  08
1B540:  MOVLB  8
1B542:  MOVWF  xE3
1B544:  MOVLW  EB
1B546:  MOVWF  xE2
1B548:  MOVLW  19
1B54A:  MOVWF  xE4
1B54C:  MOVLW  08
1B54E:  MOVLB  D
1B550:  MOVWF  x85
1B552:  MOVLW  E2
1B554:  MOVWF  x84
....................     uart_init(COMM); 
*
1B5BC:  MOVLW  09
1B5BE:  MOVLB  9
1B5C0:  MOVWF  x05
1B5C2:  MOVLW  0D
1B5C4:  MOVWF  x04
1B5C6:  MOVLW  19
1B5C8:  MOVWF  x06
1B5CA:  MOVLW  09
1B5CC:  MOVLB  D
1B5CE:  MOVWF  x85
1B5D0:  MOVLW  04
1B5D2:  MOVWF  x84
....................     uart_init(FAB); 
*
1B63A:  MOVLW  09
1B63C:  MOVLB  9
1B63E:  MOVWF  x27
1B640:  MOVLW  2F
1B642:  MOVWF  x26
1B644:  MOVLW  40
1B646:  MOVWF  x28
1B648:  MOVLW  09
1B64A:  MOVLB  D
1B64C:  MOVWF  x85
1B64E:  MOVLW  26
1B650:  MOVWF  x84
....................     uart_init(RST); 
*
1B6B8:  MOVLW  09
1B6BA:  MOVLB  9
1B6BC:  MOVWF  x70
1B6BE:  MOVLW  78
1B6C0:  MOVWF  x6F
1B6C2:  MOVLW  24
1B6C4:  MOVWF  x71
1B6C6:  MOVLW  09
1B6C8:  MOVLB  D
1B6CA:  MOVWF  x85
1B6CC:  MOVLW  6F
1B6CE:  MOVWF  x84
....................     uart_init(ADCS); 
*
1B736:  MOVLW  09
1B738:  MOVLB  9
1B73A:  MOVWF  x9D
1B73C:  MOVLW  A5
1B73E:  MOVWF  x9C
1B740:  MOVLW  2C
1B742:  MOVWF  x9E
1B744:  MOVLW  09
1B746:  MOVLB  D
1B748:  MOVWF  x85
1B74A:  MOVLW  9C
1B74C:  MOVWF  x84
....................     uart_init(MCPIC); 
*
1B7B4:  MOVLW  09
1B7B6:  MOVLB  9
1B7B8:  MOVWF  xD2
1B7BA:  MOVLW  DA
1B7BC:  MOVWF  xD1
1B7BE:  MOVLW  06
1B7C0:  MOVWF  xD3
1B7C2:  MOVLW  09
1B7C4:  MOVLB  D
1B7C6:  MOVWF  x85
1B7C8:  MOVLW  D1
1B7CA:  MOVWF  x84
....................     uart_init(PCIB); 
*
1B832:  MOVLW  09
1B834:  MOVLB  9
1B836:  MOVWF  xE1
1B838:  MOVLW  E9
1B83A:  MOVWF  xE0
1B83C:  MOVLW  24
1B83E:  MOVWF  xE2
1B840:  MOVLW  09
1B842:  MOVLB  D
1B844:  MOVWF  x85
1B846:  MOVLW  E0
1B848:  MOVWF  x84
....................     uart_init(TMCR1); 
*
1B8B0:  MOVLW  0A
1B8B2:  MOVLB  A
1B8B4:  MOVWF  x0E
1B8B6:  MOVLW  16
1B8B8:  MOVWF  x0D
1B8BA:  MOVLW  24
1B8BC:  MOVWF  x0F
1B8BE:  MOVLW  0A
1B8C0:  MOVLB  D
1B8C2:  MOVWF  x85
1B8C4:  MOVLW  0D
1B8C6:  MOVWF  x84
....................     uart_init(TMCR2); 
*
1B92E:  MOVLW  0A
1B930:  MOVLB  A
1B932:  MOVWF  x3B
1B934:  MOVLW  43
1B936:  MOVWF  x3A
1B938:  MOVLW  24
1B93A:  MOVWF  x3C
1B93C:  MOVLW  0A
1B93E:  MOVLB  D
1B940:  MOVWF  x85
1B942:  MOVLW  3A
1B944:  MOVWF  x84
....................  
....................     fprintf(PC, "\r\n  _    ___  ___  ___   _    ___  __     ___       _       _ _ _ _       \r\n"); 
*
1B9AC:  MOVLW  74
1B9AE:  MOVWF  FF6
1B9B0:  MOVLW  43
1B9B2:  MOVWF  FF7
1B9B4:  MOVLW  00
1B9B6:  MOVWF  FF8
1B9B8:  MOVLB  0
1B9BA:  CALL   4534
....................     fprintf(PC, " | |  | __|| _ || _ \\ / \\  | _ \\|  \\   / __| __ _| |_ ___| | (_) |_ ___ \r\n"); 
1B9BE:  MOVLW  C2
1B9C0:  MOVWF  FF6
1B9C2:  MOVLW  43
1B9C4:  MOVWF  FF7
1B9C6:  MOVLW  00
1B9C8:  MOVWF  FF8
1B9CA:  CALL   4534
....................     fprintf(PC, " | |_ | _| ||_|||___// _ \\ |   /||  |  \\__ \\/ _` |  _/ -_) | | |  _/ -_)\r\n"); 
1B9CE:  MOVLW  0E
1B9D0:  MOVWF  FF6
1B9D2:  MOVLW  44
1B9D4:  MOVWF  FF7
1B9D6:  MOVLW  00
1B9D8:  MOVWF  FF8
1B9DA:  CALL   4534
....................     fprintf(PC, " |___||___||___||_| /_/ \\_\\|_\\_\\|__/   |___/\\__,_|\\__\\___|_|_|_|\\__\\___|\r\n\r\n"); 
1B9DE:  MOVLW  5A
1B9E0:  MOVWF  FF6
1B9E2:  MOVLW  44
1B9E4:  MOVWF  FF7
1B9E6:  MOVLW  00
1B9E8:  MOVWF  FF8
1B9EA:  CALL   4534
....................  
....................     fprintf(PC, "Compiled on: "__DATE__ 
....................                 " "__TIME__ 
....................                 "\r\n\r\n"); 
1B9EE:  MOVLW  A8
1B9F0:  MOVWF  FF6
1B9F2:  MOVLW  44
1B9F4:  MOVWF  FF7
1B9F6:  MOVLW  00
1B9F8:  MOVWF  FF8
1B9FA:  CALL   4534
....................  
....................     // Satellite time initialization 
....................     current_time = time(0); 
1B9FE:  MOVLB  C
1BA00:  CLRF   x50
1BA02:  CLRF   x4F
1BA04:  MOVLB  0
1BA06:  CALL   4C60
1BA0A:  MOVFF  03,3E
1BA0E:  MOVFF  02,3D
1BA12:  MOVFF  01,3C
1BA16:  MOVFF  00,3B
....................     // In case RTC registers have invalid data, load the initial time 
....................     if (current_time < T0 || current_time > Tn) { 
1BA1A:  BTFSC  3E.7
1BA1C:  BRA    1BA64
1BA1E:  MOVF   3E,W
1BA20:  SUBLW  38
1BA22:  BNC   1BA3C
1BA24:  BNZ   1BA64
1BA26:  MOVF   3D,W
1BA28:  SUBLW  6D
1BA2A:  BNC   1BA3C
1BA2C:  BNZ   1BA64
1BA2E:  MOVF   3C,W
1BA30:  SUBLW  43
1BA32:  BNC   1BA3C
1BA34:  BNZ   1BA64
1BA36:  MOVF   3B,W
1BA38:  SUBLW  7F
1BA3A:  BC    1BA64
1BA3C:  BTFSC  3E.7
1BA3E:  BRA    1BA9C
1BA40:  MOVF   3E,W
1BA42:  SUBLW  7E
1BA44:  BC    1BA9C
1BA46:  XORLW  FF
1BA48:  BNZ   1BA64
1BA4A:  MOVF   3D,W
1BA4C:  SUBLW  FE
1BA4E:  BC    1BA9C
1BA50:  XORLW  FF
1BA52:  BNZ   1BA64
1BA54:  MOVF   3C,W
1BA56:  SUBLW  FE
1BA58:  BC    1BA9C
1BA5A:  XORLW  FF
1BA5C:  BNZ   1BA64
1BA5E:  MOVF   3B,W
1BA60:  SUBLW  FE
1BA62:  BC    1BA9C
....................         fprintf(PC, "> Invalid clock, recovering...\r\n"); 
1BA64:  MOVLW  CC
1BA66:  MOVWF  FF6
1BA68:  MOVLW  44
1BA6A:  MOVWF  FF7
1BA6C:  MOVLW  00
1BA6E:  MOVWF  FF8
1BA70:  CALL   4534
....................         current_time = T0; 
1BA74:  MOVLW  38
1BA76:  MOVWF  3E
1BA78:  MOVLW  6D
1BA7A:  MOVWF  3D
1BA7C:  MOVLW  43
1BA7E:  MOVWF  3C
1BA80:  MOVLW  80
1BA82:  MOVWF  3B
....................         SetTimeSec(T0); 
1BA84:  MOVLW  38
1BA86:  MOVLB  C
1BA88:  MOVWF  x52
1BA8A:  MOVLW  6D
1BA8C:  MOVWF  x51
1BA8E:  MOVLW  43
1BA90:  MOVWF  x50
1BA92:  MOVLW  80
1BA94:  MOVWF  x4F
1BA96:  MOVLB  0
1BA98:  CALL   5140
....................     } 
....................     previous_time = current_time; 
1BA9C:  MOVFF  3E,42
1BAA0:  MOVFF  3D,41
1BAA4:  MOVFF  3C,40
1BAA8:  MOVFF  3B,3F
1BAAC:  MOVLB  F
....................     // ctime(&current_time, &current_time_str); 
....................  
....................     // > RTC & Timers 
....................     setup_rtc(RTC_ENABLE | RTC_CLOCK_SOSC, 0x00); // enables internal RTC 
1BAAE:  MOVLB  F
1BAB0:  MOVLW  55
1BAB2:  MOVWF  F7E
1BAB4:  MOVLW  AA
1BAB6:  MOVWF  F7E
1BAB8:  BSF    x5F.5
1BABA:  CLRF   x5E
1BABC:  CLRF   x57
1BABE:  MOVLW  80
1BAC0:  MOVWF  x5F
1BAC2:  BCF    x5F.5
1BAC4:  BSF    F66.1
....................     setup_timer_0(T0_INTERNAL | T0_DIV_32); 
1BAC6:  MOVLW  94
1BAC8:  MOVWF  FD5
....................  
....................     // Telemetry initialization 
....................     initialize_telemetry(); 
1BACA:  MOVLB  0
1BACC:  CALL   523C
....................  
....................     // 2-way multiplexer of flash memories 
....................     output_low(MUX_SEL_COM_SHARED_FM);  // COM SHARED FM to OBC side 
1BAD0:  BCF    F94.5
1BAD2:  BCF    F8B.5
....................     output_high(MUX_SEL_MSN_SHARED_FM); // Mission SHARED FM 
1BAD4:  BCF    F92.5
1BAD6:  BSF    F89.5
....................  
....................     // 8-way multiplexer of CPLD 
....................     mux_sel(mux_mcpic); 
1BAD8:  MOVLW  05
1BADA:  MOVLB  C
1BADC:  MOVWF  xBE
1BADE:  MOVLB  0
1BAE0:  CALL   52E8
....................  
....................     // Memory 
....................     memory_setup(); 
1BAE4:  GOTO   733A
....................     print_flags(); 
1BAE8:  CALL   7470
....................  
....................     // Raf_DIO Initial settings 
....................     output_low(DIO_BURNER_ANTENNA); // DIO (Burner Circuit UHF Antenna) 
1BAEC:  BCF    F98.4
1BAEE:  BCF    F8F.4
....................     output_low(DIO_BURNER_SAP);     // DIO (Burner Circuit SAP Deployment) 
1BAF0:  BCF    F94.2
1BAF2:  BCF    F8B.2
....................     output_low(DIO_BURNER_SMA);     // DIO (Burner Circuit SMA Heater) 
1BAF4:  BCF    F97.5
1BAF6:  BCF    F8E.5
....................  
....................     // Interrputions 
....................     enable_interrupts(INT_TIMER0); 
1BAF8:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
1BAFA:  MOVLW  C0
1BAFC:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA);  // MSN 
1BAFE:  BSF    F9D.5
....................     enable_interrupts(INT_RDA2); // COMM 
1BB00:  BSF    FA3.5
....................     enable_interrupts(INT_RDA3); // FAB 
1BB02:  BSF    F61.5
....................     enable_interrupts(INT_RDA4); // RST 
1BB04:  BSF    F61.7
....................  
....................     // OCPs 
....................     output_bit(OCP_EN_ADCS, obc_flags.adcs_on_off);   // ADCS 
1BB06:  MOVLB  1
1BB08:  MOVF   x01,F
1BB0A:  BNZ   1BB10
1BB0C:  BCF    F8E.7
1BB0E:  BRA    1BB12
1BB10:  BSF    F8E.7
1BB12:  BCF    F97.7
....................     output_bit(OCP_EN_MCP, obc_flags.MCP_on_off);     // Mission Control PIC 
1BB14:  MOVF   x02,F
1BB16:  BNZ   1BB1C
1BB18:  BCF    F8C.6
1BB1A:  BRA    1BB1E
1BB1C:  BSF    F8C.6
1BB1E:  BCF    F95.6
....................     output_bit(OCP_EN_RELAY, obc_flags.relay_on_off); // Relay PIC 
1BB20:  MOVF   x0B,F
1BB22:  BNZ   1BB28
1BB24:  BCF    F8F.0
1BB26:  BRA    1BB2A
1BB28:  BSF    F8F.0
1BB2A:  BCF    F98.0
....................  
....................     execute(1, { MSG_PC, 0xFF }); // Reset log 
1BB2C:  MOVLW  DB
1BB2E:  MOVLB  B
1BB30:  MOVWF  xCC
1BB32:  SETF   xCD
1BB34:  MOVLW  0B
1BB36:  MOVLB  C
1BB38:  MOVWF  x27
1BB3A:  MOVLW  CC
1BB3C:  MOVWF  x26
1BB3E:  SETF   x28
1BB40:  MOVLW  01
1BB42:  MOVWF  x29
1BB44:  MOVLB  0
1BB46:  CALL   17C34
....................  
....................     // > Main Loop 
....................     while (TRUE) { 
....................         // Periodic tasks: 
....................         periodic_tasks(); 
1BB4A:  GOTO   1ACDA
....................         // UART tasks: 
....................         if (kbhit(PC)) { 
1BB4E:  BTFSC  F82.7
1BB50:  BRA    1BF04
....................             uart_update(PC, message_COMM); // Receive the same messages as COMM 
1BB52:  CALL   5564
1BB56:  MOVFF  01,BCE
1BB5A:  MOVLW  08
1BB5C:  MOVLB  D
1BB5E:  MOVWF  x80
1BB60:  MOVLW  E2
1BB62:  MOVWF  x7F
1BB64:  MOVFF  8C5,D82
1BB68:  MOVFF  8C4,D81
1BB6C:  MOVFF  BCE,D83
....................         } 
*
1BF04:  BRA    1BB4A
....................     } 
....................     return 0; 
1BF06:  MOVLW  00
1BF08:  MOVWF  01
.................... } 
1BF0A:  SLEEP 
*
0A09A:  MOVFF  C49,C3F
0A09E:  MOVFF  C48,C3E
0A0A2:  CLRF   x3C
0A0A4:  CLRF   x3D
*
0A0BC:  MOVFF  C49,C43
0A0C0:  MOVFF  C48,C42
0A0C4:  CLRF   x40
0A0C6:  CLRF   x41
*
0A0DE:  MOVFF  C48,00
0A0E2:  MOVFF  C49,01
0A0E6:  MOVFF  C49,C4B
0A0EA:  MOVFF  C48,C4A
0A0EE:  CLRF   x48
0A0F0:  CLRF   x49
0A0F2:  RRCF   x4B,W
0A0F4:  MOVWF  x47
0A0F6:  RRCF   x4A,W
0A0F8:  MOVWF  x46
0A0FA:  RRCF   x49,W
0A0FC:  MOVWF  x45
0A0FE:  RRCF   x48,W
0A100:  MOVWF  x44
0A102:  RRCF   x47,F
0A104:  RRCF   x46,F
0A106:  RRCF   x45,F
0A108:  RRCF   x44,F
0A10A:  RRCF   x47,F
0A10C:  RRCF   x46,F
0A10E:  RRCF   x45,F
0A110:  RRCF   x44,F
0A112:  RRCF   x47,F
0A114:  RRCF   x46,F
0A116:  RRCF   x45,F
0A118:  RRCF   x44,F
0A11A:  RRCF   x47,F
0A11C:  RRCF   x46,F
0A11E:  RRCF   x45,F
0A120:  RRCF   x44,F
0A122:  RRCF   x47,F
0A124:  RRCF   x46,F
0A126:  RRCF   x45,F
0A128:  RRCF   x44,F
0A12A:  RRCF   x47,F
0A12C:  RRCF   x46,F
0A12E:  RRCF   x45,F
0A130:  RRCF   x44,F
0A132:  MOVLW  01
0A134:  ANDWF  x47,F
*
0A9B8:  MOVFF  C49,C3F
0A9BC:  MOVFF  C48,C3E
0A9C0:  CLRF   x3C
0A9C2:  CLRF   x3D
*
0A9DA:  MOVFF  C49,C43
0A9DE:  MOVFF  C48,C42
0A9E2:  CLRF   x40
0A9E4:  CLRF   x41
*
0A9FC:  MOVFF  C48,00
0AA00:  MOVFF  C49,01
0AA04:  MOVFF  C49,C4B
0AA08:  MOVFF  C48,C4A
0AA0C:  CLRF   x48
0AA0E:  CLRF   x49
0AA10:  RRCF   x4B,W
0AA12:  MOVWF  x47
0AA14:  RRCF   x4A,W
0AA16:  MOVWF  x46
0AA18:  RRCF   x49,W
0AA1A:  MOVWF  x45
0AA1C:  RRCF   x48,W
0AA1E:  MOVWF  x44
0AA20:  RRCF   x47,F
0AA22:  RRCF   x46,F
0AA24:  RRCF   x45,F
0AA26:  RRCF   x44,F
0AA28:  RRCF   x47,F
0AA2A:  RRCF   x46,F
0AA2C:  RRCF   x45,F
0AA2E:  RRCF   x44,F
0AA30:  RRCF   x47,F
0AA32:  RRCF   x46,F
0AA34:  RRCF   x45,F
0AA36:  RRCF   x44,F
0AA38:  RRCF   x47,F
0AA3A:  RRCF   x46,F
0AA3C:  RRCF   x45,F
0AA3E:  RRCF   x44,F
0AA40:  RRCF   x47,F
0AA42:  RRCF   x46,F
0AA44:  RRCF   x45,F
0AA46:  RRCF   x44,F
0AA48:  RRCF   x47,F
0AA4A:  RRCF   x46,F
0AA4C:  RRCF   x45,F
0AA4E:  RRCF   x44,F
0AA50:  MOVLW  01
0AA52:  ANDWF  x47,F

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
