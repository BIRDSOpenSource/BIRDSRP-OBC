CCS PCH C Compiler, Version 5.050, 43599               18-Dec-24 13:02

               Filename:   Z:\home\schulz\mnt\smb\Projects\birds-rp\main_pic\main.lst

               ROM used:   62352 bytes (48%)
                           Largest free fragment is 65520
               RAM used:   2502 (70%) at main() level
                           2882 (81%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   E464
*
00008:  GOTO   00F2
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  BTFSS  FF2.5
0006E:  GOTO   0078
00072:  BTFSC  FF2.2
00074:  GOTO   19D6
00078:  BTFSS  F9D.5
0007A:  GOTO   0084
0007E:  BTFSC  F9E.5
00080:  GOTO   0AA2
00084:  BTFSS  F61.5
00086:  GOTO   0090
0008A:  BTFSC  FA6.5
0008C:  GOTO   1250
00090:  BTFSS  F61.7
00092:  GOTO   009C
00096:  BTFSC  FA6.7
00098:  GOTO   1620
0009C:  MOVFF  0E,00
000A0:  MOVFF  0F,01
000A4:  MOVFF  10,02
000A8:  MOVFF  11,03
000AC:  MOVFF  0C,FE9
000B0:  MOVFF  07,FEA
000B4:  BSF    07.7
000B6:  MOVFF  08,FE1
000BA:  MOVFF  09,FE2
000BE:  MOVFF  0A,FD9
000C2:  MOVFF  0B,FDA
000C6:  MOVFF  12,FF3
000CA:  MOVFF  13,FF4
000CE:  MOVFF  14,FFA
000D2:  MOVFF  15,FF5
000D6:  MOVFF  16,FF6
000DA:  MOVFF  17,FF7
000DE:  MOVFF  18,FF8
000E2:  MOVFF  19,FFB
000E6:  MOVF   04,W
000E8:  MOVFF  06,FE0
000EC:  MOVFF  05,FD8
000F0:  RETFIE 0
000F2:  MOVLB  0
000F4:  MOVFF  FE9,21
000F8:  MOVFF  FEA,1C
000FC:  MOVFF  FE1,1D
00100:  MOVFF  FE2,1E
00104:  MOVFF  FD9,1F
00108:  MOVFF  FDA,20
0010C:  MOVFF  FF3,27
00110:  MOVFF  FF4,28
00114:  MOVFF  FFA,29
00118:  MOVFF  FF5,2A
0011C:  MOVFF  FF6,2B
00120:  MOVFF  FF7,2C
00124:  MOVFF  FF8,2D
00128:  MOVFF  FFB,2E
0012C:  MOVFF  00,23
00130:  MOVFF  01,24
00134:  MOVFF  02,25
00138:  MOVFF  03,26
0013C:  BTFSS  FA3.5
0013E:  GOTO   0148
00142:  BTFSC  FA4.5
00144:  GOTO   0E72
00148:  MOVFF  23,00
0014C:  MOVFF  24,01
00150:  MOVFF  25,02
00154:  MOVFF  26,03
00158:  MOVFF  21,FE9
0015C:  MOVFF  1C,FEA
00160:  BSF    1C.7
00162:  MOVFF  1D,FE1
00166:  MOVFF  1E,FE2
0016A:  MOVFF  1F,FD9
0016E:  MOVFF  20,FDA
00172:  MOVFF  27,FF3
00176:  MOVFF  28,FF4
0017A:  MOVFF  29,FFA
0017E:  MOVFF  2A,FF5
00182:  MOVFF  2B,FF6
00186:  MOVFF  2C,FF7
0018A:  MOVFF  2D,FF8
0018E:  MOVFF  2E,FFB
00192:  RETFIE 1
.................... #include "device.h" 
.................... #ifndef DEVICE_H 
.................... #define DEVICE_H 
....................  
.................... // For the real case ---------------------------------------------------------------------- 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
00194:  CLRF   FF7
00196:  ADDLW  A8
00198:  MOVWF  FF6
0019A:  MOVLW  01
0019C:  ADDWFC FF7,F
0019E:  MOVLW  00
001A0:  MOVWF  FF8
001A2:  TBLRD*+
001A4:  MOVF   FF5,W
001A6:  RETURN 0
001A8:  DATA B0,A0
001AA:  DATA 00,00
001AC:  DATA 00,00
001AE:  DATA 00,00
001B0:  DATA 00,00
001B2:  DATA 00,00
001B4:  DATA 00,00
001B6:  DATA 00,00
001B8:  DATA 00,00
001BA:  DATA 00,00
001BC:  DATA 00,00
001BE:  DATA 00,00
001C0:  DATA 00,00
001C2:  DATA 00,00
001C4:  DATA 00,00
001C6:  DATA 00,00
001C8:  DATA 00,00
001CA:  DATA 00,B1
001CC:  CLRF   FF7
001CE:  ADDLW  E0
001D0:  MOVWF  FF6
001D2:  MOVLW  01
001D4:  ADDWFC FF7,F
001D6:  MOVLW  00
001D8:  MOVWF  FF8
001DA:  TBLRD*+
001DC:  MOVF   FF5,W
001DE:  RETURN 0
001E0:  DATA B0,A2
001E2:  DATA 00,00
001E4:  DATA 00,00
001E6:  DATA 00,00
001E8:  DATA 00,00
001EA:  DATA 00,00
001EC:  DATA 00,00
001EE:  DATA 00,00
001F0:  DATA 00,00
001F2:  DATA 00,00
001F4:  DATA 00,00
001F6:  DATA 00,00
001F8:  DATA 00,00
001FA:  DATA 00,00
001FC:  DATA 00,00
001FE:  DATA 00,00
00200:  DATA 00,00
00202:  DATA 00,B1
00204:  MOVFF  FEC,FFA
00208:  MOVFF  FEC,FFB
0020C:  MOVF   FED,F
0020E:  MOVF   FED,F
00210:  MOVFF  FEF,FE8
00214:  MOVWF  FF9
00216:  RETURN 0
00218:  DATA 6C,65
0021A:  DATA 61,70
0021C:  DATA 5F,73
0021E:  DATA 65,63
00220:  DATA 6F,6E
00222:  DATA 64,73
00224:  DATA 20,3D
00226:  DATA 20,25
00228:  DATA 64,0D
0022A:  DATA 0A,00
0022C:  DATA 61,64
0022E:  DATA 63,73
00230:  DATA 5F,6F
00232:  DATA 6E,5F
00234:  DATA 6F,66
00236:  DATA 66,20
00238:  DATA 3D,20
0023A:  DATA 25,64
0023C:  DATA 0D,0A
0023E:  DATA 00,00
00240:  DATA 70,63
00242:  DATA 69,62
00244:  DATA 5F,6F
00246:  DATA 6E,5F
00248:  DATA 6F,66
0024A:  DATA 66,20
0024C:  DATA 3D,20
0024E:  DATA 25,64
00250:  DATA 0D,0A
00252:  DATA 00,00
00254:  DATA 67,70
00256:  DATA 73,5F
00258:  DATA 74,69
0025A:  DATA 6D,65
0025C:  DATA 5F,73
0025E:  DATA 79,6E
00260:  DATA 63,5F
00262:  DATA 73,74
00264:  DATA 61,74
00266:  DATA 65,20
00268:  DATA 3D,20
0026A:  DATA 25,64
0026C:  DATA 0D,0A
0026E:  DATA 00,00
00270:  DATA 61,64
00272:  DATA 63,73
00274:  DATA 5F,69
00276:  DATA 6E,69
00278:  DATA 74,69
0027A:  DATA 61,6C
0027C:  DATA 5F,76
0027E:  DATA 61,6C
00280:  DATA 75,65
00282:  DATA 20,3D
00284:  DATA 20,25
00286:  DATA 64,0D
00288:  DATA 0A,00
0028A:  DATA 63,77
0028C:  DATA 5F,6D
0028E:  DATA 6F,64
00290:  DATA 65,20
00292:  DATA 3D,20
00294:  DATA 25,64
00296:  DATA 0D,0A
00298:  DATA 00,00
0029A:  DATA 68,65
0029C:  DATA 61,74
0029E:  DATA 65,72
002A0:  DATA 5F,72
002A2:  DATA 65,66
002A4:  DATA 5F,74
002A6:  DATA 65,6D
002A8:  DATA 70,65
002AA:  DATA 72,61
002AC:  DATA 74,75
002AE:  DATA 72,65
002B0:  DATA 20,3D
002B2:  DATA 20,25
002B4:  DATA 30,32
002B6:  DATA 6C,58
002B8:  DATA 0D,0A
002BA:  DATA 00,00
002BC:  DATA 68,65
002BE:  DATA 61,74
002C0:  DATA 65,72
002C2:  DATA 5F,72
002C4:  DATA 65,66
002C6:  DATA 5F,76
002C8:  DATA 6F,6C
002CA:  DATA 74,61
002CC:  DATA 67,65
002CE:  DATA 20,3D
002D0:  DATA 20,25
002D2:  DATA 30,32
002D4:  DATA 6C,58
002D6:  DATA 0D,0A
002D8:  DATA 00,00
002DA:  DATA 0D,0A
002DC:  DATA 44,61
002DE:  DATA 79,20
002E0:  DATA 6F,66
002E2:  DATA 20,74
002E4:  DATA 68,65
002E6:  DATA 20,79
002E8:  DATA 65,61
002EA:  DATA 72,20
002EC:  DATA 3D,20
002EE:  DATA 25,6C
002F0:  DATA 75,0D
002F2:  DATA 0A,00
002F4:  DATA 43,61
002F6:  DATA 6E,64
002F8:  DATA 69,64
002FA:  DATA 61,74
002FC:  DATA 65,20
002FE:  DATA 74,65
00300:  DATA 6C,65
00302:  DATA 6D,65
00304:  DATA 74,72
00306:  DATA 79,20
00308:  DATA 61,64
0030A:  DATA 64,72
0030C:  DATA 65,73
0030E:  DATA 73,20
00310:  DATA 3D,20
00312:  DATA 30,78
00314:  DATA 25,38
00316:  DATA 6C,58
00318:  DATA 0D,0A
0031A:  DATA 00,00
0031C:  DATA 49,6E
0031E:  DATA 69,74
00320:  DATA 69,61
00322:  DATA 6C,20
00324:  DATA 74,65
00326:  DATA 6C,65
00328:  DATA 6D,65
0032A:  DATA 74,72
0032C:  DATA 79,20
0032E:  DATA 61,64
00330:  DATA 64,72
00332:  DATA 65,73
00334:  DATA 73,20
00336:  DATA 3D,20
00338:  DATA 30,78
0033A:  DATA 25,38
0033C:  DATA 6C,58
0033E:  DATA 0D,0A
00340:  DATA 00,00
00342:  DATA 43,75
00344:  DATA 72,72
00346:  DATA 65,6E
00348:  DATA 74,20
0034A:  DATA 74,65
0034C:  DATA 6C,65
0034E:  DATA 6D,65
00350:  DATA 74,72
00352:  DATA 79,20
00354:  DATA 61,64
00356:  DATA 64,72
00358:  DATA 65,73
0035A:  DATA 73,20
0035C:  DATA 3D,20
0035E:  DATA 30,78
00360:  DATA 25,38
00362:  DATA 6C,58
00364:  DATA 0D,0A
00366:  DATA 00,00
00368:  DATA 54,65
0036A:  DATA 6C,65
0036C:  DATA 6D,65
0036E:  DATA 74,72
00370:  DATA 79,20
00372:  DATA 73,69
00374:  DATA 7A,65
00376:  DATA 20,3D
00378:  DATA 20,25
0037A:  DATA 75,0D
0037C:  DATA 0A,00
0037E:  DATA 4C,61
00380:  DATA 73,74
00382:  DATA 20,74
00384:  DATA 65,6C
00386:  DATA 65,6D
00388:  DATA 65,74
0038A:  DATA 72,79
0038C:  DATA 20,61
0038E:  DATA 64,64
00390:  DATA 72,65
00392:  DATA 73,73
00394:  DATA 20,3D
00396:  DATA 20,30
00398:  DATA 78,25
0039A:  DATA 38,6C
0039C:  DATA 58,0D
0039E:  DATA 0A,00
003A0:  DATA 4C,6F
003A2:  DATA 67,3A
003A4:  DATA 20,30
003A6:  DATA 78,25
003A8:  DATA 30,38
003AA:  DATA 6C,58
003AC:  DATA 20,3D
003AE:  DATA 3E,20
003B0:  DATA 30,78
003B2:  DATA 25,30
003B4:  DATA 38,6C
003B6:  DATA 58,00
003B8:  DATA 43,57
003BA:  DATA 3A,20
003BC:  DATA 30,78
003BE:  DATA 00,00
003C0:  DATA 20,30
003C2:  DATA 78,00
003C4:  DATA 53,54
003C6:  DATA 4D,20
003C8:  DATA 52,41
003CA:  DATA 57,20
003CC:  DATA 43,4D
003CE:  DATA 44,3A
003D0:  DATA 20,00
003D2:  DATA 53,54
003D4:  DATA 4D,33
003D6:  DATA 32,20
003D8:  DATA 63,6F
003DA:  DATA 6D,6D
003DC:  DATA 61,6E
003DE:  DATA 64,20
003E0:  DATA 28,38
003E2:  DATA 2F,31
003E4:  DATA 36,29
003E6:  DATA 00,00
003E8:  DATA 53,54
003EA:  DATA 4D,33
003EC:  DATA 32,20
003EE:  DATA 63,6F
003F0:  DATA 6D,6D
003F2:  DATA 61,6E
003F4:  DATA 64,20
003F6:  DATA 28,33
003F8:  DATA 32,29
003FA:  DATA 20,70
003FC:  DATA 61,72
003FE:  DATA 74,20
00400:  DATA 25,64
00402:  DATA 2E,20
00404:  DATA 00,00
00406:  DATA 53,54
00408:  DATA 4D,33
0040A:  DATA 32,20
0040C:  DATA 63,6F
0040E:  DATA 6D,6D
00410:  DATA 61,6E
00412:  DATA 64,20
00414:  DATA 28,33
00416:  DATA 32,29
00418:  DATA 20,70
0041A:  DATA 61,72
0041C:  DATA 74,20
0041E:  DATA 25,64
00420:  DATA 2E,20
00422:  DATA 00,00
00424:  DATA 41,44
00426:  DATA 43,53
00428:  DATA 3A,20
0042A:  DATA 00,00
0042C:  DATA 4D,6F
0042E:  DATA 64,65
00430:  DATA 3D,25
00432:  DATA 58,20
00434:  DATA 7C,20
00436:  DATA 00,00
00438:  DATA 0D,0A
0043A:  DATA 4E,65
0043C:  DATA 77,20
0043E:  DATA 74,69
00440:  DATA 6D,65
00442:  DATA 3A,20
00444:  DATA 25,30
00446:  DATA 34,6C
00448:  DATA 64,2F
0044A:  DATA 25,30
0044C:  DATA 32,64
0044E:  DATA 2F,25
00450:  DATA 30,32
00452:  DATA 64,20
00454:  DATA 25,30
00456:  DATA 32,64
00458:  DATA 3A,25
0045A:  DATA 30,32
0045C:  DATA 64,3A
0045E:  DATA 25,30
00460:  DATA 32,64
00462:  DATA 00,00
00464:  DATA 43,6F
00466:  DATA 70,79
00468:  DATA 20,41
0046A:  DATA 44,43
0046C:  DATA 53,20
0046E:  DATA 48,53
00470:  DATA 20,64
00472:  DATA 61,74
00474:  DATA 61,20
00476:  DATA 74,6F
00478:  DATA 20,4D
0047A:  DATA 61,69
0047C:  DATA 6E,20
0047E:  DATA 50,49
00480:  DATA 43,0D
00482:  DATA 0A,00
00484:  DATA 53,6F
00486:  DATA 75,72
00488:  DATA 63,65
0048A:  DATA 20,61
0048C:  DATA 64,64
0048E:  DATA 72,65
00490:  DATA 73,73
00492:  DATA 20,20
00494:  DATA 20,20
00496:  DATA 20,20
00498:  DATA 3D,20
0049A:  DATA 30,78
0049C:  DATA 25,38
0049E:  DATA 6C,58
004A0:  DATA 0D,0A
004A2:  DATA 00,00
004A4:  DATA 44,65
004A6:  DATA 73,74
004A8:  DATA 69,6E
004AA:  DATA 61,74
004AC:  DATA 69,6F
004AE:  DATA 6E,20
004B0:  DATA 61,64
004B2:  DATA 64,72
004B4:  DATA 65,73
004B6:  DATA 73,20
004B8:  DATA 3D,20
004BA:  DATA 30,78
004BC:  DATA 25,38
004BE:  DATA 6C,58
004C0:  DATA 0D,0A
004C2:  DATA 00,00
004C4:  DATA 53,69
004C6:  DATA 7A,65
004C8:  DATA 20,20
004CA:  DATA 20,20
004CC:  DATA 20,20
004CE:  DATA 20,20
004D0:  DATA 20,20
004D2:  DATA 20,20
004D4:  DATA 20,20
004D6:  DATA 20,20
004D8:  DATA 3D,20
004DA:  DATA 25,6C
004DC:  DATA 75,0D
004DE:  DATA 0A,00
004E0:  DATA 43,6F
004E2:  DATA 70,79
004E4:  DATA 20,47
004E6:  DATA 50,53
004E8:  DATA 20,64
004EA:  DATA 61,74
004EC:  DATA 61,20
004EE:  DATA 74,6F
004F0:  DATA 20,4D
004F2:  DATA 61,69
004F4:  DATA 6E,20
004F6:  DATA 50,49
004F8:  DATA 43,0D
004FA:  DATA 0A,00
004FC:  DATA 31,68
004FE:  DATA 20,73
00500:  DATA 6C,6F
00502:  DATA 74,73
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,20
0050A:  DATA 20,20
0050C:  DATA 20,20
0050E:  DATA 20,20
00510:  DATA 3D,20
00512:  DATA 25,64
00514:  DATA 0D,0A
00516:  DATA 00,00
00518:  DATA 53,6F
0051A:  DATA 75,72
0051C:  DATA 63,65
0051E:  DATA 20,61
00520:  DATA 64,64
00522:  DATA 72,65
00524:  DATA 73,73
00526:  DATA 20,20
00528:  DATA 20,20
0052A:  DATA 20,20
0052C:  DATA 3D,20
0052E:  DATA 30,78
00530:  DATA 25,38
00532:  DATA 6C,58
00534:  DATA 0D,0A
00536:  DATA 00,00
00538:  DATA 44,65
0053A:  DATA 73,74
0053C:  DATA 69,6E
0053E:  DATA 61,74
00540:  DATA 69,6F
00542:  DATA 6E,20
00544:  DATA 61,64
00546:  DATA 64,72
00548:  DATA 65,73
0054A:  DATA 73,20
0054C:  DATA 3D,20
0054E:  DATA 30,78
00550:  DATA 25,38
00552:  DATA 6C,58
00554:  DATA 0D,0A
00556:  DATA 00,00
00558:  DATA 53,69
0055A:  DATA 7A,65
0055C:  DATA 20,20
0055E:  DATA 20,20
00560:  DATA 20,20
00562:  DATA 20,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,20
0056C:  DATA 3D,20
0056E:  DATA 25,6C
00570:  DATA 75,0D
00572:  DATA 0A,00
00574:  DATA 43,6F
00576:  DATA 70,79
00578:  DATA 20,41
0057A:  DATA 44,43
0057C:  DATA 53,20
0057E:  DATA 64,61
00580:  DATA 74,61
00582:  DATA 20,74
00584:  DATA 6F,20
00586:  DATA 4D,61
00588:  DATA 69,6E
0058A:  DATA 20,50
0058C:  DATA 49,43
0058E:  DATA 0D,0A
00590:  DATA 00,00
00592:  DATA 44,61
00594:  DATA 79,20
00596:  DATA 6F,66
00598:  DATA 20,74
0059A:  DATA 68,65
0059C:  DATA 20,79
0059E:  DATA 65,61
005A0:  DATA 72,20
005A2:  DATA 20,20
005A4:  DATA 20,20
005A6:  DATA 3D,20
005A8:  DATA 25,6C
005AA:  DATA 75,0D
005AC:  DATA 0A,00
005AE:  DATA 53,6F
005B0:  DATA 75,72
005B2:  DATA 63,65
005B4:  DATA 20,61
005B6:  DATA 64,64
005B8:  DATA 72,65
005BA:  DATA 73,73
005BC:  DATA 20,20
005BE:  DATA 20,20
005C0:  DATA 20,20
005C2:  DATA 3D,20
005C4:  DATA 30,78
005C6:  DATA 25,38
005C8:  DATA 6C,58
005CA:  DATA 0D,0A
005CC:  DATA 00,00
005CE:  DATA 44,65
005D0:  DATA 73,74
005D2:  DATA 69,6E
005D4:  DATA 61,74
005D6:  DATA 69,6F
005D8:  DATA 6E,20
005DA:  DATA 61,64
005DC:  DATA 64,72
005DE:  DATA 65,73
005E0:  DATA 73,20
005E2:  DATA 3D,20
005E4:  DATA 30,78
005E6:  DATA 25,38
005E8:  DATA 6C,58
005EA:  DATA 0D,0A
005EC:  DATA 00,00
005EE:  DATA 53,69
005F0:  DATA 7A,65
005F2:  DATA 20,20
005F4:  DATA 20,20
005F6:  DATA 20,20
005F8:  DATA 20,20
005FA:  DATA 20,20
005FC:  DATA 20,20
005FE:  DATA 20,20
00600:  DATA 20,20
00602:  DATA 3D,20
00604:  DATA 25,6C
00606:  DATA 75,0D
00608:  DATA 0A,00
0060A:  DATA 55,70
0060C:  DATA 6C,69
0060E:  DATA 6E,6B
00610:  DATA 3A,20
00612:  DATA 00,00
00614:  DATA 20,56
00616:  DATA 61,6C
00618:  DATA 69,64
0061A:  DATA 20,75
0061C:  DATA 70,6C
0061E:  DATA 69,6E
00620:  DATA 6B,00
00622:  DATA 20,49
00624:  DATA 6E,76
00626:  DATA 61,6C
00628:  DATA 69,64
0062A:  DATA 20,28
0062C:  DATA 25,64
0062E:  DATA 29,20
00630:  DATA 6F,72
00632:  DATA 20,69
00634:  DATA 64,65
00636:  DATA 6E,74
00638:  DATA 69,63
0063A:  DATA 61,6C
0063C:  DATA 20,28
0063E:  DATA 25,64
00640:  DATA 29,20
00642:  DATA 75,70
00644:  DATA 6C,69
00646:  DATA 6E,6B
00648:  DATA 2E,00
0064A:  DATA 43,4F
0064C:  DATA 4D,3A
0064E:  DATA 20,00
00650:  DATA 52,45
00652:  DATA 4C,41
00654:  DATA 59,3A
00656:  DATA 20,00
00658:  DATA 4E,65
0065A:  DATA 77,20
0065C:  DATA 74,69
0065E:  DATA 6D,65
00660:  DATA 3A,20
00662:  DATA 25,30
00664:  DATA 34,6C
00666:  DATA 64,2F
00668:  DATA 25,30
0066A:  DATA 32,64
0066C:  DATA 2F,25
0066E:  DATA 30,32
00670:  DATA 64,20
00672:  DATA 25,30
00674:  DATA 32,64
00676:  DATA 3A,25
00678:  DATA 30,32
0067A:  DATA 64,3A
0067C:  DATA 25,30
0067E:  DATA 32,64
00680:  DATA 28,30
00682:  DATA 78,25
00684:  DATA 30,38
00686:  DATA 6C,58
00688:  DATA 29,20
0068A:  DATA 00,00
0068C:  DATA 4C,65
0068E:  DATA 61,70
00690:  DATA 3A,20
00692:  DATA 25,64
00694:  DATA 20,47
00696:  DATA 50,53
00698:  DATA 20,73
0069A:  DATA 79,6E
0069C:  DATA 63,3A
0069E:  DATA 20,30
006A0:  DATA 78,25
006A2:  DATA 30,32
006A4:  DATA 58,00
006A6:  DATA 0A,20
006A8:  DATA 20,20
006AA:  DATA 20,20
006AC:  DATA 20,20
006AE:  DATA 20,20
006B0:  DATA 66,65
006B2:  DATA 64,63
006B4:  DATA 62,61
006B6:  DATA 39,38
006B8:  DATA 37,36
006BA:  DATA 35,34
006BC:  DATA 33,32
006BE:  DATA 31,30
006C0:  DATA 0D,0A
006C2:  DATA 00,00
006C4:  DATA 74,72
006C6:  DATA 69,73
006C8:  DATA 5F,61
006CA:  DATA 20,3D
006CC:  DATA 20,00
006CE:  DATA 74,72
006D0:  DATA 69,73
006D2:  DATA 5F,62
006D4:  DATA 20,3D
006D6:  DATA 20,00
006D8:  DATA 74,72
006DA:  DATA 69,73
006DC:  DATA 5F,63
006DE:  DATA 20,3D
006E0:  DATA 20,00
006E2:  DATA 74,72
006E4:  DATA 69,73
006E6:  DATA 5F,64
006E8:  DATA 20,3D
006EA:  DATA 20,00
006EC:  DATA 74,72
006EE:  DATA 69,73
006F0:  DATA 5F,65
006F2:  DATA 20,3D
006F4:  DATA 20,00
006F6:  DATA 74,72
006F8:  DATA 69,73
006FA:  DATA 5F,66
006FC:  DATA 20,3D
006FE:  DATA 20,00
00700:  DATA 74,72
00702:  DATA 69,73
00704:  DATA 5F,67
00706:  DATA 20,3D
00708:  DATA 20,00
0070A:  DATA 2A,25
0070C:  DATA 30,34
0070E:  DATA 6C,58
00710:  DATA 20,3D
00712:  DATA 20,25
00714:  DATA 30,38
00716:  DATA 6C,58
00718:  DATA 00,00
0071A:  DATA 57,61
0071C:  DATA 69,74
0071E:  DATA 69,6E
00720:  DATA 67,20
00722:  DATA 31,30
00724:  DATA 73,20
00726:  DATA 66,6F
00728:  DATA 72,20
0072A:  DATA 72,65
0072C:  DATA 73,65
0072E:  DATA 74,2E
00730:  DATA 2E,2E
00732:  DATA 0D,0A
00734:  DATA 00,00
00736:  DATA 0D,0A
00738:  DATA 48,65
0073A:  DATA 78,20
0073C:  DATA 64,75
0073E:  DATA 6D,70
00740:  DATA 20,73
00742:  DATA 74,61
00744:  DATA 72,74
00746:  DATA 00,00
00748:  DATA 0D,0A
0074A:  DATA 48,65
0074C:  DATA 78,20
0074E:  DATA 64,75
00750:  DATA 6D,70
00752:  DATA 20,65
00754:  DATA 6E,64
00756:  DATA 0D,0A
00758:  DATA 00,00
0075A:  DATA 6D,65
0075C:  DATA 6D,63
0075E:  DATA 70,79
00760:  DATA 20,6F
00762:  DATA 72,69
00764:  DATA 67,3D
00766:  DATA 25,64
00768:  DATA 2C,64
0076A:  DATA 65,73
0076C:  DATA 74,3D
0076E:  DATA 25,64
00770:  DATA 2C,74
00772:  DATA 6F,5F
00774:  DATA 61,64
00776:  DATA 64,72
00778:  DATA 3D,25
0077A:  DATA 6C,58
0077C:  DATA 2C,66
0077E:  DATA 72,6F
00780:  DATA 6D,5F
00782:  DATA 61,64
00784:  DATA 64,72
00786:  DATA 3D,25
00788:  DATA 6C,58
0078A:  DATA 2C,73
0078C:  DATA 69,7A
0078E:  DATA 65,3D
00790:  DATA 25,6C
00792:  DATA 58,00
00794:  DATA 6D,65
00796:  DATA 6D,63
00798:  DATA 70,79
0079A:  DATA 20,6F
0079C:  DATA 72,69
0079E:  DATA 67,3D
007A0:  DATA 25,64
007A2:  DATA 2C,64
007A4:  DATA 65,73
007A6:  DATA 74,3D
007A8:  DATA 25,64
007AA:  DATA 2C,74
007AC:  DATA 6F,5F
007AE:  DATA 61,64
007B0:  DATA 64,72
007B2:  DATA 3D,25
007B4:  DATA 6C,58
007B6:  DATA 2C,66
007B8:  DATA 72,6F
007BA:  DATA 6D,5F
007BC:  DATA 61,64
007BE:  DATA 64,72
007C0:  DATA 3D,25
007C2:  DATA 6C,58
007C4:  DATA 2C,73
007C6:  DATA 69,7A
007C8:  DATA 65,3D
007CA:  DATA 25,6C
007CC:  DATA 58,00
007CE:  DATA 57,61
007D0:  DATA 69,74
007D2:  DATA 69,6E
007D4:  DATA 67,20
007D6:  DATA 66,6F
007D8:  DATA 72,20
007DA:  DATA 78,6D
007DC:  DATA 6F,64
007DE:  DATA 65,6D
007E0:  DATA 20,74
007E2:  DATA 72,61
007E4:  DATA 6E,73
007E6:  DATA 66,65
007E8:  DATA 72,2E
007EA:  DATA 2E,2E
007EC:  DATA 00,00
007EE:  DATA 0A,72
007F0:  DATA 78,2C
007F2:  DATA 25,30
007F4:  DATA 35,6C
007F6:  DATA 75,0A
007F8:  DATA 00,00
007FA:  DATA 52,65
007FC:  DATA 63,65
007FE:  DATA 69,76
00800:  DATA 69,6E
00802:  DATA 67,20
00804:  DATA 78,6D
00806:  DATA 6F,64
00808:  DATA 65,6D
0080A:  DATA 20,64
0080C:  DATA 61,74
0080E:  DATA 61,2E
00810:  DATA 2E,2E
00812:  DATA 00,00
00814:  DATA 4D,61
00816:  DATA 69,6E
00818:  DATA 20,50
0081A:  DATA 49,43
0081C:  DATA 20,72
0081E:  DATA 65,73
00820:  DATA 65,74
00822:  DATA 20,64
00824:  DATA 65,74
00826:  DATA 65,63
00828:  DATA 74,65
0082A:  DATA 64,2E
0082C:  DATA 00,00
0082E:  DATA 53,61
00830:  DATA 76,69
00832:  DATA 6E,67
00834:  DATA 20,74
00836:  DATA 65,6C
00838:  DATA 65,6D
0083A:  DATA 65,74
0083C:  DATA 72,79
0083E:  DATA 20,64
00840:  DATA 61,74
00842:  DATA 61,3A
00844:  DATA 20,00
00846:  DATA 41,64
00848:  DATA 64,72
0084A:  DATA 3A,20
0084C:  DATA 30,78
0084E:  DATA 25,30
00850:  DATA 38,6C
00852:  DATA 58,20
00854:  DATA 00,00
00856:  DATA 53,6B
00858:  DATA 69,70
0085A:  DATA 70,69
0085C:  DATA 6E,67
0085E:  DATA 20,73
00860:  DATA 61,76
00862:  DATA 69,6E
00864:  DATA 67,20
00866:  DATA 74,65
00868:  DATA 6C,65
0086A:  DATA 6D,65
0086C:  DATA 74,72
0086E:  DATA 79,20
00870:  DATA 64,61
00872:  DATA 74,61
00874:  DATA 2E,00
00876:  DATA 52,45
00878:  DATA 53,45
0087A:  DATA 54,3A
0087C:  DATA 20,00
0087E:  DATA 0D,0A
00880:  DATA 57,61
00882:  DATA 72,6E
00884:  DATA 69,6E
00886:  DATA 67,3A
00888:  DATA 20,61
0088A:  DATA 20,73
0088C:  DATA 63,68
0088E:  DATA 65,64
00890:  DATA 75,6C
00892:  DATA 65,64
00894:  DATA 20,63
00896:  DATA 6F,6D
00898:  DATA 6D,61
0089A:  DATA 6E,64
0089C:  DATA 20,28
0089E:  DATA 25,30
008A0:  DATA 32,58
008A2:  DATA 20,25
008A4:  DATA 30,32
008A6:  DATA 58,29
008A8:  DATA 20,69
008AA:  DATA 6E,20
008AC:  DATA 66,6C
008AE:  DATA 61,73
008B0:  DATA 68,20
008B2:  DATA 6D,65
008B4:  DATA 6D,6F
008B6:  DATA 72,79
008B8:  DATA 20,77
008BA:  DATA 61,73
008BC:  DATA 20,73
008BE:  DATA 63,68
008C0:  DATA 65,64
008C2:  DATA 75,6C
008C4:  DATA 65,64
008C6:  DATA 20,74
008C8:  DATA 6F,20
008CA:  DATA 72,75
008CC:  DATA 6E,20
008CE:  DATA 69,6E
008D0:  DATA 20,61
008D2:  DATA 20,70
008D4:  DATA 61,73
008D6:  DATA 74,20
008D8:  DATA 64,61
008DA:  DATA 74,65
008DC:  DATA 2F,74
008DE:  DATA 69,6D
008E0:  DATA 65,20
008E2:  DATA 61,6E
008E4:  DATA 64,20
008E6:  DATA 77,61
008E8:  DATA 73,20
008EA:  DATA 6D,61
008EC:  DATA 72,6B
008EE:  DATA 65,64
008F0:  DATA 20,61
008F2:  DATA 73,20
008F4:  DATA 63,6F
008F6:  DATA 6D,70
008F8:  DATA 6C,65
008FA:  DATA 74,65
008FC:  DATA 2E,0D
008FE:  DATA 0A,00
00900:  DATA 20,4E
00902:  DATA 65,77
00904:  DATA 20,74
00906:  DATA 69,6D
00908:  DATA 65,3A
0090A:  DATA 20,25
0090C:  DATA 30,34
0090E:  DATA 6C,64
00910:  DATA 2F,25
00912:  DATA 30,32
00914:  DATA 64,2F
00916:  DATA 25,30
00918:  DATA 32,64
0091A:  DATA 20,25
0091C:  DATA 30,32
0091E:  DATA 64,3A
00920:  DATA 25,30
00922:  DATA 32,64
00924:  DATA 3A,25
00926:  DATA 30,32
00928:  DATA 64,20
0092A:  DATA 28,30
0092C:  DATA 78,25
0092E:  DATA 30,38
00930:  DATA 6C,58
00932:  DATA 29,00
00934:  DATA 57,61
00936:  DATA 69,74
00938:  DATA 69,6E
0093A:  DATA 67,20
0093C:  DATA 66,6F
0093E:  DATA 72,20
00940:  DATA 32,34
00942:  DATA 68,20
00944:  DATA 72,65
00946:  DATA 73,65
00948:  DATA 74,2E
0094A:  DATA 2E,2E
0094C:  DATA 0D,0A
0094E:  DATA 00,00
00950:  DATA 4E,6F
00952:  DATA 20,32
00954:  DATA 34,68
00956:  DATA 20,72
00958:  DATA 65,73
0095A:  DATA 65,74
0095C:  DATA 20,68
0095E:  DATA 61,70
00960:  DATA 70,65
00962:  DATA 6E,65
00964:  DATA 64,2C
00966:  DATA 20,64
00968:  DATA 6F,69
0096A:  DATA 6E,67
0096C:  DATA 20,73
0096E:  DATA 6F,66
00970:  DATA 74,20
00972:  DATA 72,65
00974:  DATA 73,65
00976:  DATA 74,20
00978:  DATA 69,6E
0097A:  DATA 73,74
0097C:  DATA 65,61
0097E:  DATA 64,2E
00980:  DATA 0D,0A
00982:  DATA 00,00
00984:  DATA 52,65
00986:  DATA 73,65
00988:  DATA 74,20
0098A:  DATA 50,49
0098C:  DATA 43,20
0098E:  DATA 74,69
00990:  DATA 6D,65
00992:  DATA 20,63
00994:  DATA 68,61
00996:  DATA 6E,67
00998:  DATA 65,20
0099A:  DATA 41,43
0099C:  DATA 4B,2E
0099E:  DATA 00,00
009A0:  DATA 45,50
009A2:  DATA 53,3A
009A4:  DATA 20,00
009A6:  DATA 56,3D
009A8:  DATA 25,66
009AA:  DATA 2C,20
009AC:  DATA 43,3D
009AE:  DATA 25,66
009B0:  DATA 2C,20
009B2:  DATA 54,3D
009B4:  DATA 25,66
009B6:  DATA 20,7C
009B8:  DATA 20,00
009BA:  DATA 20,4E
009BC:  DATA 65,77
009BE:  DATA 20,54
009C0:  DATA 3D,30
009C2:  DATA 78,25
009C4:  DATA 30,34
009C6:  DATA 6C,58
009C8:  DATA 2C,20
009CA:  DATA 56,3D
009CC:  DATA 30,78
009CE:  DATA 25,30
009D0:  DATA 34,6C
009D2:  DATA 58,20
009D4:  DATA 7C,20
009D6:  DATA 00,00
009D8:  DATA 45,50
009DA:  DATA 53,20
009DC:  DATA 63,6D
009DE:  DATA 64,3A
009E0:  DATA 20,00
009E2:  DATA 4E,65
009E4:  DATA 77,20
009E6:  DATA 54,3D
009E8:  DATA 30,78
009EA:  DATA 25,30
009EC:  DATA 34,6C
009EE:  DATA 58,2C
009F0:  DATA 20,56
009F2:  DATA 3D,30
009F4:  DATA 78,25
009F6:  DATA 30,34
009F8:  DATA 6C,58
009FA:  DATA 00,00
009FC:  DATA 25,30
009FE:  DATA 34,6C
00A00:  DATA 64,2F
00A02:  DATA 25,30
00A04:  DATA 32,64
00A06:  DATA 2F,25
00A08:  DATA 30,32
00A0A:  DATA 64,20
00A0C:  DATA 25,30
00A0E:  DATA 32,64
00A10:  DATA 3A,25
00A12:  DATA 30,32
00A14:  DATA 64,3A
00A16:  DATA 25,30
00A18:  DATA 32,64
00A1A:  DATA 20,7C
00A1C:  DATA 20,25
00A1E:  DATA 30,32
00A20:  DATA 64,20
00A22:  DATA 7C,20
00A24:  DATA 25,30
00A26:  DATA 32,58
00A28:  DATA 20,25
00A2A:  DATA 30,32
00A2C:  DATA 58,20
00A2E:  DATA 7C,20
00A30:  DATA 00,00
00A32:  DATA 20,28
00A34:  DATA 52,65
00A36:  DATA 74,3A
00A38:  DATA 20,25
00A3A:  DATA 30,32
00A3C:  DATA 58,29
00A3E:  DATA 00,00
00A40:  DATA 49,6E
00A42:  DATA 69,74
00A44:  DATA 69,61
00A46:  DATA 6C,69
00A48:  DATA 7A,69
00A4A:  DATA 6E,67
00A4C:  DATA 20,66
00A4E:  DATA 6C,61
00A50:  DATA 73,68
00A52:  DATA 20,6D
00A54:  DATA 65,6D
00A56:  DATA 6F,72
00A58:  DATA 79,2E
00A5A:  DATA 2E,2E
00A5C:  DATA 0D,0A
00A5E:  DATA 00,00
00A60:  DATA 52,65
00A62:  DATA 74,72
00A64:  DATA 69,65
00A66:  DATA 76,69
00A68:  DATA 6E,67
00A6A:  DATA 20,61
00A6C:  DATA 64,64
00A6E:  DATA 72,65
00A70:  DATA 73,73
00A72:  DATA 65,73
00A74:  DATA 20,66
00A76:  DATA 72,6F
00A78:  DATA 6D,20
00A7A:  DATA 66,6C
00A7C:  DATA 61,73
00A7E:  DATA 68,20
00A80:  DATA 6D,65
00A82:  DATA 6D,6F
00A84:  DATA 72,79
00A86:  DATA 2E,2E
00A88:  DATA 2E,0D
00A8A:  DATA 0A,00
*
019E4:  DATA 4E,6F
019E6:  DATA 20,32
019E8:  DATA 34,68
019EA:  DATA 20,72
019EC:  DATA 65,73
019EE:  DATA 65,74
019F0:  DATA 20,68
019F2:  DATA 61,70
019F4:  DATA 70,65
019F6:  DATA 6E,65
019F8:  DATA 64,2C
019FA:  DATA 20,64
019FC:  DATA 6F,69
019FE:  DATA 6E,67
01A00:  DATA 20,73
01A02:  DATA 6F,66
01A04:  DATA 74,20
01A06:  DATA 72,65
01A08:  DATA 73,65
01A0A:  DATA 74,20
01A0C:  DATA 69,6E
01A0E:  DATA 73,74
01A10:  DATA 65,61
01A12:  DATA 64,2E
01A14:  DATA 0D,0A
01A16:  DATA 00,00
01A18:  DATA 5F,5F
01A1A:  DATA 5F,5F
01A1C:  DATA 20,20
01A1E:  DATA 20,5F
01A20:  DATA 5F,5F
01A22:  DATA 5F,5F
01A24:  DATA 5F,5F
01A26:  DATA 5F,5F
01A28:  DATA 5F,5F
01A2A:  DATA 5F,5F
01A2C:  DATA 5F,5F
01A2E:  DATA 5F,5F
01A30:  DATA 5F,5F
01A32:  DATA 5F,5F
01A34:  DATA 5F,5F
01A36:  DATA 5F,5F
01A38:  DATA 5F,5F
01A3A:  DATA 5F,5F
01A3C:  DATA 5F,5F
01A3E:  DATA 5F,5F
01A40:  DATA 5F,5F
01A42:  DATA 5F,5F
01A44:  DATA 5F,5F
01A46:  DATA 5F,5F
01A48:  DATA 5F,5F
01A4A:  DATA 5F,5F
01A4C:  DATA 5F,5F
01A4E:  DATA 5F,5F
01A50:  DATA 5F,5F
01A52:  DATA 5F,5F
01A54:  DATA 5F,5F
01A56:  DATA 5F,20
01A58:  DATA 20,20
01A5A:  DATA 5F,5F
01A5C:  DATA 5F,5F
01A5E:  DATA 5F,5F
01A60:  DATA 5F,5F
01A62:  DATA 5F,0D
01A64:  DATA 0A,00
01A66:  DATA 5C,20
01A68:  DATA 20,20
01A6A:  DATA 5C,20
01A6C:  DATA 2F,20
01A6E:  DATA 20,20
01A70:  DATA 2F,5C
01A72:  DATA 5F,20
01A74:  DATA 20,20
01A76:  DATA 5F,5F
01A78:  DATA 5F,5F
01A7A:  DATA 5F,2F
01A7C:  DATA 5C,5F
01A7E:  DATA 5F,5F
01A80:  DATA 5F,5F
01A82:  DATA 5F,20
01A84:  DATA 20,20
01A86:  DATA 5C,5F
01A88:  DATA 5F,20
01A8A:  DATA 20,20
01A8C:  DATA 20,5F
01A8E:  DATA 5F,5F
01A90:  DATA 2F,5C
01A92:  DATA 5F,20
01A94:  DATA 20,20
01A96:  DATA 5F,5F
01A98:  DATA 5F,5F
01A9A:  DATA 5F,2F
01A9C:  DATA 5C,5F
01A9E:  DATA 20,20
01AA0:  DATA 20,5F
01AA2:  DATA 5F,5F
01AA4:  DATA 20,5C
01AA6:  DATA 20,2F
01AA8:  DATA 20,20
01AAA:  DATA 20,5F
01AAC:  DATA 5F,5F
01AAE:  DATA 5F,5F
01AB0:  DATA 2F,0D
01AB2:  DATA 0A,00
01AB4:  DATA 20,5C
01AB6:  DATA 20,20
01AB8:  DATA 20,79
01ABA:  DATA 20,20
01ABC:  DATA 20,2F
01ABE:  DATA 20,20
01AC0:  DATA 7C,20
01AC2:  DATA 20,20
01AC4:  DATA 20,5F
01AC6:  DATA 5F,29
01AC8:  DATA 5F,20
01ACA:  DATA 20,7C
01ACC:  DATA 20,20
01ACE:  DATA 20,20
01AD0:  DATA 20,20
01AD2:  DATA 20,5F
01AD4:  DATA 2F,20
01AD6:  DATA 7C,20
01AD8:  DATA 20,20
01ADA:  DATA 20,7C
01ADC:  DATA 20,20
01ADE:  DATA 20,20
01AE0:  DATA 7C,20
01AE2:  DATA 20,20
01AE4:  DATA 20,5F
01AE6:  DATA 5F,29
01AE8:  DATA 5F,20
01AEA:  DATA 2F,20
01AEC:  DATA 20,20
01AEE:  DATA 20,5C
01AF0:  DATA 20,20
01AF2:  DATA 5C,2F
01AF4:  DATA 20,5C
01AF6:  DATA 5F,5F
01AF8:  DATA 5F,5F
01AFA:  DATA 5F,20
01AFC:  DATA 20,5C
01AFE:  DATA 20,0D
01B00:  DATA 0A,00
01B02:  DATA 20,20
01B04:  DATA 5C,20
01B06:  DATA 20,20
01B08:  DATA 20,20
01B0A:  DATA 2F,20
01B0C:  DATA 20,20
01B0E:  DATA 7C,20
01B10:  DATA 20,20
01B12:  DATA 20,20
01B14:  DATA 20,20
01B16:  DATA 20,5C
01B18:  DATA 20,7C
01B1A:  DATA 20,20
01B1C:  DATA 20,20
01B1E:  DATA 7C,20
01B20:  DATA 20,20
01B22:  DATA 5C,20
01B24:  DATA 7C,20
01B26:  DATA 20,20
01B28:  DATA 20,7C
01B2A:  DATA 20,20
01B2C:  DATA 20,20
01B2E:  DATA 7C,20
01B30:  DATA 20,20
01B32:  DATA 20,20
01B34:  DATA 20,20
01B36:  DATA 20,5C
01B38:  DATA 5C,20
01B3A:  DATA 20,20
01B3C:  DATA 20,20
01B3E:  DATA 5C,5F
01B40:  DATA 5F,5F
01B42:  DATA 5F,2F
01B44:  DATA 20,20
01B46:  DATA 20,20
01B48:  DATA 20,20
01B4A:  DATA 20,20
01B4C:  DATA 5C,0D
01B4E:  DATA 0A,00
01B50:  DATA 20,20
01B52:  DATA 20,5C
01B54:  DATA 5F,5F
01B56:  DATA 5F,2F
01B58:  DATA 20,20
01B5A:  DATA 20,2F
01B5C:  DATA 5F,5F
01B5E:  DATA 5F,5F
01B60:  DATA 5F,5F
01B62:  DATA 5F,20
01B64:  DATA 20,2F
01B66:  DATA 20,7C
01B68:  DATA 5F,5F
01B6A:  DATA 5F,5F
01B6C:  DATA 7C,5F
01B6E:  DATA 20,20
01B70:  DATA 2F,20
01B72:  DATA 7C,5F
01B74:  DATA 5F,5F
01B76:  DATA 5F,7C
01B78:  DATA 20,20
01B7A:  DATA 20,2F
01B7C:  DATA 5F,5F
01B7E:  DATA 5F,5F
01B80:  DATA 5F,5F
01B82:  DATA 5F,20
01B84:  DATA 20,2F
01B86:  DATA 20,5C
01B88:  DATA 5F,5F
01B8A:  DATA 5F,5F
01B8C:  DATA 5F,5F
01B8E:  DATA 20,20
01B90:  DATA 2F,5F
01B92:  DATA 5F,5F
01B94:  DATA 5F,5F
01B96:  DATA 5F,5F
01B98:  DATA 20,20
01B9A:  DATA 2F,0D
01B9C:  DATA 0A,00
01B9E:  DATA 20,20
01BA0:  DATA 20,20
01BA2:  DATA 20,20
01BA4:  DATA 20,20
01BA6:  DATA 20,20
01BA8:  DATA 20,20
01BAA:  DATA 20,20
01BAC:  DATA 20,20
01BAE:  DATA 20,20
01BB0:  DATA 20,5C
01BB2:  DATA 2F,20
01BB4:  DATA 20,20
01BB6:  DATA 20,20
01BB8:  DATA 20,20
01BBA:  DATA 20,20
01BBC:  DATA 5C,2F
01BBE:  DATA 20,20
01BC0:  DATA 20,20
01BC2:  DATA 20,20
01BC4:  DATA 20,20
01BC6:  DATA 20,20
01BC8:  DATA 20,20
01BCA:  DATA 20,20
01BCC:  DATA 20,20
01BCE:  DATA 20,20
01BD0:  DATA 20,5C
01BD2:  DATA 2F,20
01BD4:  DATA 20,20
01BD6:  DATA 20,20
01BD8:  DATA 20,20
01BDA:  DATA 20,20
01BDC:  DATA 5C,2F
01BDE:  DATA 20,20
01BE0:  DATA 20,20
01BE2:  DATA 20,20
01BE4:  DATA 20,20
01BE6:  DATA 5C,2F
01BE8:  DATA 20,0D
01BEA:  DATA 0A,0D
01BEC:  DATA 0A,00
01BEE:  DATA 43,6F
01BF0:  DATA 6D,70
01BF2:  DATA 69,6C
01BF4:  DATA 65,64
01BF6:  DATA 20,6F
01BF8:  DATA 6E,3A
01BFA:  DATA 20,31
01BFC:  DATA 38,2D
01BFE:  DATA 44,65
01C00:  DATA 63,2D
01C02:  DATA 32,34
01C04:  DATA 20,31
01C06:  DATA 33,3A
01C08:  DATA 30,32
01C0A:  DATA 3A,33
01C0C:  DATA 31,0D
01C0E:  DATA 0A,0D
01C10:  DATA 0A,00
01C12:  DATA 3E,20
01C14:  DATA 49,6E
01C16:  DATA 76,61
01C18:  DATA 6C,69
01C1A:  DATA 64,20
01C1C:  DATA 63,6C
01C1E:  DATA 6F,63
01C20:  DATA 6B,2C
01C22:  DATA 20,72
01C24:  DATA 65,63
01C26:  DATA 6F,76
01C28:  DATA 65,72
01C2A:  DATA 69,6E
01C2C:  DATA 67,2E
01C2E:  DATA 2E,2E
01C30:  DATA 0D,0A
01C32:  DATA 00,00
*
01C7A:  TBLRD*+
01C7C:  MOVF   FF5,F
01C7E:  BZ    1CA0
01C80:  MOVFF  FF6,A55
01C84:  MOVFF  FF7,A56
01C88:  MOVFF  FF8,A57
01C8C:  MOVFF  FF5,B1F
01C90:  RCALL  1C34
01C92:  MOVFF  A55,FF6
01C96:  MOVFF  A56,FF7
01C9A:  MOVFF  A57,FF8
01C9E:  BRA    1C7A
01CA0:  RETURN 0
01CA2:  MOVWF  00
01CA4:  SWAPF  00,W
01CA6:  ANDLW  0F
01CA8:  MULLW  0A
01CAA:  MOVF   00,W
01CAC:  ANDLW  0F
01CAE:  ADDWF  FF3,W
01CB0:  RETURN 0
01CB2:  RETURN 0
01CB4:  MOVLB  A
01CB6:  CLRF   x5F
01CB8:  CLRF   x60
01CBA:  MOVLW  01
01CBC:  MOVWF  x61
01CBE:  CLRF   FDA
01CC0:  CLRF   FD9
01CC2:  MOVLW  0A
01CC4:  MOVWF  x64
01CC6:  MOVLW  57
01CC8:  MOVWF  x63
01CCA:  MOVLW  0A
01CCC:  MOVWF  FEA
01CCE:  MOVLW  5B
01CD0:  MOVWF  FE9
01CD2:  MOVFF  A64,FE2
01CD6:  MOVFF  A63,FE1
01CDA:  MOVFF  A61,A62
01CDE:  BCF    FD8.0
01CE0:  MOVF   FE5,W
01CE2:  MULWF  FEE
01CE4:  MOVF   FF3,W
01CE6:  ADDWFC x5F,F
01CE8:  MOVF   FF4,W
01CEA:  ADDWFC x60,F
01CEC:  DECFSZ x62,F
01CEE:  BRA    1CDE
01CF0:  MOVFF  A5F,FDE
01CF4:  MOVFF  A60,A5F
01CF8:  CLRF   x60
01CFA:  BTFSC  FD8.0
01CFC:  INCF   x60,F
01CFE:  INCF   x63,F
01D00:  BTFSC  FD8.2
01D02:  INCF   x64,F
01D04:  INCF   x61,F
01D06:  MOVF   x61,W
01D08:  SUBLW  05
01D0A:  BNZ   1CCA
01D0C:  MOVLB  0
01D0E:  RETURN 0
01D10:  CLRF   01
01D12:  CLRF   02
01D14:  CLRF   00
01D16:  CLRF   03
01D18:  MOVLB  A
01D1A:  MOVF   x5A,W
01D1C:  BNZ   1D22
01D1E:  MOVF   x59,W
01D20:  BZ    1D52
01D22:  MOVLW  10
01D24:  MOVWF  x5B
01D26:  BCF    FD8.0
01D28:  RLCF   x57,F
01D2A:  RLCF   x58,F
01D2C:  RLCF   00,F
01D2E:  RLCF   03,F
01D30:  MOVF   x5A,W
01D32:  SUBWF  03,W
01D34:  BNZ   1D3A
01D36:  MOVF   x59,W
01D38:  SUBWF  00,W
01D3A:  BNC   1D4A
01D3C:  MOVF   x59,W
01D3E:  SUBWF  00,F
01D40:  BTFSS  FD8.0
01D42:  DECF   03,F
01D44:  MOVF   x5A,W
01D46:  SUBWF  03,F
01D48:  BSF    FD8.0
01D4A:  RLCF   01,F
01D4C:  RLCF   02,F
01D4E:  DECFSZ x5B,F
01D50:  BRA    1D26
01D52:  MOVLB  0
01D54:  RETURN 0
*
01DDE:  MOVLB  A
01DE0:  MOVF   x3C,W
01DE2:  CLRF   01
01DE4:  SUBWF  x3B,W
01DE6:  BC    1DEE
01DE8:  MOVFF  A3B,00
01DEC:  BRA    1E06
01DEE:  CLRF   00
01DF0:  MOVLW  08
01DF2:  MOVWF  x3D
01DF4:  RLCF   x3B,F
01DF6:  RLCF   00,F
01DF8:  MOVF   x3C,W
01DFA:  SUBWF  00,W
01DFC:  BTFSC  FD8.0
01DFE:  MOVWF  00
01E00:  RLCF   01,F
01E02:  DECFSZ x3D,F
01E04:  BRA    1DF4
01E06:  MOVLB  0
01E08:  RETURN 0
*
01E6C:  BTFSC  FD8.1
01E6E:  BRA    1E78
01E70:  MOVLW  0A
01E72:  MOVWF  FEA
01E74:  MOVLW  63
01E76:  MOVWF  FE9
01E78:  MOVLB  A
01E7A:  MOVF   x5E,W
01E7C:  XORWF  x62,W
01E7E:  ANDLW  80
01E80:  MOVWF  x68
01E82:  BTFSS  x5E.7
01E84:  BRA    1E9C
01E86:  COMF   x5B,F
01E88:  COMF   x5C,F
01E8A:  COMF   x5D,F
01E8C:  COMF   x5E,F
01E8E:  INCF   x5B,F
01E90:  BTFSC  FD8.2
01E92:  INCF   x5C,F
01E94:  BTFSC  FD8.2
01E96:  INCF   x5D,F
01E98:  BTFSC  FD8.2
01E9A:  INCF   x5E,F
01E9C:  BTFSS  x62.7
01E9E:  BRA    1EB6
01EA0:  COMF   x5F,F
01EA2:  COMF   x60,F
01EA4:  COMF   x61,F
01EA6:  COMF   x62,F
01EA8:  INCF   x5F,F
01EAA:  BTFSC  FD8.2
01EAC:  INCF   x60,F
01EAE:  BTFSC  FD8.2
01EB0:  INCF   x61,F
01EB2:  BTFSC  FD8.2
01EB4:  INCF   x62,F
01EB6:  CLRF   00
01EB8:  CLRF   01
01EBA:  CLRF   02
01EBC:  CLRF   03
01EBE:  CLRF   x63
01EC0:  CLRF   x64
01EC2:  CLRF   x65
01EC4:  CLRF   x66
01EC6:  MOVF   x62,W
01EC8:  IORWF  x61,W
01ECA:  IORWF  x60,W
01ECC:  IORWF  x5F,W
01ECE:  BZ    1F28
01ED0:  MOVLW  20
01ED2:  MOVWF  x67
01ED4:  BCF    FD8.0
01ED6:  RLCF   x5B,F
01ED8:  RLCF   x5C,F
01EDA:  RLCF   x5D,F
01EDC:  RLCF   x5E,F
01EDE:  RLCF   x63,F
01EE0:  RLCF   x64,F
01EE2:  RLCF   x65,F
01EE4:  RLCF   x66,F
01EE6:  MOVF   x62,W
01EE8:  SUBWF  x66,W
01EEA:  BNZ   1EFC
01EEC:  MOVF   x61,W
01EEE:  SUBWF  x65,W
01EF0:  BNZ   1EFC
01EF2:  MOVF   x60,W
01EF4:  SUBWF  x64,W
01EF6:  BNZ   1EFC
01EF8:  MOVF   x5F,W
01EFA:  SUBWF  x63,W
01EFC:  BNC   1F1C
01EFE:  MOVF   x5F,W
01F00:  SUBWF  x63,F
01F02:  MOVF   x60,W
01F04:  BTFSS  FD8.0
01F06:  INCFSZ x60,W
01F08:  SUBWF  x64,F
01F0A:  MOVF   x61,W
01F0C:  BTFSS  FD8.0
01F0E:  INCFSZ x61,W
01F10:  SUBWF  x65,F
01F12:  MOVF   x62,W
01F14:  BTFSS  FD8.0
01F16:  INCFSZ x62,W
01F18:  SUBWF  x66,F
01F1A:  BSF    FD8.0
01F1C:  RLCF   00,F
01F1E:  RLCF   01,F
01F20:  RLCF   02,F
01F22:  RLCF   03,F
01F24:  DECFSZ x67,F
01F26:  BRA    1ED4
01F28:  BTFSS  x68.7
01F2A:  BRA    1F42
01F2C:  COMF   00,F
01F2E:  COMF   01,F
01F30:  COMF   02,F
01F32:  COMF   03,F
01F34:  INCF   00,F
01F36:  BTFSC  FD8.2
01F38:  INCF   01,F
01F3A:  BTFSC  FD8.2
01F3C:  INCF   02,F
01F3E:  BTFSC  FD8.2
01F40:  INCF   03,F
01F42:  MOVFF  A63,FEF
01F46:  MOVFF  A64,FEC
01F4A:  MOVFF  A65,FEC
01F4E:  MOVFF  A66,FEC
01F52:  MOVLB  0
01F54:  RETURN 0
*
0244C:  MOVLB  A
0244E:  MOVF   x5A,W
02450:  MULWF  x5C
02452:  MOVFF  FF3,01
02456:  MOVFF  FF4,00
0245A:  MULWF  x5D
0245C:  MOVF   FF3,W
0245E:  ADDWF  00,F
02460:  MOVF   x5B,W
02462:  MULWF  x5C
02464:  MOVF   FF3,W
02466:  ADDWFC 00,W
02468:  MOVWF  02
0246A:  MOVLB  0
0246C:  RETURN 0
*
02862:  MOVWF  00
02864:  SWAPF  00,W
02866:  ADDWF  00,W
02868:  ANDLW  0F
0286A:  BTFSC  FD8.1
0286C:  ADDLW  16
0286E:  DAW   
02870:  BTFSC  00.4
02872:  ADDLW  15
02874:  BTFSC  00.5
02876:  ADDLW  30
02878:  BTFSC  00.6
0287A:  ADDLW  60
0287C:  BTFSC  00.7
0287E:  ADDLW  20
02880:  DAW   
02882:  RETURN 0
02884:  RETURN 0
*
02968:  TSTFSZ 01
0296A:  BRA    2972
0296C:  TSTFSZ 02
0296E:  BRA    2974
02970:  BRA    2980
02972:  INCF   02,F
02974:  MOVFF  00,FEE
02978:  DECFSZ 01,F
0297A:  BRA    2974
0297C:  DECFSZ 02,F
0297E:  BRA    2974
02980:  RETURN 0
*
029AC:  MOVLB  B
029AE:  MOVF   x1D,W
029B0:  ANDLW  07
029B2:  MOVWF  00
029B4:  RRCF   x1D,W
029B6:  MOVWF  01
029B8:  RRCF   01,F
029BA:  RRCF   01,F
029BC:  MOVLW  1F
029BE:  ANDWF  01,F
029C0:  MOVF   01,W
029C2:  ADDWF  x1F,W
029C4:  MOVWF  FE9
029C6:  MOVLW  00
029C8:  ADDWFC x20,W
029CA:  MOVWF  FEA
029CC:  CLRF   01
029CE:  INCF   01,F
029D0:  INCF   00,F
029D2:  BRA    29D6
029D4:  RLCF   01,F
029D6:  DECFSZ 00,F
029D8:  BRA    29D4
029DA:  MOVF   x1E,F
029DC:  BZ    29E4
029DE:  MOVF   01,W
029E0:  IORWF  FEF,F
029E2:  BRA    29EA
029E4:  COMF   01,F
029E6:  MOVF   01,W
029E8:  ANDWF  FEF,F
029EA:  MOVLB  0
029EC:  RETURN 0
*
02ED0:  BTFSC  FD8.1
02ED2:  BRA    2EDC
02ED4:  MOVLW  0A
02ED6:  MOVWF  FEA
02ED8:  MOVLW  6D
02EDA:  MOVWF  FE9
02EDC:  CLRF   00
02EDE:  CLRF   01
02EE0:  CLRF   02
02EE2:  CLRF   03
02EE4:  MOVLB  A
02EE6:  CLRF   x6D
02EE8:  CLRF   x6E
02EEA:  CLRF   x6F
02EEC:  CLRF   x70
02EEE:  MOVF   x6C,W
02EF0:  IORWF  x6B,W
02EF2:  IORWF  x6A,W
02EF4:  IORWF  x69,W
02EF6:  BZ    2F50
02EF8:  MOVLW  20
02EFA:  MOVWF  x71
02EFC:  BCF    FD8.0
02EFE:  RLCF   x65,F
02F00:  RLCF   x66,F
02F02:  RLCF   x67,F
02F04:  RLCF   x68,F
02F06:  RLCF   x6D,F
02F08:  RLCF   x6E,F
02F0A:  RLCF   x6F,F
02F0C:  RLCF   x70,F
02F0E:  MOVF   x6C,W
02F10:  SUBWF  x70,W
02F12:  BNZ   2F24
02F14:  MOVF   x6B,W
02F16:  SUBWF  x6F,W
02F18:  BNZ   2F24
02F1A:  MOVF   x6A,W
02F1C:  SUBWF  x6E,W
02F1E:  BNZ   2F24
02F20:  MOVF   x69,W
02F22:  SUBWF  x6D,W
02F24:  BNC   2F44
02F26:  MOVF   x69,W
02F28:  SUBWF  x6D,F
02F2A:  MOVF   x6A,W
02F2C:  BTFSS  FD8.0
02F2E:  INCFSZ x6A,W
02F30:  SUBWF  x6E,F
02F32:  MOVF   x6B,W
02F34:  BTFSS  FD8.0
02F36:  INCFSZ x6B,W
02F38:  SUBWF  x6F,F
02F3A:  MOVF   x6C,W
02F3C:  BTFSS  FD8.0
02F3E:  INCFSZ x6C,W
02F40:  SUBWF  x70,F
02F42:  BSF    FD8.0
02F44:  RLCF   00,F
02F46:  RLCF   01,F
02F48:  RLCF   02,F
02F4A:  RLCF   03,F
02F4C:  DECFSZ x71,F
02F4E:  BRA    2EFC
02F50:  MOVFF  A6D,FEF
02F54:  MOVFF  A6E,FEC
02F58:  MOVFF  A6F,FEC
02F5C:  MOVFF  A70,FEC
02F60:  MOVLB  0
02F62:  RETURN 0
*
03048:  TBLRD*+
0304A:  MOVFF  FF6,A3C
0304E:  MOVFF  FF7,A3D
03052:  MOVFF  FF8,A3E
03056:  MOVFF  FF5,B1F
0305A:  CALL   1C34
0305E:  MOVFF  A3C,FF6
03062:  MOVFF  A3D,FF7
03066:  MOVFF  A3E,FF8
0306A:  MOVLB  A
0306C:  DECFSZ x3B,F
0306E:  BRA    3072
03070:  BRA    3076
03072:  MOVLB  0
03074:  BRA    3048
03076:  MOVLB  0
03078:  RETURN 0
0307A:  MOVFF  FEA,A43
0307E:  MOVFF  FE9,A42
03082:  MOVLB  A
03084:  SWAPF  x3C,W
03086:  IORLW  F0
03088:  MOVWF  x3E
0308A:  ADDWF  x3E,F
0308C:  ADDLW  E2
0308E:  MOVWF  x3F
03090:  ADDLW  32
03092:  MOVWF  x41
03094:  MOVF   x3C,W
03096:  ANDLW  0F
03098:  ADDWF  x3F,F
0309A:  ADDWF  x3F,F
0309C:  ADDWF  x41,F
0309E:  ADDLW  E9
030A0:  MOVWF  x40
030A2:  ADDWF  x40,F
030A4:  ADDWF  x40,F
030A6:  SWAPF  x3B,W
030A8:  ANDLW  0F
030AA:  ADDWF  x40,F
030AC:  ADDWF  x41,F
030AE:  RLCF   x40,F
030B0:  RLCF   x41,F
030B2:  COMF   x41,F
030B4:  RLCF   x41,F
030B6:  MOVF   x3B,W
030B8:  ANDLW  0F
030BA:  ADDWF  x41,F
030BC:  RLCF   x3E,F
030BE:  MOVLW  07
030C0:  MOVWF  x3D
030C2:  MOVLW  0A
030C4:  DECF   x40,F
030C6:  ADDWF  x41,F
030C8:  BNC   30C4
030CA:  DECF   x3F,F
030CC:  ADDWF  x40,F
030CE:  BNC   30CA
030D0:  DECF   x3E,F
030D2:  ADDWF  x3F,F
030D4:  BNC   30D0
030D6:  DECF   x3D,F
030D8:  ADDWF  x3E,F
030DA:  BNC   30D6
030DC:  MOVLW  0A
030DE:  MOVWF  FEA
030E0:  MOVLW  3D
030E2:  MOVWF  FE9
030E4:  MOVLW  07
030E6:  ANDWF  x42,W
030E8:  BCF    x42.6
030EA:  ADDWF  FE9,F
030EC:  MOVLW  00
030EE:  ADDWFC FEA,F
030F0:  MOVF   FE9,W
030F2:  SUBLW  41
030F4:  BNZ   30FE
030F6:  MOVF   FEA,W
030F8:  SUBLW  0A
030FA:  BNZ   30FE
030FC:  BSF    x42.6
030FE:  MOVF   FEF,W
03100:  MOVWF  00
03102:  BNZ   3114
03104:  BTFSC  x42.6
03106:  BRA    3114
03108:  BTFSC  x42.4
0310A:  BRA    3138
0310C:  BTFSC  x42.3
0310E:  BRA    3114
03110:  MOVLW  20
03112:  BRA    311A
03114:  BSF    x42.3
03116:  BCF    x42.4
03118:  MOVLW  30
0311A:  ADDWF  00,F
0311C:  MOVFF  FEA,A3C
03120:  MOVFF  FE9,A3B
03124:  MOVFF  00,B1F
03128:  MOVLB  0
0312A:  CALL   1C34
0312E:  MOVFF  A3C,FEA
03132:  MOVFF  A3B,FE9
03136:  MOVLB  A
03138:  MOVF   FEE,W
0313A:  BTFSS  x42.6
0313C:  BRA    30F0
0313E:  MOVLB  0
03140:  RETURN 0
03142:  MOVLB  A
03144:  BTFSC  x59.7
03146:  BRA    316C
03148:  MOVLW  0F
0314A:  MOVWF  00
0314C:  SWAPF  x58,W
0314E:  ANDWF  00,F
03150:  MOVLW  0A
03152:  SUBWF  00,W
03154:  BC    315C
03156:  MOVLW  30
03158:  ADDWF  00,F
0315A:  BRA    3160
0315C:  MOVF   x59,W
0315E:  ADDWF  00,F
03160:  MOVFF  00,B1F
03164:  MOVLB  0
03166:  CALL   1C34
0316A:  MOVLB  A
0316C:  MOVLW  0F
0316E:  ANDWF  x58,F
03170:  MOVLW  0A
03172:  SUBWF  x58,W
03174:  BC    317A
03176:  MOVLW  30
03178:  BRA    317E
0317A:  BCF    x59.7
0317C:  MOVF   x59,W
0317E:  ADDWF  x58,F
03180:  MOVFF  A58,B1F
03184:  MOVLB  0
03186:  CALL   1C34
0318A:  RETURN 0
0318C:  MOVF   01,W
0318E:  MOVFF  A39,A3B
03192:  MOVLW  64
03194:  MOVLB  A
03196:  MOVWF  x3C
03198:  MOVLB  0
0319A:  CALL   1DDE
0319E:  MOVFF  00,A39
031A2:  MOVF   01,W
031A4:  MOVLW  30
031A6:  BNZ   31B8
031A8:  MOVLB  A
031AA:  BTFSS  x3A.1
031AC:  BRA    31CE
031AE:  BTFSC  x3A.3
031B0:  BRA    31CE
031B2:  BTFSC  x3A.4
031B4:  MOVLW  20
031B6:  BRA    31C0
031B8:  MOVLB  A
031BA:  BCF    x3A.3
031BC:  BCF    x3A.4
031BE:  BSF    x3A.0
031C0:  ADDWF  01,F
031C2:  MOVFF  01,B1F
031C6:  MOVLB  0
031C8:  CALL   1C34
031CC:  MOVLB  A
031CE:  MOVFF  A39,A3B
031D2:  MOVLW  0A
031D4:  MOVWF  x3C
031D6:  MOVLB  0
031D8:  CALL   1DDE
031DC:  MOVFF  00,A39
031E0:  MOVF   01,W
031E2:  MOVLW  30
031E4:  BNZ   31F6
031E6:  MOVLB  A
031E8:  BTFSC  x3A.3
031EA:  BRA    3202
031EC:  BTFSS  x3A.0
031EE:  BRA    3202
031F0:  BTFSC  x3A.4
031F2:  MOVLW  20
031F4:  MOVLB  0
031F6:  ADDWF  01,F
031F8:  MOVFF  01,B1F
031FC:  CALL   1C34
03200:  MOVLB  A
03202:  MOVLW  30
03204:  ADDWF  x39,F
03206:  MOVFF  A39,B1F
0320A:  MOVLB  0
0320C:  CALL   1C34
03210:  GOTO   3672 (RETURN)
*
04960:  MOVLW  20
04962:  MOVLB  A
04964:  BTFSS  x26.4
04966:  MOVLW  30
04968:  MOVWF  x27
0496A:  MOVFF  A25,00
0496E:  BTFSS  x25.7
04970:  BRA    4982
04972:  COMF   00,F
04974:  INCF   00,F
04976:  MOVFF  00,A25
0497A:  MOVLW  2D
0497C:  MOVWF  x27
0497E:  BSF    x26.7
04980:  BSF    x26.0
04982:  MOVF   01,W
04984:  MOVFF  A25,A3B
04988:  MOVLW  64
0498A:  MOVWF  x3C
0498C:  MOVLB  0
0498E:  CALL   1DDE
04992:  MOVFF  00,A25
04996:  MOVLW  30
04998:  ADDWF  01,W
0499A:  MOVLB  A
0499C:  MOVWF  x28
0499E:  MOVFF  A25,A3B
049A2:  MOVLW  0A
049A4:  MOVWF  x3C
049A6:  MOVLB  0
049A8:  CALL   1DDE
049AC:  MOVLW  30
049AE:  ADDWF  00,W
049B0:  MOVLB  A
049B2:  MOVWF  x2A
049B4:  MOVLW  30
049B6:  ADDWF  01,W
049B8:  MOVWF  x29
049BA:  MOVFF  A27,00
049BE:  MOVLW  30
049C0:  SUBWF  x28,W
049C2:  BZ    49CC
049C4:  BSF    x26.1
049C6:  BTFSC  x26.7
049C8:  BSF    x26.2
049CA:  BRA    49F0
049CC:  MOVFF  A27,A28
049D0:  MOVLW  20
049D2:  MOVWF  x27
049D4:  MOVLW  30
049D6:  SUBWF  x29,W
049D8:  BZ    49E2
049DA:  BSF    x26.0
049DC:  BTFSC  x26.7
049DE:  BSF    x26.1
049E0:  BRA    49F0
049E2:  BTFSS  FD8.2
049E4:  BSF    x26.0
049E6:  BNZ   49F0
049E8:  MOVFF  A28,A29
049EC:  MOVLW  20
049EE:  MOVWF  x28
049F0:  BTFSC  x26.2
049F2:  BRA    49FE
049F4:  BTFSC  x26.1
049F6:  BRA    4A08
049F8:  BTFSC  x26.0
049FA:  BRA    4A12
049FC:  BRA    4A1C
049FE:  MOVFF  A27,B1F
04A02:  MOVLB  0
04A04:  CALL   1C34
04A08:  MOVFF  A28,B1F
04A0C:  MOVLB  0
04A0E:  CALL   1C34
04A12:  MOVFF  A29,B1F
04A16:  MOVLB  0
04A18:  CALL   1C34
04A1C:  MOVFF  A2A,B1F
04A20:  MOVLB  0
04A22:  CALL   1C34
04A26:  RETURN 0
*
04D28:  MOVFF  FEA,A2B
04D2C:  MOVFF  FE9,A2A
04D30:  MOVLB  A
04D32:  BTFSS  x24.7
04D34:  BRA    4D46
04D36:  BSF    x2A.7
04D38:  BTFSS  x2A.4
04D3A:  INCF   x2A,F
04D3C:  COMF   x23,F
04D3E:  COMF   x24,F
04D40:  INCF   x23,F
04D42:  BTFSC  FD8.2
04D44:  INCF   x24,F
04D46:  SWAPF  x24,W
04D48:  IORLW  F0
04D4A:  MOVWF  x26
04D4C:  ADDWF  x26,F
04D4E:  ADDLW  E2
04D50:  MOVWF  x27
04D52:  ADDLW  32
04D54:  MOVWF  x29
04D56:  MOVF   x24,W
04D58:  ANDLW  0F
04D5A:  ADDWF  x27,F
04D5C:  ADDWF  x27,F
04D5E:  ADDWF  x29,F
04D60:  ADDLW  E9
04D62:  MOVWF  x28
04D64:  ADDWF  x28,F
04D66:  ADDWF  x28,F
04D68:  SWAPF  x23,W
04D6A:  ANDLW  0F
04D6C:  ADDWF  x28,F
04D6E:  ADDWF  x29,F
04D70:  RLCF   x28,F
04D72:  RLCF   x29,F
04D74:  COMF   x29,F
04D76:  RLCF   x29,F
04D78:  MOVF   x23,W
04D7A:  ANDLW  0F
04D7C:  ADDWF  x29,F
04D7E:  RLCF   x26,F
04D80:  MOVLW  07
04D82:  MOVWF  x25
04D84:  MOVLW  0A
04D86:  DECF   x28,F
04D88:  ADDWF  x29,F
04D8A:  BNC   4D86
04D8C:  DECF   x27,F
04D8E:  ADDWF  x28,F
04D90:  BNC   4D8C
04D92:  DECF   x26,F
04D94:  ADDWF  x27,F
04D96:  BNC   4D92
04D98:  DECF   x25,F
04D9A:  ADDWF  x26,F
04D9C:  BNC   4D98
04D9E:  MOVLW  0A
04DA0:  MOVWF  FEA
04DA2:  MOVLW  25
04DA4:  MOVWF  FE9
04DA6:  MOVLW  07
04DA8:  ANDWF  x2A,W
04DAA:  BCF    x2A.6
04DAC:  MOVF   FED,F
04DAE:  ANDWF  x2A,W
04DB0:  BNZ   4DC0
04DB2:  BTFSC  x2A.4
04DB4:  MOVF   FEE,F
04DB6:  BTFSC  x2A.4
04DB8:  BRA    4DC0
04DBA:  MOVLW  20
04DBC:  MOVWF  00
04DBE:  BRA    4E02
04DC0:  ADDWF  FE9,F
04DC2:  MOVLW  00
04DC4:  ADDWFC FEA,F
04DC6:  MOVF   FE9,W
04DC8:  SUBLW  29
04DCA:  BNZ   4DD4
04DCC:  MOVF   FEA,W
04DCE:  SUBLW  0A
04DD0:  BNZ   4DD4
04DD2:  BSF    x2A.6
04DD4:  MOVF   FEF,W
04DD6:  MOVWF  00
04DD8:  BNZ   4DEA
04DDA:  BTFSC  x2A.6
04DDC:  BRA    4DEA
04DDE:  BTFSC  x2A.4
04DE0:  BRA    4E1E
04DE2:  BTFSC  x2A.3
04DE4:  BRA    4DEA
04DE6:  MOVLW  20
04DE8:  BRA    4E00
04DEA:  BTFSS  x2A.7
04DEC:  BRA    4DFA
04DEE:  MOVLW  2D
04DF0:  MOVWF  00
04DF2:  MOVF   FED,W
04DF4:  BCF    x2A.6
04DF6:  BCF    x2A.7
04DF8:  BRA    4E02
04DFA:  BSF    x2A.3
04DFC:  BCF    x2A.4
04DFE:  MOVLW  30
04E00:  ADDWF  00,F
04E02:  MOVFF  FEA,A24
04E06:  MOVFF  FE9,A23
04E0A:  MOVFF  00,B1F
04E0E:  MOVLB  0
04E10:  CALL   1C34
04E14:  MOVFF  A24,FEA
04E18:  MOVFF  A23,FE9
04E1C:  MOVLB  A
04E1E:  MOVF   FEE,W
04E20:  BTFSS  x2A.6
04E22:  BRA    4DC6
04E24:  MOVLB  0
04E26:  RETURN 0
04E28:  MOVLW  20
04E2A:  MOVLB  A
04E2C:  BTFSS  x24.4
04E2E:  MOVLW  30
04E30:  MOVWF  x25
04E32:  MOVFF  A23,00
04E36:  BTFSS  x23.7
04E38:  BRA    4E4A
04E3A:  COMF   00,F
04E3C:  INCF   00,F
04E3E:  MOVFF  00,A23
04E42:  MOVLW  2D
04E44:  MOVWF  x25
04E46:  BSF    x24.7
04E48:  BSF    x24.0
04E4A:  MOVF   01,W
04E4C:  MOVFF  A23,A3B
04E50:  MOVLW  64
04E52:  MOVWF  x3C
04E54:  MOVLB  0
04E56:  CALL   1DDE
04E5A:  MOVFF  00,A23
04E5E:  MOVLW  30
04E60:  ADDWF  01,W
04E62:  MOVLB  A
04E64:  MOVWF  x26
04E66:  MOVFF  A23,A3B
04E6A:  MOVLW  0A
04E6C:  MOVWF  x3C
04E6E:  MOVLB  0
04E70:  CALL   1DDE
04E74:  MOVLW  30
04E76:  ADDWF  00,W
04E78:  MOVLB  A
04E7A:  MOVWF  x28
04E7C:  MOVLW  30
04E7E:  ADDWF  01,W
04E80:  MOVWF  x27
04E82:  MOVFF  A25,00
04E86:  MOVLW  30
04E88:  SUBWF  x26,W
04E8A:  BZ    4E94
04E8C:  BSF    x24.1
04E8E:  BTFSC  x24.7
04E90:  BSF    x24.2
04E92:  BRA    4EB8
04E94:  BTFSC  x24.2
04E96:  BRA    4EB8
04E98:  MOVFF  A25,A26
04E9C:  BTFSC  x24.1
04E9E:  BRA    4EA8
04EA0:  MOVLW  30
04EA2:  SUBWF  x27,W
04EA4:  BZ    4EAE
04EA6:  BSF    x24.0
04EA8:  BTFSC  x24.7
04EAA:  BSF    x24.1
04EAC:  BRA    4EB8
04EAE:  BTFSS  FD8.2
04EB0:  BSF    x24.0
04EB2:  BTFSC  FD8.2
04EB4:  MOVFF  A26,A27
04EB8:  BTFSC  x24.2
04EBA:  BRA    4EC6
04EBC:  BTFSC  x24.1
04EBE:  BRA    4ED0
04EC0:  BTFSC  x24.0
04EC2:  BRA    4EDA
04EC4:  BRA    4EE4
04EC6:  MOVFF  A25,B1F
04ECA:  MOVLB  0
04ECC:  CALL   1C34
04ED0:  MOVFF  A26,B1F
04ED4:  MOVLB  0
04ED6:  CALL   1C34
04EDA:  MOVFF  A27,B1F
04EDE:  MOVLB  0
04EE0:  CALL   1C34
04EE4:  MOVFF  A28,B1F
04EE8:  MOVLB  0
04EEA:  CALL   1C34
04EEE:  RETURN 0
*
0802E:  MOVF   FE9,W
08030:  MOVLB  A
08032:  MOVWF  x29
08034:  MOVLW  3B
08036:  MOVWF  x30
08038:  MOVLW  9A
0803A:  MOVWF  x2F
0803C:  MOVLW  CA
0803E:  MOVWF  x2E
08040:  CLRF   x2D
08042:  MOVLW  0A
08044:  MOVWF  x2B
08046:  BSF    FD8.1
08048:  MOVLW  0A
0804A:  MOVWF  FEA
0804C:  MOVLW  25
0804E:  MOVWF  FE9
08050:  MOVFF  A28,A68
08054:  MOVFF  A27,A67
08058:  MOVFF  A26,A66
0805C:  MOVFF  A25,A65
08060:  MOVFF  A30,A6C
08064:  MOVFF  A2F,A6B
08068:  MOVFF  A2E,A6A
0806C:  MOVFF  A2D,A69
08070:  MOVLB  0
08072:  CALL   2ED0
08076:  MOVF   01,W
08078:  MOVF   00,F
0807A:  BNZ   80A2
0807C:  MOVLB  A
0807E:  MOVF   x2B,W
08080:  XORLW  01
08082:  BTFSS  FD8.2
08084:  BRA    808A
08086:  MOVLB  0
08088:  BRA    80A2
0808A:  MOVF   x29,W
0808C:  BZ    80A6
0808E:  ANDLW  0F
08090:  SUBWF  x2B,W
08092:  BZ    8096
08094:  BC    80B6
08096:  BTFSC  x29.7
08098:  BRA    80B6
0809A:  BTFSC  x29.6
0809C:  BRA    80A6
0809E:  MOVLW  20
080A0:  BRA    80A8
080A2:  MOVLB  A
080A4:  CLRF   x29
080A6:  MOVLW  30
080A8:  ADDWF  00,F
080AA:  MOVFF  00,B1F
080AE:  MOVLB  0
080B0:  CALL   1C34
080B4:  MOVLB  A
080B6:  BCF    FD8.1
080B8:  MOVFF  A30,A68
080BC:  MOVFF  A2F,A67
080C0:  MOVFF  A2E,A66
080C4:  MOVFF  A2D,A65
080C8:  CLRF   x6C
080CA:  CLRF   x6B
080CC:  CLRF   x6A
080CE:  MOVLW  0A
080D0:  MOVWF  x69
080D2:  MOVLB  0
080D4:  CALL   2ED0
080D8:  MOVFF  03,A30
080DC:  MOVFF  02,A2F
080E0:  MOVFF  01,A2E
080E4:  MOVFF  00,A2D
080E8:  MOVLB  A
080EA:  DECFSZ x2B,F
080EC:  BRA    8046
080EE:  MOVLB  0
080F0:  RETURN 0
*
083B2:  MOVLW  B6
083B4:  MOVWF  00
083B6:  CLRF   03
083B8:  CLRF   02
083BA:  CLRF   01
083BC:  MOVLB  A
083BE:  MOVF   x21,W
083C0:  IORWF  x22,W
083C2:  IORWF  x23,W
083C4:  IORWF  x24,W
083C6:  BNZ   83CC
083C8:  CLRF   00
083CA:  BRA    83E6
083CC:  BCF    FD8.0
083CE:  BTFSC  01.7
083D0:  BRA    83E4
083D2:  RLCF   x21,F
083D4:  RLCF   x22,F
083D6:  RLCF   x23,F
083D8:  RLCF   x24,F
083DA:  RLCF   03,F
083DC:  RLCF   02,F
083DE:  RLCF   01,F
083E0:  DECFSZ 00,F
083E2:  BRA    83CC
083E4:  BCF    01.7
083E6:  MOVLB  0
083E8:  GOTO   87CC (RETURN)
083EC:  MOVLB  A
083EE:  MOVF   x31,W
083F0:  BTFSC  FD8.2
083F2:  BRA    84D6
083F4:  MOVWF  00
083F6:  MOVF   x35,W
083F8:  BTFSC  FD8.2
083FA:  BRA    84D6
083FC:  ADDWF  00,F
083FE:  BNC   8408
08400:  MOVLW  81
08402:  ADDWF  00,F
08404:  BC    84D6
08406:  BRA    8410
08408:  MOVLW  7F
0840A:  SUBWF  00,F
0840C:  BNC   84D6
0840E:  BZ    84D6
08410:  MOVFF  A32,A39
08414:  MOVF   x36,W
08416:  XORWF  x39,F
08418:  BSF    x32.7
0841A:  BSF    x36.7
0841C:  MOVF   x34,W
0841E:  MULWF  x38
08420:  MOVFF  FF4,A3B
08424:  MOVF   x33,W
08426:  MULWF  x37
08428:  MOVFF  FF4,03
0842C:  MOVFF  FF3,A3A
08430:  MULWF  x38
08432:  MOVF   FF3,W
08434:  ADDWF  x3B,F
08436:  MOVF   FF4,W
08438:  ADDWFC x3A,F
0843A:  MOVLW  00
0843C:  ADDWFC 03,F
0843E:  MOVF   x34,W
08440:  MULWF  x37
08442:  MOVF   FF3,W
08444:  ADDWF  x3B,F
08446:  MOVF   FF4,W
08448:  ADDWFC x3A,F
0844A:  MOVLW  00
0844C:  CLRF   02
0844E:  ADDWFC 03,F
08450:  ADDWFC 02,F
08452:  MOVF   x32,W
08454:  MULWF  x38
08456:  MOVF   FF3,W
08458:  ADDWF  x3A,F
0845A:  MOVF   FF4,W
0845C:  ADDWFC 03,F
0845E:  MOVLW  00
08460:  ADDWFC 02,F
08462:  MOVF   x32,W
08464:  MULWF  x37
08466:  MOVF   FF3,W
08468:  ADDWF  03,F
0846A:  MOVF   FF4,W
0846C:  ADDWFC 02,F
0846E:  MOVLW  00
08470:  CLRF   01
08472:  ADDWFC 01,F
08474:  MOVF   x34,W
08476:  MULWF  x36
08478:  MOVF   FF3,W
0847A:  ADDWF  x3A,F
0847C:  MOVF   FF4,W
0847E:  ADDWFC 03,F
08480:  MOVLW  00
08482:  ADDWFC 02,F
08484:  ADDWFC 01,F
08486:  MOVF   x33,W
08488:  MULWF  x36
0848A:  MOVF   FF3,W
0848C:  ADDWF  03,F
0848E:  MOVF   FF4,W
08490:  ADDWFC 02,F
08492:  MOVLW  00
08494:  ADDWFC 01,F
08496:  MOVF   x32,W
08498:  MULWF  x36
0849A:  MOVF   FF3,W
0849C:  ADDWF  02,F
0849E:  MOVF   FF4,W
084A0:  ADDWFC 01,F
084A2:  INCF   00,F
084A4:  BTFSC  01.7
084A6:  BRA    84B2
084A8:  RLCF   x3A,F
084AA:  RLCF   03,F
084AC:  RLCF   02,F
084AE:  RLCF   01,F
084B0:  DECF   00,F
084B2:  MOVLW  00
084B4:  BTFSS  x3A.7
084B6:  BRA    84CC
084B8:  INCF   03,F
084BA:  ADDWFC 02,F
084BC:  ADDWFC 01,F
084BE:  MOVF   01,W
084C0:  BNZ   84CC
084C2:  MOVF   02,W
084C4:  BNZ   84CC
084C6:  MOVF   03,W
084C8:  BNZ   84CC
084CA:  INCF   00,F
084CC:  BTFSC  x39.7
084CE:  BSF    01.7
084D0:  BTFSS  x39.7
084D2:  BCF    01.7
084D4:  BRA    84DE
084D6:  CLRF   00
084D8:  CLRF   01
084DA:  CLRF   02
084DC:  CLRF   03
084DE:  MOVLB  0
084E0:  RETURN 0
084E2:  MOVLW  80
084E4:  BTFSS  FD8.1
084E6:  BRA    84EC
084E8:  MOVLB  A
084EA:  XORWF  x35,F
084EC:  MOVLB  A
084EE:  CLRF   x3A
084F0:  CLRF   x3B
084F2:  MOVFF  A31,A39
084F6:  MOVF   x35,W
084F8:  XORWF  x39,F
084FA:  MOVF   x30,W
084FC:  BTFSC  FD8.2
084FE:  BRA    86BE
08500:  MOVWF  x38
08502:  MOVWF  00
08504:  MOVF   x34,W
08506:  BTFSC  FD8.2
08508:  BRA    86D0
0850A:  SUBWF  x38,F
0850C:  BTFSC  FD8.2
0850E:  BRA    8616
08510:  BNC   858E
08512:  MOVFF  A35,A3E
08516:  BSF    x3E.7
08518:  MOVFF  A36,A3D
0851C:  MOVFF  A37,A3C
08520:  CLRF   x3B
08522:  BCF    FD8.0
08524:  RRCF   x3E,F
08526:  RRCF   x3D,F
08528:  RRCF   x3C,F
0852A:  RRCF   x3B,F
0852C:  DECFSZ x38,F
0852E:  BRA    8520
08530:  BTFSS  x39.7
08532:  BRA    853A
08534:  BSF    x3A.0
08536:  BRA    86F8
08538:  BCF    x3A.0
0853A:  BCF    x38.0
0853C:  BSF    x3A.4
0853E:  MOVLW  0A
08540:  MOVWF  FEA
08542:  MOVLW  33
08544:  MOVWF  FE9
08546:  BRA    871E
08548:  BCF    x3A.4
0854A:  BTFSC  x39.7
0854C:  BRA    8562
0854E:  BTFSS  x38.0
08550:  BRA    8578
08552:  RRCF   x3E,F
08554:  RRCF   x3D,F
08556:  RRCF   x3C,F
08558:  RRCF   x3B,F
0855A:  INCF   00,F
0855C:  BTFSC  FD8.2
0855E:  BRA    86EE
08560:  BRA    8578
08562:  BTFSC  x3E.7
08564:  BRA    857E
08566:  BCF    FD8.0
08568:  RLCF   x3B,F
0856A:  RLCF   x3C,F
0856C:  RLCF   x3D,F
0856E:  RLCF   x3E,F
08570:  DECF   00,F
08572:  BTFSC  FD8.2
08574:  BRA    86EE
08576:  BRA    8562
08578:  BSF    x3A.6
0857A:  BRA    8656
0857C:  BCF    x3A.6
0857E:  MOVFF  A31,A39
08582:  BTFSS  x31.7
08584:  BRA    858A
08586:  BSF    x3E.7
08588:  BRA    86E0
0858A:  BCF    x3E.7
0858C:  BRA    86E0
0858E:  MOVFF  A34,A38
08592:  MOVFF  A34,00
08596:  MOVF   x30,W
08598:  SUBWF  x38,F
0859A:  MOVFF  A31,A3E
0859E:  BSF    x3E.7
085A0:  MOVFF  A32,A3D
085A4:  MOVFF  A33,A3C
085A8:  CLRF   x3B
085AA:  BCF    FD8.0
085AC:  RRCF   x3E,F
085AE:  RRCF   x3D,F
085B0:  RRCF   x3C,F
085B2:  RRCF   x3B,F
085B4:  DECFSZ x38,F
085B6:  BRA    85A8
085B8:  BTFSS  x39.7
085BA:  BRA    85C2
085BC:  BSF    x3A.1
085BE:  BRA    86F8
085C0:  BCF    x3A.1
085C2:  BCF    x38.0
085C4:  BSF    x3A.5
085C6:  MOVLW  0A
085C8:  MOVWF  FEA
085CA:  MOVLW  37
085CC:  MOVWF  FE9
085CE:  BRA    871E
085D0:  BCF    x3A.5
085D2:  BTFSC  x39.7
085D4:  BRA    85EA
085D6:  BTFSS  x38.0
085D8:  BRA    8600
085DA:  RRCF   x3E,F
085DC:  RRCF   x3D,F
085DE:  RRCF   x3C,F
085E0:  RRCF   x3B,F
085E2:  INCF   00,F
085E4:  BTFSC  FD8.2
085E6:  BRA    86EE
085E8:  BRA    8600
085EA:  BTFSC  x3E.7
085EC:  BRA    8606
085EE:  BCF    FD8.0
085F0:  RLCF   x3B,F
085F2:  RLCF   x3C,F
085F4:  RLCF   x3D,F
085F6:  RLCF   x3E,F
085F8:  DECF   00,F
085FA:  BTFSC  FD8.2
085FC:  BRA    86EE
085FE:  BRA    85EA
08600:  BSF    x3A.7
08602:  BRA    8656
08604:  BCF    x3A.7
08606:  MOVFF  A35,A39
0860A:  BTFSS  x35.7
0860C:  BRA    8612
0860E:  BSF    x3E.7
08610:  BRA    86E0
08612:  BCF    x3E.7
08614:  BRA    86E0
08616:  MOVFF  A35,A3E
0861A:  BSF    x3E.7
0861C:  MOVFF  A36,A3D
08620:  MOVFF  A37,A3C
08624:  BTFSS  x39.7
08626:  BRA    8630
08628:  BCF    x3E.7
0862A:  BSF    x3A.2
0862C:  BRA    86F8
0862E:  BCF    x3A.2
08630:  CLRF   x3B
08632:  BCF    x38.0
08634:  MOVLW  0A
08636:  MOVWF  FEA
08638:  MOVLW  33
0863A:  MOVWF  FE9
0863C:  BRA    871E
0863E:  BTFSC  x39.7
08640:  BRA    867A
08642:  MOVFF  A31,A39
08646:  BTFSS  x38.0
08648:  BRA    8656
0864A:  RRCF   x3E,F
0864C:  RRCF   x3D,F
0864E:  RRCF   x3C,F
08650:  RRCF   x3B,F
08652:  INCF   00,F
08654:  BZ    86EE
08656:  BTFSS  x3B.7
08658:  BRA    8670
0865A:  INCF   x3C,F
0865C:  BNZ   8670
0865E:  INCF   x3D,F
08660:  BNZ   8670
08662:  INCF   x3E,F
08664:  BNZ   8670
08666:  RRCF   x3E,F
08668:  RRCF   x3D,F
0866A:  RRCF   x3C,F
0866C:  INCF   00,F
0866E:  BZ    86EE
08670:  BTFSC  x3A.6
08672:  BRA    857C
08674:  BTFSC  x3A.7
08676:  BRA    8604
08678:  BRA    86B2
0867A:  MOVLW  80
0867C:  XORWF  x3E,F
0867E:  BTFSS  x3E.7
08680:  BRA    868A
08682:  BRA    86F8
08684:  MOVFF  A35,A39
08688:  BRA    869E
0868A:  MOVFF  A31,A39
0868E:  MOVF   x3E,F
08690:  BNZ   869E
08692:  MOVF   x3D,F
08694:  BNZ   869E
08696:  MOVF   x3C,F
08698:  BNZ   869E
0869A:  CLRF   00
0869C:  BRA    86E0
0869E:  BTFSC  x3E.7
086A0:  BRA    86B2
086A2:  BCF    FD8.0
086A4:  RLCF   x3B,F
086A6:  RLCF   x3C,F
086A8:  RLCF   x3D,F
086AA:  RLCF   x3E,F
086AC:  DECFSZ 00,F
086AE:  BRA    869E
086B0:  BRA    86EE
086B2:  BTFSS  x39.7
086B4:  BRA    86BA
086B6:  BSF    x3E.7
086B8:  BRA    86E0
086BA:  BCF    x3E.7
086BC:  BRA    86E0
086BE:  MOVFF  A34,00
086C2:  MOVFF  A35,A3E
086C6:  MOVFF  A36,A3D
086CA:  MOVFF  A37,A3C
086CE:  BRA    86E0
086D0:  MOVFF  A30,00
086D4:  MOVFF  A31,A3E
086D8:  MOVFF  A32,A3D
086DC:  MOVFF  A33,A3C
086E0:  MOVFF  A3E,01
086E4:  MOVFF  A3D,02
086E8:  MOVFF  A3C,03
086EC:  BRA    8756
086EE:  CLRF   00
086F0:  CLRF   01
086F2:  CLRF   02
086F4:  CLRF   03
086F6:  BRA    8756
086F8:  CLRF   x3B
086FA:  COMF   x3C,F
086FC:  COMF   x3D,F
086FE:  COMF   x3E,F
08700:  COMF   x3B,F
08702:  INCF   x3B,F
08704:  BNZ   8710
08706:  INCF   x3C,F
08708:  BNZ   8710
0870A:  INCF   x3D,F
0870C:  BNZ   8710
0870E:  INCF   x3E,F
08710:  BTFSC  x3A.0
08712:  BRA    8538
08714:  BTFSC  x3A.1
08716:  BRA    85C0
08718:  BTFSC  x3A.2
0871A:  BRA    862E
0871C:  BRA    8684
0871E:  MOVF   FEF,W
08720:  ADDWF  x3C,F
08722:  BNC   872E
08724:  INCF   x3D,F
08726:  BNZ   872E
08728:  INCF   x3E,F
0872A:  BTFSC  FD8.2
0872C:  BSF    x38.0
0872E:  MOVF   FED,F
08730:  MOVF   FEF,W
08732:  ADDWF  x3D,F
08734:  BNC   873C
08736:  INCF   x3E,F
08738:  BTFSC  FD8.2
0873A:  BSF    x38.0
0873C:  MOVF   FED,F
0873E:  MOVF   FEF,W
08740:  BTFSC  FEF.7
08742:  BRA    8746
08744:  XORLW  80
08746:  ADDWF  x3E,F
08748:  BTFSC  FD8.0
0874A:  BSF    x38.0
0874C:  BTFSC  x3A.4
0874E:  BRA    8548
08750:  BTFSC  x3A.5
08752:  BRA    85D0
08754:  BRA    863E
08756:  MOVLB  0
08758:  RETURN 0
0875A:  MOVLB  A
0875C:  MOVF   x31,W
0875E:  SUBLW  B6
08760:  MOVWF  x31
08762:  CLRF   03
08764:  MOVFF  A32,A35
08768:  BSF    x32.7
0876A:  BCF    FD8.0
0876C:  RRCF   x32,F
0876E:  RRCF   x33,F
08770:  RRCF   x34,F
08772:  RRCF   03,F
08774:  RRCF   02,F
08776:  RRCF   01,F
08778:  RRCF   00,F
0877A:  DECFSZ x31,F
0877C:  BRA    876A
0877E:  BTFSS  x35.7
08780:  BRA    8798
08782:  COMF   00,F
08784:  COMF   01,F
08786:  COMF   02,F
08788:  COMF   03,F
0878A:  INCF   00,F
0878C:  BTFSC  FD8.2
0878E:  INCF   01,F
08790:  BTFSC  FD8.2
08792:  INCF   02,F
08794:  BTFSC  FD8.2
08796:  INCF   03,F
08798:  MOVLB  0
0879A:  RETURN 0
*
08E68:  TBLRD*+
08E6A:  MOVFF  FF6,A5A
08E6E:  MOVFF  FF7,A5B
08E72:  MOVFF  FF8,A5C
08E76:  MOVF   FF5,W
08E78:  BTFSS  F9E.4
08E7A:  BRA    8E78
08E7C:  MOVWF  FAD
08E7E:  MOVFF  A5A,FF6
08E82:  MOVFF  A5B,FF7
08E86:  MOVFF  A5C,FF8
08E8A:  MOVLB  A
08E8C:  DECFSZ x59,F
08E8E:  BRA    8E92
08E90:  BRA    8E96
08E92:  MOVLB  0
08E94:  BRA    8E68
08E96:  MOVLB  0
08E98:  GOTO   932C (RETURN)
08E9C:  MOVF   FE9,W
08E9E:  MOVLB  A
08EA0:  MOVWF  x5D
08EA2:  MOVLW  3B
08EA4:  MOVWF  x64
08EA6:  MOVLW  9A
08EA8:  MOVWF  x63
08EAA:  MOVLW  CA
08EAC:  MOVWF  x62
08EAE:  CLRF   x61
08EB0:  MOVLW  0A
08EB2:  MOVWF  x5F
08EB4:  BSF    FD8.1
08EB6:  MOVLW  0A
08EB8:  MOVWF  FEA
08EBA:  MOVLW  59
08EBC:  MOVWF  FE9
08EBE:  MOVFF  A5C,A68
08EC2:  MOVFF  A5B,A67
08EC6:  MOVFF  A5A,A66
08ECA:  MOVFF  A59,A65
08ECE:  MOVFF  A64,A6C
08ED2:  MOVFF  A63,A6B
08ED6:  MOVFF  A62,A6A
08EDA:  MOVFF  A61,A69
08EDE:  MOVLB  0
08EE0:  CALL   2ED0
08EE4:  MOVF   01,W
08EE6:  MOVF   00,F
08EE8:  BNZ   8F10
08EEA:  MOVLB  A
08EEC:  MOVF   x5F,W
08EEE:  XORLW  01
08EF0:  BTFSS  FD8.2
08EF2:  BRA    8EF8
08EF4:  MOVLB  0
08EF6:  BRA    8F10
08EF8:  MOVF   x5D,W
08EFA:  BZ    8F14
08EFC:  ANDLW  0F
08EFE:  SUBWF  x5F,W
08F00:  BZ    8F04
08F02:  BC    8F20
08F04:  BTFSC  x5D.7
08F06:  BRA    8F20
08F08:  BTFSC  x5D.6
08F0A:  BRA    8F14
08F0C:  MOVLW  20
08F0E:  BRA    8F16
08F10:  MOVLB  A
08F12:  CLRF   x5D
08F14:  MOVLW  30
08F16:  ADDWF  00,F
08F18:  MOVF   00,W
08F1A:  BTFSS  F9E.4
08F1C:  BRA    8F1A
08F1E:  MOVWF  FAD
08F20:  BCF    FD8.1
08F22:  MOVFF  A64,A68
08F26:  MOVFF  A63,A67
08F2A:  MOVFF  A62,A66
08F2E:  MOVFF  A61,A65
08F32:  CLRF   x6C
08F34:  CLRF   x6B
08F36:  CLRF   x6A
08F38:  MOVLW  0A
08F3A:  MOVWF  x69
08F3C:  MOVLB  0
08F3E:  CALL   2ED0
08F42:  MOVFF  03,A64
08F46:  MOVFF  02,A63
08F4A:  MOVFF  01,A62
08F4E:  MOVFF  00,A61
08F52:  MOVLB  A
08F54:  DECFSZ x5F,F
08F56:  BRA    8EB4
08F58:  MOVLB  0
08F5A:  GOTO   9342 (RETURN)
*
09D56:  MOVLW  8E
09D58:  MOVWF  00
09D5A:  MOVFF  A24,01
09D5E:  MOVFF  A23,02
09D62:  CLRF   03
09D64:  BTFSS  01.7
09D66:  BRA    9D72
09D68:  COMF   01,F
09D6A:  COMF   02,F
09D6C:  INCF   02,F
09D6E:  BNZ   9D72
09D70:  INCF   01,F
09D72:  MOVF   01,F
09D74:  BNZ   9D88
09D76:  MOVFF  02,01
09D7A:  CLRF   02
09D7C:  MOVLW  08
09D7E:  SUBWF  00,F
09D80:  MOVF   01,F
09D82:  BNZ   9D88
09D84:  CLRF   00
09D86:  BRA    9DA2
09D88:  BCF    FD8.0
09D8A:  BTFSC  01.7
09D8C:  BRA    9D96
09D8E:  RLCF   02,F
09D90:  RLCF   01,F
09D92:  DECF   00,F
09D94:  BRA    9D88
09D96:  MOVLB  A
09D98:  BTFSS  x24.7
09D9A:  BRA    9DA0
09D9C:  MOVLB  0
09D9E:  BRA    9DA2
09DA0:  BCF    01.7
09DA2:  MOVLB  0
09DA4:  GOTO   9E70 (RETURN)
09DA8:  MOVFF  A22,A29
09DAC:  MOVLB  A
09DAE:  MOVF   x26,W
09DB0:  XORWF  x29,F
09DB2:  BTFSS  x29.7
09DB4:  BRA    9DC0
09DB6:  BCF    FD8.2
09DB8:  BCF    FD8.0
09DBA:  BTFSC  x22.7
09DBC:  BSF    FD8.0
09DBE:  BRA    9E1E
09DC0:  MOVFF  A22,A29
09DC4:  MOVFF  A25,A2A
09DC8:  MOVF   x21,W
09DCA:  SUBWF  x2A,F
09DCC:  BZ    9DDA
09DCE:  BTFSS  x29.7
09DD0:  BRA    9E1E
09DD2:  MOVF   FD8,W
09DD4:  XORLW  01
09DD6:  MOVWF  FD8
09DD8:  BRA    9E1E
09DDA:  MOVFF  A26,A2A
09DDE:  MOVF   x22,W
09DE0:  SUBWF  x2A,F
09DE2:  BZ    9DF0
09DE4:  BTFSS  x29.7
09DE6:  BRA    9E1E
09DE8:  MOVF   FD8,W
09DEA:  XORLW  01
09DEC:  MOVWF  FD8
09DEE:  BRA    9E1E
09DF0:  MOVFF  A27,A2A
09DF4:  MOVF   x23,W
09DF6:  SUBWF  x2A,F
09DF8:  BZ    9E06
09DFA:  BTFSS  x29.7
09DFC:  BRA    9E1E
09DFE:  MOVF   FD8,W
09E00:  XORLW  01
09E02:  MOVWF  FD8
09E04:  BRA    9E1E
09E06:  MOVFF  A28,A2A
09E0A:  MOVF   x24,W
09E0C:  SUBWF  x2A,F
09E0E:  BZ    9E1C
09E10:  BTFSS  x29.7
09E12:  BRA    9E1E
09E14:  MOVF   FD8,W
09E16:  XORLW  01
09E18:  MOVWF  FD8
09E1A:  BRA    9E1E
09E1C:  BCF    FD8.0
09E1E:  MOVLB  0
09E20:  RETURN 0
09E22:  MOVLW  8E
09E24:  MOVWF  00
09E26:  MOVLB  A
09E28:  MOVF   x21,W
09E2A:  SUBWF  00,F
09E2C:  MOVFF  A22,02
09E30:  MOVFF  A23,01
09E34:  BSF    02.7
09E36:  MOVF   00,F
09E38:  BZ    9E4C
09E3A:  BCF    FD8.0
09E3C:  MOVF   02,F
09E3E:  BNZ   9E44
09E40:  MOVF   01,F
09E42:  BZ    9E4C
09E44:  RRCF   02,F
09E46:  RRCF   01,F
09E48:  DECFSZ 00,F
09E4A:  BRA    9E3A
09E4C:  BTFSS  x22.7
09E4E:  BRA    9E5A
09E50:  COMF   01,F
09E52:  COMF   02,F
09E54:  INCF   01,F
09E56:  BTFSC  FD8.2
09E58:  INCF   02,F
09E5A:  MOVLB  0
09E5C:  RETURN 0
*
0B46A:  MOVLW  8E
0B46C:  MOVWF  00
0B46E:  MOVFF  A31,01
0B472:  MOVFF  A30,02
0B476:  CLRF   03
0B478:  MOVF   01,F
0B47A:  BNZ   B48E
0B47C:  MOVFF  02,01
0B480:  CLRF   02
0B482:  MOVLW  08
0B484:  SUBWF  00,F
0B486:  MOVF   01,F
0B488:  BNZ   B48E
0B48A:  CLRF   00
0B48C:  BRA    B49E
0B48E:  BCF    FD8.0
0B490:  BTFSC  01.7
0B492:  BRA    B49C
0B494:  RLCF   02,F
0B496:  RLCF   01,F
0B498:  DECF   00,F
0B49A:  BRA    B48E
0B49C:  BCF    01.7
0B49E:  RETURN 0
0B4A0:  MOVLB  A
0B4A2:  MOVF   x30,W
0B4A4:  BTFSC  FD8.2
0B4A6:  BRA    B5F2
0B4A8:  MOVWF  x3C
0B4AA:  MOVF   x34,W
0B4AC:  BTFSC  FD8.2
0B4AE:  BRA    B5F2
0B4B0:  SUBWF  x3C,F
0B4B2:  BNC   B4BE
0B4B4:  MOVLW  7F
0B4B6:  ADDWF  x3C,F
0B4B8:  BTFSC  FD8.0
0B4BA:  BRA    B5F2
0B4BC:  BRA    B4CA
0B4BE:  MOVLW  81
0B4C0:  SUBWF  x3C,F
0B4C2:  BTFSS  FD8.0
0B4C4:  BRA    B5F2
0B4C6:  BTFSC  FD8.2
0B4C8:  BRA    B5F2
0B4CA:  MOVFF  A3C,00
0B4CE:  CLRF   01
0B4D0:  CLRF   02
0B4D2:  CLRF   03
0B4D4:  CLRF   x3B
0B4D6:  MOVFF  A31,A3A
0B4DA:  BSF    x3A.7
0B4DC:  MOVFF  A32,A39
0B4E0:  MOVFF  A33,A38
0B4E4:  MOVLW  19
0B4E6:  MOVWF  x3C
0B4E8:  MOVF   x37,W
0B4EA:  SUBWF  x38,F
0B4EC:  BC    B508
0B4EE:  MOVLW  01
0B4F0:  SUBWF  x39,F
0B4F2:  BC    B508
0B4F4:  SUBWF  x3A,F
0B4F6:  BC    B508
0B4F8:  SUBWF  x3B,F
0B4FA:  BC    B508
0B4FC:  INCF   x3B,F
0B4FE:  INCF   x3A,F
0B500:  INCF   x39,F
0B502:  MOVF   x37,W
0B504:  ADDWF  x38,F
0B506:  BRA    B558
0B508:  MOVF   x36,W
0B50A:  SUBWF  x39,F
0B50C:  BC    B532
0B50E:  MOVLW  01
0B510:  SUBWF  x3A,F
0B512:  BC    B532
0B514:  SUBWF  x3B,F
0B516:  BC    B532
0B518:  INCF   x3B,F
0B51A:  INCF   x3A,F
0B51C:  MOVF   x36,W
0B51E:  ADDWF  x39,F
0B520:  MOVF   x37,W
0B522:  ADDWF  x38,F
0B524:  BNC   B558
0B526:  INCF   x39,F
0B528:  BNZ   B558
0B52A:  INCF   x3A,F
0B52C:  BNZ   B558
0B52E:  INCF   x3B,F
0B530:  BRA    B558
0B532:  MOVF   x35,W
0B534:  IORLW  80
0B536:  SUBWF  x3A,F
0B538:  BC    B556
0B53A:  MOVLW  01
0B53C:  SUBWF  x3B,F
0B53E:  BC    B556
0B540:  INCF   x3B,F
0B542:  MOVF   x35,W
0B544:  IORLW  80
0B546:  ADDWF  x3A,F
0B548:  MOVF   x36,W
0B54A:  ADDWF  x39,F
0B54C:  BNC   B520
0B54E:  INCF   x3A,F
0B550:  BNZ   B520
0B552:  INCF   x3B,F
0B554:  BRA    B520
0B556:  BSF    03.0
0B558:  DECFSZ x3C,F
0B55A:  BRA    B55E
0B55C:  BRA    B574
0B55E:  BCF    FD8.0
0B560:  RLCF   x38,F
0B562:  RLCF   x39,F
0B564:  RLCF   x3A,F
0B566:  RLCF   x3B,F
0B568:  BCF    FD8.0
0B56A:  RLCF   03,F
0B56C:  RLCF   02,F
0B56E:  RLCF   01,F
0B570:  RLCF   x3D,F
0B572:  BRA    B4E8
0B574:  BTFSS  x3D.0
0B576:  BRA    B584
0B578:  BCF    FD8.0
0B57A:  RRCF   01,F
0B57C:  RRCF   02,F
0B57E:  RRCF   03,F
0B580:  RRCF   x3D,F
0B582:  BRA    B588
0B584:  DECF   00,F
0B586:  BZ    B5F2
0B588:  BTFSC  x3D.7
0B58A:  BRA    B5C8
0B58C:  BCF    FD8.0
0B58E:  RLCF   x38,F
0B590:  RLCF   x39,F
0B592:  RLCF   x3A,F
0B594:  RLCF   x3B,F
0B596:  MOVF   x37,W
0B598:  SUBWF  x38,F
0B59A:  BC    B5AA
0B59C:  MOVLW  01
0B59E:  SUBWF  x39,F
0B5A0:  BC    B5AA
0B5A2:  SUBWF  x3A,F
0B5A4:  BC    B5AA
0B5A6:  SUBWF  x3B,F
0B5A8:  BNC   B5DE
0B5AA:  MOVF   x36,W
0B5AC:  SUBWF  x39,F
0B5AE:  BC    B5BA
0B5B0:  MOVLW  01
0B5B2:  SUBWF  x3A,F
0B5B4:  BC    B5BA
0B5B6:  SUBWF  x3B,F
0B5B8:  BNC   B5DE
0B5BA:  MOVF   x35,W
0B5BC:  IORLW  80
0B5BE:  SUBWF  x3A,F
0B5C0:  BC    B5C8
0B5C2:  MOVLW  01
0B5C4:  SUBWF  x3B,F
0B5C6:  BNC   B5DE
0B5C8:  INCF   03,F
0B5CA:  BNZ   B5DE
0B5CC:  INCF   02,F
0B5CE:  BNZ   B5DE
0B5D0:  INCF   01,F
0B5D2:  BNZ   B5DE
0B5D4:  INCF   00,F
0B5D6:  BZ    B5F2
0B5D8:  RRCF   01,F
0B5DA:  RRCF   02,F
0B5DC:  RRCF   03,F
0B5DE:  MOVFF  A31,A3C
0B5E2:  MOVF   x35,W
0B5E4:  XORWF  x3C,F
0B5E6:  BTFSS  x3C.7
0B5E8:  BRA    B5EE
0B5EA:  BSF    01.7
0B5EC:  BRA    B5FA
0B5EE:  BCF    01.7
0B5F0:  BRA    B5FA
0B5F2:  CLRF   00
0B5F4:  CLRF   01
0B5F6:  CLRF   02
0B5F8:  CLRF   03
0B5FA:  MOVLB  0
0B5FC:  RETURN 0
0B5FE:  MOVF   FE9,W
0B600:  MOVLB  A
0B602:  MOVWF  x29
0B604:  MOVF   x28,W
0B606:  MOVWF  x2B
0B608:  BZ    B642
0B60A:  MOVFF  A27,A34
0B60E:  MOVFF  A26,A33
0B612:  MOVFF  A25,A32
0B616:  MOVFF  A24,A31
0B61A:  CLRF   x38
0B61C:  CLRF   x37
0B61E:  MOVLW  20
0B620:  MOVWF  x36
0B622:  MOVLW  82
0B624:  MOVWF  x35
0B626:  MOVLB  0
0B628:  CALL   83EC
0B62C:  MOVFF  03,A27
0B630:  MOVFF  02,A26
0B634:  MOVFF  01,A25
0B638:  MOVFF  00,A24
0B63C:  MOVLB  A
0B63E:  DECFSZ x2B,F
0B640:  BRA    B60A
0B642:  MOVFF  A27,A34
0B646:  MOVFF  A26,A33
0B64A:  MOVFF  A25,A32
0B64E:  MOVFF  A24,A31
0B652:  MOVLB  0
0B654:  CALL   875A
0B658:  MOVFF  03,A27
0B65C:  MOVFF  02,A26
0B660:  MOVFF  01,A25
0B664:  MOVFF  00,A24
0B668:  MOVLB  A
0B66A:  BTFSS  x27.7
0B66C:  BRA    B688
0B66E:  DECF   x29,F
0B670:  BSF    x29.5
0B672:  COMF   x24,F
0B674:  COMF   x25,F
0B676:  COMF   x26,F
0B678:  COMF   x27,F
0B67A:  INCF   x24,F
0B67C:  BTFSC  FD8.2
0B67E:  INCF   x25,F
0B680:  BTFSC  FD8.2
0B682:  INCF   x26,F
0B684:  BTFSC  FD8.2
0B686:  INCF   x27,F
0B688:  MOVLW  3B
0B68A:  MOVWF  x30
0B68C:  MOVLW  9A
0B68E:  MOVWF  x2F
0B690:  MOVLW  CA
0B692:  MOVWF  x2E
0B694:  CLRF   x2D
0B696:  MOVLW  0A
0B698:  MOVWF  x2B
0B69A:  MOVF   x28,W
0B69C:  BTFSC  FD8.2
0B69E:  INCF   x29,F
0B6A0:  BSF    FD8.1
0B6A2:  MOVLW  0A
0B6A4:  MOVWF  FEA
0B6A6:  MOVLW  24
0B6A8:  MOVWF  FE9
0B6AA:  MOVFF  A27,A68
0B6AE:  MOVFF  A26,A67
0B6B2:  MOVFF  A25,A66
0B6B6:  MOVFF  A24,A65
0B6BA:  MOVFF  A30,A6C
0B6BE:  MOVFF  A2F,A6B
0B6C2:  MOVFF  A2E,A6A
0B6C6:  MOVFF  A2D,A69
0B6CA:  MOVLB  0
0B6CC:  CALL   2ED0
0B6D0:  MOVF   01,W
0B6D2:  MOVF   00,F
0B6D4:  BNZ   B6FC
0B6D6:  MOVLB  A
0B6D8:  INCF   x28,W
0B6DA:  SUBWF  x2B,W
0B6DC:  BTFSS  FD8.2
0B6DE:  BRA    B6E4
0B6E0:  MOVLB  0
0B6E2:  BRA    B6FC
0B6E4:  MOVF   x29,W
0B6E6:  BZ    B702
0B6E8:  ANDLW  0F
0B6EA:  SUBWF  x2B,W
0B6EC:  BZ    B6F0
0B6EE:  BC    B77E
0B6F0:  BTFSC  x29.7
0B6F2:  BRA    B77E
0B6F4:  BTFSC  x29.6
0B6F6:  BRA    B702
0B6F8:  MOVLW  20
0B6FA:  BRA    B770
0B6FC:  MOVLW  20
0B6FE:  MOVLB  A
0B700:  ANDWF  x29,F
0B702:  BTFSS  x29.5
0B704:  BRA    B726
0B706:  BCF    x29.5
0B708:  MOVF   x28,W
0B70A:  BTFSS  FD8.2
0B70C:  DECF   x29,F
0B70E:  MOVF   00,W
0B710:  MOVWF  x29
0B712:  MOVLW  2D
0B714:  MOVLB  B
0B716:  MOVWF  x1F
0B718:  MOVLB  0
0B71A:  CALL   1C34
0B71E:  MOVLB  A
0B720:  MOVF   x29,W
0B722:  MOVWF  00
0B724:  CLRF   x29
0B726:  MOVF   x28,W
0B728:  SUBWF  x2B,W
0B72A:  BNZ   B748
0B72C:  MOVF   00,W
0B72E:  MOVWF  x29
0B730:  MOVLW  2E
0B732:  MOVLB  B
0B734:  MOVWF  x1F
0B736:  MOVLB  0
0B738:  CALL   1C34
0B73C:  MOVLB  A
0B73E:  MOVF   x29,W
0B740:  MOVWF  00
0B742:  MOVLW  20
0B744:  ANDWF  x29,F
0B746:  MOVLW  00
0B748:  MOVLW  30
0B74A:  BTFSS  x29.5
0B74C:  BRA    B770
0B74E:  BCF    x29.5
0B750:  MOVF   x28,W
0B752:  BTFSS  FD8.2
0B754:  DECF   x29,F
0B756:  MOVF   00,W
0B758:  MOVWF  x29
0B75A:  MOVLW  2D
0B75C:  MOVLB  B
0B75E:  MOVWF  x1F
0B760:  MOVLB  0
0B762:  CALL   1C34
0B766:  MOVLB  A
0B768:  MOVF   x29,W
0B76A:  MOVWF  00
0B76C:  CLRF   x29
0B76E:  MOVLW  30
0B770:  ADDWF  00,F
0B772:  MOVFF  00,B1F
0B776:  MOVLB  0
0B778:  CALL   1C34
0B77C:  MOVLB  A
0B77E:  BCF    FD8.1
0B780:  MOVFF  A30,A68
0B784:  MOVFF  A2F,A67
0B788:  MOVFF  A2E,A66
0B78C:  MOVFF  A2D,A65
0B790:  CLRF   x6C
0B792:  CLRF   x6B
0B794:  CLRF   x6A
0B796:  MOVLW  0A
0B798:  MOVWF  x69
0B79A:  MOVLB  0
0B79C:  CALL   2ED0
0B7A0:  MOVFF  03,A30
0B7A4:  MOVFF  02,A2F
0B7A8:  MOVFF  01,A2E
0B7AC:  MOVFF  00,A2D
0B7B0:  MOVLB  A
0B7B2:  DECFSZ x2B,F
0B7B4:  BRA    B6A0
0B7B6:  MOVLB  0
0B7B8:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #FUSES NOWDT NOBROWNOUT SOSC_DIG 
.................... #use delay(crystal = 16Mhz, clock = 16Mhz) // For crystal 
*
036F2:  MOVLW  0A
036F4:  MOVWF  FEA
036F6:  MOVLW  DB
036F8:  MOVWF  FE9
036FA:  MOVF   FEF,W
036FC:  BZ    371A
036FE:  MOVLW  05
03700:  MOVWF  01
03702:  CLRF   00
03704:  DECFSZ 00,F
03706:  BRA    3704
03708:  DECFSZ 01,F
0370A:  BRA    3702
0370C:  MOVLW  2E
0370E:  MOVWF  00
03710:  DECFSZ 00,F
03712:  BRA    3710
03714:  BRA    3716
03716:  DECFSZ FEF,F
03718:  BRA    36FE
0371A:  RETURN 0
....................  
.................... #device HIGH_INTS = TRUE 
....................  
.................... #pin_select TX1 = PIN_D6 
.................... #pin_select RX1 = PIN_D7 
.................... #use rs232(baud = 115200, parity = N, UART1, bits = 8, stream = PCIB, ERRORS) // PCIB 
*
00A8C:  BTFSS  F9E.5
00A8E:  BRA    0A8C
00A90:  MOVFF  FAB,30
00A94:  MOVFF  FAE,01
00A98:  BTFSS  30.1
00A9A:  BRA    0AA0
00A9C:  BCF    FAB.4
00A9E:  BSF    FAB.4
00AA0:  RETURN 0
*
029F8:  BTFSS  F9E.4
029FA:  BRA    29F8
029FC:  MOVWF  FAD
029FE:  RETURN 0
....................  
.................... #pin_select TX2 = PIN_D3 
.................... #pin_select RX2 = PIN_D2 
.................... #use rs232(baud = 9600, parity = N, UART2, bits = 8, stream = COMM, ERRORS) // COM PIC 
*
00E58:  BTFSS  FA4.5
00E5A:  BRA    0E58
00E5C:  MOVLB  F
00E5E:  MOVFF  F33,30
00E62:  MOVFF  F1E,01
00E66:  BTFSS  30.1
00E68:  BRA    0E6E
00E6A:  BCF    x33.4
00E6C:  BSF    x33.4
00E6E:  MOVLB  0
00E70:  RETURN 0
*
02A0A:  BTFSS  FA4.4
02A0C:  BRA    2A0A
02A0E:  MOVLB  F
02A10:  MOVWF  x1D
02A12:  MOVLB  0
02A14:  RETURN 0
....................  
.................... #pin_select TX3 = PIN_E5 
.................... #pin_select RX3 = PIN_E4 
.................... #use rs232(baud = 9600, parity = N, UART3, bits = 8, stream = FAB, ERRORS) // FAB PIC 
*
01236:  BTFSS  FA6.5
01238:  BRA    1236
0123A:  MOVLB  F
0123C:  MOVFF  F2F,30
01240:  MOVFF  F2A,01
01244:  BTFSS  30.1
01246:  BRA    124C
01248:  BCF    x2F.4
0124A:  BSF    x2F.4
0124C:  MOVLB  0
0124E:  RETURN 0
*
02A6E:  BTFSS  FA6.4
02A70:  BRA    2A6E
02A72:  MOVLB  F
02A74:  MOVWF  x29
02A76:  MOVLB  0
02A78:  RETURN 0
....................  
.................... #pin_select TX4 = PIN_E3 
.................... #pin_select RX4 = PIN_F2 
.................... #use rs232(baud = 19200, parity = N, UART4, bits = 8, stream = RST, ERRORS) // RESET PIC 
*
01606:  BTFSS  FA6.7
01608:  BRA    1606
0160A:  MOVLB  E
0160C:  MOVFF  EFF,30
01610:  MOVFF  EFA,01
01614:  BTFSS  30.1
01616:  BRA    161C
01618:  BCF    xFF.4
0161A:  BSF    xFF.4
0161C:  MOVLB  0
0161E:  RETURN 0
*
02A84:  BTFSS  FA6.6
02A86:  BRA    2A84
02A88:  MOVLB  E
02A8A:  MOVWF  xF9
02A8C:  MOVLB  0
02A8E:  RETURN 0
....................  
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PC, ERRORS)            // DEBUG 
*
01C34:  BCF    F94.6
01C36:  BCF    F8B.6
01C38:  MOVLW  08
01C3A:  MOVWF  01
01C3C:  BRA    1C3E
01C3E:  NOP   
01C40:  BSF    01.7
01C42:  BRA    1C64
01C44:  BCF    01.7
01C46:  MOVLB  B
01C48:  RRCF   x1F,F
01C4A:  MOVLB  0
01C4C:  BTFSC  FD8.0
01C4E:  BSF    F8B.6
01C50:  BTFSS  FD8.0
01C52:  BCF    F8B.6
01C54:  BSF    01.6
01C56:  BRA    1C64
01C58:  BCF    01.6
01C5A:  DECFSZ 01,F
01C5C:  BRA    1C46
01C5E:  BRA    1C60
01C60:  NOP   
01C62:  BSF    F8B.6
01C64:  MOVLW  84
01C66:  MOVWF  FE9
01C68:  DECFSZ FE9,F
01C6A:  BRA    1C68
01C6C:  BRA    1C6E
01C6E:  NOP   
01C70:  BTFSC  01.7
01C72:  BRA    1C44
01C74:  BTFSC  01.6
01C76:  BRA    1C58
01C78:  RETURN 0
*
02B88:  BSF    F94.7
02B8A:  BTFSC  F82.7
02B8C:  BRA    2B8A
02B8E:  MOVLW  08
02B90:  MOVWF  00
02B92:  MOVLB  B
02B94:  CLRF   x1D
02B96:  BSF    00.7
02B98:  BRA    2BB6
02B9A:  BCF    00.7
02B9C:  BRA    2BB6
02B9E:  BCF    FD8.0
02BA0:  BTFSC  F82.7
02BA2:  BSF    FD8.0
02BA4:  RRCF   x1D,F
02BA6:  BSF    00.6
02BA8:  BRA    2BB6
02BAA:  BCF    00.6
02BAC:  DECFSZ 00,F
02BAE:  BRA    2B9E
02BB0:  MOVFF  B1D,01
02BB4:  BRA    2BCE
02BB6:  MOVLW  84
02BB8:  BTFSC  00.7
02BBA:  MOVLW  24
02BBC:  MOVWF  01
02BBE:  DECFSZ 01,F
02BC0:  BRA    2BBE
02BC2:  BRA    2BC4
02BC4:  BTFSC  00.7
02BC6:  BRA    2B9A
02BC8:  BTFSC  00.6
02BCA:  BRA    2BAA
02BCC:  BRA    2B9E
02BCE:  MOVLB  0
02BD0:  RETURN 0
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_D5, rcv = PIN_F6, bits = 8, stream = ADCS, ERRORS)          // ADCS 
*
02A20:  BCF    F95.5
02A22:  BCF    F8C.5
02A24:  MOVLW  08
02A26:  MOVWF  01
02A28:  BRA    2A2A
02A2A:  NOP   
02A2C:  BSF    01.7
02A2E:  BRA    2A50
02A30:  BCF    01.7
02A32:  MOVLB  B
02A34:  RRCF   x1F,F
02A36:  MOVLB  0
02A38:  BTFSC  FD8.0
02A3A:  BSF    F8C.5
02A3C:  BTFSS  FD8.0
02A3E:  BCF    F8C.5
02A40:  BSF    01.6
02A42:  BRA    2A50
02A44:  BCF    01.6
02A46:  DECFSZ 01,F
02A48:  BRA    2A32
02A4A:  BRA    2A4C
02A4C:  NOP   
02A4E:  BSF    F8C.5
02A50:  MOVLW  84
02A52:  MOVWF  FE9
02A54:  DECFSZ FE9,F
02A56:  BRA    2A54
02A58:  BRA    2A5A
02A5A:  NOP   
02A5C:  BTFSC  01.7
02A5E:  BRA    2A30
02A60:  BTFSC  01.6
02A62:  BRA    2A44
02A64:  RETURN 0
*
02C06:  BSF    F97.6
02C08:  BTFSC  F85.6
02C0A:  BRA    2C08
02C0C:  MOVLW  08
02C0E:  MOVWF  00
02C10:  MOVLB  B
02C12:  CLRF   x1D
02C14:  BSF    00.7
02C16:  BRA    2C34
02C18:  BCF    00.7
02C1A:  BRA    2C34
02C1C:  BCF    FD8.0
02C1E:  BTFSC  F85.6
02C20:  BSF    FD8.0
02C22:  RRCF   x1D,F
02C24:  BSF    00.6
02C26:  BRA    2C34
02C28:  BCF    00.6
02C2A:  DECFSZ 00,F
02C2C:  BRA    2C1C
02C2E:  MOVFF  B1D,01
02C32:  BRA    2C4C
02C34:  MOVLW  84
02C36:  BTFSC  00.7
02C38:  MOVLW  24
02C3A:  MOVWF  01
02C3C:  DECFSZ 01,F
02C3E:  BRA    2C3C
02C40:  BRA    2C42
02C42:  BTFSC  00.7
02C44:  BRA    2C18
02C46:  BTFSC  00.6
02C48:  BRA    2C28
02C4A:  BRA    2C1C
02C4C:  MOVLB  0
02C4E:  RETURN 0
....................  
.................... #use spi(MASTER, CLK = PIN_E1, DI = PIN_E0, DO = PIN_E6, BAUD = 1000000, BITS = 8, STREAM = MAIN_FM, MODE = 0)    // MAIN flash memory port 
*
02AE6:  MOVLB  B
02AE8:  MOVF   x20,W
02AEA:  SUBLW  08
02AEC:  BZ    2AF6
02AEE:  MOVWF  x21
02AF0:  RLCF   x1F,F
02AF2:  DECFSZ x21,F
02AF4:  BRA    2AF0
02AF6:  BSF    F96.0
02AF8:  BCF    F96.6
02AFA:  BCF    F96.1
02AFC:  BCF    F8D.1
02AFE:  MOVFF  B20,B21
02B02:  BTFSS  x1F.7
02B04:  BCF    F8D.6
02B06:  BTFSC  x1F.7
02B08:  BSF    F8D.6
02B0A:  RLCF   x1F,F
02B0C:  BSF    F8D.1
02B0E:  RLCF   01,F
02B10:  BTFSS  F84.0
02B12:  BCF    01.0
02B14:  BTFSC  F84.0
02B16:  BSF    01.0
02B18:  BCF    F8D.1
02B1A:  DECFSZ x21,F
02B1C:  BRA    2B02
02B1E:  MOVLB  0
02B20:  RETURN 0
.................... #use spi(MASTER, CLK = PIN_B2, DI = PIN_B5, DO = PIN_B4, BAUD = 1000000, BITS = 8, STREAM = COM_FM, MODE = 0)     // COM flash memory port 
*
02A9A:  MOVLB  B
02A9C:  MOVF   x20,W
02A9E:  SUBLW  08
02AA0:  BZ    2AAA
02AA2:  MOVWF  x21
02AA4:  RLCF   x1F,F
02AA6:  DECFSZ x21,F
02AA8:  BRA    2AA4
02AAA:  BSF    F93.5
02AAC:  BCF    F93.4
02AAE:  BCF    F93.2
02AB0:  BCF    F8A.2
02AB2:  MOVFF  B20,B21
02AB6:  BTFSS  x1F.7
02AB8:  BCF    F8A.4
02ABA:  BTFSC  x1F.7
02ABC:  BSF    F8A.4
02ABE:  RLCF   x1F,F
02AC0:  BSF    F8A.2
02AC2:  RLCF   01,F
02AC4:  BTFSS  F81.5
02AC6:  BCF    01.0
02AC8:  BTFSC  F81.5
02ACA:  BSF    01.0
02ACC:  BCF    F8A.2
02ACE:  DECFSZ x21,F
02AD0:  BRA    2AB6
02AD2:  MOVLB  0
02AD4:  RETURN 0
.................... #use spi(MASTER, CLK = PIN_A3, DI = PIN_A0, DO = PIN_A1, BAUD = 1000000, BITS = 8, STREAM = MISSION_FM, MODE = 0) // MISSION flash memory port 
*
02B32:  MOVLB  B
02B34:  MOVF   x20,W
02B36:  SUBLW  08
02B38:  BZ    2B42
02B3A:  MOVWF  x21
02B3C:  RLCF   x1F,F
02B3E:  DECFSZ x21,F
02B40:  BRA    2B3C
02B42:  BSF    F92.0
02B44:  BCF    F92.1
02B46:  BCF    F92.3
02B48:  BCF    F89.3
02B4A:  MOVFF  B20,B21
02B4E:  BTFSS  x1F.7
02B50:  BCF    F89.1
02B52:  BTFSC  x1F.7
02B54:  BSF    F89.1
02B56:  RLCF   x1F,F
02B58:  BSF    F89.3
02B5A:  RLCF   01,F
02B5C:  BTFSS  F80.0
02B5E:  BCF    01.0
02B60:  BTFSC  F80.0
02B62:  BSF    01.0
02B64:  BCF    F89.3
02B66:  DECFSZ x21,F
02B68:  BRA    2B4E
02B6A:  MOVLB  0
02B6C:  RETURN 0
....................  
.................... #define MUX_SEL_COM_SHARED_FM PIN_C5 // Low = Main PIC; High = COM PIC 
.................... #define MUX_SEL_MSN_SHARED_FM PIN_A5 // Low = Main PIC; High = Mission 
.................... #define OCP_EN_ADCS PIN_G4      // ADCS board enable 
.................... #define OCP_EN_PCIB PIN_F5      // PCIB enable 
....................  
.................... #endif // !DEVICE_H 
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
06E28:  MOVFF  A28,A2E
06E2C:  MOVFF  A27,A2D
06E30:  MOVFF  A2A,A30
06E34:  MOVFF  A29,A2F
06E38:  MOVLB  A
06E3A:  MOVF   x2C,F
06E3C:  BNZ   6E44
06E3E:  MOVF   x2B,W
06E40:  SUBLW  00
06E42:  BC    6EA4
.................... { 
....................    if(*su1!=*su2) 
06E44:  MOVFF  A2D,FE9
06E48:  MOVFF  A2E,FEA
06E4C:  MOVFF  FEF,A31
06E50:  MOVFF  A30,03
06E54:  MOVFF  A2F,FE9
06E58:  MOVFF  A30,FEA
06E5C:  MOVF   FEF,W
06E5E:  SUBWF  x31,W
06E60:  BZ    6E8E
....................       return ((*su1<*su2)?-1:1); 
06E62:  MOVFF  A2E,03
06E66:  MOVFF  A2D,FE9
06E6A:  MOVFF  03,FEA
06E6E:  MOVFF  FEF,A31
06E72:  MOVFF  A30,03
06E76:  MOVFF  A2F,FE9
06E7A:  MOVFF  A30,FEA
06E7E:  MOVF   FEF,W
06E80:  SUBWF  x31,W
06E82:  BC    6E88
06E84:  MOVLW  FF
06E86:  BRA    6E8A
06E88:  MOVLW  01
06E8A:  MOVWF  01
06E8C:  BRA    6EA8
06E8E:  INCF   x2D,F
06E90:  BTFSC  FD8.2
06E92:  INCF   x2E,F
06E94:  INCF   x2F,F
06E96:  BTFSC  FD8.2
06E98:  INCF   x30,F
06E9A:  MOVF   x2B,W
06E9C:  BTFSC  FD8.2
06E9E:  DECF   x2C,F
06EA0:  DECF   x2B,F
06EA2:  BRA    6E3A
.................... } 
.................... return 0; 
06EA4:  MOVLW  00
06EA6:  MOVWF  01
06EA8:  MOVLB  0
06EAA:  GOTO   6F3A (RETURN)
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #ifndef DEVICE_H 
.................... #define DEVICE_H 
....................  
.................... // For the real case ---------------------------------------------------------------------- 
.................... #include <18F67J94.h> 
....................  
.................... #FUSES NOWDT NOBROWNOUT SOSC_DIG 
.................... #use delay(crystal = 16Mhz, clock = 16Mhz) // For crystal 
....................  
.................... #device HIGH_INTS = TRUE 
....................  
.................... #pin_select TX1 = PIN_D6 
.................... #pin_select RX1 = PIN_D7 
.................... #use rs232(baud = 115200, parity = N, UART1, bits = 8, stream = PCIB, ERRORS) // PCIB 
....................  
.................... #pin_select TX2 = PIN_D3 
.................... #pin_select RX2 = PIN_D2 
.................... #use rs232(baud = 9600, parity = N, UART2, bits = 8, stream = COMM, ERRORS) // COM PIC 
....................  
.................... #pin_select TX3 = PIN_E5 
.................... #pin_select RX3 = PIN_E4 
.................... #use rs232(baud = 9600, parity = N, UART3, bits = 8, stream = FAB, ERRORS) // FAB PIC 
....................  
.................... #pin_select TX4 = PIN_E3 
.................... #pin_select RX4 = PIN_F2 
.................... #use rs232(baud = 19200, parity = N, UART4, bits = 8, stream = RST, ERRORS) // RESET PIC 
....................  
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PC, ERRORS)            // DEBUG 
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_D5, rcv = PIN_F6, bits = 8, stream = ADCS, ERRORS)          // ADCS 
....................  
.................... #use spi(MASTER, CLK = PIN_E1, DI = PIN_E0, DO = PIN_E6, BAUD = 1000000, BITS = 8, STREAM = MAIN_FM, MODE = 0)    // MAIN flash memory port 
.................... #use spi(MASTER, CLK = PIN_B2, DI = PIN_B5, DO = PIN_B4, BAUD = 1000000, BITS = 8, STREAM = COM_FM, MODE = 0)     // COM flash memory port 
.................... #use spi(MASTER, CLK = PIN_A3, DI = PIN_A0, DO = PIN_A1, BAUD = 1000000, BITS = 8, STREAM = MISSION_FM, MODE = 0) // MISSION flash memory port 
....................  
.................... #define MUX_SEL_COM_SHARED_FM PIN_C5 // Low = Main PIC; High = COM PIC 
.................... #define MUX_SEL_MSN_SHARED_FM PIN_A5 // Low = Main PIC; High = Mission 
.................... #define OCP_EN_ADCS PIN_G4      // ADCS board enable 
.................... #define OCP_EN_PCIB PIN_F5      // PCIB enable 
....................  
.................... #endif // !DEVICE_H 
....................  
.................... #include <time.h> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                       /// 
.................... ///                               time.h                                  /// 
.................... ///                                                                       /// 
.................... /// Time algorithms.  This follows the standard C API, with the following /// 
.................... /// exceptions:                                                           /// 
.................... ///   * ctime() and asctime() have another optional input parameter which /// 
.................... ///     is the pointer to where to save the result string.                /// 
.................... ///     Normally ctime() and asctime() write the output to a globally     /// 
.................... ///     allocated string and return a pointer to this string.  By using   /// 
.................... ///     this optional extra function parameter, you can store the         /// 
.................... ///     result string into a specified location.                          /// 
.................... ///   * The output string of ctime() and asctime() are not statically     /// 
.................... ///     allocated.  That means any other code that runs after ctime()     /// 
.................... ///     or asctime() can corrupt the result value.  Either perform        /// 
.................... ///     a string copy of the result into a new location, or use the       /// 
.................... ///     optional parameter of these functions to store the result         /// 
....................  
.................... ///   * strftime() is not supported.                                      /// 
.................... ///   * SetTime() is added that initializes/set the current time.         /// 
.................... ///   * GetTime() is added so you can read directly into a struct_tm,     /// 
.................... ///      instead of having to use localtime(time()) which is usually      /// 
.................... ///       innefecient.                                                    /// 
.................... ///   * TimeInit() added for any real time clock devices that may need    /// 
.................... ///      to be initialized first.                                         /// 
.................... ///   * Not all timebases have a tick system, so it's not recommended     /// 
.................... ///      to use clock().  If you need clock(), look at CCS's              /// 
.................... ///      #use timer() library.                                            /// 
.................... ///   * Added timeasc(), which converts a string to a time_t.  It is      /// 
.................... ///      basically the reverse of asctime().  Returns TRUE if successful  /// 
.................... ///      conversion, FALSE if not because format is wrong.                /// 
.................... ///   * Added TIME_T_USES_2010.  Normally time_t is number of seconds     /// 
.................... ///      since January 1 1970.  However, if time_t is a 32bit number this /// 
.................... ///      value will rollover sometime in 2032.  If TIME_T_USES_2010 is    /// 
.................... ///      defined then time_t is number of seconds since January 1 2010,   /// 
.................... ///      and a 32bit time_t won't rollover until 2072.   Most modern      /// 
.................... ///      operating systems (like Windows and Linux) uses a 64bit time_t   /// 
.................... ///      so they aren't effected.  If you are interfacing with another    /// 
.................... ///      system that uses a normal time_t, then that system will need to  /// 
.................... ///      add 1262304000 to the value coming from this library.            /// 
.................... ///      To enable this feature, then #define TIME_T_USES_2010            /// 
.................... ///                                                                       /// 
.................... /// This file only provides the prototypes and definitions needed to      /// 
.................... /// proved a time alogrithm that follows the C standard library.  You     /// 
.................... /// also need to include/link the actual library that performs the time   /// 
.................... /// base.  As of this writing CCS provides the following compatible       /// 
.................... /// timebase libraries:                                                   /// 
.................... ///      rtcperipheral.c - for PICs with internal real time clock.        /// 
.................... ///      ds1305.c - external DS1305 real time clock.                      /// 
.................... ///      rtcticks.c - Use a PIC's timer with CCS #use timer() library.    /// 
.................... ///                                                                       /// 
.................... /// API:                                                                  /// 
.................... ///                                                                       /// 
.................... /// Variable definitions:                                                 /// 
.................... ///   c - clock timer (clock_t), number of ticks since powerup.  See      /// 
.................... ///       CLOCKS_PER_SECOND to determine clock rate.                      /// 
.................... ///                                                                       /// 
.................... ///   t - second timer (time_t), number of seconds since Jan 1st, 1970.   /// 
.................... ///                                                                       /// 
.................... ///   ts - time struct (struct_tm), a structure that holds time in        /// 
.................... ///        descriptive format (seconds, minutes, hours, day, month, etc). /// 
.................... ///                                                                       /// 
.................... /// CLOCKS_PER_SECOND - This is a constant which needs to be defined that /// 
.................... ///   configures the timebase used by the clock timer and clock().        /// 
.................... ///   If you are not using clock() then you don't need to define this.    /// 
.................... ///   If you are using a method such a PIC's timer for the timebase then  /// 
.................... ///   you will need to set this.                                          /// 
.................... ///                                                                       /// 
.................... /// c = clock() - Return current clock timer.                             /// 
.................... ///                                                                       /// 
.................... /// t = time(*t) - Return current second timer.  Returns twice (as a      /// 
.................... ///         a return, and saves to input pointer).                        /// 
.................... ///                                                                       /// 
.................... /// SetTime(*tm) - Initializes the current time with a struct_tm          /// 
.................... ///                                                                       /// 
.................... /// SetTimeSec(t) - Initializes the current time with a seconds time      /// 
.................... ///                                                                       /// 
.................... /// t = mktime(*tm) - Converts a time struct to a second timer.           /// 
.................... ///                                                                       /// 
.................... /// t = difftime(t,t) - Returns difference between two second timers.     /// 
.................... ///                                                                       /// 
.................... /// *char = ctime(*t, *char) - Converts second timer to a readable string /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *char = asctime(*ts, *char) - Converts time struct to a readable      /// 
.................... ///                            string.                                    /// 
.................... ///                            Www Mmm dd hh:mm:ss yyyy                   /// 
.................... ///                                                                       /// 
.................... /// *ts = localtime(*t) - Converts second timer to a time struct.         /// 
.................... ///                  *ts points to a global time struct and will be       /// 
.................... ///                  corrupted in future calls to localtime().            /// 
.................... ///                                                                       /// 
.................... /// GetTime(*tm) - Returns the current time as a time struct              /// 
.................... ///                                                                       /// 
.................... /// TimeInit() - Initializes the timing device                            /// 
.................... ///                                                                       /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... /// VERSION HISTORY                                                     /// 
.................... ///                                                                     /// 
.................... /// June 9 2015:                                                        /// 
.................... ///   Fixed the struct_tm typedef so 'struct tm' would be legal         /// 
.................... ///      syntax.                                                        /// 
.................... ///   The parameters that CCS added to asctime() and ctime() are now    /// 
.................... ///      optional.                                                      /// 
.................... ///   Fixed a bug where tm_mday was sometimes off by 1 day.             /// 
.................... ///                                                                     /// 
.................... /// September 25 2014:                                                  /// 
.................... ///   Cleaned up documentation.                                         /// 
.................... ///   Added timeasc().                                                  /// 
.................... ///   Added TIME_T_USES_2010 compile time option.                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_H__ 
.................... #define __TIME_H__ 
....................  
.................... #include <stdlibm.h> 
....................  
.................... /* API Types*/ 
.................... typedef signed int32 time_t; 
.................... typedef unsigned int32 clock_t; 
....................  
.................... typedef enum 
.................... { 
....................    SUNDAY = 0, 
....................    MONDAY, 
....................    TUESDAY, 
....................    WEDNESDAY, 
....................    THURSDAY, 
....................    FRIDAY, 
....................    SATURDAY    
.................... }  Weekday; 
....................  
.................... typedef enum 
.................... { 
....................    JANUARY = 0, 
....................    FEBRUARY, 
....................    MARCH, 
....................    APRIL, 
....................    MAY, 
....................    JUNE, 
....................    JULY, 
....................    AUGUST, 
....................    SEPTEMBER, 
....................    OCTOBER, 
....................    NOVEMBER, 
....................    DECEMBER 
.................... }  Month; 
....................  
.................... typedef struct tm 
.................... { 
....................    unsigned int8 tm_sec;   // seconds after the minute (0-59) 
....................    unsigned int8 tm_min;   // minutes after the hour (0-59) 
....................    unsigned int8 tm_hour;  // hours since midnight (0-23) 
....................    unsigned int8 tm_mday;  // day of the month (1-31) 
....................    Month tm_mon;           // month of the year (0-11) 
....................    unsigned int16 tm_year; // years since 1900 
....................    Weekday tm_wday;        // day of the week (0-6) (Sunday=0) 
....................    unsigned int16 tm_yday; // day of the year (0-365) 
.................... } struct_tm; 
....................  
....................  
.................... /* returns number of ticks incremented at CLOCKS_PER_SECOND rate.  This 
....................    function must be provided by the library of your timebase */ 
.................... clock_t clock(void); 
....................  
.................... /* returns time in seconds since January 1 1970 (or January 1 2010 if  
....................    TIME_T_USES_2010 is being used).  This function must be provided by the 
....................    library of your timebase.  For example, see CCS's ds1305.c driver. */ 
.................... time_t time(time_t * timer); 
....................  
.................... /* Returns the difference in seconds between two times 
....................  * Times later and earlier are expressed in seconds  
....................  */ 
.................... signed int32 difftime(time_t later, time_t earlier); 
....................  
.................... /* Calculates the Unix Time from a standard time format 
....................  * Returns the Unix Time (time in seconds since Jan 1, 1970 00:00:00) 
....................  */ 
.................... time_t mktime(struct_tm * timeT); 
....................  
.................... /* Returns the given time as a string of the form:  
....................  *  Day Mon X HH:MM:SS YYYY\0  
....................  */ 
.................... char * asctime(struct_tm * timeptr, char *szTime = 0); 
....................  
.................... /* the inverse of asctime().  you can skip the wday portion of the string, and 
....................    then this function will not populate the tm_wday in pTm.  If you do skip 
....................    the wday portion of the string, then you can use localtime(mktime()) to 
....................    populate tm_wday with the correct value based on the date.  if pTm is 
....................    NULL it won't save result, but function will still return TRUE or FALSE. 
....................    Function returns TRUE if the format of the input string is valid. */ 
.................... int1 timeasc(struct_tm *pTm, char *szTime); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and returns the equivalent string.  
....................  */ 
.................... char * ctime(time_t * timer, char *szTime = 0); 
....................  
.................... /* Converts the given calendar time (in seconds) to local time 
....................  * and sets this time in the global g_lTime 
....................  * Returns a pointer to g_lTime 
....................  */ 
.................... struct_tm * localtime ( time_t * timer ); 
.................... #define gmtime(t) localtime(t) 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTime(struct_tm * nTime); 
....................  
.................... /* Set the time of your system.  This function must pe provided by the library 
....................    of your timebase (see CCS's ds1305.c driver) */ 
.................... void SetTimeSec(time_t sTime); 
....................  
.................... /* Get the time of your system.  This is similar to the standard time() 
....................    function, but this returns directly to a struct_tm.  Since most RTC's work 
....................    with a structure similar to struct_tm, this may be more effecient to use 
....................    than time().   This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void GetTime(struct_tm *pRetTm); 
....................  
.................... /* Initialize your timebase. This function must pe provided by the library of your  
....................    timebase (see CCS's ds1305.c driver) */ 
.................... void TimeInit(void); 
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
*
04A28:  MOVLW  18
04A2A:  MOVWF  FF6
04A2C:  MOVLW  02
04A2E:  MOVWF  FF7
04A30:  MOVLW  00
04A32:  MOVWF  FF8
04A34:  MOVLW  0F
04A36:  MOVLB  A
04A38:  MOVWF  x3B
04A3A:  MOVLB  0
04A3C:  CALL   3048
04A40:  MOVFF  EE,A25
04A44:  MOVLW  18
04A46:  MOVLB  A
04A48:  MOVWF  x26
04A4A:  MOVLB  0
04A4C:  RCALL  4960
04A4E:  MOVLW  0D
04A50:  MOVLB  B
04A52:  MOVWF  x1F
04A54:  MOVLB  0
04A56:  CALL   1C34
04A5A:  MOVLW  0A
04A5C:  MOVLB  B
04A5E:  MOVWF  x1F
04A60:  MOVLB  0
04A62:  CALL   1C34
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
04A66:  MOVLW  2C
04A68:  MOVWF  FF6
04A6A:  MOVLW  02
04A6C:  MOVWF  FF7
04A6E:  MOVLW  00
04A70:  MOVWF  FF8
04A72:  MOVLW  0E
04A74:  MOVLB  A
04A76:  MOVWF  x3B
04A78:  MOVLB  0
04A7A:  CALL   3048
04A7E:  MOVFF  EF,A25
04A82:  MOVLW  18
04A84:  MOVLB  A
04A86:  MOVWF  x26
04A88:  MOVLB  0
04A8A:  RCALL  4960
04A8C:  MOVLW  0D
04A8E:  MOVLB  B
04A90:  MOVWF  x1F
04A92:  MOVLB  0
04A94:  CALL   1C34
04A98:  MOVLW  0A
04A9A:  MOVLB  B
04A9C:  MOVWF  x1F
04A9E:  MOVLB  0
04AA0:  CALL   1C34
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
04AA4:  MOVLW  40
04AA6:  MOVWF  FF6
04AA8:  MOVLW  02
04AAA:  MOVWF  FF7
04AAC:  MOVLW  00
04AAE:  MOVWF  FF8
04AB0:  MOVLW  0E
04AB2:  MOVLB  A
04AB4:  MOVWF  x3B
04AB6:  MOVLB  0
04AB8:  CALL   3048
04ABC:  MOVFF  F0,A25
04AC0:  MOVLW  18
04AC2:  MOVLB  A
04AC4:  MOVWF  x26
04AC6:  MOVLB  0
04AC8:  RCALL  4960
04ACA:  MOVLW  0D
04ACC:  MOVLB  B
04ACE:  MOVWF  x1F
04AD0:  MOVLB  0
04AD2:  CALL   1C34
04AD6:  MOVLW  0A
04AD8:  MOVLB  B
04ADA:  MOVWF  x1F
04ADC:  MOVLB  0
04ADE:  CALL   1C34
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
04AE2:  MOVLW  54
04AE4:  MOVWF  FF6
04AE6:  MOVLW  02
04AE8:  MOVWF  FF7
04AEA:  MOVLW  00
04AEC:  MOVWF  FF8
04AEE:  MOVLW  16
04AF0:  MOVLB  A
04AF2:  MOVWF  x3B
04AF4:  MOVLB  0
04AF6:  CALL   3048
04AFA:  MOVFF  F1,A25
04AFE:  MOVLW  18
04B00:  MOVLB  A
04B02:  MOVWF  x26
04B04:  MOVLB  0
04B06:  RCALL  4960
04B08:  MOVLW  0D
04B0A:  MOVLB  B
04B0C:  MOVWF  x1F
04B0E:  MOVLB  0
04B10:  CALL   1C34
04B14:  MOVLW  0A
04B16:  MOVLB  B
04B18:  MOVWF  x1F
04B1A:  MOVLB  0
04B1C:  CALL   1C34
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
04B20:  MOVLW  70
04B22:  MOVWF  FF6
04B24:  MOVLW  02
04B26:  MOVWF  FF7
04B28:  MOVLW  00
04B2A:  MOVWF  FF8
04B2C:  MOVLW  15
04B2E:  MOVLB  A
04B30:  MOVWF  x3B
04B32:  MOVLB  0
04B34:  CALL   3048
04B38:  MOVFF  F2,A25
04B3C:  MOVLW  18
04B3E:  MOVLB  A
04B40:  MOVWF  x26
04B42:  MOVLB  0
04B44:  RCALL  4960
04B46:  MOVLW  0D
04B48:  MOVLB  B
04B4A:  MOVWF  x1F
04B4C:  MOVLB  0
04B4E:  CALL   1C34
04B52:  MOVLW  0A
04B54:  MOVLB  B
04B56:  MOVWF  x1F
04B58:  MOVLB  0
04B5A:  CALL   1C34
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
04B5E:  MOVLW  8A
04B60:  MOVWF  FF6
04B62:  MOVLW  02
04B64:  MOVWF  FF7
04B66:  MOVLW  00
04B68:  MOVWF  FF8
04B6A:  MOVLW  0A
04B6C:  MOVLB  A
04B6E:  MOVWF  x3B
04B70:  MOVLB  0
04B72:  CALL   3048
04B76:  MOVFF  F3,A25
04B7A:  MOVLW  18
04B7C:  MOVLB  A
04B7E:  MOVWF  x26
04B80:  MOVLB  0
04B82:  RCALL  4960
04B84:  MOVLW  0D
04B86:  MOVLB  B
04B88:  MOVWF  x1F
04B8A:  MOVLB  0
04B8C:  CALL   1C34
04B90:  MOVLW  0A
04B92:  MOVLB  B
04B94:  MOVWF  x1F
04B96:  MOVLB  0
04B98:  CALL   1C34
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
04B9C:  MOVLW  9A
04B9E:  MOVWF  FF6
04BA0:  MOVLW  02
04BA2:  MOVWF  FF7
04BA4:  MOVLW  00
04BA6:  MOVWF  FF8
04BA8:  MOVLW  19
04BAA:  MOVLB  A
04BAC:  MOVWF  x3B
04BAE:  MOVLB  0
04BB0:  CALL   3048
04BB4:  MOVFF  F4,A58
04BB8:  MOVLW  37
04BBA:  MOVLB  A
04BBC:  MOVWF  x59
04BBE:  MOVLB  0
04BC0:  CALL   3142
04BC4:  MOVLW  0D
04BC6:  MOVLB  B
04BC8:  MOVWF  x1F
04BCA:  MOVLB  0
04BCC:  CALL   1C34
04BD0:  MOVLW  0A
04BD2:  MOVLB  B
04BD4:  MOVWF  x1F
04BD6:  MOVLB  0
04BD8:  CALL   1C34
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
04BDC:  MOVLW  BC
04BDE:  MOVWF  FF6
04BE0:  MOVLW  02
04BE2:  MOVWF  FF7
04BE4:  MOVLW  00
04BE6:  MOVWF  FF8
04BE8:  MOVLW  15
04BEA:  MOVLB  A
04BEC:  MOVWF  x3B
04BEE:  MOVLB  0
04BF0:  CALL   3048
04BF4:  MOVFF  F6,A58
04BF8:  MOVLW  37
04BFA:  MOVLB  A
04BFC:  MOVWF  x59
04BFE:  MOVLB  0
04C00:  CALL   3142
04C04:  MOVLW  0D
04C06:  MOVLB  B
04C08:  MOVWF  x1F
04C0A:  MOVLB  0
04C0C:  CALL   1C34
04C10:  MOVLW  0A
04C12:  MOVLB  B
04C14:  MOVWF  x1F
04C16:  MOVLB  0
04C18:  CALL   1C34
....................     fprintf(PC, "\r\n"); 
04C1C:  MOVLW  0D
04C1E:  MOVLB  B
04C20:  MOVWF  x1F
04C22:  MOVLB  0
04C24:  CALL   1C34
04C28:  MOVLW  0A
04C2A:  MOVLB  B
04C2C:  MOVWF  x1F
04C2E:  MOVLB  0
04C30:  CALL   1C34
04C34:  RETURN 0
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "libuart.h" 
.................... #ifndef LIBUART_H 
.................... #define LIBUART_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... typedef struct message_config { 
....................     char identifier; // Message identifier 
....................     char length;     // Message length 
....................     int standard;    // Message follows standard structure (true/false) 
.................... } message_config; 
....................  
.................... message_config mconfig[] = { 
....................     { MSG_COMM, MSG_LENGTH_COMM, MSG_CHECKSUM_COMM }, 
....................     { MSG_PCIB, MSG_LENGTH_PCIB, MSG_CHECKSUM_PCIB }, 
....................     { MSG_RST, MSG_LENGTH_RST, MSG_CHECKSUM_RST }, 
....................     { MSG_FAB, MSG_LENGTH_FAB, MSG_CHECKSUM_FAB }, 
....................     { MSG_ADCS, MSG_LENGTH_ADCS, MSG_CHECKSUM_ADCS } 
.................... }; 
....................  
.................... message_config* message_COMM = &mconfig[0]; 
.................... message_config* message_PCIB = &mconfig[1]; 
.................... message_config* message_RST = &mconfig[2]; 
.................... message_config* message_FAB = &mconfig[3]; 
.................... message_config* message_ADCS = &mconfig[4]; 
....................  
.................... typedef uint8_t (*bytes_available_fn)(); 
.................... typedef uint8_t (*get_char_fn)(); 
.................... typedef void (*put_char_fn)(uint8_t data); 
....................  
.................... typedef struct uart_fn { 
....................     bytes_available_fn* bytes_available; 
....................     get_char_fn* get_char; 
....................     put_char_fn* put_char; 
.................... } uart_fn; 
....................  
.................... #define uart_simple(uart_stream)                       \ 
....................     inline uint8_t bytes_available_##uart_stream()     \ 
....................     {                                                  \ 
....................         return kbhit(uart_stream);                     \ 
....................     }                                                  \ 
....................     inline uint8_t get_character_##uart_stream()       \ 
....................     {                                                  \ 
....................         return fgetc(uart_stream);                     \ 
....................     }                                                  \ 
....................     inline void put_character_##uart_stream(uint8_t c) \ 
....................     {                                                  \ 
....................         fputc(c, uart_stream);                         \ 
....................     }                                                  \ 
....................     uart_fn uart_port_##uart_stream = { bytes_available_##uart_stream, &get_character_##uart_stream, &put_character_##uart_stream } 
....................  
.................... #define uart_use(uart_stream)                            \ 
....................     uart uart_##uart_stream;                             \ 
....................     char buffer_##uart_stream[MSG_LENGTH_##uart_stream]; \ 
....................     uart_simple(uart_stream) 
....................  
.................... #define uart_init(uart_stream)                          \ 
....................     uart_##uart_stream.data = &buffer_##uart_stream;    \ 
....................     uart_##uart_stream.size = MSG_LENGTH_##uart_stream; \ 
....................     uart_reset(&uart_##uart_stream) 
.................... #define uart_update(uart_stream, message_config) \ 
....................     uart_process(&uart_##uart_stream, message_config, fgetc(uart_stream)); 
.................... #define uart_update_all(uart_stream) \ 
....................     uart_process_all(&uart_##uart_stream, fgetc(uart_stream)); 
....................  
.................... #define uart_ready(uart_stream) uart_##uart_stream.state == ready 
.................... #define uart_message(uart_stream) uart_##uart_stream.data 
.................... #define uart_clean(uart_stream) uart_reset(&uart_##uart_stream) 
....................  
.................... enum state_en { 
....................     waiting, 
....................     receiving, 
....................     ready 
.................... }; 
....................  
.................... typedef struct uart { 
....................     char* data; 
....................     int size; 
....................     char* position; 
....................     char* end; 
....................     state_en state; 
....................     int standard; 
.................... } uart; 
....................  
.................... inline void uart_reset(uart* buffer) 
.................... { 
....................     buffer->position = buffer->data; 
*
00DEA:  MOVLW  03
00DEC:  ADDWF  x39,W
00DEE:  MOVWF  01
00DF0:  MOVLW  00
00DF2:  ADDWFC x3A,W
00DF4:  MOVFF  B39,FE9
00DF8:  MOVFF  B3A,FEA
00DFC:  MOVFF  FEC,03
00E00:  MOVF   FED,F
00E02:  MOVFF  FEF,B3D
00E06:  MOVWF  FEA
00E08:  MOVFF  01,FE9
00E0C:  MOVFF  03,FEC
00E10:  MOVF   FED,F
00E12:  MOVFF  B3D,FEF
*
011BA:  MOVLW  03
011BC:  ADDWF  x39,W
011BE:  MOVWF  01
011C0:  MOVLW  00
011C2:  ADDWFC x3A,W
011C4:  MOVFF  B39,FE9
011C8:  MOVFF  B3A,FEA
011CC:  MOVFF  FEC,03
011D0:  MOVF   FED,F
011D2:  MOVFF  FEF,B3D
011D6:  MOVWF  FEA
011D8:  MOVFF  01,FE9
011DC:  MOVFF  03,FEC
011E0:  MOVF   FED,F
011E2:  MOVFF  B3D,FEF
*
01598:  MOVLW  03
0159A:  ADDWF  x39,W
0159C:  MOVWF  01
0159E:  MOVLW  00
015A0:  ADDWFC x3A,W
015A2:  MOVFF  B39,FE9
015A6:  MOVFF  B3A,FEA
015AA:  MOVFF  FEC,03
015AE:  MOVF   FED,F
015B0:  MOVFF  FEF,B3D
015B4:  MOVWF  FEA
015B6:  MOVFF  01,FE9
015BA:  MOVFF  03,FEC
015BE:  MOVF   FED,F
015C0:  MOVFF  B3D,FEF
*
01968:  MOVLW  03
0196A:  ADDWF  x39,W
0196C:  MOVWF  01
0196E:  MOVLW  00
01970:  ADDWFC x3A,W
01972:  MOVFF  B39,FE9
01976:  MOVFF  B3A,FEA
0197A:  MOVFF  FEC,03
0197E:  MOVF   FED,F
01980:  MOVFF  FEF,B3D
01984:  MOVWF  FEA
01986:  MOVFF  01,FE9
0198A:  MOVFF  03,FEC
0198E:  MOVF   FED,F
01990:  MOVFF  B3D,FEF
*
07BAA:  MOVLW  03
07BAC:  ADDWF  x39,W
07BAE:  MOVWF  01
07BB0:  MOVLW  00
07BB2:  ADDWFC x3A,W
07BB4:  MOVFF  B39,FE9
07BB8:  MOVFF  B3A,FEA
07BBC:  MOVFF  FEC,03
07BC0:  MOVF   FED,F
07BC2:  MOVFF  FEF,B3D
07BC6:  MOVWF  FEA
07BC8:  MOVFF  01,FE9
07BCC:  MOVFF  03,FEC
07BD0:  MOVF   FED,F
07BD2:  MOVFF  B3D,FEF
*
07C48:  MOVLW  03
07C4A:  ADDWF  x39,W
07C4C:  MOVWF  01
07C4E:  MOVLW  00
07C50:  ADDWFC x3A,W
07C52:  MOVFF  B39,FE9
07C56:  MOVFF  B3A,FEA
07C5A:  MOVFF  FEC,03
07C5E:  MOVF   FED,F
07C60:  MOVFF  FEF,B3D
07C64:  MOVWF  FEA
07C66:  MOVFF  01,FE9
07C6A:  MOVFF  03,FEC
07C6E:  MOVF   FED,F
07C70:  MOVFF  B3D,FEF
*
07DA6:  MOVLW  03
07DA8:  ADDWF  x39,W
07DAA:  MOVWF  01
07DAC:  MOVLW  00
07DAE:  ADDWFC x3A,W
07DB0:  MOVFF  B39,FE9
07DB4:  MOVFF  B3A,FEA
07DB8:  MOVFF  FEC,03
07DBC:  MOVF   FED,F
07DBE:  MOVFF  FEF,B3D
07DC2:  MOVWF  FEA
07DC4:  MOVFF  01,FE9
07DC8:  MOVFF  03,FEC
07DCC:  MOVF   FED,F
07DCE:  MOVFF  B3D,FEF
*
0C43A:  MOVLW  03
0C43C:  ADDWF  x39,W
0C43E:  MOVWF  01
0C440:  MOVLW  00
0C442:  ADDWFC x3A,W
0C444:  MOVFF  B39,FE9
0C448:  MOVFF  B3A,FEA
0C44C:  MOVFF  FEC,03
0C450:  MOVF   FED,F
0C452:  MOVFF  FEF,B3D
0C456:  MOVWF  FEA
0C458:  MOVFF  01,FE9
0C45C:  MOVFF  03,FEC
0C460:  MOVF   FED,F
0C462:  MOVFF  B3D,FEF
*
0D1C6:  MOVLW  03
0D1C8:  ADDWF  x39,W
0D1CA:  MOVWF  01
0D1CC:  MOVLW  00
0D1CE:  ADDWFC x3A,W
0D1D0:  MOVFF  B39,FE9
0D1D4:  MOVFF  B3A,FEA
0D1D8:  MOVFF  FEC,03
0D1DC:  MOVF   FED,F
0D1DE:  MOVFF  FEF,B3D
0D1E2:  MOVWF  FEA
0D1E4:  MOVFF  01,FE9
0D1E8:  MOVFF  03,FEC
0D1EC:  MOVF   FED,F
0D1EE:  MOVFF  B3D,FEF
*
0D274:  MOVLW  03
0D276:  ADDWF  x39,W
0D278:  MOVWF  01
0D27A:  MOVLW  00
0D27C:  ADDWFC x3A,W
0D27E:  MOVFF  B39,FE9
0D282:  MOVFF  B3A,FEA
0D286:  MOVFF  FEC,03
0D28A:  MOVF   FED,F
0D28C:  MOVFF  FEF,B3D
0D290:  MOVWF  FEA
0D292:  MOVFF  01,FE9
0D296:  MOVFF  03,FEC
0D29A:  MOVF   FED,F
0D29C:  MOVFF  B3D,FEF
*
0D322:  MOVLW  03
0D324:  ADDWF  x39,W
0D326:  MOVWF  01
0D328:  MOVLW  00
0D32A:  ADDWFC x3A,W
0D32C:  MOVFF  B39,FE9
0D330:  MOVFF  B3A,FEA
0D334:  MOVFF  FEC,03
0D338:  MOVF   FED,F
0D33A:  MOVFF  FEF,B3D
0D33E:  MOVWF  FEA
0D340:  MOVFF  01,FE9
0D344:  MOVFF  03,FEC
0D348:  MOVF   FED,F
0D34A:  MOVFF  B3D,FEF
*
0D3CE:  MOVLW  03
0D3D0:  ADDWF  x39,W
0D3D2:  MOVWF  01
0D3D4:  MOVLW  00
0D3D6:  ADDWFC x3A,W
0D3D8:  MOVFF  B39,FE9
0D3DC:  MOVFF  B3A,FEA
0D3E0:  MOVFF  FEC,03
0D3E4:  MOVF   FED,F
0D3E6:  MOVFF  FEF,B3D
0D3EA:  MOVWF  FEA
0D3EC:  MOVFF  01,FE9
0D3F0:  MOVFF  03,FEC
0D3F4:  MOVF   FED,F
0D3F6:  MOVFF  B3D,FEF
*
0D47A:  MOVLW  03
0D47C:  ADDWF  x39,W
0D47E:  MOVWF  01
0D480:  MOVLW  00
0D482:  ADDWFC x3A,W
0D484:  MOVFF  B39,FE9
0D488:  MOVFF  B3A,FEA
0D48C:  MOVFF  FEC,03
0D490:  MOVF   FED,F
0D492:  MOVFF  FEF,B3D
0D496:  MOVWF  FEA
0D498:  MOVFF  01,FE9
0D49C:  MOVFF  03,FEC
0D4A0:  MOVF   FED,F
0D4A2:  MOVFF  B3D,FEF
*
0D526:  MOVLW  03
0D528:  ADDWF  x39,W
0D52A:  MOVWF  01
0D52C:  MOVLW  00
0D52E:  ADDWFC x3A,W
0D530:  MOVFF  B39,FE9
0D534:  MOVFF  B3A,FEA
0D538:  MOVFF  FEC,03
0D53C:  MOVF   FED,F
0D53E:  MOVFF  FEF,B3D
0D542:  MOVWF  FEA
0D544:  MOVFF  01,FE9
0D548:  MOVFF  03,FEC
0D54C:  MOVF   FED,F
0D54E:  MOVFF  B3D,FEF
*
0E2A8:  MOVLW  03
0E2AA:  ADDWF  x39,W
0E2AC:  MOVWF  01
0E2AE:  MOVLW  00
0E2B0:  ADDWFC x3A,W
0E2B2:  MOVFF  B39,FE9
0E2B6:  MOVFF  B3A,FEA
0E2BA:  MOVFF  FEC,03
0E2BE:  MOVF   FED,F
0E2C0:  MOVFF  FEF,B3D
0E2C4:  MOVWF  FEA
0E2C6:  MOVFF  01,FE9
0E2CA:  MOVFF  03,FEC
0E2CE:  MOVF   FED,F
0E2D0:  MOVFF  B3D,FEF
*
0E316:  MOVLW  03
0E318:  ADDWF  x39,W
0E31A:  MOVWF  01
0E31C:  MOVLW  00
0E31E:  ADDWFC x3A,W
0E320:  MOVFF  B39,FE9
0E324:  MOVFF  B3A,FEA
0E328:  MOVFF  FEC,03
0E32C:  MOVF   FED,F
0E32E:  MOVFF  FEF,B3D
0E332:  MOVWF  FEA
0E334:  MOVFF  01,FE9
0E338:  MOVFF  03,FEC
0E33C:  MOVF   FED,F
0E33E:  MOVFF  B3D,FEF
*
0E384:  MOVLW  03
0E386:  ADDWF  x39,W
0E388:  MOVWF  01
0E38A:  MOVLW  00
0E38C:  ADDWFC x3A,W
0E38E:  MOVFF  B39,FE9
0E392:  MOVFF  B3A,FEA
0E396:  MOVFF  FEC,03
0E39A:  MOVF   FED,F
0E39C:  MOVFF  FEF,B3D
0E3A0:  MOVWF  FEA
0E3A2:  MOVFF  01,FE9
0E3A6:  MOVFF  03,FEC
0E3AA:  MOVF   FED,F
0E3AC:  MOVFF  B3D,FEF
*
0E3F2:  MOVLW  03
0E3F4:  ADDWF  x39,W
0E3F6:  MOVWF  01
0E3F8:  MOVLW  00
0E3FA:  ADDWFC x3A,W
0E3FC:  MOVFF  B39,FE9
0E400:  MOVFF  B3A,FEA
0E404:  MOVFF  FEC,03
0E408:  MOVF   FED,F
0E40A:  MOVFF  FEF,B3D
0E40E:  MOVWF  FEA
0E410:  MOVFF  01,FE9
0E414:  MOVFF  03,FEC
0E418:  MOVF   FED,F
0E41A:  MOVFF  B3D,FEF
*
0E77C:  MOVLW  03
0E77E:  ADDWF  x39,W
0E780:  MOVWF  01
0E782:  MOVLW  00
0E784:  ADDWFC x3A,W
0E786:  MOVFF  B39,FE9
0E78A:  MOVFF  B3A,FEA
0E78E:  MOVFF  FEC,03
0E792:  MOVF   FED,F
0E794:  MOVFF  FEF,B3D
0E798:  MOVWF  FEA
0E79A:  MOVFF  01,FE9
0E79E:  MOVFF  03,FEC
0E7A2:  MOVF   FED,F
0E7A4:  MOVFF  B3D,FEF
*
0E7FA:  MOVLW  03
0E7FC:  ADDWF  x39,W
0E7FE:  MOVWF  01
0E800:  MOVLW  00
0E802:  ADDWFC x3A,W
0E804:  MOVFF  B39,FE9
0E808:  MOVFF  B3A,FEA
0E80C:  MOVFF  FEC,03
0E810:  MOVF   FED,F
0E812:  MOVFF  FEF,B3D
0E816:  MOVWF  FEA
0E818:  MOVFF  01,FE9
0E81C:  MOVFF  03,FEC
0E820:  MOVF   FED,F
0E822:  MOVFF  B3D,FEF
*
0E878:  MOVLW  03
0E87A:  ADDWF  x39,W
0E87C:  MOVWF  01
0E87E:  MOVLW  00
0E880:  ADDWFC x3A,W
0E882:  MOVFF  B39,FE9
0E886:  MOVFF  B3A,FEA
0E88A:  MOVFF  FEC,03
0E88E:  MOVF   FED,F
0E890:  MOVFF  FEF,B3D
0E894:  MOVWF  FEA
0E896:  MOVFF  01,FE9
0E89A:  MOVFF  03,FEC
0E89E:  MOVF   FED,F
0E8A0:  MOVFF  B3D,FEF
*
0E8F6:  MOVLW  03
0E8F8:  ADDWF  x39,W
0E8FA:  MOVWF  01
0E8FC:  MOVLW  00
0E8FE:  ADDWFC x3A,W
0E900:  MOVFF  B39,FE9
0E904:  MOVFF  B3A,FEA
0E908:  MOVFF  FEC,03
0E90C:  MOVF   FED,F
0E90E:  MOVFF  FEF,B3D
0E912:  MOVWF  FEA
0E914:  MOVFF  01,FE9
0E918:  MOVFF  03,FEC
0E91C:  MOVF   FED,F
0E91E:  MOVFF  B3D,FEF
*
0E974:  MOVLW  03
0E976:  ADDWF  x39,W
0E978:  MOVWF  01
0E97A:  MOVLW  00
0E97C:  ADDWFC x3A,W
0E97E:  MOVFF  B39,FE9
0E982:  MOVFF  B3A,FEA
0E986:  MOVFF  FEC,03
0E98A:  MOVF   FED,F
0E98C:  MOVFF  FEF,B3D
0E990:  MOVWF  FEA
0E992:  MOVFF  01,FE9
0E996:  MOVFF  03,FEC
0E99A:  MOVF   FED,F
0E99C:  MOVFF  B3D,FEF
*
0E9F2:  MOVLW  03
0E9F4:  ADDWF  x39,W
0E9F6:  MOVWF  01
0E9F8:  MOVLW  00
0E9FA:  ADDWFC x3A,W
0E9FC:  MOVFF  B39,FE9
0EA00:  MOVFF  B3A,FEA
0EA04:  MOVFF  FEC,03
0EA08:  MOVF   FED,F
0EA0A:  MOVFF  FEF,B3D
0EA0E:  MOVWF  FEA
0EA10:  MOVFF  01,FE9
0EA14:  MOVFF  03,FEC
0EA18:  MOVF   FED,F
0EA1A:  MOVFF  B3D,FEF
*
0EF68:  MOVLW  03
0EF6A:  ADDWF  x39,W
0EF6C:  MOVWF  01
0EF6E:  MOVLW  00
0EF70:  ADDWFC x3A,W
0EF72:  MOVFF  B39,FE9
0EF76:  MOVFF  B3A,FEA
0EF7A:  MOVFF  FEC,03
0EF7E:  MOVF   FED,F
0EF80:  MOVFF  FEF,B3D
0EF84:  MOVWF  FEA
0EF86:  MOVFF  01,FE9
0EF8A:  MOVFF  03,FEC
0EF8E:  MOVF   FED,F
0EF90:  MOVFF  B3D,FEF
*
0F320:  MOVLW  03
0F322:  ADDWF  x39,W
0F324:  MOVWF  01
0F326:  MOVLW  00
0F328:  ADDWFC x3A,W
0F32A:  MOVFF  B39,FE9
0F32E:  MOVFF  B3A,FEA
0F332:  MOVFF  FEC,03
0F336:  MOVF   FED,F
0F338:  MOVFF  FEF,B3D
0F33C:  MOVWF  FEA
0F33E:  MOVFF  01,FE9
0F342:  MOVFF  03,FEC
0F346:  MOVF   FED,F
0F348:  MOVFF  B3D,FEF
....................     buffer->end = buffer->data; 
*
00E16:  MOVLW  05
00E18:  ADDWF  x39,W
00E1A:  MOVWF  01
00E1C:  MOVLW  00
00E1E:  ADDWFC x3A,W
00E20:  MOVFF  B39,FE9
00E24:  MOVFF  B3A,FEA
00E28:  MOVFF  FEC,03
00E2C:  MOVF   FED,F
00E2E:  MOVFF  FEF,B3D
00E32:  MOVWF  FEA
00E34:  MOVFF  01,FE9
00E38:  MOVFF  03,FEC
00E3C:  MOVF   FED,F
00E3E:  MOVFF  B3D,FEF
*
011E6:  MOVLW  05
011E8:  ADDWF  x39,W
011EA:  MOVWF  01
011EC:  MOVLW  00
011EE:  ADDWFC x3A,W
011F0:  MOVFF  B39,FE9
011F4:  MOVFF  B3A,FEA
011F8:  MOVFF  FEC,03
011FC:  MOVF   FED,F
011FE:  MOVFF  FEF,B3D
01202:  MOVWF  FEA
01204:  MOVFF  01,FE9
01208:  MOVFF  03,FEC
0120C:  MOVF   FED,F
0120E:  MOVFF  B3D,FEF
*
015C4:  MOVLW  05
015C6:  ADDWF  x39,W
015C8:  MOVWF  01
015CA:  MOVLW  00
015CC:  ADDWFC x3A,W
015CE:  MOVFF  B39,FE9
015D2:  MOVFF  B3A,FEA
015D6:  MOVFF  FEC,03
015DA:  MOVF   FED,F
015DC:  MOVFF  FEF,B3D
015E0:  MOVWF  FEA
015E2:  MOVFF  01,FE9
015E6:  MOVFF  03,FEC
015EA:  MOVF   FED,F
015EC:  MOVFF  B3D,FEF
*
01994:  MOVLW  05
01996:  ADDWF  x39,W
01998:  MOVWF  01
0199A:  MOVLW  00
0199C:  ADDWFC x3A,W
0199E:  MOVFF  B39,FE9
019A2:  MOVFF  B3A,FEA
019A6:  MOVFF  FEC,03
019AA:  MOVF   FED,F
019AC:  MOVFF  FEF,B3D
019B0:  MOVWF  FEA
019B2:  MOVFF  01,FE9
019B6:  MOVFF  03,FEC
019BA:  MOVF   FED,F
019BC:  MOVFF  B3D,FEF
*
07BD6:  MOVLW  05
07BD8:  ADDWF  x39,W
07BDA:  MOVWF  01
07BDC:  MOVLW  00
07BDE:  ADDWFC x3A,W
07BE0:  MOVFF  B39,FE9
07BE4:  MOVFF  B3A,FEA
07BE8:  MOVFF  FEC,03
07BEC:  MOVF   FED,F
07BEE:  MOVFF  FEF,B3D
07BF2:  MOVWF  FEA
07BF4:  MOVFF  01,FE9
07BF8:  MOVFF  03,FEC
07BFC:  MOVF   FED,F
07BFE:  MOVFF  B3D,FEF
*
07C74:  MOVLW  05
07C76:  ADDWF  x39,W
07C78:  MOVWF  01
07C7A:  MOVLW  00
07C7C:  ADDWFC x3A,W
07C7E:  MOVFF  B39,FE9
07C82:  MOVFF  B3A,FEA
07C86:  MOVFF  FEC,03
07C8A:  MOVF   FED,F
07C8C:  MOVFF  FEF,B3D
07C90:  MOVWF  FEA
07C92:  MOVFF  01,FE9
07C96:  MOVFF  03,FEC
07C9A:  MOVF   FED,F
07C9C:  MOVFF  B3D,FEF
*
07DD2:  MOVLW  05
07DD4:  ADDWF  x39,W
07DD6:  MOVWF  01
07DD8:  MOVLW  00
07DDA:  ADDWFC x3A,W
07DDC:  MOVFF  B39,FE9
07DE0:  MOVFF  B3A,FEA
07DE4:  MOVFF  FEC,03
07DE8:  MOVF   FED,F
07DEA:  MOVFF  FEF,B3D
07DEE:  MOVWF  FEA
07DF0:  MOVFF  01,FE9
07DF4:  MOVFF  03,FEC
07DF8:  MOVF   FED,F
07DFA:  MOVFF  B3D,FEF
*
0C466:  MOVLW  05
0C468:  ADDWF  x39,W
0C46A:  MOVWF  01
0C46C:  MOVLW  00
0C46E:  ADDWFC x3A,W
0C470:  MOVFF  B39,FE9
0C474:  MOVFF  B3A,FEA
0C478:  MOVFF  FEC,03
0C47C:  MOVF   FED,F
0C47E:  MOVFF  FEF,B3D
0C482:  MOVWF  FEA
0C484:  MOVFF  01,FE9
0C488:  MOVFF  03,FEC
0C48C:  MOVF   FED,F
0C48E:  MOVFF  B3D,FEF
*
0D1F2:  MOVLW  05
0D1F4:  ADDWF  x39,W
0D1F6:  MOVWF  01
0D1F8:  MOVLW  00
0D1FA:  ADDWFC x3A,W
0D1FC:  MOVFF  B39,FE9
0D200:  MOVFF  B3A,FEA
0D204:  MOVFF  FEC,03
0D208:  MOVF   FED,F
0D20A:  MOVFF  FEF,B3D
0D20E:  MOVWF  FEA
0D210:  MOVFF  01,FE9
0D214:  MOVFF  03,FEC
0D218:  MOVF   FED,F
0D21A:  MOVFF  B3D,FEF
*
0D2A0:  MOVLW  05
0D2A2:  ADDWF  x39,W
0D2A4:  MOVWF  01
0D2A6:  MOVLW  00
0D2A8:  ADDWFC x3A,W
0D2AA:  MOVFF  B39,FE9
0D2AE:  MOVFF  B3A,FEA
0D2B2:  MOVFF  FEC,03
0D2B6:  MOVF   FED,F
0D2B8:  MOVFF  FEF,B3D
0D2BC:  MOVWF  FEA
0D2BE:  MOVFF  01,FE9
0D2C2:  MOVFF  03,FEC
0D2C6:  MOVF   FED,F
0D2C8:  MOVFF  B3D,FEF
*
0D34E:  MOVLW  05
0D350:  ADDWF  x39,W
0D352:  MOVWF  01
0D354:  MOVLW  00
0D356:  ADDWFC x3A,W
0D358:  MOVFF  B39,FE9
0D35C:  MOVFF  B3A,FEA
0D360:  MOVFF  FEC,03
0D364:  MOVF   FED,F
0D366:  MOVFF  FEF,B3D
0D36A:  MOVWF  FEA
0D36C:  MOVFF  01,FE9
0D370:  MOVFF  03,FEC
0D374:  MOVF   FED,F
0D376:  MOVFF  B3D,FEF
*
0D3FA:  MOVLW  05
0D3FC:  ADDWF  x39,W
0D3FE:  MOVWF  01
0D400:  MOVLW  00
0D402:  ADDWFC x3A,W
0D404:  MOVFF  B39,FE9
0D408:  MOVFF  B3A,FEA
0D40C:  MOVFF  FEC,03
0D410:  MOVF   FED,F
0D412:  MOVFF  FEF,B3D
0D416:  MOVWF  FEA
0D418:  MOVFF  01,FE9
0D41C:  MOVFF  03,FEC
0D420:  MOVF   FED,F
0D422:  MOVFF  B3D,FEF
*
0D4A6:  MOVLW  05
0D4A8:  ADDWF  x39,W
0D4AA:  MOVWF  01
0D4AC:  MOVLW  00
0D4AE:  ADDWFC x3A,W
0D4B0:  MOVFF  B39,FE9
0D4B4:  MOVFF  B3A,FEA
0D4B8:  MOVFF  FEC,03
0D4BC:  MOVF   FED,F
0D4BE:  MOVFF  FEF,B3D
0D4C2:  MOVWF  FEA
0D4C4:  MOVFF  01,FE9
0D4C8:  MOVFF  03,FEC
0D4CC:  MOVF   FED,F
0D4CE:  MOVFF  B3D,FEF
*
0D552:  MOVLW  05
0D554:  ADDWF  x39,W
0D556:  MOVWF  01
0D558:  MOVLW  00
0D55A:  ADDWFC x3A,W
0D55C:  MOVFF  B39,FE9
0D560:  MOVFF  B3A,FEA
0D564:  MOVFF  FEC,03
0D568:  MOVF   FED,F
0D56A:  MOVFF  FEF,B3D
0D56E:  MOVWF  FEA
0D570:  MOVFF  01,FE9
0D574:  MOVFF  03,FEC
0D578:  MOVF   FED,F
0D57A:  MOVFF  B3D,FEF
*
0E2D4:  MOVLW  05
0E2D6:  ADDWF  x39,W
0E2D8:  MOVWF  01
0E2DA:  MOVLW  00
0E2DC:  ADDWFC x3A,W
0E2DE:  MOVFF  B39,FE9
0E2E2:  MOVFF  B3A,FEA
0E2E6:  MOVFF  FEC,03
0E2EA:  MOVF   FED,F
0E2EC:  MOVFF  FEF,B3D
0E2F0:  MOVWF  FEA
0E2F2:  MOVFF  01,FE9
0E2F6:  MOVFF  03,FEC
0E2FA:  MOVF   FED,F
0E2FC:  MOVFF  B3D,FEF
*
0E342:  MOVLW  05
0E344:  ADDWF  x39,W
0E346:  MOVWF  01
0E348:  MOVLW  00
0E34A:  ADDWFC x3A,W
0E34C:  MOVFF  B39,FE9
0E350:  MOVFF  B3A,FEA
0E354:  MOVFF  FEC,03
0E358:  MOVF   FED,F
0E35A:  MOVFF  FEF,B3D
0E35E:  MOVWF  FEA
0E360:  MOVFF  01,FE9
0E364:  MOVFF  03,FEC
0E368:  MOVF   FED,F
0E36A:  MOVFF  B3D,FEF
*
0E3B0:  MOVLW  05
0E3B2:  ADDWF  x39,W
0E3B4:  MOVWF  01
0E3B6:  MOVLW  00
0E3B8:  ADDWFC x3A,W
0E3BA:  MOVFF  B39,FE9
0E3BE:  MOVFF  B3A,FEA
0E3C2:  MOVFF  FEC,03
0E3C6:  MOVF   FED,F
0E3C8:  MOVFF  FEF,B3D
0E3CC:  MOVWF  FEA
0E3CE:  MOVFF  01,FE9
0E3D2:  MOVFF  03,FEC
0E3D6:  MOVF   FED,F
0E3D8:  MOVFF  B3D,FEF
*
0E41E:  MOVLW  05
0E420:  ADDWF  x39,W
0E422:  MOVWF  01
0E424:  MOVLW  00
0E426:  ADDWFC x3A,W
0E428:  MOVFF  B39,FE9
0E42C:  MOVFF  B3A,FEA
0E430:  MOVFF  FEC,03
0E434:  MOVF   FED,F
0E436:  MOVFF  FEF,B3D
0E43A:  MOVWF  FEA
0E43C:  MOVFF  01,FE9
0E440:  MOVFF  03,FEC
0E444:  MOVF   FED,F
0E446:  MOVFF  B3D,FEF
*
0E7A8:  MOVLW  05
0E7AA:  ADDWF  x39,W
0E7AC:  MOVWF  01
0E7AE:  MOVLW  00
0E7B0:  ADDWFC x3A,W
0E7B2:  MOVFF  B39,FE9
0E7B6:  MOVFF  B3A,FEA
0E7BA:  MOVFF  FEC,03
0E7BE:  MOVF   FED,F
0E7C0:  MOVFF  FEF,B3D
0E7C4:  MOVWF  FEA
0E7C6:  MOVFF  01,FE9
0E7CA:  MOVFF  03,FEC
0E7CE:  MOVF   FED,F
0E7D0:  MOVFF  B3D,FEF
*
0E826:  MOVLW  05
0E828:  ADDWF  x39,W
0E82A:  MOVWF  01
0E82C:  MOVLW  00
0E82E:  ADDWFC x3A,W
0E830:  MOVFF  B39,FE9
0E834:  MOVFF  B3A,FEA
0E838:  MOVFF  FEC,03
0E83C:  MOVF   FED,F
0E83E:  MOVFF  FEF,B3D
0E842:  MOVWF  FEA
0E844:  MOVFF  01,FE9
0E848:  MOVFF  03,FEC
0E84C:  MOVF   FED,F
0E84E:  MOVFF  B3D,FEF
*
0E8A4:  MOVLW  05
0E8A6:  ADDWF  x39,W
0E8A8:  MOVWF  01
0E8AA:  MOVLW  00
0E8AC:  ADDWFC x3A,W
0E8AE:  MOVFF  B39,FE9
0E8B2:  MOVFF  B3A,FEA
0E8B6:  MOVFF  FEC,03
0E8BA:  MOVF   FED,F
0E8BC:  MOVFF  FEF,B3D
0E8C0:  MOVWF  FEA
0E8C2:  MOVFF  01,FE9
0E8C6:  MOVFF  03,FEC
0E8CA:  MOVF   FED,F
0E8CC:  MOVFF  B3D,FEF
*
0E922:  MOVLW  05
0E924:  ADDWF  x39,W
0E926:  MOVWF  01
0E928:  MOVLW  00
0E92A:  ADDWFC x3A,W
0E92C:  MOVFF  B39,FE9
0E930:  MOVFF  B3A,FEA
0E934:  MOVFF  FEC,03
0E938:  MOVF   FED,F
0E93A:  MOVFF  FEF,B3D
0E93E:  MOVWF  FEA
0E940:  MOVFF  01,FE9
0E944:  MOVFF  03,FEC
0E948:  MOVF   FED,F
0E94A:  MOVFF  B3D,FEF
*
0E9A0:  MOVLW  05
0E9A2:  ADDWF  x39,W
0E9A4:  MOVWF  01
0E9A6:  MOVLW  00
0E9A8:  ADDWFC x3A,W
0E9AA:  MOVFF  B39,FE9
0E9AE:  MOVFF  B3A,FEA
0E9B2:  MOVFF  FEC,03
0E9B6:  MOVF   FED,F
0E9B8:  MOVFF  FEF,B3D
0E9BC:  MOVWF  FEA
0E9BE:  MOVFF  01,FE9
0E9C2:  MOVFF  03,FEC
0E9C6:  MOVF   FED,F
0E9C8:  MOVFF  B3D,FEF
*
0EA1E:  MOVLW  05
0EA20:  ADDWF  x39,W
0EA22:  MOVWF  01
0EA24:  MOVLW  00
0EA26:  ADDWFC x3A,W
0EA28:  MOVFF  B39,FE9
0EA2C:  MOVFF  B3A,FEA
0EA30:  MOVFF  FEC,03
0EA34:  MOVF   FED,F
0EA36:  MOVFF  FEF,B3D
0EA3A:  MOVWF  FEA
0EA3C:  MOVFF  01,FE9
0EA40:  MOVFF  03,FEC
0EA44:  MOVF   FED,F
0EA46:  MOVFF  B3D,FEF
*
0EF94:  MOVLW  05
0EF96:  ADDWF  x39,W
0EF98:  MOVWF  01
0EF9A:  MOVLW  00
0EF9C:  ADDWFC x3A,W
0EF9E:  MOVFF  B39,FE9
0EFA2:  MOVFF  B3A,FEA
0EFA6:  MOVFF  FEC,03
0EFAA:  MOVF   FED,F
0EFAC:  MOVFF  FEF,B3D
0EFB0:  MOVWF  FEA
0EFB2:  MOVFF  01,FE9
0EFB6:  MOVFF  03,FEC
0EFBA:  MOVF   FED,F
0EFBC:  MOVFF  B3D,FEF
*
0F34C:  MOVLW  05
0F34E:  ADDWF  x39,W
0F350:  MOVWF  01
0F352:  MOVLW  00
0F354:  ADDWFC x3A,W
0F356:  MOVFF  B39,FE9
0F35A:  MOVFF  B3A,FEA
0F35E:  MOVFF  FEC,03
0F362:  MOVF   FED,F
0F364:  MOVFF  FEF,B3D
0F368:  MOVWF  FEA
0F36A:  MOVFF  01,FE9
0F36E:  MOVFF  03,FEC
0F372:  MOVF   FED,F
0F374:  MOVFF  B3D,FEF
....................     buffer->state = waiting; 
*
00E42:  MOVLW  07
00E44:  ADDWF  x39,W
00E46:  MOVWF  FE9
00E48:  MOVLW  00
00E4A:  ADDWFC x3A,W
00E4C:  MOVWF  FEA
00E4E:  CLRF   FEF
*
01212:  MOVLW  07
01214:  ADDWF  x39,W
01216:  MOVWF  FE9
01218:  MOVLW  00
0121A:  ADDWFC x3A,W
0121C:  MOVWF  FEA
0121E:  CLRF   FEF
*
015F0:  MOVLW  07
015F2:  ADDWF  x39,W
015F4:  MOVWF  FE9
015F6:  MOVLW  00
015F8:  ADDWFC x3A,W
015FA:  MOVWF  FEA
015FC:  CLRF   FEF
*
019C0:  MOVLW  07
019C2:  ADDWF  x39,W
019C4:  MOVWF  FE9
019C6:  MOVLW  00
019C8:  ADDWFC x3A,W
019CA:  MOVWF  FEA
019CC:  CLRF   FEF
*
07C02:  MOVLW  07
07C04:  ADDWF  x39,W
07C06:  MOVWF  FE9
07C08:  MOVLW  00
07C0A:  ADDWFC x3A,W
07C0C:  MOVWF  FEA
07C0E:  CLRF   FEF
*
07CA0:  MOVLW  07
07CA2:  ADDWF  x39,W
07CA4:  MOVWF  FE9
07CA6:  MOVLW  00
07CA8:  ADDWFC x3A,W
07CAA:  MOVWF  FEA
07CAC:  CLRF   FEF
*
07DFE:  MOVLW  07
07E00:  ADDWF  x39,W
07E02:  MOVWF  FE9
07E04:  MOVLW  00
07E06:  ADDWFC x3A,W
07E08:  MOVWF  FEA
07E0A:  CLRF   FEF
*
0C492:  MOVLW  07
0C494:  ADDWF  x39,W
0C496:  MOVWF  FE9
0C498:  MOVLW  00
0C49A:  ADDWFC x3A,W
0C49C:  MOVWF  FEA
0C49E:  CLRF   FEF
*
0D21E:  MOVLW  07
0D220:  ADDWF  x39,W
0D222:  MOVWF  FE9
0D224:  MOVLW  00
0D226:  ADDWFC x3A,W
0D228:  MOVWF  FEA
0D22A:  CLRF   FEF
0D22C:  MOVLB  8
*
0D2CC:  MOVLW  07
0D2CE:  ADDWF  x39,W
0D2D0:  MOVWF  FE9
0D2D2:  MOVLW  00
0D2D4:  ADDWFC x3A,W
0D2D6:  MOVWF  FEA
0D2D8:  CLRF   FEF
0D2DA:  MOVLB  7
*
0D37A:  MOVLW  07
0D37C:  ADDWF  x39,W
0D37E:  MOVWF  FE9
0D380:  MOVLW  00
0D382:  ADDWFC x3A,W
0D384:  MOVWF  FEA
0D386:  CLRF   FEF
0D388:  MOVLB  8
*
0D426:  MOVLW  07
0D428:  ADDWF  x39,W
0D42A:  MOVWF  FE9
0D42C:  MOVLW  00
0D42E:  ADDWFC x3A,W
0D430:  MOVWF  FEA
0D432:  CLRF   FEF
0D434:  MOVLB  8
*
0D4D2:  MOVLW  07
0D4D4:  ADDWF  x39,W
0D4D6:  MOVWF  FE9
0D4D8:  MOVLW  00
0D4DA:  ADDWFC x3A,W
0D4DC:  MOVWF  FEA
0D4DE:  CLRF   FEF
0D4E0:  MOVLB  8
*
0D57E:  MOVLW  07
0D580:  ADDWF  x39,W
0D582:  MOVWF  FE9
0D584:  MOVLW  00
0D586:  ADDWFC x3A,W
0D588:  MOVWF  FEA
0D58A:  CLRF   FEF
0D58C:  MOVLB  7
*
0E300:  MOVLW  07
0E302:  ADDWF  x39,W
0E304:  MOVWF  FE9
0E306:  MOVLW  00
0E308:  ADDWFC x3A,W
0E30A:  MOVWF  FEA
0E30C:  CLRF   FEF
*
0E36E:  MOVLW  07
0E370:  ADDWF  x39,W
0E372:  MOVWF  FE9
0E374:  MOVLW  00
0E376:  ADDWFC x3A,W
0E378:  MOVWF  FEA
0E37A:  CLRF   FEF
*
0E3DC:  MOVLW  07
0E3DE:  ADDWF  x39,W
0E3E0:  MOVWF  FE9
0E3E2:  MOVLW  00
0E3E4:  ADDWFC x3A,W
0E3E6:  MOVWF  FEA
0E3E8:  CLRF   FEF
*
0E44A:  MOVLW  07
0E44C:  ADDWF  x39,W
0E44E:  MOVWF  FE9
0E450:  MOVLW  00
0E452:  ADDWFC x3A,W
0E454:  MOVWF  FEA
0E456:  CLRF   FEF
*
0E7D4:  MOVLW  07
0E7D6:  ADDWF  x39,W
0E7D8:  MOVWF  FE9
0E7DA:  MOVLW  00
0E7DC:  ADDWFC x3A,W
0E7DE:  MOVWF  FEA
0E7E0:  CLRF   FEF
*
0E852:  MOVLW  07
0E854:  ADDWF  x39,W
0E856:  MOVWF  FE9
0E858:  MOVLW  00
0E85A:  ADDWFC x3A,W
0E85C:  MOVWF  FEA
0E85E:  CLRF   FEF
*
0E8D0:  MOVLW  07
0E8D2:  ADDWF  x39,W
0E8D4:  MOVWF  FE9
0E8D6:  MOVLW  00
0E8D8:  ADDWFC x3A,W
0E8DA:  MOVWF  FEA
0E8DC:  CLRF   FEF
*
0E94E:  MOVLW  07
0E950:  ADDWF  x39,W
0E952:  MOVWF  FE9
0E954:  MOVLW  00
0E956:  ADDWFC x3A,W
0E958:  MOVWF  FEA
0E95A:  CLRF   FEF
*
0E9CC:  MOVLW  07
0E9CE:  ADDWF  x39,W
0E9D0:  MOVWF  FE9
0E9D2:  MOVLW  00
0E9D4:  ADDWFC x3A,W
0E9D6:  MOVWF  FEA
0E9D8:  CLRF   FEF
*
0EA4A:  MOVLW  07
0EA4C:  ADDWF  x39,W
0EA4E:  MOVWF  FE9
0EA50:  MOVLW  00
0EA52:  ADDWFC x3A,W
0EA54:  MOVWF  FEA
0EA56:  CLRF   FEF
*
0EFC0:  MOVLW  07
0EFC2:  ADDWF  x39,W
0EFC4:  MOVWF  FE9
0EFC6:  MOVLW  00
0EFC8:  ADDWFC x3A,W
0EFCA:  MOVWF  FEA
0EFCC:  CLRF   FEF
0EFCE:  MOVLB  0
*
0F378:  MOVLW  07
0F37A:  ADDWF  x39,W
0F37C:  MOVWF  FE9
0F37E:  MOVLW  00
0F380:  ADDWFC x3A,W
0F382:  MOVWF  FEA
0F384:  CLRF   FEF
0F386:  MOVLB  0
.................... } 
....................  
.................... inline void check_string(uart* buffer) 
*
00C08:  CLRF   x3B
*
00FD8:  CLRF   x3B
*
013B6:  CLRF   x3B
*
01786:  CLRF   x3B
*
0ED86:  CLRF   x3B
*
0F13E:  CLRF   x3B
.................... { 
....................     unsigned int checksum = 0; 
....................     if (!buffer->standard) { 
*
00C0A:  MOVLW  08
00C0C:  ADDWF  x39,W
00C0E:  MOVWF  FE9
00C10:  MOVLW  00
00C12:  ADDWFC x3A,W
00C14:  MOVWF  FEA
00C16:  MOVF   FEF,F
00C18:  BNZ   0C2C
*
00FDA:  MOVLW  08
00FDC:  ADDWF  x39,W
00FDE:  MOVWF  FE9
00FE0:  MOVLW  00
00FE2:  ADDWFC x3A,W
00FE4:  MOVWF  FEA
00FE6:  MOVF   FEF,F
00FE8:  BNZ   0FFC
*
013B8:  MOVLW  08
013BA:  ADDWF  x39,W
013BC:  MOVWF  FE9
013BE:  MOVLW  00
013C0:  ADDWFC x3A,W
013C2:  MOVWF  FEA
013C4:  MOVF   FEF,F
013C6:  BNZ   13DA
*
01788:  MOVLW  08
0178A:  ADDWF  x39,W
0178C:  MOVWF  FE9
0178E:  MOVLW  00
01790:  ADDWFC x3A,W
01792:  MOVWF  FEA
01794:  MOVF   FEF,F
01796:  BNZ   17AA
*
0ED88:  MOVLW  08
0ED8A:  ADDWF  x39,W
0ED8C:  MOVWF  FE9
0ED8E:  MOVLW  00
0ED90:  ADDWFC x3A,W
0ED92:  MOVWF  FEA
0ED94:  MOVF   FEF,F
0ED96:  BNZ   EDAA
*
0F140:  MOVLW  08
0F142:  ADDWF  x39,W
0F144:  MOVWF  FE9
0F146:  MOVLW  00
0F148:  ADDWFC x3A,W
0F14A:  MOVWF  FEA
0F14C:  MOVF   FEF,F
0F14E:  BNZ   F162
....................         buffer->state = ready; 
*
00C1A:  MOVLW  07
00C1C:  ADDWF  x39,W
00C1E:  MOVWF  FE9
00C20:  MOVLW  00
00C22:  ADDWFC x3A,W
00C24:  MOVWF  FEA
00C26:  MOVLW  02
00C28:  MOVWF  FEF
*
00FEA:  MOVLW  07
00FEC:  ADDWF  x39,W
00FEE:  MOVWF  FE9
00FF0:  MOVLW  00
00FF2:  ADDWFC x3A,W
00FF4:  MOVWF  FEA
00FF6:  MOVLW  02
00FF8:  MOVWF  FEF
*
013C8:  MOVLW  07
013CA:  ADDWF  x39,W
013CC:  MOVWF  FE9
013CE:  MOVLW  00
013D0:  ADDWFC x3A,W
013D2:  MOVWF  FEA
013D4:  MOVLW  02
013D6:  MOVWF  FEF
*
01798:  MOVLW  07
0179A:  ADDWF  x39,W
0179C:  MOVWF  FE9
0179E:  MOVLW  00
017A0:  ADDWFC x3A,W
017A2:  MOVWF  FEA
017A4:  MOVLW  02
017A6:  MOVWF  FEF
*
0ED98:  MOVLW  07
0ED9A:  ADDWF  x39,W
0ED9C:  MOVWF  FE9
0ED9E:  MOVLW  00
0EDA0:  ADDWFC x3A,W
0EDA2:  MOVWF  FEA
0EDA4:  MOVLW  02
0EDA6:  MOVWF  FEF
*
0F150:  MOVLW  07
0F152:  ADDWF  x39,W
0F154:  MOVWF  FE9
0F156:  MOVLW  00
0F158:  ADDWFC x3A,W
0F15A:  MOVWF  FEA
0F15C:  MOVLW  02
0F15E:  MOVWF  FEF
....................     } else { 
*
00C2A:  BRA    0D20
*
00FFA:  BRA    10F0
*
013D8:  BRA    14CE
*
017A8:  BRA    189E
*
0EDA8:  BRA    EE9E
*
0F160:  BRA    F256
....................         for (unsigned int* ptr = (buffer->data + 1); ptr < (buffer->end - 1); ptr++) { 
*
00C2C:  MOVFF  B39,FE9
00C30:  MOVFF  B3A,FEA
00C34:  MOVFF  FEC,B3F
00C38:  MOVF   FED,F
00C3A:  MOVFF  FEF,B3E
00C3E:  MOVLW  01
00C40:  ADDWF  x3E,W
00C42:  MOVWF  x3C
00C44:  MOVLW  00
00C46:  ADDWFC x3F,W
00C48:  MOVWF  x3D
00C4A:  MOVLW  05
00C4C:  ADDWF  x39,W
00C4E:  MOVWF  FE9
00C50:  MOVLW  00
00C52:  ADDWFC x3A,W
00C54:  MOVWF  FEA
00C56:  MOVFF  FEC,B3F
00C5A:  MOVF   FED,F
00C5C:  MOVFF  FEF,B3E
00C60:  MOVLW  01
00C62:  SUBWF  x3E,W
00C64:  MOVWF  00
00C66:  MOVLW  00
00C68:  SUBWFB x3F,W
00C6A:  MOVWF  03
00C6C:  MOVFF  00,01
00C70:  MOVF   x3D,W
00C72:  SUBWF  03,W
00C74:  BNC   0C92
00C76:  BNZ   0C7E
00C78:  MOVF   01,W
00C7A:  SUBWF  x3C,W
00C7C:  BC    0C92
*
00FFC:  MOVFF  B39,FE9
01000:  MOVFF  B3A,FEA
01004:  MOVFF  FEC,B3F
01008:  MOVF   FED,F
0100A:  MOVFF  FEF,B3E
0100E:  MOVLW  01
01010:  ADDWF  x3E,W
01012:  MOVWF  x3C
01014:  MOVLW  00
01016:  ADDWFC x3F,W
01018:  MOVWF  x3D
0101A:  MOVLW  05
0101C:  ADDWF  x39,W
0101E:  MOVWF  FE9
01020:  MOVLW  00
01022:  ADDWFC x3A,W
01024:  MOVWF  FEA
01026:  MOVFF  FEC,B3F
0102A:  MOVF   FED,F
0102C:  MOVFF  FEF,B3E
01030:  MOVLW  01
01032:  SUBWF  x3E,W
01034:  MOVWF  00
01036:  MOVLW  00
01038:  SUBWFB x3F,W
0103A:  MOVWF  03
0103C:  MOVFF  00,01
01040:  MOVF   x3D,W
01042:  SUBWF  03,W
01044:  BNC   1062
01046:  BNZ   104E
01048:  MOVF   01,W
0104A:  SUBWF  x3C,W
0104C:  BC    1062
*
013DA:  MOVFF  B39,FE9
013DE:  MOVFF  B3A,FEA
013E2:  MOVFF  FEC,B3F
013E6:  MOVF   FED,F
013E8:  MOVFF  FEF,B3E
013EC:  MOVLW  01
013EE:  ADDWF  x3E,W
013F0:  MOVWF  x3C
013F2:  MOVLW  00
013F4:  ADDWFC x3F,W
013F6:  MOVWF  x3D
013F8:  MOVLW  05
013FA:  ADDWF  x39,W
013FC:  MOVWF  FE9
013FE:  MOVLW  00
01400:  ADDWFC x3A,W
01402:  MOVWF  FEA
01404:  MOVFF  FEC,B3F
01408:  MOVF   FED,F
0140A:  MOVFF  FEF,B3E
0140E:  MOVLW  01
01410:  SUBWF  x3E,W
01412:  MOVWF  00
01414:  MOVLW  00
01416:  SUBWFB x3F,W
01418:  MOVWF  03
0141A:  MOVFF  00,01
0141E:  MOVF   x3D,W
01420:  SUBWF  03,W
01422:  BNC   1440
01424:  BNZ   142C
01426:  MOVF   01,W
01428:  SUBWF  x3C,W
0142A:  BC    1440
*
017AA:  MOVFF  B39,FE9
017AE:  MOVFF  B3A,FEA
017B2:  MOVFF  FEC,B3F
017B6:  MOVF   FED,F
017B8:  MOVFF  FEF,B3E
017BC:  MOVLW  01
017BE:  ADDWF  x3E,W
017C0:  MOVWF  x3C
017C2:  MOVLW  00
017C4:  ADDWFC x3F,W
017C6:  MOVWF  x3D
017C8:  MOVLW  05
017CA:  ADDWF  x39,W
017CC:  MOVWF  FE9
017CE:  MOVLW  00
017D0:  ADDWFC x3A,W
017D2:  MOVWF  FEA
017D4:  MOVFF  FEC,B3F
017D8:  MOVF   FED,F
017DA:  MOVFF  FEF,B3E
017DE:  MOVLW  01
017E0:  SUBWF  x3E,W
017E2:  MOVWF  00
017E4:  MOVLW  00
017E6:  SUBWFB x3F,W
017E8:  MOVWF  03
017EA:  MOVFF  00,01
017EE:  MOVF   x3D,W
017F0:  SUBWF  03,W
017F2:  BNC   1810
017F4:  BNZ   17FC
017F6:  MOVF   01,W
017F8:  SUBWF  x3C,W
017FA:  BC    1810
*
0EDAA:  MOVFF  B39,FE9
0EDAE:  MOVFF  B3A,FEA
0EDB2:  MOVFF  FEC,B3F
0EDB6:  MOVF   FED,F
0EDB8:  MOVFF  FEF,B3E
0EDBC:  MOVLW  01
0EDBE:  ADDWF  x3E,W
0EDC0:  MOVWF  x3C
0EDC2:  MOVLW  00
0EDC4:  ADDWFC x3F,W
0EDC6:  MOVWF  x3D
0EDC8:  MOVLW  05
0EDCA:  ADDWF  x39,W
0EDCC:  MOVWF  FE9
0EDCE:  MOVLW  00
0EDD0:  ADDWFC x3A,W
0EDD2:  MOVWF  FEA
0EDD4:  MOVFF  FEC,B3F
0EDD8:  MOVF   FED,F
0EDDA:  MOVFF  FEF,B3E
0EDDE:  MOVLW  01
0EDE0:  SUBWF  x3E,W
0EDE2:  MOVWF  00
0EDE4:  MOVLW  00
0EDE6:  SUBWFB x3F,W
0EDE8:  MOVWF  03
0EDEA:  MOVFF  00,01
0EDEE:  MOVF   x3D,W
0EDF0:  SUBWF  03,W
0EDF2:  BNC   EE10
0EDF4:  BNZ   EDFC
0EDF6:  MOVF   01,W
0EDF8:  SUBWF  x3C,W
0EDFA:  BC    EE10
*
0F162:  MOVFF  B39,FE9
0F166:  MOVFF  B3A,FEA
0F16A:  MOVFF  FEC,B3F
0F16E:  MOVF   FED,F
0F170:  MOVFF  FEF,B3E
0F174:  MOVLW  01
0F176:  ADDWF  x3E,W
0F178:  MOVWF  x3C
0F17A:  MOVLW  00
0F17C:  ADDWFC x3F,W
0F17E:  MOVWF  x3D
0F180:  MOVLW  05
0F182:  ADDWF  x39,W
0F184:  MOVWF  FE9
0F186:  MOVLW  00
0F188:  ADDWFC x3A,W
0F18A:  MOVWF  FEA
0F18C:  MOVFF  FEC,B3F
0F190:  MOVF   FED,F
0F192:  MOVFF  FEF,B3E
0F196:  MOVLW  01
0F198:  SUBWF  x3E,W
0F19A:  MOVWF  00
0F19C:  MOVLW  00
0F19E:  SUBWFB x3F,W
0F1A0:  MOVWF  03
0F1A2:  MOVFF  00,01
0F1A6:  MOVF   x3D,W
0F1A8:  SUBWF  03,W
0F1AA:  BNC   F1C8
0F1AC:  BNZ   F1B4
0F1AE:  MOVF   01,W
0F1B0:  SUBWF  x3C,W
0F1B2:  BC    F1C8
....................             checksum ^= *ptr; 
*
00C7E:  MOVFF  B3C,FE9
00C82:  MOVFF  B3D,FEA
00C86:  MOVF   FEF,W
00C88:  XORWF  x3B,F
00C8A:  INCF   x3C,F
00C8C:  BTFSC  FD8.2
00C8E:  INCF   x3D,F
00C90:  BRA    0C4A
*
0104E:  MOVFF  B3C,FE9
01052:  MOVFF  B3D,FEA
01056:  MOVF   FEF,W
01058:  XORWF  x3B,F
0105A:  INCF   x3C,F
0105C:  BTFSC  FD8.2
0105E:  INCF   x3D,F
01060:  BRA    101A
*
0142C:  MOVFF  B3C,FE9
01430:  MOVFF  B3D,FEA
01434:  MOVF   FEF,W
01436:  XORWF  x3B,F
01438:  INCF   x3C,F
0143A:  BTFSC  FD8.2
0143C:  INCF   x3D,F
0143E:  BRA    13F8
*
017FC:  MOVFF  B3C,FE9
01800:  MOVFF  B3D,FEA
01804:  MOVF   FEF,W
01806:  XORWF  x3B,F
01808:  INCF   x3C,F
0180A:  BTFSC  FD8.2
0180C:  INCF   x3D,F
0180E:  BRA    17C8
*
0EDFC:  MOVFF  B3C,FE9
0EE00:  MOVFF  B3D,FEA
0EE04:  MOVF   FEF,W
0EE06:  XORWF  x3B,F
0EE08:  INCF   x3C,F
0EE0A:  BTFSC  FD8.2
0EE0C:  INCF   x3D,F
0EE0E:  BRA    EDC8
*
0F1B4:  MOVFF  B3C,FE9
0F1B8:  MOVFF  B3D,FEA
0F1BC:  MOVF   FEF,W
0F1BE:  XORWF  x3B,F
0F1C0:  INCF   x3C,F
0F1C2:  BTFSC  FD8.2
0F1C4:  INCF   x3D,F
0F1C6:  BRA    F180
....................         } 
....................         if ((*(buffer->position - 1) == checksum) && (*buffer->position == buffer->data[0] + 1)) { 
*
00C92:  MOVLW  03
00C94:  ADDWF  x39,W
00C96:  MOVWF  FE9
00C98:  MOVLW  00
00C9A:  ADDWFC x3A,W
00C9C:  MOVWF  FEA
00C9E:  MOVFF  FEC,B3F
00CA2:  MOVF   FED,F
00CA4:  MOVFF  FEF,B3E
00CA8:  MOVLW  01
00CAA:  SUBWF  x3E,W
00CAC:  MOVWF  00
00CAE:  MOVLW  00
00CB0:  SUBWFB x3F,W
00CB2:  MOVWF  03
00CB4:  MOVFF  00,FE9
00CB8:  MOVWF  FEA
00CBA:  MOVF   x3B,W
00CBC:  SUBWF  FEF,W
00CBE:  BNZ   0D12
00CC0:  MOVLW  03
00CC2:  ADDWF  x39,W
00CC4:  MOVWF  FE9
00CC6:  MOVLW  00
00CC8:  ADDWFC x3A,W
00CCA:  MOVWF  FEA
00CCC:  MOVFF  FEC,03
00CD0:  MOVF   FED,F
00CD2:  MOVFF  FEF,FE9
00CD6:  MOVFF  03,FEA
00CDA:  MOVFF  FEF,B3E
00CDE:  MOVFF  B39,FE9
00CE2:  MOVFF  B3A,FEA
00CE6:  MOVFF  FEC,B40
00CEA:  MOVF   FED,F
00CEC:  MOVFF  FEF,B3F
00CF0:  MOVFF  B3F,FE9
00CF4:  MOVFF  B40,FEA
00CF8:  MOVLW  01
00CFA:  ADDWF  FEF,W
00CFC:  SUBWF  x3E,W
00CFE:  BNZ   0D12
*
01062:  MOVLW  03
01064:  ADDWF  x39,W
01066:  MOVWF  FE9
01068:  MOVLW  00
0106A:  ADDWFC x3A,W
0106C:  MOVWF  FEA
0106E:  MOVFF  FEC,B3F
01072:  MOVF   FED,F
01074:  MOVFF  FEF,B3E
01078:  MOVLW  01
0107A:  SUBWF  x3E,W
0107C:  MOVWF  00
0107E:  MOVLW  00
01080:  SUBWFB x3F,W
01082:  MOVWF  03
01084:  MOVFF  00,FE9
01088:  MOVWF  FEA
0108A:  MOVF   x3B,W
0108C:  SUBWF  FEF,W
0108E:  BNZ   10E2
01090:  MOVLW  03
01092:  ADDWF  x39,W
01094:  MOVWF  FE9
01096:  MOVLW  00
01098:  ADDWFC x3A,W
0109A:  MOVWF  FEA
0109C:  MOVFF  FEC,03
010A0:  MOVF   FED,F
010A2:  MOVFF  FEF,FE9
010A6:  MOVFF  03,FEA
010AA:  MOVFF  FEF,B3E
010AE:  MOVFF  B39,FE9
010B2:  MOVFF  B3A,FEA
010B6:  MOVFF  FEC,B40
010BA:  MOVF   FED,F
010BC:  MOVFF  FEF,B3F
010C0:  MOVFF  B3F,FE9
010C4:  MOVFF  B40,FEA
010C8:  MOVLW  01
010CA:  ADDWF  FEF,W
010CC:  SUBWF  x3E,W
010CE:  BNZ   10E2
*
01440:  MOVLW  03
01442:  ADDWF  x39,W
01444:  MOVWF  FE9
01446:  MOVLW  00
01448:  ADDWFC x3A,W
0144A:  MOVWF  FEA
0144C:  MOVFF  FEC,B3F
01450:  MOVF   FED,F
01452:  MOVFF  FEF,B3E
01456:  MOVLW  01
01458:  SUBWF  x3E,W
0145A:  MOVWF  00
0145C:  MOVLW  00
0145E:  SUBWFB x3F,W
01460:  MOVWF  03
01462:  MOVFF  00,FE9
01466:  MOVWF  FEA
01468:  MOVF   x3B,W
0146A:  SUBWF  FEF,W
0146C:  BNZ   14C0
0146E:  MOVLW  03
01470:  ADDWF  x39,W
01472:  MOVWF  FE9
01474:  MOVLW  00
01476:  ADDWFC x3A,W
01478:  MOVWF  FEA
0147A:  MOVFF  FEC,03
0147E:  MOVF   FED,F
01480:  MOVFF  FEF,FE9
01484:  MOVFF  03,FEA
01488:  MOVFF  FEF,B3E
0148C:  MOVFF  B39,FE9
01490:  MOVFF  B3A,FEA
01494:  MOVFF  FEC,B40
01498:  MOVF   FED,F
0149A:  MOVFF  FEF,B3F
0149E:  MOVFF  B3F,FE9
014A2:  MOVFF  B40,FEA
014A6:  MOVLW  01
014A8:  ADDWF  FEF,W
014AA:  SUBWF  x3E,W
014AC:  BNZ   14C0
*
01810:  MOVLW  03
01812:  ADDWF  x39,W
01814:  MOVWF  FE9
01816:  MOVLW  00
01818:  ADDWFC x3A,W
0181A:  MOVWF  FEA
0181C:  MOVFF  FEC,B3F
01820:  MOVF   FED,F
01822:  MOVFF  FEF,B3E
01826:  MOVLW  01
01828:  SUBWF  x3E,W
0182A:  MOVWF  00
0182C:  MOVLW  00
0182E:  SUBWFB x3F,W
01830:  MOVWF  03
01832:  MOVFF  00,FE9
01836:  MOVWF  FEA
01838:  MOVF   x3B,W
0183A:  SUBWF  FEF,W
0183C:  BNZ   1890
0183E:  MOVLW  03
01840:  ADDWF  x39,W
01842:  MOVWF  FE9
01844:  MOVLW  00
01846:  ADDWFC x3A,W
01848:  MOVWF  FEA
0184A:  MOVFF  FEC,03
0184E:  MOVF   FED,F
01850:  MOVFF  FEF,FE9
01854:  MOVFF  03,FEA
01858:  MOVFF  FEF,B3E
0185C:  MOVFF  B39,FE9
01860:  MOVFF  B3A,FEA
01864:  MOVFF  FEC,B40
01868:  MOVF   FED,F
0186A:  MOVFF  FEF,B3F
0186E:  MOVFF  B3F,FE9
01872:  MOVFF  B40,FEA
01876:  MOVLW  01
01878:  ADDWF  FEF,W
0187A:  SUBWF  x3E,W
0187C:  BNZ   1890
*
0EE10:  MOVLW  03
0EE12:  ADDWF  x39,W
0EE14:  MOVWF  FE9
0EE16:  MOVLW  00
0EE18:  ADDWFC x3A,W
0EE1A:  MOVWF  FEA
0EE1C:  MOVFF  FEC,B3F
0EE20:  MOVF   FED,F
0EE22:  MOVFF  FEF,B3E
0EE26:  MOVLW  01
0EE28:  SUBWF  x3E,W
0EE2A:  MOVWF  00
0EE2C:  MOVLW  00
0EE2E:  SUBWFB x3F,W
0EE30:  MOVWF  03
0EE32:  MOVFF  00,FE9
0EE36:  MOVWF  FEA
0EE38:  MOVF   x3B,W
0EE3A:  SUBWF  FEF,W
0EE3C:  BNZ   EE90
0EE3E:  MOVLW  03
0EE40:  ADDWF  x39,W
0EE42:  MOVWF  FE9
0EE44:  MOVLW  00
0EE46:  ADDWFC x3A,W
0EE48:  MOVWF  FEA
0EE4A:  MOVFF  FEC,03
0EE4E:  MOVF   FED,F
0EE50:  MOVFF  FEF,FE9
0EE54:  MOVFF  03,FEA
0EE58:  MOVFF  FEF,B3E
0EE5C:  MOVFF  B39,FE9
0EE60:  MOVFF  B3A,FEA
0EE64:  MOVFF  FEC,B40
0EE68:  MOVF   FED,F
0EE6A:  MOVFF  FEF,B3F
0EE6E:  MOVFF  B3F,FE9
0EE72:  MOVFF  B40,FEA
0EE76:  MOVLW  01
0EE78:  ADDWF  FEF,W
0EE7A:  SUBWF  x3E,W
0EE7C:  BNZ   EE90
*
0F1C8:  MOVLW  03
0F1CA:  ADDWF  x39,W
0F1CC:  MOVWF  FE9
0F1CE:  MOVLW  00
0F1D0:  ADDWFC x3A,W
0F1D2:  MOVWF  FEA
0F1D4:  MOVFF  FEC,B3F
0F1D8:  MOVF   FED,F
0F1DA:  MOVFF  FEF,B3E
0F1DE:  MOVLW  01
0F1E0:  SUBWF  x3E,W
0F1E2:  MOVWF  00
0F1E4:  MOVLW  00
0F1E6:  SUBWFB x3F,W
0F1E8:  MOVWF  03
0F1EA:  MOVFF  00,FE9
0F1EE:  MOVWF  FEA
0F1F0:  MOVF   x3B,W
0F1F2:  SUBWF  FEF,W
0F1F4:  BNZ   F248
0F1F6:  MOVLW  03
0F1F8:  ADDWF  x39,W
0F1FA:  MOVWF  FE9
0F1FC:  MOVLW  00
0F1FE:  ADDWFC x3A,W
0F200:  MOVWF  FEA
0F202:  MOVFF  FEC,03
0F206:  MOVF   FED,F
0F208:  MOVFF  FEF,FE9
0F20C:  MOVFF  03,FEA
0F210:  MOVFF  FEF,B3E
0F214:  MOVFF  B39,FE9
0F218:  MOVFF  B3A,FEA
0F21C:  MOVFF  FEC,B40
0F220:  MOVF   FED,F
0F222:  MOVFF  FEF,B3F
0F226:  MOVFF  B3F,FE9
0F22A:  MOVFF  B40,FEA
0F22E:  MOVLW  01
0F230:  ADDWF  FEF,W
0F232:  SUBWF  x3E,W
0F234:  BNZ   F248
....................             buffer->state = ready; 
*
00D00:  MOVLW  07
00D02:  ADDWF  x39,W
00D04:  MOVWF  FE9
00D06:  MOVLW  00
00D08:  ADDWFC x3A,W
00D0A:  MOVWF  FEA
00D0C:  MOVLW  02
00D0E:  MOVWF  FEF
*
010D0:  MOVLW  07
010D2:  ADDWF  x39,W
010D4:  MOVWF  FE9
010D6:  MOVLW  00
010D8:  ADDWFC x3A,W
010DA:  MOVWF  FEA
010DC:  MOVLW  02
010DE:  MOVWF  FEF
*
014AE:  MOVLW  07
014B0:  ADDWF  x39,W
014B2:  MOVWF  FE9
014B4:  MOVLW  00
014B6:  ADDWFC x3A,W
014B8:  MOVWF  FEA
014BA:  MOVLW  02
014BC:  MOVWF  FEF
*
0187E:  MOVLW  07
01880:  ADDWF  x39,W
01882:  MOVWF  FE9
01884:  MOVLW  00
01886:  ADDWFC x3A,W
01888:  MOVWF  FEA
0188A:  MOVLW  02
0188C:  MOVWF  FEF
*
0EE7E:  MOVLW  07
0EE80:  ADDWF  x39,W
0EE82:  MOVWF  FE9
0EE84:  MOVLW  00
0EE86:  ADDWFC x3A,W
0EE88:  MOVWF  FEA
0EE8A:  MOVLW  02
0EE8C:  MOVWF  FEF
*
0F236:  MOVLW  07
0F238:  ADDWF  x39,W
0F23A:  MOVWF  FE9
0F23C:  MOVLW  00
0F23E:  ADDWFC x3A,W
0F240:  MOVWF  FEA
0F242:  MOVLW  02
0F244:  MOVWF  FEF
....................         } else { 
*
00D10:  BRA    0D20
*
010E0:  BRA    10F0
*
014BE:  BRA    14CE
*
0188E:  BRA    189E
*
0EE8E:  BRA    EE9E
*
0F246:  BRA    F256
....................             buffer->state = waiting; 
*
00D12:  MOVLW  07
00D14:  ADDWF  x39,W
00D16:  MOVWF  FE9
00D18:  MOVLW  00
00D1A:  ADDWFC x3A,W
00D1C:  MOVWF  FEA
00D1E:  CLRF   FEF
*
010E2:  MOVLW  07
010E4:  ADDWF  x39,W
010E6:  MOVWF  FE9
010E8:  MOVLW  00
010EA:  ADDWFC x3A,W
010EC:  MOVWF  FEA
010EE:  CLRF   FEF
*
014C0:  MOVLW  07
014C2:  ADDWF  x39,W
014C4:  MOVWF  FE9
014C6:  MOVLW  00
014C8:  ADDWFC x3A,W
014CA:  MOVWF  FEA
014CC:  CLRF   FEF
*
01890:  MOVLW  07
01892:  ADDWF  x39,W
01894:  MOVWF  FE9
01896:  MOVLW  00
01898:  ADDWFC x3A,W
0189A:  MOVWF  FEA
0189C:  CLRF   FEF
*
0EE90:  MOVLW  07
0EE92:  ADDWF  x39,W
0EE94:  MOVWF  FE9
0EE96:  MOVLW  00
0EE98:  ADDWFC x3A,W
0EE9A:  MOVWF  FEA
0EE9C:  CLRF   FEF
*
0F248:  MOVLW  07
0F24A:  ADDWF  x39,W
0F24C:  MOVWF  FE9
0F24E:  MOVLW  00
0F250:  ADDWFC x3A,W
0F252:  MOVWF  FEA
0F254:  CLRF   FEF
....................         } 
....................     } 
....................     buffer->position = buffer->data; 
*
00D20:  MOVLW  03
00D22:  ADDWF  x39,W
00D24:  MOVWF  01
00D26:  MOVLW  00
00D28:  ADDWFC x3A,W
00D2A:  MOVFF  B39,FE9
00D2E:  MOVFF  B3A,FEA
00D32:  MOVFF  FEC,03
00D36:  MOVF   FED,F
00D38:  MOVFF  FEF,B40
00D3C:  MOVWF  FEA
00D3E:  MOVFF  01,FE9
00D42:  MOVFF  03,FEC
00D46:  MOVF   FED,F
00D48:  MOVFF  B40,FEF
*
010F0:  MOVLW  03
010F2:  ADDWF  x39,W
010F4:  MOVWF  01
010F6:  MOVLW  00
010F8:  ADDWFC x3A,W
010FA:  MOVFF  B39,FE9
010FE:  MOVFF  B3A,FEA
01102:  MOVFF  FEC,03
01106:  MOVF   FED,F
01108:  MOVFF  FEF,B40
0110C:  MOVWF  FEA
0110E:  MOVFF  01,FE9
01112:  MOVFF  03,FEC
01116:  MOVF   FED,F
01118:  MOVFF  B40,FEF
*
014CE:  MOVLW  03
014D0:  ADDWF  x39,W
014D2:  MOVWF  01
014D4:  MOVLW  00
014D6:  ADDWFC x3A,W
014D8:  MOVFF  B39,FE9
014DC:  MOVFF  B3A,FEA
014E0:  MOVFF  FEC,03
014E4:  MOVF   FED,F
014E6:  MOVFF  FEF,B40
014EA:  MOVWF  FEA
014EC:  MOVFF  01,FE9
014F0:  MOVFF  03,FEC
014F4:  MOVF   FED,F
014F6:  MOVFF  B40,FEF
*
0189E:  MOVLW  03
018A0:  ADDWF  x39,W
018A2:  MOVWF  01
018A4:  MOVLW  00
018A6:  ADDWFC x3A,W
018A8:  MOVFF  B39,FE9
018AC:  MOVFF  B3A,FEA
018B0:  MOVFF  FEC,03
018B4:  MOVF   FED,F
018B6:  MOVFF  FEF,B40
018BA:  MOVWF  FEA
018BC:  MOVFF  01,FE9
018C0:  MOVFF  03,FEC
018C4:  MOVF   FED,F
018C6:  MOVFF  B40,FEF
*
0EE9E:  MOVLW  03
0EEA0:  ADDWF  x39,W
0EEA2:  MOVWF  01
0EEA4:  MOVLW  00
0EEA6:  ADDWFC x3A,W
0EEA8:  MOVFF  B39,FE9
0EEAC:  MOVFF  B3A,FEA
0EEB0:  MOVFF  FEC,03
0EEB4:  MOVF   FED,F
0EEB6:  MOVFF  FEF,B40
0EEBA:  MOVWF  FEA
0EEBC:  MOVFF  01,FE9
0EEC0:  MOVFF  03,FEC
0EEC4:  MOVF   FED,F
0EEC6:  MOVFF  B40,FEF
*
0F256:  MOVLW  03
0F258:  ADDWF  x39,W
0F25A:  MOVWF  01
0F25C:  MOVLW  00
0F25E:  ADDWFC x3A,W
0F260:  MOVFF  B39,FE9
0F264:  MOVFF  B3A,FEA
0F268:  MOVFF  FEC,03
0F26C:  MOVF   FED,F
0F26E:  MOVFF  FEF,B40
0F272:  MOVWF  FEA
0F274:  MOVFF  01,FE9
0F278:  MOVFF  03,FEC
0F27C:  MOVF   FED,F
0F27E:  MOVFF  B40,FEF
....................     buffer->end = buffer->data; 
*
00D4C:  MOVLW  05
00D4E:  ADDWF  x39,W
00D50:  MOVWF  01
00D52:  MOVLW  00
00D54:  ADDWFC x3A,W
00D56:  MOVFF  B39,FE9
00D5A:  MOVFF  B3A,FEA
00D5E:  MOVFF  FEC,03
00D62:  MOVF   FED,F
00D64:  MOVFF  FEF,B40
00D68:  MOVWF  FEA
00D6A:  MOVFF  01,FE9
00D6E:  MOVFF  03,FEC
00D72:  MOVF   FED,F
00D74:  MOVFF  B40,FEF
*
0111C:  MOVLW  05
0111E:  ADDWF  x39,W
01120:  MOVWF  01
01122:  MOVLW  00
01124:  ADDWFC x3A,W
01126:  MOVFF  B39,FE9
0112A:  MOVFF  B3A,FEA
0112E:  MOVFF  FEC,03
01132:  MOVF   FED,F
01134:  MOVFF  FEF,B40
01138:  MOVWF  FEA
0113A:  MOVFF  01,FE9
0113E:  MOVFF  03,FEC
01142:  MOVF   FED,F
01144:  MOVFF  B40,FEF
*
014FA:  MOVLW  05
014FC:  ADDWF  x39,W
014FE:  MOVWF  01
01500:  MOVLW  00
01502:  ADDWFC x3A,W
01504:  MOVFF  B39,FE9
01508:  MOVFF  B3A,FEA
0150C:  MOVFF  FEC,03
01510:  MOVF   FED,F
01512:  MOVFF  FEF,B40
01516:  MOVWF  FEA
01518:  MOVFF  01,FE9
0151C:  MOVFF  03,FEC
01520:  MOVF   FED,F
01522:  MOVFF  B40,FEF
*
018CA:  MOVLW  05
018CC:  ADDWF  x39,W
018CE:  MOVWF  01
018D0:  MOVLW  00
018D2:  ADDWFC x3A,W
018D4:  MOVFF  B39,FE9
018D8:  MOVFF  B3A,FEA
018DC:  MOVFF  FEC,03
018E0:  MOVF   FED,F
018E2:  MOVFF  FEF,B40
018E6:  MOVWF  FEA
018E8:  MOVFF  01,FE9
018EC:  MOVFF  03,FEC
018F0:  MOVF   FED,F
018F2:  MOVFF  B40,FEF
*
0EECA:  MOVLW  05
0EECC:  ADDWF  x39,W
0EECE:  MOVWF  01
0EED0:  MOVLW  00
0EED2:  ADDWFC x3A,W
0EED4:  MOVFF  B39,FE9
0EED8:  MOVFF  B3A,FEA
0EEDC:  MOVFF  FEC,03
0EEE0:  MOVF   FED,F
0EEE2:  MOVFF  FEF,B40
0EEE6:  MOVWF  FEA
0EEE8:  MOVFF  01,FE9
0EEEC:  MOVFF  03,FEC
0EEF0:  MOVF   FED,F
0EEF2:  MOVFF  B40,FEF
*
0F282:  MOVLW  05
0F284:  ADDWF  x39,W
0F286:  MOVWF  01
0F288:  MOVLW  00
0F28A:  ADDWFC x3A,W
0F28C:  MOVFF  B39,FE9
0F290:  MOVFF  B3A,FEA
0F294:  MOVFF  FEC,03
0F298:  MOVF   FED,F
0F29A:  MOVFF  FEF,B40
0F29E:  MOVWF  FEA
0F2A0:  MOVFF  01,FE9
0F2A4:  MOVFF  03,FEC
0F2A8:  MOVF   FED,F
0F2AA:  MOVFF  B40,FEF
.................... } 
....................  
.................... inline void uart_process_all(uart* buffer, char rx) 
.................... { 
....................     switch (buffer->state) { 
....................     case ready: 
....................     case waiting: 
....................         for (int i = 0; i < sizeof(mconfig) / sizeof(message_config); i++) { 
....................             if (mconfig[i].identifier == rx) { // Found a message unique identifier 
....................                 buffer->end += (mconfig[i].length - 1); 
....................                 buffer->standard = mconfig[i].standard; 
....................                 *(buffer->position) = rx; 
....................                 buffer->position++; 
....................                 buffer->state = receiving; 
....................                 break; 
....................             } 
....................         } 
....................         break; 
....................     case receiving: 
....................         *(buffer->position) = rx; 
....................         if (buffer->position >= buffer->end) { 
....................             check_string(buffer); 
....................             break; 
....................         } 
....................         buffer->position++; 
....................         break; 
....................     default: 
....................         break; 
....................     } 
....................     if (buffer->position >= buffer->data + buffer->size) { 
....................         uart_reset(buffer); 
....................     } 
.................... } 
....................  
.................... inline void uart_process(uart* buffer, message_config* cfg, char rx) 
.................... { 
....................     switch (buffer->state) { 
*
00ABE:  MOVLW  07
00AC0:  ADDWF  x34,W
00AC2:  MOVWF  FE9
00AC4:  MOVLW  00
00AC6:  ADDWFC x35,W
00AC8:  MOVWF  FEA
00ACA:  MOVF   FEF,W
00ACC:  XORLW  02
00ACE:  MOVLB  0
00AD0:  BZ    0ADC
00AD2:  XORLW  02
00AD4:  BZ    0ADC
00AD6:  XORLW  01
00AD8:  BZ    0BA2
00ADA:  BRA    0D92
*
00E8E:  MOVLW  07
00E90:  ADDWF  x34,W
00E92:  MOVWF  FE9
00E94:  MOVLW  00
00E96:  ADDWFC x35,W
00E98:  MOVWF  FEA
00E9A:  MOVF   FEF,W
00E9C:  XORLW  02
00E9E:  MOVLB  0
00EA0:  BZ    0EAC
00EA2:  XORLW  02
00EA4:  BZ    0EAC
00EA6:  XORLW  01
00EA8:  BZ    0F72
00EAA:  BRA    1162
*
0126C:  MOVLW  07
0126E:  ADDWF  x34,W
01270:  MOVWF  FE9
01272:  MOVLW  00
01274:  ADDWFC x35,W
01276:  MOVWF  FEA
01278:  MOVF   FEF,W
0127A:  XORLW  02
0127C:  MOVLB  0
0127E:  BZ    128A
01280:  XORLW  02
01282:  BZ    128A
01284:  XORLW  01
01286:  BZ    1350
01288:  BRA    1540
*
0163C:  MOVLW  07
0163E:  ADDWF  x34,W
01640:  MOVWF  FE9
01642:  MOVLW  00
01644:  ADDWFC x35,W
01646:  MOVWF  FEA
01648:  MOVF   FEF,W
0164A:  XORLW  02
0164C:  MOVLB  0
0164E:  BZ    165A
01650:  XORLW  02
01652:  BZ    165A
01654:  XORLW  01
01656:  BZ    1720
01658:  BRA    1910
*
0EC3C:  MOVLW  07
0EC3E:  ADDWF  x34,W
0EC40:  MOVWF  FE9
0EC42:  MOVLW  00
0EC44:  ADDWFC x35,W
0EC46:  MOVWF  FEA
0EC48:  MOVF   FEF,W
0EC4A:  XORLW  02
0EC4C:  MOVLB  0
0EC4E:  BZ    EC5A
0EC50:  XORLW  02
0EC52:  BZ    EC5A
0EC54:  XORLW  01
0EC56:  BZ    ED20
0EC58:  BRA    EF10
*
0EFF4:  MOVLW  07
0EFF6:  ADDWF  x34,W
0EFF8:  MOVWF  FE9
0EFFA:  MOVLW  00
0EFFC:  ADDWFC x35,W
0EFFE:  MOVWF  FEA
0F000:  MOVF   FEF,W
0F002:  XORLW  02
0F004:  MOVLB  0
0F006:  BZ    F012
0F008:  XORLW  02
0F00A:  BZ    F012
0F00C:  XORLW  01
0F00E:  BZ    F0D8
0F010:  BRA    F2C8
....................     case ready: 
....................     case waiting: 
....................         if (cfg->identifier == rx) { // Found a message unique identifier 
*
00ADC:  MOVLB  B
00ADE:  MOVFF  B36,FE9
00AE2:  MOVFF  B37,FEA
00AE6:  MOVF   x38,W
00AE8:  SUBWF  FEF,W
00AEA:  BNZ   0BA0
*
00EAC:  MOVLB  B
00EAE:  MOVFF  B36,FE9
00EB2:  MOVFF  B37,FEA
00EB6:  MOVF   x38,W
00EB8:  SUBWF  FEF,W
00EBA:  BNZ   0F70
*
0128A:  MOVLB  B
0128C:  MOVFF  B36,FE9
01290:  MOVFF  B37,FEA
01294:  MOVF   x38,W
01296:  SUBWF  FEF,W
01298:  BNZ   134E
*
0165A:  MOVLB  B
0165C:  MOVFF  B36,FE9
01660:  MOVFF  B37,FEA
01664:  MOVF   x38,W
01666:  SUBWF  FEF,W
01668:  BNZ   171E
*
0EC5A:  MOVLB  B
0EC5C:  MOVFF  B36,FE9
0EC60:  MOVFF  B37,FEA
0EC64:  MOVF   x38,W
0EC66:  SUBWF  FEF,W
0EC68:  BNZ   ED1E
*
0F012:  MOVLB  B
0F014:  MOVFF  B36,FE9
0F018:  MOVFF  B37,FEA
0F01C:  MOVF   x38,W
0F01E:  SUBWF  FEF,W
0F020:  BNZ   F0D6
....................             buffer->end += (cfg->length - 1); 
*
00AEC:  MOVLW  05
00AEE:  ADDWF  x34,W
00AF0:  MOVWF  01
00AF2:  MOVLW  00
00AF4:  ADDWFC x35,W
00AF6:  MOVFF  01,B39
00AFA:  MOVWF  x3A
00AFC:  MOVWF  FEA
00AFE:  MOVFF  01,FE9
00B02:  MOVFF  FEC,B3C
00B06:  MOVF   FED,F
00B08:  MOVFF  FEF,B3B
00B0C:  MOVLW  01
00B0E:  ADDWF  x36,W
00B10:  MOVWF  FE9
00B12:  MOVLW  00
00B14:  ADDWFC x37,W
00B16:  MOVWF  FEA
00B18:  MOVLW  01
00B1A:  SUBWF  FEF,W
00B1C:  ADDWF  x3B,W
00B1E:  MOVWF  01
00B20:  MOVLW  00
00B22:  ADDWFC x3C,W
00B24:  MOVFF  B3A,FEA
00B28:  MOVFF  B39,FE9
00B2C:  MOVWF  FEC
00B2E:  MOVF   FED,F
00B30:  MOVFF  01,FEF
*
00EBC:  MOVLW  05
00EBE:  ADDWF  x34,W
00EC0:  MOVWF  01
00EC2:  MOVLW  00
00EC4:  ADDWFC x35,W
00EC6:  MOVFF  01,B39
00ECA:  MOVWF  x3A
00ECC:  MOVWF  FEA
00ECE:  MOVFF  01,FE9
00ED2:  MOVFF  FEC,B3C
00ED6:  MOVF   FED,F
00ED8:  MOVFF  FEF,B3B
00EDC:  MOVLW  01
00EDE:  ADDWF  x36,W
00EE0:  MOVWF  FE9
00EE2:  MOVLW  00
00EE4:  ADDWFC x37,W
00EE6:  MOVWF  FEA
00EE8:  MOVLW  01
00EEA:  SUBWF  FEF,W
00EEC:  ADDWF  x3B,W
00EEE:  MOVWF  01
00EF0:  MOVLW  00
00EF2:  ADDWFC x3C,W
00EF4:  MOVFF  B3A,FEA
00EF8:  MOVFF  B39,FE9
00EFC:  MOVWF  FEC
00EFE:  MOVF   FED,F
00F00:  MOVFF  01,FEF
*
0129A:  MOVLW  05
0129C:  ADDWF  x34,W
0129E:  MOVWF  01
012A0:  MOVLW  00
012A2:  ADDWFC x35,W
012A4:  MOVFF  01,B39
012A8:  MOVWF  x3A
012AA:  MOVWF  FEA
012AC:  MOVFF  01,FE9
012B0:  MOVFF  FEC,B3C
012B4:  MOVF   FED,F
012B6:  MOVFF  FEF,B3B
012BA:  MOVLW  01
012BC:  ADDWF  x36,W
012BE:  MOVWF  FE9
012C0:  MOVLW  00
012C2:  ADDWFC x37,W
012C4:  MOVWF  FEA
012C6:  MOVLW  01
012C8:  SUBWF  FEF,W
012CA:  ADDWF  x3B,W
012CC:  MOVWF  01
012CE:  MOVLW  00
012D0:  ADDWFC x3C,W
012D2:  MOVFF  B3A,FEA
012D6:  MOVFF  B39,FE9
012DA:  MOVWF  FEC
012DC:  MOVF   FED,F
012DE:  MOVFF  01,FEF
*
0166A:  MOVLW  05
0166C:  ADDWF  x34,W
0166E:  MOVWF  01
01670:  MOVLW  00
01672:  ADDWFC x35,W
01674:  MOVFF  01,B39
01678:  MOVWF  x3A
0167A:  MOVWF  FEA
0167C:  MOVFF  01,FE9
01680:  MOVFF  FEC,B3C
01684:  MOVF   FED,F
01686:  MOVFF  FEF,B3B
0168A:  MOVLW  01
0168C:  ADDWF  x36,W
0168E:  MOVWF  FE9
01690:  MOVLW  00
01692:  ADDWFC x37,W
01694:  MOVWF  FEA
01696:  MOVLW  01
01698:  SUBWF  FEF,W
0169A:  ADDWF  x3B,W
0169C:  MOVWF  01
0169E:  MOVLW  00
016A0:  ADDWFC x3C,W
016A2:  MOVFF  B3A,FEA
016A6:  MOVFF  B39,FE9
016AA:  MOVWF  FEC
016AC:  MOVF   FED,F
016AE:  MOVFF  01,FEF
*
0EC6A:  MOVLW  05
0EC6C:  ADDWF  x34,W
0EC6E:  MOVWF  01
0EC70:  MOVLW  00
0EC72:  ADDWFC x35,W
0EC74:  MOVFF  01,B39
0EC78:  MOVWF  x3A
0EC7A:  MOVWF  FEA
0EC7C:  MOVFF  01,FE9
0EC80:  MOVFF  FEC,B3C
0EC84:  MOVF   FED,F
0EC86:  MOVFF  FEF,B3B
0EC8A:  MOVLW  01
0EC8C:  ADDWF  x36,W
0EC8E:  MOVWF  FE9
0EC90:  MOVLW  00
0EC92:  ADDWFC x37,W
0EC94:  MOVWF  FEA
0EC96:  MOVLW  01
0EC98:  SUBWF  FEF,W
0EC9A:  ADDWF  x3B,W
0EC9C:  MOVWF  01
0EC9E:  MOVLW  00
0ECA0:  ADDWFC x3C,W
0ECA2:  MOVFF  B3A,FEA
0ECA6:  MOVFF  B39,FE9
0ECAA:  MOVWF  FEC
0ECAC:  MOVF   FED,F
0ECAE:  MOVFF  01,FEF
*
0F022:  MOVLW  05
0F024:  ADDWF  x34,W
0F026:  MOVWF  01
0F028:  MOVLW  00
0F02A:  ADDWFC x35,W
0F02C:  MOVFF  01,B39
0F030:  MOVWF  x3A
0F032:  MOVWF  FEA
0F034:  MOVFF  01,FE9
0F038:  MOVFF  FEC,B3C
0F03C:  MOVF   FED,F
0F03E:  MOVFF  FEF,B3B
0F042:  MOVLW  01
0F044:  ADDWF  x36,W
0F046:  MOVWF  FE9
0F048:  MOVLW  00
0F04A:  ADDWFC x37,W
0F04C:  MOVWF  FEA
0F04E:  MOVLW  01
0F050:  SUBWF  FEF,W
0F052:  ADDWF  x3B,W
0F054:  MOVWF  01
0F056:  MOVLW  00
0F058:  ADDWFC x3C,W
0F05A:  MOVFF  B3A,FEA
0F05E:  MOVFF  B39,FE9
0F062:  MOVWF  FEC
0F064:  MOVF   FED,F
0F066:  MOVFF  01,FEF
....................             buffer->standard = cfg->standard; 
*
00B34:  MOVLW  08
00B36:  ADDWF  x34,W
00B38:  MOVWF  01
00B3A:  MOVLW  00
00B3C:  ADDWFC x35,W
00B3E:  MOVWF  03
00B40:  MOVLW  02
00B42:  ADDWF  x36,W
00B44:  MOVWF  FE9
00B46:  MOVLW  00
00B48:  ADDWFC x37,W
00B4A:  MOVWF  FEA
00B4C:  MOVFF  FEF,B3B
00B50:  MOVFF  03,FEA
00B54:  MOVFF  01,FE9
00B58:  MOVFF  B3B,FEF
*
00F04:  MOVLW  08
00F06:  ADDWF  x34,W
00F08:  MOVWF  01
00F0A:  MOVLW  00
00F0C:  ADDWFC x35,W
00F0E:  MOVWF  03
00F10:  MOVLW  02
00F12:  ADDWF  x36,W
00F14:  MOVWF  FE9
00F16:  MOVLW  00
00F18:  ADDWFC x37,W
00F1A:  MOVWF  FEA
00F1C:  MOVFF  FEF,B3B
00F20:  MOVFF  03,FEA
00F24:  MOVFF  01,FE9
00F28:  MOVFF  B3B,FEF
*
012E2:  MOVLW  08
012E4:  ADDWF  x34,W
012E6:  MOVWF  01
012E8:  MOVLW  00
012EA:  ADDWFC x35,W
012EC:  MOVWF  03
012EE:  MOVLW  02
012F0:  ADDWF  x36,W
012F2:  MOVWF  FE9
012F4:  MOVLW  00
012F6:  ADDWFC x37,W
012F8:  MOVWF  FEA
012FA:  MOVFF  FEF,B3B
012FE:  MOVFF  03,FEA
01302:  MOVFF  01,FE9
01306:  MOVFF  B3B,FEF
*
016B2:  MOVLW  08
016B4:  ADDWF  x34,W
016B6:  MOVWF  01
016B8:  MOVLW  00
016BA:  ADDWFC x35,W
016BC:  MOVWF  03
016BE:  MOVLW  02
016C0:  ADDWF  x36,W
016C2:  MOVWF  FE9
016C4:  MOVLW  00
016C6:  ADDWFC x37,W
016C8:  MOVWF  FEA
016CA:  MOVFF  FEF,B3B
016CE:  MOVFF  03,FEA
016D2:  MOVFF  01,FE9
016D6:  MOVFF  B3B,FEF
*
0ECB2:  MOVLW  08
0ECB4:  ADDWF  x34,W
0ECB6:  MOVWF  01
0ECB8:  MOVLW  00
0ECBA:  ADDWFC x35,W
0ECBC:  MOVWF  03
0ECBE:  MOVLW  02
0ECC0:  ADDWF  x36,W
0ECC2:  MOVWF  FE9
0ECC4:  MOVLW  00
0ECC6:  ADDWFC x37,W
0ECC8:  MOVWF  FEA
0ECCA:  MOVFF  FEF,B3B
0ECCE:  MOVFF  03,FEA
0ECD2:  MOVFF  01,FE9
0ECD6:  MOVFF  B3B,FEF
*
0F06A:  MOVLW  08
0F06C:  ADDWF  x34,W
0F06E:  MOVWF  01
0F070:  MOVLW  00
0F072:  ADDWFC x35,W
0F074:  MOVWF  03
0F076:  MOVLW  02
0F078:  ADDWF  x36,W
0F07A:  MOVWF  FE9
0F07C:  MOVLW  00
0F07E:  ADDWFC x37,W
0F080:  MOVWF  FEA
0F082:  MOVFF  FEF,B3B
0F086:  MOVFF  03,FEA
0F08A:  MOVFF  01,FE9
0F08E:  MOVFF  B3B,FEF
....................             *(buffer->position) = rx; 
*
00B5C:  MOVLW  03
00B5E:  ADDWF  x34,W
00B60:  MOVWF  FE9
00B62:  MOVLW  00
00B64:  ADDWFC x35,W
00B66:  MOVWF  FEA
00B68:  MOVFF  FEC,03
00B6C:  MOVF   FED,F
00B6E:  MOVFF  FEF,FE9
00B72:  MOVFF  03,FEA
00B76:  MOVFF  B38,FEF
*
00F2C:  MOVLW  03
00F2E:  ADDWF  x34,W
00F30:  MOVWF  FE9
00F32:  MOVLW  00
00F34:  ADDWFC x35,W
00F36:  MOVWF  FEA
00F38:  MOVFF  FEC,03
00F3C:  MOVF   FED,F
00F3E:  MOVFF  FEF,FE9
00F42:  MOVFF  03,FEA
00F46:  MOVFF  B38,FEF
*
0130A:  MOVLW  03
0130C:  ADDWF  x34,W
0130E:  MOVWF  FE9
01310:  MOVLW  00
01312:  ADDWFC x35,W
01314:  MOVWF  FEA
01316:  MOVFF  FEC,03
0131A:  MOVF   FED,F
0131C:  MOVFF  FEF,FE9
01320:  MOVFF  03,FEA
01324:  MOVFF  B38,FEF
*
016DA:  MOVLW  03
016DC:  ADDWF  x34,W
016DE:  MOVWF  FE9
016E0:  MOVLW  00
016E2:  ADDWFC x35,W
016E4:  MOVWF  FEA
016E6:  MOVFF  FEC,03
016EA:  MOVF   FED,F
016EC:  MOVFF  FEF,FE9
016F0:  MOVFF  03,FEA
016F4:  MOVFF  B38,FEF
*
0ECDA:  MOVLW  03
0ECDC:  ADDWF  x34,W
0ECDE:  MOVWF  FE9
0ECE0:  MOVLW  00
0ECE2:  ADDWFC x35,W
0ECE4:  MOVWF  FEA
0ECE6:  MOVFF  FEC,03
0ECEA:  MOVF   FED,F
0ECEC:  MOVFF  FEF,FE9
0ECF0:  MOVFF  03,FEA
0ECF4:  MOVFF  B38,FEF
*
0F092:  MOVLW  03
0F094:  ADDWF  x34,W
0F096:  MOVWF  FE9
0F098:  MOVLW  00
0F09A:  ADDWFC x35,W
0F09C:  MOVWF  FEA
0F09E:  MOVFF  FEC,03
0F0A2:  MOVF   FED,F
0F0A4:  MOVFF  FEF,FE9
0F0A8:  MOVFF  03,FEA
0F0AC:  MOVFF  B38,FEF
....................             buffer->position++; 
*
00B7A:  MOVLW  03
00B7C:  ADDWF  x34,W
00B7E:  MOVWF  FE9
00B80:  MOVLW  00
00B82:  ADDWFC x35,W
00B84:  MOVWF  FEA
00B86:  MOVLW  01
00B88:  ADDWF  FEE,F
00B8A:  BNC   0B8E
00B8C:  INCF   FEF,F
*
00F4A:  MOVLW  03
00F4C:  ADDWF  x34,W
00F4E:  MOVWF  FE9
00F50:  MOVLW  00
00F52:  ADDWFC x35,W
00F54:  MOVWF  FEA
00F56:  MOVLW  01
00F58:  ADDWF  FEE,F
00F5A:  BNC   0F5E
00F5C:  INCF   FEF,F
*
01328:  MOVLW  03
0132A:  ADDWF  x34,W
0132C:  MOVWF  FE9
0132E:  MOVLW  00
01330:  ADDWFC x35,W
01332:  MOVWF  FEA
01334:  MOVLW  01
01336:  ADDWF  FEE,F
01338:  BNC   133C
0133A:  INCF   FEF,F
*
016F8:  MOVLW  03
016FA:  ADDWF  x34,W
016FC:  MOVWF  FE9
016FE:  MOVLW  00
01700:  ADDWFC x35,W
01702:  MOVWF  FEA
01704:  MOVLW  01
01706:  ADDWF  FEE,F
01708:  BNC   170C
0170A:  INCF   FEF,F
*
0ECF8:  MOVLW  03
0ECFA:  ADDWF  x34,W
0ECFC:  MOVWF  FE9
0ECFE:  MOVLW  00
0ED00:  ADDWFC x35,W
0ED02:  MOVWF  FEA
0ED04:  MOVLW  01
0ED06:  ADDWF  FEE,F
0ED08:  BNC   ED0C
0ED0A:  INCF   FEF,F
*
0F0B0:  MOVLW  03
0F0B2:  ADDWF  x34,W
0F0B4:  MOVWF  FE9
0F0B6:  MOVLW  00
0F0B8:  ADDWFC x35,W
0F0BA:  MOVWF  FEA
0F0BC:  MOVLW  01
0F0BE:  ADDWF  FEE,F
0F0C0:  BNC   F0C4
0F0C2:  INCF   FEF,F
....................             buffer->state = receiving; 
*
00B8E:  MOVLW  07
00B90:  ADDWF  x34,W
00B92:  MOVWF  FE9
00B94:  MOVLW  00
00B96:  ADDWFC x35,W
00B98:  MOVWF  FEA
00B9A:  MOVLW  01
00B9C:  MOVWF  FEF
*
00F5E:  MOVLW  07
00F60:  ADDWF  x34,W
00F62:  MOVWF  FE9
00F64:  MOVLW  00
00F66:  ADDWFC x35,W
00F68:  MOVWF  FEA
00F6A:  MOVLW  01
00F6C:  MOVWF  FEF
*
0133C:  MOVLW  07
0133E:  ADDWF  x34,W
01340:  MOVWF  FE9
01342:  MOVLW  00
01344:  ADDWFC x35,W
01346:  MOVWF  FEA
01348:  MOVLW  01
0134A:  MOVWF  FEF
*
0170C:  MOVLW  07
0170E:  ADDWF  x34,W
01710:  MOVWF  FE9
01712:  MOVLW  00
01714:  ADDWFC x35,W
01716:  MOVWF  FEA
01718:  MOVLW  01
0171A:  MOVWF  FEF
*
0ED0C:  MOVLW  07
0ED0E:  ADDWF  x34,W
0ED10:  MOVWF  FE9
0ED12:  MOVLW  00
0ED14:  ADDWFC x35,W
0ED16:  MOVWF  FEA
0ED18:  MOVLW  01
0ED1A:  MOVWF  FEF
*
0F0C4:  MOVLW  07
0F0C6:  ADDWF  x34,W
0F0C8:  MOVWF  FE9
0F0CA:  MOVLW  00
0F0CC:  ADDWFC x35,W
0F0CE:  MOVWF  FEA
0F0D0:  MOVLW  01
0F0D2:  MOVWF  FEF
....................             break; 
*
00B9E:  BRA    0D94
*
00F6E:  BRA    1164
*
0134C:  BRA    1542
*
0171C:  BRA    1912
*
0ED1C:  BRA    EF12
*
0F0D4:  BRA    F2CA
....................         } 
....................         break; 
*
00BA0:  BRA    0D94
*
00F70:  BRA    1164
*
0134E:  BRA    1542
*
0171E:  BRA    1912
*
0ED1E:  BRA    EF12
*
0F0D6:  BRA    F2CA
....................     case receiving: 
....................         *(buffer->position) = rx; 
*
00BA2:  MOVLW  03
00BA4:  MOVLB  B
00BA6:  ADDWF  x34,W
00BA8:  MOVWF  FE9
00BAA:  MOVLW  00
00BAC:  ADDWFC x35,W
00BAE:  MOVWF  FEA
00BB0:  MOVFF  FEC,03
00BB4:  MOVF   FED,F
00BB6:  MOVFF  FEF,FE9
00BBA:  MOVFF  03,FEA
00BBE:  MOVFF  B38,FEF
*
00F72:  MOVLW  03
00F74:  MOVLB  B
00F76:  ADDWF  x34,W
00F78:  MOVWF  FE9
00F7A:  MOVLW  00
00F7C:  ADDWFC x35,W
00F7E:  MOVWF  FEA
00F80:  MOVFF  FEC,03
00F84:  MOVF   FED,F
00F86:  MOVFF  FEF,FE9
00F8A:  MOVFF  03,FEA
00F8E:  MOVFF  B38,FEF
*
01350:  MOVLW  03
01352:  MOVLB  B
01354:  ADDWF  x34,W
01356:  MOVWF  FE9
01358:  MOVLW  00
0135A:  ADDWFC x35,W
0135C:  MOVWF  FEA
0135E:  MOVFF  FEC,03
01362:  MOVF   FED,F
01364:  MOVFF  FEF,FE9
01368:  MOVFF  03,FEA
0136C:  MOVFF  B38,FEF
*
01720:  MOVLW  03
01722:  MOVLB  B
01724:  ADDWF  x34,W
01726:  MOVWF  FE9
01728:  MOVLW  00
0172A:  ADDWFC x35,W
0172C:  MOVWF  FEA
0172E:  MOVFF  FEC,03
01732:  MOVF   FED,F
01734:  MOVFF  FEF,FE9
01738:  MOVFF  03,FEA
0173C:  MOVFF  B38,FEF
*
0ED20:  MOVLW  03
0ED22:  MOVLB  B
0ED24:  ADDWF  x34,W
0ED26:  MOVWF  FE9
0ED28:  MOVLW  00
0ED2A:  ADDWFC x35,W
0ED2C:  MOVWF  FEA
0ED2E:  MOVFF  FEC,03
0ED32:  MOVF   FED,F
0ED34:  MOVFF  FEF,FE9
0ED38:  MOVFF  03,FEA
0ED3C:  MOVFF  B38,FEF
*
0F0D8:  MOVLW  03
0F0DA:  MOVLB  B
0F0DC:  ADDWF  x34,W
0F0DE:  MOVWF  FE9
0F0E0:  MOVLW  00
0F0E2:  ADDWFC x35,W
0F0E4:  MOVWF  FEA
0F0E6:  MOVFF  FEC,03
0F0EA:  MOVF   FED,F
0F0EC:  MOVFF  FEF,FE9
0F0F0:  MOVFF  03,FEA
0F0F4:  MOVFF  B38,FEF
....................         if (buffer->position >= buffer->end) { 
*
00BC2:  MOVLW  03
00BC4:  ADDWF  x34,W
00BC6:  MOVWF  FE9
00BC8:  MOVLW  00
00BCA:  ADDWFC x35,W
00BCC:  MOVWF  FEA
00BCE:  MOVFF  FEC,B3A
00BD2:  MOVF   FED,F
00BD4:  MOVFF  FEF,B39
00BD8:  MOVLW  05
00BDA:  ADDWF  x34,W
00BDC:  MOVWF  FE9
00BDE:  MOVLW  00
00BE0:  ADDWFC x35,W
00BE2:  MOVWF  FEA
00BE4:  MOVFF  FEC,03
00BE8:  MOVF   FED,F
00BEA:  MOVFF  FEF,01
00BEE:  MOVF   03,W
00BF0:  SUBWF  x3A,W
00BF2:  BTFSS  FD8.0
00BF4:  BRA    0D7A
00BF6:  BNZ   0C00
00BF8:  MOVF   01,W
00BFA:  SUBWF  x39,W
00BFC:  BTFSS  FD8.0
00BFE:  BRA    0D7A
*
00F92:  MOVLW  03
00F94:  ADDWF  x34,W
00F96:  MOVWF  FE9
00F98:  MOVLW  00
00F9A:  ADDWFC x35,W
00F9C:  MOVWF  FEA
00F9E:  MOVFF  FEC,B3A
00FA2:  MOVF   FED,F
00FA4:  MOVFF  FEF,B39
00FA8:  MOVLW  05
00FAA:  ADDWF  x34,W
00FAC:  MOVWF  FE9
00FAE:  MOVLW  00
00FB0:  ADDWFC x35,W
00FB2:  MOVWF  FEA
00FB4:  MOVFF  FEC,03
00FB8:  MOVF   FED,F
00FBA:  MOVFF  FEF,01
00FBE:  MOVF   03,W
00FC0:  SUBWF  x3A,W
00FC2:  BTFSS  FD8.0
00FC4:  BRA    114A
00FC6:  BNZ   0FD0
00FC8:  MOVF   01,W
00FCA:  SUBWF  x39,W
00FCC:  BTFSS  FD8.0
00FCE:  BRA    114A
*
01370:  MOVLW  03
01372:  ADDWF  x34,W
01374:  MOVWF  FE9
01376:  MOVLW  00
01378:  ADDWFC x35,W
0137A:  MOVWF  FEA
0137C:  MOVFF  FEC,B3A
01380:  MOVF   FED,F
01382:  MOVFF  FEF,B39
01386:  MOVLW  05
01388:  ADDWF  x34,W
0138A:  MOVWF  FE9
0138C:  MOVLW  00
0138E:  ADDWFC x35,W
01390:  MOVWF  FEA
01392:  MOVFF  FEC,03
01396:  MOVF   FED,F
01398:  MOVFF  FEF,01
0139C:  MOVF   03,W
0139E:  SUBWF  x3A,W
013A0:  BTFSS  FD8.0
013A2:  BRA    1528
013A4:  BNZ   13AE
013A6:  MOVF   01,W
013A8:  SUBWF  x39,W
013AA:  BTFSS  FD8.0
013AC:  BRA    1528
*
01740:  MOVLW  03
01742:  ADDWF  x34,W
01744:  MOVWF  FE9
01746:  MOVLW  00
01748:  ADDWFC x35,W
0174A:  MOVWF  FEA
0174C:  MOVFF  FEC,B3A
01750:  MOVF   FED,F
01752:  MOVFF  FEF,B39
01756:  MOVLW  05
01758:  ADDWF  x34,W
0175A:  MOVWF  FE9
0175C:  MOVLW  00
0175E:  ADDWFC x35,W
01760:  MOVWF  FEA
01762:  MOVFF  FEC,03
01766:  MOVF   FED,F
01768:  MOVFF  FEF,01
0176C:  MOVF   03,W
0176E:  SUBWF  x3A,W
01770:  BTFSS  FD8.0
01772:  BRA    18F8
01774:  BNZ   177E
01776:  MOVF   01,W
01778:  SUBWF  x39,W
0177A:  BTFSS  FD8.0
0177C:  BRA    18F8
*
0ED40:  MOVLW  03
0ED42:  ADDWF  x34,W
0ED44:  MOVWF  FE9
0ED46:  MOVLW  00
0ED48:  ADDWFC x35,W
0ED4A:  MOVWF  FEA
0ED4C:  MOVFF  FEC,B3A
0ED50:  MOVF   FED,F
0ED52:  MOVFF  FEF,B39
0ED56:  MOVLW  05
0ED58:  ADDWF  x34,W
0ED5A:  MOVWF  FE9
0ED5C:  MOVLW  00
0ED5E:  ADDWFC x35,W
0ED60:  MOVWF  FEA
0ED62:  MOVFF  FEC,03
0ED66:  MOVF   FED,F
0ED68:  MOVFF  FEF,01
0ED6C:  MOVF   03,W
0ED6E:  SUBWF  x3A,W
0ED70:  BTFSS  FD8.0
0ED72:  BRA    EEF8
0ED74:  BNZ   ED7E
0ED76:  MOVF   01,W
0ED78:  SUBWF  x39,W
0ED7A:  BTFSS  FD8.0
0ED7C:  BRA    EEF8
*
0F0F8:  MOVLW  03
0F0FA:  ADDWF  x34,W
0F0FC:  MOVWF  FE9
0F0FE:  MOVLW  00
0F100:  ADDWFC x35,W
0F102:  MOVWF  FEA
0F104:  MOVFF  FEC,B3A
0F108:  MOVF   FED,F
0F10A:  MOVFF  FEF,B39
0F10E:  MOVLW  05
0F110:  ADDWF  x34,W
0F112:  MOVWF  FE9
0F114:  MOVLW  00
0F116:  ADDWFC x35,W
0F118:  MOVWF  FEA
0F11A:  MOVFF  FEC,03
0F11E:  MOVF   FED,F
0F120:  MOVFF  FEF,01
0F124:  MOVF   03,W
0F126:  SUBWF  x3A,W
0F128:  BTFSS  FD8.0
0F12A:  BRA    F2B0
0F12C:  BNZ   F136
0F12E:  MOVF   01,W
0F130:  SUBWF  x39,W
0F132:  BTFSS  FD8.0
0F134:  BRA    F2B0
....................             check_string(buffer); 
*
00C00:  MOVFF  B35,B3A
00C04:  MOVFF  B34,B39
*
00FD0:  MOVFF  B35,B3A
00FD4:  MOVFF  B34,B39
*
013AE:  MOVFF  B35,B3A
013B2:  MOVFF  B34,B39
*
0177E:  MOVFF  B35,B3A
01782:  MOVFF  B34,B39
*
0ED7E:  MOVFF  B35,B3A
0ED82:  MOVFF  B34,B39
*
0F136:  MOVFF  B35,B3A
0F13A:  MOVFF  B34,B39
....................             break; 
*
00D78:  BRA    0D94
*
01148:  BRA    1164
*
01526:  BRA    1542
*
018F6:  BRA    1912
*
0EEF6:  BRA    EF12
*
0F2AE:  BRA    F2CA
....................         } 
....................         buffer->position++; 
*
00D7A:  MOVLW  03
00D7C:  ADDWF  x34,W
00D7E:  MOVWF  FE9
00D80:  MOVLW  00
00D82:  ADDWFC x35,W
00D84:  MOVWF  FEA
00D86:  MOVLW  01
00D88:  ADDWF  FEE,F
00D8A:  BNC   0D8E
00D8C:  INCF   FEF,F
*
0114A:  MOVLW  03
0114C:  ADDWF  x34,W
0114E:  MOVWF  FE9
01150:  MOVLW  00
01152:  ADDWFC x35,W
01154:  MOVWF  FEA
01156:  MOVLW  01
01158:  ADDWF  FEE,F
0115A:  BNC   115E
0115C:  INCF   FEF,F
*
01528:  MOVLW  03
0152A:  ADDWF  x34,W
0152C:  MOVWF  FE9
0152E:  MOVLW  00
01530:  ADDWFC x35,W
01532:  MOVWF  FEA
01534:  MOVLW  01
01536:  ADDWF  FEE,F
01538:  BNC   153C
0153A:  INCF   FEF,F
*
018F8:  MOVLW  03
018FA:  ADDWF  x34,W
018FC:  MOVWF  FE9
018FE:  MOVLW  00
01900:  ADDWFC x35,W
01902:  MOVWF  FEA
01904:  MOVLW  01
01906:  ADDWF  FEE,F
01908:  BNC   190C
0190A:  INCF   FEF,F
*
0EEF8:  MOVLW  03
0EEFA:  ADDWF  x34,W
0EEFC:  MOVWF  FE9
0EEFE:  MOVLW  00
0EF00:  ADDWFC x35,W
0EF02:  MOVWF  FEA
0EF04:  MOVLW  01
0EF06:  ADDWF  FEE,F
0EF08:  BNC   EF0C
0EF0A:  INCF   FEF,F
*
0F2B0:  MOVLW  03
0F2B2:  ADDWF  x34,W
0F2B4:  MOVWF  FE9
0F2B6:  MOVLW  00
0F2B8:  ADDWFC x35,W
0F2BA:  MOVWF  FEA
0F2BC:  MOVLW  01
0F2BE:  ADDWF  FEE,F
0F2C0:  BNC   F2C4
0F2C2:  INCF   FEF,F
....................         break; 
*
00D8E:  BRA    0D94
00D90:  MOVLB  0
*
0115E:  BRA    1164
01160:  MOVLB  0
*
0153C:  BRA    1542
0153E:  MOVLB  0
*
0190C:  BRA    1912
0190E:  MOVLB  0
*
0EF0C:  BRA    EF12
0EF0E:  MOVLB  0
*
0F2C4:  BRA    F2CA
0F2C6:  MOVLB  0
....................     default: 
....................         break; 
*
00D92:  MOVLB  B
*
01162:  MOVLB  B
*
01540:  MOVLB  B
*
01910:  MOVLB  B
*
0EF10:  MOVLB  B
*
0F2C8:  MOVLB  B
....................     } 
....................     if (buffer->position >= buffer->data + buffer->size) { 
*
00D94:  MOVLW  03
00D96:  ADDWF  x34,W
00D98:  MOVWF  FE9
00D9A:  MOVLW  00
00D9C:  ADDWFC x35,W
00D9E:  MOVWF  FEA
00DA0:  MOVFF  FEC,B3A
00DA4:  MOVF   FED,F
00DA6:  MOVFF  FEF,B39
00DAA:  MOVFF  B34,FE9
00DAE:  MOVFF  B35,FEA
00DB2:  MOVFF  FEC,B3C
00DB6:  MOVF   FED,F
00DB8:  MOVFF  FEF,B3B
00DBC:  MOVLW  02
00DBE:  ADDWF  x34,W
00DC0:  MOVWF  FE9
00DC2:  MOVLW  00
00DC4:  ADDWFC x35,W
00DC6:  MOVWF  FEA
00DC8:  MOVF   FEF,W
00DCA:  ADDWF  x3B,W
00DCC:  MOVWF  01
00DCE:  MOVLW  00
00DD0:  ADDWFC x3C,W
00DD2:  MOVWF  03
00DD4:  MOVF   03,W
00DD6:  SUBWF  x3A,W
00DD8:  BNC   0E50
00DDA:  BNZ   0DE2
00DDC:  MOVF   01,W
00DDE:  SUBWF  x39,W
00DE0:  BNC   0E50
*
01164:  MOVLW  03
01166:  ADDWF  x34,W
01168:  MOVWF  FE9
0116A:  MOVLW  00
0116C:  ADDWFC x35,W
0116E:  MOVWF  FEA
01170:  MOVFF  FEC,B3A
01174:  MOVF   FED,F
01176:  MOVFF  FEF,B39
0117A:  MOVFF  B34,FE9
0117E:  MOVFF  B35,FEA
01182:  MOVFF  FEC,B3C
01186:  MOVF   FED,F
01188:  MOVFF  FEF,B3B
0118C:  MOVLW  02
0118E:  ADDWF  x34,W
01190:  MOVWF  FE9
01192:  MOVLW  00
01194:  ADDWFC x35,W
01196:  MOVWF  FEA
01198:  MOVF   FEF,W
0119A:  ADDWF  x3B,W
0119C:  MOVWF  01
0119E:  MOVLW  00
011A0:  ADDWFC x3C,W
011A2:  MOVWF  03
011A4:  MOVF   03,W
011A6:  SUBWF  x3A,W
011A8:  BNC   1220
011AA:  BNZ   11B2
011AC:  MOVF   01,W
011AE:  SUBWF  x39,W
011B0:  BNC   1220
*
01542:  MOVLW  03
01544:  ADDWF  x34,W
01546:  MOVWF  FE9
01548:  MOVLW  00
0154A:  ADDWFC x35,W
0154C:  MOVWF  FEA
0154E:  MOVFF  FEC,B3A
01552:  MOVF   FED,F
01554:  MOVFF  FEF,B39
01558:  MOVFF  B34,FE9
0155C:  MOVFF  B35,FEA
01560:  MOVFF  FEC,B3C
01564:  MOVF   FED,F
01566:  MOVFF  FEF,B3B
0156A:  MOVLW  02
0156C:  ADDWF  x34,W
0156E:  MOVWF  FE9
01570:  MOVLW  00
01572:  ADDWFC x35,W
01574:  MOVWF  FEA
01576:  MOVF   FEF,W
01578:  ADDWF  x3B,W
0157A:  MOVWF  01
0157C:  MOVLW  00
0157E:  ADDWFC x3C,W
01580:  MOVWF  03
01582:  MOVF   03,W
01584:  SUBWF  x3A,W
01586:  BNC   15FE
01588:  BNZ   1590
0158A:  MOVF   01,W
0158C:  SUBWF  x39,W
0158E:  BNC   15FE
*
01912:  MOVLW  03
01914:  ADDWF  x34,W
01916:  MOVWF  FE9
01918:  MOVLW  00
0191A:  ADDWFC x35,W
0191C:  MOVWF  FEA
0191E:  MOVFF  FEC,B3A
01922:  MOVF   FED,F
01924:  MOVFF  FEF,B39
01928:  MOVFF  B34,FE9
0192C:  MOVFF  B35,FEA
01930:  MOVFF  FEC,B3C
01934:  MOVF   FED,F
01936:  MOVFF  FEF,B3B
0193A:  MOVLW  02
0193C:  ADDWF  x34,W
0193E:  MOVWF  FE9
01940:  MOVLW  00
01942:  ADDWFC x35,W
01944:  MOVWF  FEA
01946:  MOVF   FEF,W
01948:  ADDWF  x3B,W
0194A:  MOVWF  01
0194C:  MOVLW  00
0194E:  ADDWFC x3C,W
01950:  MOVWF  03
01952:  MOVF   03,W
01954:  SUBWF  x3A,W
01956:  BNC   19CE
01958:  BNZ   1960
0195A:  MOVF   01,W
0195C:  SUBWF  x39,W
0195E:  BNC   19CE
*
0EF12:  MOVLW  03
0EF14:  ADDWF  x34,W
0EF16:  MOVWF  FE9
0EF18:  MOVLW  00
0EF1A:  ADDWFC x35,W
0EF1C:  MOVWF  FEA
0EF1E:  MOVFF  FEC,B3A
0EF22:  MOVF   FED,F
0EF24:  MOVFF  FEF,B39
0EF28:  MOVFF  B34,FE9
0EF2C:  MOVFF  B35,FEA
0EF30:  MOVFF  FEC,B3C
0EF34:  MOVF   FED,F
0EF36:  MOVFF  FEF,B3B
0EF3A:  MOVLW  02
0EF3C:  ADDWF  x34,W
0EF3E:  MOVWF  FE9
0EF40:  MOVLW  00
0EF42:  ADDWFC x35,W
0EF44:  MOVWF  FEA
0EF46:  MOVF   FEF,W
0EF48:  ADDWF  x3B,W
0EF4A:  MOVWF  01
0EF4C:  MOVLW  00
0EF4E:  ADDWFC x3C,W
0EF50:  MOVWF  03
0EF52:  MOVF   03,W
0EF54:  SUBWF  x3A,W
0EF56:  BNC   EFCE
0EF58:  BNZ   EF60
0EF5A:  MOVF   01,W
0EF5C:  SUBWF  x39,W
0EF5E:  BNC   EFCE
*
0F2CA:  MOVLW  03
0F2CC:  ADDWF  x34,W
0F2CE:  MOVWF  FE9
0F2D0:  MOVLW  00
0F2D2:  ADDWFC x35,W
0F2D4:  MOVWF  FEA
0F2D6:  MOVFF  FEC,B3A
0F2DA:  MOVF   FED,F
0F2DC:  MOVFF  FEF,B39
0F2E0:  MOVFF  B34,FE9
0F2E4:  MOVFF  B35,FEA
0F2E8:  MOVFF  FEC,B3C
0F2EC:  MOVF   FED,F
0F2EE:  MOVFF  FEF,B3B
0F2F2:  MOVLW  02
0F2F4:  ADDWF  x34,W
0F2F6:  MOVWF  FE9
0F2F8:  MOVLW  00
0F2FA:  ADDWFC x35,W
0F2FC:  MOVWF  FEA
0F2FE:  MOVF   FEF,W
0F300:  ADDWF  x3B,W
0F302:  MOVWF  01
0F304:  MOVLW  00
0F306:  ADDWFC x3C,W
0F308:  MOVWF  03
0F30A:  MOVF   03,W
0F30C:  SUBWF  x3A,W
0F30E:  BNC   F386
0F310:  BNZ   F318
0F312:  MOVF   01,W
0F314:  SUBWF  x39,W
0F316:  BNC   F386
....................         uart_reset(buffer); 
*
00DE2:  MOVFF  B35,B3A
00DE6:  MOVFF  B34,B39
*
011B2:  MOVFF  B35,B3A
011B6:  MOVFF  B34,B39
*
01590:  MOVFF  B35,B3A
01594:  MOVFF  B34,B39
*
01960:  MOVFF  B35,B3A
01964:  MOVFF  B34,B39
*
0EF60:  MOVFF  B35,B3A
0EF64:  MOVFF  B34,B39
*
0F318:  MOVFF  B35,B3A
0F31C:  MOVFF  B34,B39
....................     } 
.................... } 
....................  
.................... #endif // !LIBUART_H 
....................  
.................... #include "libuart_fn.h" 
.................... #ifndef LIBUART_FN_H 
.................... #define LIBUART_FN_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... void uart_print_pc_hex(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size - 1; i++) { 
*
04EF0:  MOVLB  A
04EF2:  CLRF   x56
04EF4:  MOVLW  01
04EF6:  SUBWF  x55,W
04EF8:  SUBWF  x56,W
04EFA:  BC    4F28
....................         fprintf(PC, "%02X ", data[i]); 
04EFC:  MOVF   x56,W
04EFE:  ADDWF  x53,W
04F00:  MOVWF  FE9
04F02:  MOVLW  00
04F04:  ADDWFC x54,W
04F06:  MOVWF  FEA
04F08:  MOVFF  FEF,A58
04F0C:  MOVLW  37
04F0E:  MOVWF  x59
04F10:  MOVLB  0
04F12:  CALL   3142
04F16:  MOVLW  20
04F18:  MOVLB  B
04F1A:  MOVWF  x1F
04F1C:  MOVLB  0
04F1E:  CALL   1C34
04F22:  MOVLB  A
04F24:  INCF   x56,F
04F26:  BRA    4EF4
....................     } 
....................     fprintf(PC, "%02X", data[size - 1]); 
04F28:  MOVLW  01
04F2A:  SUBWF  x55,W
04F2C:  ADDWF  x53,W
04F2E:  MOVWF  FE9
04F30:  MOVLW  00
04F32:  ADDWFC x54,W
04F34:  MOVWF  FEA
04F36:  MOVFF  FEF,A58
04F3A:  MOVLW  37
04F3C:  MOVWF  x59
04F3E:  MOVLB  0
04F40:  CALL   3142
04F44:  RETURN 0
.................... } 
....................  
.................... void uart_print_pc_hex_short(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size; i++) { 
*
0AAD8:  MOVLB  A
0AADA:  CLRF   x1D
0AADC:  MOVF   x1C,W
0AADE:  SUBWF  x1D,W
0AAE0:  BC    AB02
....................         fprintf(PC, "%02X", data[i]); 
0AAE2:  MOVF   x1D,W
0AAE4:  ADDWF  x1A,W
0AAE6:  MOVWF  FE9
0AAE8:  MOVLW  00
0AAEA:  ADDWFC x1B,W
0AAEC:  MOVWF  FEA
0AAEE:  MOVFF  FEF,A58
0AAF2:  MOVLW  37
0AAF4:  MOVWF  x59
0AAF6:  MOVLB  0
0AAF8:  CALL   3142
0AAFC:  MOVLB  A
0AAFE:  INCF   x1D,F
0AB00:  BRA    AADC
....................     } 
0AB02:  MOVLB  0
0AB04:  RETURN 0
.................... } 
....................  
.................... void uart_download_packet(uart_fn* port, uint8_t* buffer, uint32_t size, uint32_t timeout) 
*
0726A:  MOVLB  A
0726C:  CLRF   xD9
.................... { 
....................     uint8_t n = 0; 
....................     for (uint32_t i = 0; i < timeout; i++) { 
0726E:  CLRF   xDD
07270:  CLRF   xDC
07272:  CLRF   xDB
07274:  CLRF   xDA
07276:  MOVF   xDD,W
07278:  SUBWF  xD8,W
0727A:  BNC   7322
0727C:  BNZ   7294
0727E:  MOVF   xDC,W
07280:  SUBWF  xD7,W
07282:  BNC   7322
07284:  BNZ   7294
07286:  MOVF   xDB,W
07288:  SUBWF  xD6,W
0728A:  BNC   7322
0728C:  BNZ   7294
0728E:  MOVF   xD5,W
07290:  SUBWF  xDA,W
07292:  BC    7322
....................         if (port->bytes_available()) { 
07294:  MOVFF  ACD,01
07298:  MOVFF  ACE,03
0729C:  MOVFF  ACD,ADE
072A0:  MOVFF  ACE,ADF
072A4:  MOVFF  ACE,FEA
072A8:  MOVFF  ACD,FE9
072AC:  MOVLB  0
072AE:  CALL   0204
072B2:  MOVF   01,F
072B4:  BZ    730E
....................             buffer[n++] = port->get_char(); 
072B6:  MOVLB  A
072B8:  MOVF   xD9,W
072BA:  INCF   xD9,F
072BC:  ADDWF  xCF,W
072BE:  MOVWF  01
072C0:  MOVLW  00
072C2:  ADDWFC xD0,W
072C4:  MOVWF  03
072C6:  MOVFF  01,ADE
072CA:  MOVWF  xDF
072CC:  MOVLW  04
072CE:  ADDWF  xCD,W
072D0:  MOVWF  01
072D2:  MOVLW  00
072D4:  ADDWFC xCE,W
072D6:  MOVWF  03
072D8:  MOVFF  01,AE0
072DC:  MOVWF  xE1
072DE:  MOVWF  FEA
072E0:  MOVFF  01,FE9
072E4:  MOVLB  0
072E6:  CALL   0204
072EA:  MOVFF  ADF,FEA
072EE:  MOVFF  ADE,FE9
072F2:  MOVFF  01,FEF
....................             if (n >= size) 
072F6:  MOVLB  A
072F8:  MOVF   xD4,F
072FA:  BNZ   730C
072FC:  MOVF   xD3,F
072FE:  BNZ   730C
07300:  MOVF   xD2,F
07302:  BNZ   730C
07304:  MOVF   xD1,W
07306:  SUBWF  xD9,W
07308:  BNC   730C
....................                 break; 
0730A:  BRA    7322
0730C:  MOVLB  0
....................         } 
0730E:  MOVLW  01
07310:  MOVLB  A
07312:  ADDWF  xDA,F
07314:  BTFSC  FD8.0
07316:  INCF   xDB,F
07318:  BTFSC  FD8.2
0731A:  INCF   xDC,F
0731C:  BTFSC  FD8.2
0731E:  INCF   xDD,F
07320:  BRA    7276
....................     } 
07322:  MOVLB  0
07324:  RETURN 0
.................... } 
....................  
.................... // Send packet macro; buffer is of type uint8_t*; 
.................... void uart_send_packet(uart_fn* port, uint8_t* buffer, uint32_t size) 
.................... { 
....................     for (uint8_t* i = buffer; i < size + buffer; i++) { 
*
08C4E:  MOVFF  AF3,AF9
08C52:  MOVFF  AF2,AF8
08C56:  MOVLB  A
08C58:  MOVF   xF2,W
08C5A:  ADDWF  xF4,W
08C5C:  MOVWF  01
08C5E:  MOVF   xF3,W
08C60:  ADDWFC xF5,W
08C62:  MOVWF  03
08C64:  MOVF   xF9,W
08C66:  SUBWF  03,W
08C68:  BNC   8CA8
08C6A:  BNZ   8C72
08C6C:  MOVF   01,W
08C6E:  SUBWF  xF8,W
08C70:  BC    8CA8
....................         port->put_char(*i); 
08C72:  MOVLW  08
08C74:  ADDWF  xF0,W
08C76:  MOVWF  01
08C78:  MOVLW  00
08C7A:  ADDWFC xF1,W
08C7C:  MOVFF  01,AFA
08C80:  MOVWF  xFB
08C82:  MOVFF  AF9,03
08C86:  MOVFF  AF8,FE9
08C8A:  MOVFF  AF9,FEA
08C8E:  MOVFF  FEF,B1E
08C92:  MOVWF  FEA
08C94:  MOVFF  01,FE9
08C98:  MOVLB  0
08C9A:  CALL   0204
08C9E:  MOVLB  A
08CA0:  INCF   xF8,F
08CA2:  BTFSC  FD8.2
08CA4:  INCF   xF9,F
08CA6:  BRA    8C58
....................     } 
08CA8:  MOVLB  0
08CAA:  RETURN 0
.................... } 
....................  
.................... void uart_send_packet_repeat(uart_fn* port, uint8_t* buffer, uint32_t size, uint8_t repetitions, uint32_t delay) 
.................... { 
....................     for(uint8_t i=0; i<repetitions; i++){ 
08CAC:  MOVLB  A
08CAE:  CLRF   x64
08CB0:  MOVF   x5F,W
08CB2:  SUBWF  x64,W
08CB4:  BC    8D04
....................         uart_send_packet(port, buffer, size); 
08CB6:  MOVFF  A58,AF1
08CBA:  MOVFF  A57,AF0
08CBE:  MOVFF  A5A,AF3
08CC2:  MOVFF  A59,AF2
08CC6:  MOVFF  A5E,AF7
08CCA:  MOVFF  A5D,AF6
08CCE:  MOVFF  A5C,AF5
08CD2:  MOVFF  A5B,AF4
08CD6:  MOVLB  0
08CD8:  RCALL  8C4E
....................         delay_ms(delay); 
08CDA:  MOVFF  A61,A65
08CDE:  MOVLB  A
08CE0:  INCF   x65,F
08CE2:  DECF   x65,F
08CE4:  BTFSC  FD8.2
08CE6:  BRA    8CF4
08CE8:  SETF   xDB
08CEA:  MOVLB  0
08CEC:  CALL   36F2
08CF0:  MOVLB  A
08CF2:  BRA    8CE2
08CF4:  MOVFF  A60,ADB
08CF8:  MOVLB  0
08CFA:  CALL   36F2
08CFE:  MOVLB  A
08D00:  INCF   x64,F
08D02:  BRA    8CB0
....................     } 
08D04:  MOVLB  0
08D06:  RETURN 0
.................... } 
....................  
.................... #endif // !LIBUART_FN_H 
....................  
....................  
.................... #include "rtcperipheral.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          rtcperipheral.c                          //// 
.................... ////                                                                   //// 
.................... //// Using the built-in RTC provided on some devices, provides a time  //// 
.................... //// base and the functions needed for a time.h compatable driver.     //// 
.................... //// See time.h for documentation of the time.h library.               //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __RTCPERIPHERAL_C__ 
.................... #define __RTCPERIPHERAL_C__ 
....................  
.................... #include <time.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              time.c                                 /// 
.................... ///                                                                     /// 
.................... /// Contains common time routines that can be used by several           /// 
.................... /// timebases, and the runtime code needed for time.h.                  /// 
.................... ///                                                                     /// 
.................... /// See time.h for documentation.                                       /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __TIME_C__ 
.................... #define __TIME_C__ 
....................  
.................... /* Returns the number of days in a given month, leap year dependent 
....................  */ 
.................... static unsigned int8 DaysInMonth(unsigned int8 month, int1 IsLeapYear) 
.................... { 
....................    switch(month) 
*
01E0A:  MOVLB  A
01E0C:  MOVF   x54,W
01E0E:  XORLW  00
01E10:  MOVLB  0
01E12:  BZ    1E42
01E14:  XORLW  02
01E16:  BZ    1E42
01E18:  XORLW  06
01E1A:  BZ    1E42
01E1C:  XORLW  02
01E1E:  BZ    1E42
01E20:  XORLW  01
01E22:  BZ    1E42
01E24:  XORLW  0E
01E26:  BZ    1E42
01E28:  XORLW  02
01E2A:  BZ    1E42
01E2C:  XORLW  0A
01E2E:  BZ    1E48
01E30:  XORLW  02
01E32:  BZ    1E60
01E34:  XORLW  06
01E36:  BZ    1E60
01E38:  XORLW  0D
01E3A:  BZ    1E60
01E3C:  XORLW  02
01E3E:  BZ    1E60
01E40:  BRA    1E66
....................    { 
....................       case JANUARY: 
....................       case MARCH: 
....................       case MAY: 
....................       case JULY: 
....................       case AUGUST: 
....................       case OCTOBER: 
....................       case DECEMBER: 
....................          return 31; 
01E42:  MOVLW  1F
01E44:  MOVWF  01
01E46:  BRA    1E6A
....................  
....................       case FEBRUARY: 
....................          if(IsLeapYear) 
01E48:  MOVLB  A
01E4A:  MOVF   x55,F
01E4C:  BZ    1E58
....................             return 29;             
01E4E:  MOVLW  1D
01E50:  MOVWF  01
01E52:  MOVLB  0
01E54:  BRA    1E6A
01E56:  MOVLB  A
....................          return 28; 
01E58:  MOVLW  1C
01E5A:  MOVWF  01
01E5C:  MOVLB  0
01E5E:  BRA    1E6A
....................  
....................       case APRIL: 
....................       case JUNE: 
....................       case SEPTEMBER: 
....................       case NOVEMBER: 
....................          return 30; 
01E60:  MOVLW  1E
01E62:  MOVWF  01
01E64:  BRA    1E6A
....................        
....................       // error 
....................       default: 
....................          return 0; 
01E66:  MOVLW  00
01E68:  MOVWF  01
....................    } 
01E6A:  RETURN 0
.................... }  
....................  
.................... /* Formats a given week day (as an integer) to a string 
....................  */ 
.................... static void WeekdayAbbreviations(unsigned int8 day, char* wString) 
.................... { 
....................    switch(day) 
....................    { 
....................       case SUNDAY: 
....................       memcpy(wString,"Sun\0",4); 
....................       break; 
....................        
....................       case MONDAY: 
....................       memcpy(wString,"Mon\0",4); 
....................       break; 
....................        
....................       case TUESDAY: 
....................       memcpy(wString,"Tue\0",4); 
....................       break; 
....................        
....................       case WEDNESDAY: 
....................       memcpy(wString,"Wed\0",4); 
....................       break; 
....................        
....................       case THURSDAY: 
....................       memcpy(wString,"Thu\0",4); 
....................       break; 
....................        
....................       case FRIDAY: 
....................       memcpy(wString,"Fri\0",4); 
....................       break; 
....................        
....................       case SATURDAY: 
....................       memcpy(wString,"Sat\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(wString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Formats a given month (as an integer) to a string 
....................  */ 
.................... static void MonthAbbreviations(unsigned int8 month, char* mString) 
.................... { 
....................    switch(month) 
....................    { 
....................       case JANUARY: 
....................       memcpy(mString,"Jan\0",4); 
....................       break; 
....................        
....................       case FEBRUARY: 
....................       memcpy(mString,"Feb\0",4); 
....................       break; 
....................        
....................       case MARCH: 
....................       memcpy(mString,"Mar\0",4); 
....................       break; 
....................        
....................       case APRIL: 
....................       memcpy(mString,"Apr\0",4); 
....................       break; 
....................        
....................       case MAY: 
....................       memcpy(mString,"May\0",4); 
....................       break; 
....................        
....................       case JUNE: 
....................       memcpy(mString,"Jun\0",4); 
....................       break; 
....................        
....................       case JULY: 
....................       memcpy(mString,"Jul\0",4); 
....................       break; 
....................        
....................       case AUGUST: 
....................       memcpy(mString,"Aug\0",4); 
....................       break; 
....................        
....................       case SEPTEMBER: 
....................       memcpy(mString,"Sep\0",4); 
....................       break; 
....................        
....................       case OCTOBER: 
....................       memcpy(mString,"Oct\0",4); 
....................       break; 
....................        
....................       case NOVEMBER: 
....................       memcpy(mString,"Nov\0",4); 
....................       break; 
....................        
....................       case DECEMBER: 
....................       memcpy(mString,"Dec\0",4); 
....................       break; 
....................        
....................       default: 
....................       memcpy(mString,"Invalid\0",8); 
....................       break; 
....................    } 
.................... } 
....................  
.................... /* Determines if a year is a leap year 
....................  * 'year' is the number of years since 1900 
....................  * A year is a leap year if is evenly divisible by 4 while not divisible by 100 
....................  * or if it is evenly divisible by 400. (Ex. 2000 is a leap year, 2100 is not) 
....................  * Returns TRUE if the year is a leap year, FALSE if not 
....................  */ 
.................... static int1 LeapYear(unsigned int16 year) 
.................... { 
....................    if( ((year + 1900) % 400 == 0) ||  
....................        (((year + 1900) % 4 == 0) && ((year + 1900) % 100 != 0)) ) 
*
01D56:  MOVLW  6C
01D58:  MOVLB  A
01D5A:  ADDWF  x53,W
01D5C:  MOVWF  x55
01D5E:  MOVLW  07
01D60:  ADDWFC x54,W
01D62:  MOVWF  x56
01D64:  MOVWF  x58
01D66:  MOVFF  A55,A57
01D6A:  MOVLW  01
01D6C:  MOVWF  x5A
01D6E:  MOVLW  90
01D70:  MOVWF  x59
01D72:  MOVLB  0
01D74:  RCALL  1D10
01D76:  MOVFF  00,A55
01D7A:  MOVLB  A
01D7C:  MOVFF  03,A56
01D80:  MOVF   x55,F
01D82:  BNZ   1D88
01D84:  MOVF   x56,F
01D86:  BZ    1DD0
01D88:  MOVLW  6C
01D8A:  ADDWF  x53,W
01D8C:  MOVWF  x55
01D8E:  MOVLW  07
01D90:  ADDWFC x54,W
01D92:  MOVWF  x56
01D94:  MOVLW  03
01D96:  ANDWF  x55,F
01D98:  CLRF   x56
01D9A:  MOVF   x55,F
01D9C:  BNZ   1DD6
01D9E:  MOVF   x56,F
01DA0:  BNZ   1DD6
01DA2:  MOVLW  6C
01DA4:  ADDWF  x53,W
01DA6:  MOVWF  x55
01DA8:  MOVLW  07
01DAA:  ADDWFC x54,W
01DAC:  MOVWF  x56
01DAE:  MOVWF  x58
01DB0:  MOVFF  A55,A57
01DB4:  CLRF   x5A
01DB6:  MOVLW  64
01DB8:  MOVWF  x59
01DBA:  MOVLB  0
01DBC:  RCALL  1D10
01DBE:  MOVFF  00,A55
01DC2:  MOVLB  A
01DC4:  MOVFF  03,A56
01DC8:  MOVF   x55,F
01DCA:  BNZ   1DD0
01DCC:  MOVF   x56,F
01DCE:  BZ    1DD6
....................       return TRUE; 
01DD0:  MOVLW  01
01DD2:  MOVWF  01
01DD4:  BRA    1DDA
....................       
....................    return FALSE; 
01DD6:  MOVLW  00
01DD8:  MOVWF  01
01DDA:  MOVLB  0
01DDC:  RETURN 0
.................... } 
....................  
.................... // see time.h for documentation 
.................... signed int32 difftime(time_t later, time_t earlier) 
.................... { 
....................    return (later - earlier); 
.................... } 
....................  
.................... // see time.h for documentation 
.................... time_t mktime(struct_tm * timeT) 
*
01F56:  MOVLB  A
01F58:  CLRF   x32
01F5A:  CLRF   x31
01F5C:  CLRF   x30
01F5E:  CLRF   x2F
01F60:  BCF    x33.0
01F62:  CLRF   x35
01F64:  CLRF   x34
.................... { 
....................    time_t unixTime = 0; 
....................    int1 isLeapYear = FALSE; 
....................    unsigned int16 i = 0; 
....................     
....................    if(timeT != NULL) 
01F66:  MOVF   x2D,F
01F68:  BNZ   1F70
01F6A:  MOVF   x2E,F
01F6C:  BTFSC  FD8.2
01F6E:  BRA    2392
....................    { 
....................     
....................       unixTime += timeT->tm_sec; 
01F70:  MOVFF  A2D,FE9
01F74:  MOVFF  A2E,FEA
01F78:  MOVF   FEF,W
01F7A:  ADDWF  x2F,F
01F7C:  MOVLW  00
01F7E:  ADDWFC x30,F
01F80:  ADDWFC x31,F
01F82:  ADDWFC x32,F
....................       unixTime += (unsigned int32)(timeT->tm_min) * 60; 
01F84:  MOVLW  01
01F86:  ADDWF  x2D,W
01F88:  MOVWF  FE9
01F8A:  MOVLW  00
01F8C:  ADDWFC x2E,W
01F8E:  MOVWF  FEA
01F90:  MOVF   FEF,W
01F92:  CLRF   x39
01F94:  CLRF   x38
01F96:  CLRF   x37
01F98:  MOVWF  x36
01F9A:  MOVFF  FEA,A3B
01F9E:  MOVFF  FE9,A3A
01FA2:  MOVFF  A39,A5A
01FA6:  MOVFF  A38,A59
01FAA:  MOVFF  A37,A58
01FAE:  MOVWF  x57
01FB0:  CLRF   x5E
01FB2:  CLRF   x5D
01FB4:  CLRF   x5C
01FB6:  MOVLW  3C
01FB8:  MOVWF  x5B
01FBA:  MOVLB  0
01FBC:  RCALL  1CB4
01FBE:  MOVFF  A3B,FEA
01FC2:  MOVFF  A3A,FE9
01FC6:  MOVF   00,W
01FC8:  MOVLB  A
01FCA:  ADDWF  x2F,F
01FCC:  MOVF   01,W
01FCE:  ADDWFC x30,F
01FD0:  MOVF   02,W
01FD2:  ADDWFC x31,F
01FD4:  MOVF   03,W
01FD6:  ADDWFC x32,F
....................       unixTime += (unsigned int32)(timeT->tm_hour) * 3600; 
01FD8:  MOVLW  02
01FDA:  ADDWF  x2D,W
01FDC:  MOVWF  FE9
01FDE:  MOVLW  00
01FE0:  ADDWFC x2E,W
01FE2:  MOVWF  FEA
01FE4:  MOVF   FEF,W
01FE6:  CLRF   x39
01FE8:  CLRF   x38
01FEA:  CLRF   x37
01FEC:  MOVWF  x36
01FEE:  MOVFF  FEA,A3B
01FF2:  MOVFF  FE9,A3A
01FF6:  MOVFF  A39,A5A
01FFA:  MOVFF  A38,A59
01FFE:  MOVFF  A37,A58
02002:  MOVWF  x57
02004:  CLRF   x5E
02006:  CLRF   x5D
02008:  MOVLW  0E
0200A:  MOVWF  x5C
0200C:  MOVLW  10
0200E:  MOVWF  x5B
02010:  MOVLB  0
02012:  RCALL  1CB4
02014:  MOVFF  A3B,FEA
02018:  MOVFF  A3A,FE9
0201C:  MOVF   00,W
0201E:  MOVLB  A
02020:  ADDWF  x2F,F
02022:  MOVF   01,W
02024:  ADDWFC x30,F
02026:  MOVF   02,W
02028:  ADDWFC x31,F
0202A:  MOVF   03,W
0202C:  ADDWFC x32,F
....................        
....................       isLeapYear = LeapYear(timeT->tm_year); 
0202E:  MOVLW  05
02030:  ADDWF  x2D,W
02032:  MOVWF  FE9
02034:  MOVLW  00
02036:  ADDWFC x2E,W
02038:  MOVWF  FEA
0203A:  MOVFF  FEC,A54
0203E:  MOVF   FED,F
02040:  MOVFF  FEF,A53
02044:  MOVLB  0
02046:  RCALL  1D56
02048:  MOVLB  A
0204A:  BCF    x33.0
0204C:  BTFSC  01.0
0204E:  BSF    x33.0
....................        /* Clamp the month to [0,11) */ 
....................       timeT->tm_mon %= 12; 
02050:  MOVLW  04
02052:  ADDWF  x2D,W
02054:  MOVWF  FE9
02056:  MOVLW  00
02058:  ADDWFC x2E,W
0205A:  MOVWF  FEA
0205C:  MOVFF  FEF,A3B
02060:  MOVLW  0C
02062:  MOVWF  x3C
02064:  MOVLB  0
02066:  RCALL  1DDE
02068:  MOVFF  00,FEF
....................       for(i = 1;i <= timeT->tm_mon;i++) 
0206C:  MOVLB  A
0206E:  CLRF   x35
02070:  MOVLW  01
02072:  MOVWF  x34
02074:  MOVLW  04
02076:  ADDWF  x2D,W
02078:  MOVWF  FE9
0207A:  MOVLW  00
0207C:  ADDWFC x2E,W
0207E:  MOVWF  FEA
02080:  MOVF   FEF,W
02082:  MOVF   x35,F
02084:  BNZ   20F2
02086:  SUBWF  x34,W
02088:  BZ    208C
0208A:  BC    20F2
....................       { 
....................          unixTime += (DaysInMonth(i - 1,isLeapYear) * 86400); 
0208C:  MOVLW  01
0208E:  SUBWF  x34,W
02090:  MOVWF  x36
02092:  MOVLW  00
02094:  SUBWFB x35,W
02096:  MOVWF  x37
02098:  MOVLW  00
0209A:  BTFSC  x33.0
0209C:  MOVLW  01
0209E:  MOVWF  x38
020A0:  MOVFF  A36,A54
020A4:  MOVWF  x55
020A6:  MOVLB  0
020A8:  RCALL  1E0A
020AA:  MOVFF  FEA,A38
020AE:  MOVFF  FE9,A37
020B2:  MOVLB  A
020B4:  CLRF   x5A
020B6:  CLRF   x59
020B8:  CLRF   x58
020BA:  MOVFF  01,A57
020BE:  CLRF   x5E
020C0:  MOVLW  01
020C2:  MOVWF  x5D
020C4:  MOVLW  51
020C6:  MOVWF  x5C
020C8:  MOVLW  80
020CA:  MOVWF  x5B
020CC:  MOVLB  0
020CE:  RCALL  1CB4
020D0:  MOVFF  A38,FEA
020D4:  MOVFF  A37,FE9
020D8:  MOVF   00,W
020DA:  MOVLB  A
020DC:  ADDWF  x2F,F
020DE:  MOVF   01,W
020E0:  ADDWFC x30,F
020E2:  MOVF   02,W
020E4:  ADDWFC x31,F
020E6:  MOVF   03,W
020E8:  ADDWFC x32,F
020EA:  INCF   x34,F
020EC:  BTFSC  FD8.2
020EE:  INCF   x35,F
020F0:  BRA    2074
....................       } 
....................        
....................       /* Clamp the days in the month */ 
....................       //timeT->tm_mday %= DaysInMonth(timeT->tm_mon,isLeapYear); 
....................       unixTime += (timeT->tm_mday - 1) * 86400; 
020F2:  MOVLW  03
020F4:  ADDWF  x2D,W
020F6:  MOVWF  FE9
020F8:  MOVLW  00
020FA:  ADDWFC x2E,W
020FC:  MOVWF  FEA
020FE:  MOVLW  01
02100:  SUBWF  FEF,W
02102:  MOVWF  x37
02104:  MOVFF  FEA,A39
02108:  MOVFF  FE9,A38
0210C:  CLRF   x5A
0210E:  CLRF   x59
02110:  CLRF   x58
02112:  MOVWF  x57
02114:  CLRF   x5E
02116:  MOVLW  01
02118:  MOVWF  x5D
0211A:  MOVLW  51
0211C:  MOVWF  x5C
0211E:  MOVLW  80
02120:  MOVWF  x5B
02122:  MOVLB  0
02124:  RCALL  1CB4
02126:  MOVFF  A39,FEA
0212A:  MOVFF  A38,FE9
0212E:  MOVF   00,W
02130:  MOVLB  A
02132:  ADDWF  x2F,F
02134:  MOVF   01,W
02136:  ADDWFC x30,F
02138:  MOVF   02,W
0213A:  ADDWFC x31,F
0213C:  MOVF   03,W
0213E:  ADDWFC x32,F
....................        
....................       if(isLeapYear) 
02140:  BTFSS  x33.0
02142:  BRA    21DC
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 366; 
02144:  MOVLW  08
02146:  ADDWF  x2D,W
02148:  MOVWF  01
0214A:  MOVLW  00
0214C:  ADDWFC x2E,W
0214E:  MOVWF  03
02150:  MOVFF  01,A36
02154:  MOVWF  x37
02156:  MOVFF  FEA,A39
0215A:  MOVFF  FE9,A38
0215E:  BCF    FD8.1
02160:  MOVFF  A32,A5E
02164:  MOVFF  A31,A5D
02168:  MOVFF  A30,A5C
0216C:  MOVFF  A2F,A5B
02170:  CLRF   x62
02172:  MOVLW  01
02174:  MOVWF  x61
02176:  MOVLW  51
02178:  MOVWF  x60
0217A:  MOVLW  80
0217C:  MOVWF  x5F
0217E:  MOVLB  0
02180:  RCALL  1E6C
02182:  MOVFF  A39,FEA
02186:  MOVFF  A38,FE9
0218A:  MOVFF  03,A3D
0218E:  MOVFF  02,A3C
02192:  MOVFF  01,A3B
02196:  MOVFF  00,A3A
0219A:  BSF    FD8.1
0219C:  MOVLW  0A
0219E:  MOVWF  FEA
021A0:  MOVLW  40
021A2:  MOVWF  FE9
021A4:  MOVFF  03,A5E
021A8:  MOVFF  02,A5D
021AC:  MOVFF  01,A5C
021B0:  MOVFF  00,A5B
021B4:  MOVLB  A
021B6:  CLRF   x62
021B8:  CLRF   x61
021BA:  MOVLW  01
021BC:  MOVWF  x60
021BE:  MOVLW  6E
021C0:  MOVWF  x5F
021C2:  MOVLB  0
021C4:  RCALL  1E6C
021C6:  MOVFF  A37,FEA
021CA:  MOVFF  A36,FE9
021CE:  MOVFF  A41,FEC
021D2:  MOVF   FED,F
021D4:  MOVFF  A40,FEF
....................       } 
021D8:  BRA    2270
021DA:  MOVLB  A
....................       else 
....................       { 
....................          timeT->tm_yday = (unixTime / 86400) % 365; 
021DC:  MOVLW  08
021DE:  ADDWF  x2D,W
021E0:  MOVWF  01
021E2:  MOVLW  00
021E4:  ADDWFC x2E,W
021E6:  MOVWF  03
021E8:  MOVFF  01,A36
021EC:  MOVWF  x37
021EE:  MOVFF  FEA,A39
021F2:  MOVFF  FE9,A38
021F6:  BCF    FD8.1
021F8:  MOVFF  A32,A5E
021FC:  MOVFF  A31,A5D
02200:  MOVFF  A30,A5C
02204:  MOVFF  A2F,A5B
02208:  CLRF   x62
0220A:  MOVLW  01
0220C:  MOVWF  x61
0220E:  MOVLW  51
02210:  MOVWF  x60
02212:  MOVLW  80
02214:  MOVWF  x5F
02216:  MOVLB  0
02218:  RCALL  1E6C
0221A:  MOVFF  A39,FEA
0221E:  MOVFF  A38,FE9
02222:  MOVFF  03,A3D
02226:  MOVFF  02,A3C
0222A:  MOVFF  01,A3B
0222E:  MOVFF  00,A3A
02232:  BSF    FD8.1
02234:  MOVLW  0A
02236:  MOVWF  FEA
02238:  MOVLW  40
0223A:  MOVWF  FE9
0223C:  MOVFF  03,A5E
02240:  MOVFF  02,A5D
02244:  MOVFF  01,A5C
02248:  MOVFF  00,A5B
0224C:  MOVLB  A
0224E:  CLRF   x62
02250:  CLRF   x61
02252:  MOVLW  01
02254:  MOVWF  x60
02256:  MOVLW  6D
02258:  MOVWF  x5F
0225A:  MOVLB  0
0225C:  RCALL  1E6C
0225E:  MOVFF  A37,FEA
02262:  MOVFF  A36,FE9
02266:  MOVFF  A41,FEC
0226A:  MOVF   FED,F
0226C:  MOVFF  A40,FEF
....................       } 
....................        
....................      #if defined(TIME_T_USES_2010) 
....................       i = 110; 
....................       if(timeT->tm_year - 110 >= 0) 
....................      #else 
....................       i = 70; 
02270:  MOVLB  A
02272:  CLRF   x35
02274:  MOVLW  46
02276:  MOVWF  x34
....................       if(timeT->tm_year - 70 >= 0) 
02278:  MOVLW  05
0227A:  ADDWF  x2D,W
0227C:  MOVWF  FE9
0227E:  MOVLW  00
02280:  ADDWFC x2E,W
02282:  MOVWF  FEA
02284:  MOVFF  FEC,A37
02288:  MOVF   FED,F
0228A:  MOVFF  FEF,A36
0228E:  MOVLW  46
02290:  SUBWF  x36,F
02292:  MOVLW  00
02294:  SUBWFB x37,F
....................      #endif 
....................       { 
....................          while(i < (timeT->tm_year)) 
02296:  MOVLW  05
02298:  ADDWF  x2D,W
0229A:  MOVWF  FE9
0229C:  MOVLW  00
0229E:  ADDWFC x2E,W
022A0:  MOVWF  FEA
022A2:  MOVFF  FEC,03
022A6:  MOVF   FED,F
022A8:  MOVFF  FEF,01
022AC:  MOVF   x35,W
022AE:  SUBWF  03,W
022B0:  BNC   22F8
022B2:  BNZ   22BA
022B4:  MOVF   01,W
022B6:  SUBWF  x34,W
022B8:  BC    22F8
....................          { 
....................             isLeapYear = LeapYear(i); 
022BA:  MOVFF  A35,A54
022BE:  MOVFF  A34,A53
022C2:  MOVLB  0
022C4:  RCALL  1D56
022C6:  MOVLB  A
022C8:  BCF    x33.0
022CA:  BTFSC  01.0
022CC:  BSF    x33.0
....................             if(isLeapYear) 
022CE:  BTFSS  x33.0
022D0:  BRA    22E0
....................             { 
....................                unixTime += (31622400); // seconds in 366 days 
022D2:  MOVLW  85
022D4:  ADDWF  x30,F
022D6:  MOVLW  E2
022D8:  ADDWFC x31,F
022DA:  MOVLW  01
022DC:  ADDWFC x32,F
....................             } 
022DE:  BRA    22F0
....................             else 
....................             { 
....................                unixTime += (31536000); // seconds in 365 days 
022E0:  MOVLW  80
022E2:  ADDWF  x2F,F
022E4:  MOVLW  33
022E6:  ADDWFC x30,F
022E8:  MOVLW  E1
022EA:  ADDWFC x31,F
022EC:  MOVLW  01
022EE:  ADDWFC x32,F
....................             } 
....................             i++; 
022F0:  INCF   x34,F
022F2:  BTFSC  FD8.2
022F4:  INCF   x35,F
022F6:  BRA    2296
....................          } 
....................       } 
....................        
....................      #if defined(TIME_T_USES_2010) 
....................       timeT->tm_wday = ((unixTime / 86400) + 5) % 7; 
....................      #else 
....................       timeT->tm_wday = ((unixTime / 86400) + 4) % 7; 
022F8:  MOVLW  07
022FA:  ADDWF  x2D,W
022FC:  MOVWF  01
022FE:  MOVLW  00
02300:  ADDWFC x2E,W
02302:  MOVWF  03
02304:  MOVFF  01,A36
02308:  MOVWF  x37
0230A:  MOVFF  FEA,A39
0230E:  MOVFF  FE9,A38
02312:  BCF    FD8.1
02314:  MOVFF  A32,A5E
02318:  MOVFF  A31,A5D
0231C:  MOVFF  A30,A5C
02320:  MOVFF  A2F,A5B
02324:  CLRF   x62
02326:  MOVLW  01
02328:  MOVWF  x61
0232A:  MOVLW  51
0232C:  MOVWF  x60
0232E:  MOVLW  80
02330:  MOVWF  x5F
02332:  MOVLB  0
02334:  RCALL  1E6C
02336:  MOVFF  A39,FEA
0233A:  MOVFF  A38,FE9
0233E:  MOVFF  03,A3D
02342:  MOVFF  02,A3C
02346:  MOVFF  01,A3B
0234A:  MOVFF  00,A3A
0234E:  MOVLW  04
02350:  MOVLB  A
02352:  ADDWF  x3A,F
02354:  MOVLW  00
02356:  ADDWFC x3B,F
02358:  ADDWFC x3C,F
0235A:  ADDWFC x3D,F
0235C:  BSF    FD8.1
0235E:  MOVLW  0A
02360:  MOVWF  FEA
02362:  MOVLW  40
02364:  MOVWF  FE9
02366:  MOVFF  A3D,A5E
0236A:  MOVFF  A3C,A5D
0236E:  MOVFF  A3B,A5C
02372:  MOVFF  A3A,A5B
02376:  CLRF   x62
02378:  CLRF   x61
0237A:  CLRF   x60
0237C:  MOVLW  07
0237E:  MOVWF  x5F
02380:  MOVLB  0
02382:  RCALL  1E6C
02384:  MOVFF  A37,FEA
02388:  MOVFF  A36,FE9
0238C:  MOVFF  A40,FEF
02390:  MOVLB  A
....................      #endif 
....................    } 
....................  
....................    return unixTime; 
02392:  MOVFF  A2F,00
02396:  MOVFF  A30,01
0239A:  MOVFF  A31,02
0239E:  MOVFF  A32,03
023A2:  MOVLB  0
023A4:  RETURN 0
.................... } 
....................  
.................... // see time.h for documentation 
.................... char * asctime ( struct_tm * timeptr, char * szTime = 0) 
.................... { 
....................    char result[25]; 
....................  
....................    WeekdayAbbreviations(timeptr->tm_wday, &result[0]); 
....................    result[3] = ' '; 
....................    MonthAbbreviations(timeptr->tm_mon, &result[4]); 
....................  
....................    sprintf(&result[7]," %u %02u:%02u:%02u %04lu", 
....................       timeptr->tm_mday, 
....................       timeptr->tm_hour, 
....................       timeptr->tm_min, 
....................       timeptr->tm_sec, 
....................       (timeptr->tm_year + (unsigned int16)1900)); 
....................  
....................    if (szTime) 
....................    { 
....................       strcpy(szTime, result); 
....................       return szTime; 
....................    } 
....................     
....................    return result; 
.................... } 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // stop in 's1' on a space. 
.................... // return FALSE on match, TRUE on error 
.................... static int1 _time_stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)||(*s1==' ')); 
....................     s1++, s2++) 
....................     if ((*s1 == '\0') || (*s1 == ' ')) 
....................        return(FALSE);   //match 
....................  return(TRUE); //not match 
.................... } 
....................  
.................... // see time.h for documentation 
.................... int1 timeasc(struct_tm *pTm, char *szTime) 
.................... { 
....................    struct_tm tm; 
....................    char str[9]; 
....................     
....................    if (strlen(szTime) > 20) 
....................    { 
....................       if (szTime[3] != ' ')   return(FALSE); 
....................       for (tm.tm_wday=0; tm.tm_wday<7; tm.tm_wday++) 
....................       { 
....................          WeekdayAbbreviations(tm.tm_wday, str); 
....................          if (!_time_stricmp(szTime, str)) 
....................             break; 
....................       } 
....................     
....................       if (tm.tm_wday >= 7) 
....................          return(FALSE); 
....................       szTime += 4; 
....................    } 
....................    else 
....................    { 
....................       tm.tm_wday = 0; 
....................    } 
....................     
....................    if (szTime[3] != ' ')   return(FALSE); 
....................    for (tm.tm_mon=0; tm.tm_mon<12; tm.tm_mon++) 
....................    { 
....................       MonthAbbreviations(tm.tm_mon, str); 
....................       if (!_time_stricmp(szTime, str)) 
....................          break; 
....................    } 
....................    if (tm.tm_mon >= 12) 
....................       return(FALSE); 
....................    szTime += 4; 
....................  
....................    tm.tm_mday = atoi(szTime); 
....................    szTime += 2; 
....................    if (*szTime == ' ') 
....................       szTime += 1; 
....................  
....................    if (szTime[2] != ':')   return(FALSE); 
....................    tm.tm_hour = atoi(szTime); 
....................    szTime += 3; 
....................  
....................    if (szTime[2] != ':')   return(FALSE); 
....................    tm.tm_min = atoi(szTime);    
....................    szTime += 3; 
....................  
....................    if (szTime[2] != ' ')   return(FALSE); 
....................    tm.tm_sec = atoi(szTime); 
....................    szTime += 3; 
....................  
....................    tm.tm_year = atol(szTime) - 1900; 
....................    szTime += 4; 
....................  
....................    if (pTm != NULL) 
....................    { 
....................       memcpy(pTm, &tm, sizeof(tm)); 
....................    } 
....................     
....................    return(*szTime == '\0'); 
.................... } 
....................  
.................... // see time.h for documentation 
.................... char * ctime ( time_t * timer, char *szTime = 0 ) 
.................... { 
....................    return (asctime(localtime(timer),szTime)); 
.................... } 
....................  
.................... /* Global local time variable */ 
.................... struct_tm g_lTime; 
....................  
.................... // see time.h for documenation 
.................... struct_tm * localtime(time_t * timer) 
*
0246E:  MOVLB  A
02470:  BCF    x52.0
02472:  BCF    x52.1
.................... { 
....................    time_t timeCounter; 
....................    int1 done = FALSE; 
....................    int1 isLeapYear = FALSE;   //1970 or 2010 is not a leap year 
....................  
....................    if(timer != NULL) 
02474:  MOVF   x4C,F
02476:  BNZ   247E
02478:  MOVF   x4D,F
0247A:  BTFSC  FD8.2
0247C:  BRA    2856
....................    { 
....................       timeCounter = *timer; 
0247E:  MOVFF  A4C,FE9
02482:  MOVFF  A4D,FEA
02486:  MOVFF  FEF,A4E
0248A:  MOVFF  FEC,A4F
0248E:  MOVFF  FEC,A50
02492:  MOVFF  FEC,A51
....................      #if defined(TIME_T_USES_2010) 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 5) % 7;//fill in the weekday 
....................       g_lTime.tm_year = 110; 
....................      #else 
....................       g_lTime.tm_wday = ((timeCounter / 86400) + 4) % 7;//fill in the weekday 
02496:  BCF    FD8.1
02498:  MOVFF  A51,A5E
0249C:  MOVFF  A50,A5D
024A0:  MOVFF  A4F,A5C
024A4:  MOVFF  A4E,A5B
024A8:  CLRF   x62
024AA:  MOVLW  01
024AC:  MOVWF  x61
024AE:  MOVLW  51
024B0:  MOVWF  x60
024B2:  MOVLW  80
024B4:  MOVWF  x5F
024B6:  MOVLB  0
024B8:  RCALL  1E6C
024BA:  MOVFF  03,A56
024BE:  MOVFF  02,A55
024C2:  MOVFF  01,A54
024C6:  MOVFF  00,A53
024CA:  MOVLW  04
024CC:  MOVLB  A
024CE:  ADDWF  x53,F
024D0:  MOVLW  00
024D2:  ADDWFC x54,F
024D4:  ADDWFC x55,F
024D6:  ADDWFC x56,F
024D8:  BSF    FD8.1
024DA:  MOVLW  0A
024DC:  MOVWF  FEA
024DE:  MOVLW  57
024E0:  MOVWF  FE9
024E2:  MOVFF  A56,A5E
024E6:  MOVFF  A55,A5D
024EA:  MOVFF  A54,A5C
024EE:  MOVFF  A53,A5B
024F2:  CLRF   x62
024F4:  CLRF   x61
024F6:  CLRF   x60
024F8:  MOVLW  07
024FA:  MOVWF  x5F
024FC:  MOVLB  0
024FE:  RCALL  1E6C
02500:  MOVFF  A57,7B5
....................       g_lTime.tm_year = 70;//we are starting in 1970 
02504:  MOVLB  7
02506:  CLRF   xB4
02508:  MOVLW  46
0250A:  MOVWF  xB3
....................      #endif 
....................        
....................       while(!done) 
0250C:  MOVLB  A
0250E:  BTFSC  x52.0
02510:  BRA    25FA
....................       { 
....................          if(timeCounter < (31622400) && isLeapYear) // seconds in 366 days 
02512:  BTFSC  x51.7
02514:  BRA    252C
02516:  MOVF   x51,W
02518:  SUBLW  01
0251A:  BNC   2562
0251C:  BNZ   252C
0251E:  MOVF   x50,W
02520:  SUBLW  E2
02522:  BNC   2562
02524:  BNZ   252C
02526:  MOVF   x4F,W
02528:  SUBLW  84
0252A:  BNC   2562
0252C:  BTFSS  x52.1
0252E:  BRA    2562
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
02530:  BCF    FD8.1
02532:  MOVFF  A51,A5E
02536:  MOVFF  A50,A5D
0253A:  MOVFF  A4F,A5C
0253E:  MOVFF  A4E,A5B
02542:  CLRF   x62
02544:  MOVLW  01
02546:  MOVWF  x61
02548:  MOVLW  51
0254A:  MOVWF  x60
0254C:  MOVLW  80
0254E:  MOVWF  x5F
02550:  MOVLB  0
02552:  RCALL  1E6C
02554:  MOVFF  01,7B7
02558:  MOVFF  00,7B6
....................             break; 
0255C:  MOVLB  A
0255E:  BRA    25FA
....................          } 
02560:  BRA    25B4
....................          else if(timeCounter < (31536000)) // seconds in 365 days 
02562:  BTFSC  x51.7
02564:  BRA    2584
02566:  MOVF   x51,W
02568:  SUBLW  01
0256A:  BNC   25B4
0256C:  BNZ   2584
0256E:  MOVF   x50,W
02570:  SUBLW  E1
02572:  BNC   25B4
02574:  BNZ   2584
02576:  MOVF   x4F,W
02578:  SUBLW  33
0257A:  BNC   25B4
0257C:  BNZ   2584
0257E:  MOVF   x4E,W
02580:  SUBLW  7F
02582:  BNC   25B4
....................          { 
....................             g_lTime.tm_yday = (timeCounter / 86400); 
02584:  BCF    FD8.1
02586:  MOVFF  A51,A5E
0258A:  MOVFF  A50,A5D
0258E:  MOVFF  A4F,A5C
02592:  MOVFF  A4E,A5B
02596:  CLRF   x62
02598:  MOVLW  01
0259A:  MOVWF  x61
0259C:  MOVLW  51
0259E:  MOVWF  x60
025A0:  MOVLW  80
025A2:  MOVWF  x5F
025A4:  MOVLB  0
025A6:  RCALL  1E6C
025A8:  MOVFF  01,7B7
025AC:  MOVFF  00,7B6
....................             break; 
025B0:  MOVLB  A
025B2:  BRA    25FA
....................          } 
....................           
....................          if(isLeapYear) 
025B4:  BTFSS  x52.1
025B6:  BRA    25CA
....................          { 
....................             timeCounter -= 31622400; // seconds in 366 days 
025B8:  MOVLW  00
025BA:  SUBWF  x4E,F
025BC:  MOVLW  85
025BE:  SUBWFB x4F,F
025C0:  MOVLW  E2
025C2:  SUBWFB x50,F
025C4:  MOVLW  01
025C6:  SUBWFB x51,F
....................          } 
025C8:  BRA    25DA
....................          else 
....................          { 
....................             timeCounter -= 31536000; // seconds in 365 days 
025CA:  MOVLW  80
025CC:  SUBWF  x4E,F
025CE:  MOVLW  33
025D0:  SUBWFB x4F,F
025D2:  MOVLW  E1
025D4:  SUBWFB x50,F
025D6:  MOVLW  01
025D8:  SUBWFB x51,F
....................          } 
....................           
....................          g_lTime.tm_year++; 
025DA:  MOVLB  7
025DC:  INCF   xB3,F
025DE:  BTFSC  FD8.2
025E0:  INCF   xB4,F
....................          isLeapYear = LeapYear(g_lTime.tm_year); 
025E2:  MOVFF  7B4,A54
025E6:  MOVFF  7B3,A53
025EA:  MOVLB  0
025EC:  CALL   1D56
025F0:  MOVLB  A
025F2:  BCF    x52.1
025F4:  BTFSC  01.0
025F6:  BSF    x52.1
025F8:  BRA    250E
....................       } 
....................        
....................       g_lTime.tm_mon = 0; 
025FA:  MOVLB  7
025FC:  CLRF   xB2
....................       while(!done) 
025FE:  MOVLB  A
02600:  BTFSC  x52.0
02602:  BRA    2736
....................       {          
....................          if(timeCounter < DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
02604:  MOVLW  00
02606:  BTFSC  x52.1
02608:  MOVLW  01
0260A:  MOVWF  x53
0260C:  MOVFF  7B2,A54
02610:  MOVWF  x55
02612:  MOVLB  0
02614:  CALL   1E0A
02618:  MOVFF  FEA,A55
0261C:  MOVFF  FE9,A54
02620:  MOVLB  A
02622:  CLRF   x5A
02624:  CLRF   x59
02626:  CLRF   x58
02628:  MOVFF  01,A57
0262C:  CLRF   x5E
0262E:  MOVLW  01
02630:  MOVWF  x5D
02632:  MOVLW  51
02634:  MOVWF  x5C
02636:  MOVLW  80
02638:  MOVWF  x5B
0263A:  MOVLB  0
0263C:  CALL   1CB4
02640:  MOVFF  A55,FEA
02644:  MOVFF  A54,FE9
02648:  MOVLB  A
0264A:  BTFSC  x51.7
0264C:  BRA    266C
0264E:  MOVF   x51,W
02650:  SUBWF  03,W
02652:  BNC   2670
02654:  BNZ   266C
02656:  MOVF   x50,W
02658:  SUBWF  02,W
0265A:  BNC   2670
0265C:  BNZ   266C
0265E:  MOVF   x4F,W
02660:  SUBWF  01,W
02662:  BNC   2670
02664:  BNZ   266C
02666:  MOVF   00,W
02668:  SUBWF  x4E,W
0266A:  BC    2670
....................          { 
....................             break; 
0266C:  BRA    2736
....................          } 
0266E:  BRA    2734
....................          else if(timeCounter >= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400) 
02670:  MOVLW  00
02672:  BTFSC  x52.1
02674:  MOVLW  01
02676:  MOVWF  x53
02678:  MOVFF  7B2,A54
0267C:  MOVWF  x55
0267E:  MOVLB  0
02680:  CALL   1E0A
02684:  MOVFF  FEA,A55
02688:  MOVFF  FE9,A54
0268C:  MOVLB  A
0268E:  CLRF   x5A
02690:  CLRF   x59
02692:  CLRF   x58
02694:  MOVFF  01,A57
02698:  CLRF   x5E
0269A:  MOVLW  01
0269C:  MOVWF  x5D
0269E:  MOVLW  51
026A0:  MOVWF  x5C
026A2:  MOVLW  80
026A4:  MOVWF  x5B
026A6:  MOVLB  0
026A8:  CALL   1CB4
026AC:  MOVFF  A55,FEA
026B0:  MOVFF  A54,FE9
026B4:  MOVLB  A
026B6:  BTFSC  x51.7
026B8:  BRA    2734
026BA:  MOVF   03,W
026BC:  SUBWF  x51,W
026BE:  BNC   2734
026C0:  BNZ   26D8
026C2:  MOVF   02,W
026C4:  SUBWF  x50,W
026C6:  BNC   2734
026C8:  BNZ   26D8
026CA:  MOVF   01,W
026CC:  SUBWF  x4F,W
026CE:  BNC   2734
026D0:  BNZ   26D8
026D2:  MOVF   00,W
026D4:  SUBWF  x4E,W
026D6:  BNC   2734
....................          { 
....................             timeCounter -= DaysInMonth(g_lTime.tm_mon,isLeapYear) * 86400; 
026D8:  MOVLW  00
026DA:  BTFSC  x52.1
026DC:  MOVLW  01
026DE:  MOVWF  x53
026E0:  MOVFF  7B2,A54
026E4:  MOVWF  x55
026E6:  MOVLB  0
026E8:  CALL   1E0A
026EC:  MOVFF  FEA,A55
026F0:  MOVFF  FE9,A54
026F4:  MOVLB  A
026F6:  CLRF   x5A
026F8:  CLRF   x59
026FA:  CLRF   x58
026FC:  MOVFF  01,A57
02700:  CLRF   x5E
02702:  MOVLW  01
02704:  MOVWF  x5D
02706:  MOVLW  51
02708:  MOVWF  x5C
0270A:  MOVLW  80
0270C:  MOVWF  x5B
0270E:  MOVLB  0
02710:  CALL   1CB4
02714:  MOVFF  A55,FEA
02718:  MOVFF  A54,FE9
0271C:  MOVF   00,W
0271E:  MOVLB  A
02720:  SUBWF  x4E,F
02722:  MOVF   01,W
02724:  SUBWFB x4F,F
02726:  MOVF   02,W
02728:  SUBWFB x50,F
0272A:  MOVF   03,W
0272C:  SUBWFB x51,F
....................             g_lTime.tm_mon++; 
0272E:  MOVLB  7
02730:  INCF   xB2,F
02732:  MOVLB  A
....................          } 
02734:  BRA    2600
....................       }   
....................  
....................       g_lTime.tm_mday = (timeCounter / (86400)); 
02736:  BCF    FD8.1
02738:  MOVFF  A51,A5E
0273C:  MOVFF  A50,A5D
02740:  MOVFF  A4F,A5C
02744:  MOVFF  A4E,A5B
02748:  CLRF   x62
0274A:  MOVLW  01
0274C:  MOVWF  x61
0274E:  MOVLW  51
02750:  MOVWF  x60
02752:  MOVLW  80
02754:  MOVWF  x5F
02756:  MOVLB  0
02758:  CALL   1E6C
0275C:  MOVFF  00,7B1
....................       timeCounter -= (g_lTime.tm_mday * (86400)); 
02760:  MOVLB  A
02762:  CLRF   x5A
02764:  CLRF   x59
02766:  CLRF   x58
02768:  MOVFF  7B1,A57
0276C:  CLRF   x5E
0276E:  MOVLW  01
02770:  MOVWF  x5D
02772:  MOVLW  51
02774:  MOVWF  x5C
02776:  MOVLW  80
02778:  MOVWF  x5B
0277A:  MOVLB  0
0277C:  CALL   1CB4
02780:  MOVF   00,W
02782:  MOVLB  A
02784:  SUBWF  x4E,F
02786:  MOVF   01,W
02788:  SUBWFB x4F,F
0278A:  MOVF   02,W
0278C:  SUBWFB x50,F
0278E:  MOVF   03,W
02790:  SUBWFB x51,F
....................       g_lTime.tm_mday += 1; 
02792:  MOVLW  01
02794:  MOVLB  7
02796:  ADDWF  xB1,F
....................        
....................       g_lTime.tm_hour = (timeCounter / (3600)); 
02798:  BCF    FD8.1
0279A:  MOVFF  A51,A5E
0279E:  MOVFF  A50,A5D
027A2:  MOVFF  A4F,A5C
027A6:  MOVFF  A4E,A5B
027AA:  MOVLB  A
027AC:  CLRF   x62
027AE:  CLRF   x61
027B0:  MOVLW  0E
027B2:  MOVWF  x60
027B4:  MOVLW  10
027B6:  MOVWF  x5F
027B8:  MOVLB  0
027BA:  CALL   1E6C
027BE:  MOVFF  00,7B0
....................       timeCounter -= ((unsigned int32)g_lTime.tm_hour) * 3600; 
027C2:  MOVLB  A
027C4:  CLRF   x56
027C6:  CLRF   x55
027C8:  CLRF   x54
027CA:  MOVFF  7B0,A53
027CE:  MOVFF  A56,A5A
027D2:  MOVFF  A55,A59
027D6:  MOVFF  A54,A58
027DA:  MOVFF  7B0,A57
027DE:  CLRF   x5E
027E0:  CLRF   x5D
027E2:  MOVLW  0E
027E4:  MOVWF  x5C
027E6:  MOVLW  10
027E8:  MOVWF  x5B
027EA:  MOVLB  0
027EC:  CALL   1CB4
027F0:  MOVF   00,W
027F2:  MOVLB  A
027F4:  SUBWF  x4E,F
027F6:  MOVF   01,W
027F8:  SUBWFB x4F,F
027FA:  MOVF   02,W
027FC:  SUBWFB x50,F
027FE:  MOVF   03,W
02800:  SUBWFB x51,F
....................        
....................       g_lTime.tm_min = (timeCounter / 60); 
02802:  BCF    FD8.1
02804:  MOVFF  A51,A5E
02808:  MOVFF  A50,A5D
0280C:  MOVFF  A4F,A5C
02810:  MOVFF  A4E,A5B
02814:  CLRF   x62
02816:  CLRF   x61
02818:  CLRF   x60
0281A:  MOVLW  3C
0281C:  MOVWF  x5F
0281E:  MOVLB  0
02820:  CALL   1E6C
02824:  MOVFF  00,7AF
....................       timeCounter -= (((unsigned int16)g_lTime.tm_min) * 60); 
02828:  MOVLB  A
0282A:  CLRF   x54
0282C:  MOVFF  7AF,A53
02830:  MOVFF  A54,A5B
02834:  MOVFF  7AF,A5A
02838:  CLRF   x5D
0283A:  MOVLW  3C
0283C:  MOVWF  x5C
0283E:  MOVLB  0
02840:  RCALL  244C
02842:  MOVF   01,W
02844:  MOVLB  A
02846:  SUBWF  x4E,F
02848:  MOVF   02,W
0284A:  SUBWFB x4F,F
0284C:  MOVLW  00
0284E:  SUBWFB x50,F
02850:  SUBWFB x51,F
....................       
....................       g_lTime.tm_sec = timeCounter; 
02852:  MOVFF  A4E,7AE
....................    } 
....................     
....................    return &g_lTime; 
02856:  MOVLW  AE
02858:  MOVWF  01
0285A:  MOVLW  07
0285C:  MOVWF  02
0285E:  MOVLB  0
02860:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define CLOCKS_PER_SECOND -1 
....................  
.................... /* Globals & Resources */ 
.................... static time_t calendar_time; //seconds since Jan 1, 1970 00:00:00 
....................  
.................... /* Returns processor time used by program (clock ticks)  
....................  * The built-in RTC does not use ticks, so return 0 
....................  */ 
.................... clock_t clock() 
.................... { 
....................     return 0; 
.................... } 
....................  
.................... /* Returns the current calendar time. 
....................  * First gets the time from the built-in RTC, converts it to seconds, 
....................  * and sets this as the calendar time. 
....................  * If a timer is specified, it will be set to the current calendar time. 
....................  * It is assumed that SetTime has already been called and the 
....................  * built-in RTCC is initialized. 
....................  */ 
.................... time_t time(time_t* timer) 
.................... { 
....................     struct_tm nTime; 
....................     rtc_time_t datetime; 
....................     rtc_read(&datetime); 
*
023A6:  MOVLB  F
023A8:  BSF    x5F.0
023AA:  BSF    x5F.1
023AC:  MOVLW  0A
023AE:  MOVWF  FEA
023B0:  MOVLW  24
023B2:  MOVWF  FE9
023B4:  MOVLW  04
023B6:  MOVWF  01
023B8:  MOVF   x5C,W
023BA:  MOVLB  0
023BC:  RCALL  1CA2
023BE:  MOVWF  FEE
023C0:  MOVLB  F
023C2:  MOVF   x5D,W
023C4:  MOVLB  0
023C6:  RCALL  1CA2
023C8:  MOVWF  FEE
023CA:  DECFSZ 01,F
023CC:  BRA    23D0
023CE:  BRA    23D4
023D0:  MOVLB  F
023D2:  BRA    23B8
....................  
....................     // adjust date to be time.h compatible 
....................     nTime.tm_year = datetime.tm_year + 100; // starting at 1900 
023D4:  MOVLW  64
023D6:  MOVLB  A
023D8:  ADDWF  x24,W
023DA:  MOVWF  x1F
023DC:  CLRF   x20
023DE:  BTFSC  FD8.0
023E0:  INCF   x1F,F
....................     nTime.tm_mon = datetime.tm_mon - 1;     // 0-11 
023E2:  MOVLW  01
023E4:  SUBWF  x27,W
023E6:  MOVWF  x1E
....................     nTime.tm_mday = datetime.tm_mday - 1;   // 0-30 
023E8:  MOVLW  01
023EA:  SUBWF  x26,W
023EC:  MOVWF  x1D
....................  
....................     nTime.tm_hour = datetime.tm_hour; 
023EE:  MOVFF  A28,A1C
....................     nTime.tm_sec = datetime.tm_sec; 
023F2:  MOVFF  A2A,A1A
....................     nTime.tm_min = datetime.tm_min; 
023F6:  MOVFF  A2B,A1B
....................  
....................     // mktime() calculates the yday and wday 
....................  
....................     calendar_time = mktime(&nTime); 
023FA:  MOVLW  0A
023FC:  MOVWF  x2E
023FE:  MOVLW  1A
02400:  MOVWF  x2D
02402:  MOVLB  0
02404:  RCALL  1F56
02406:  MOVFF  03,7BB
0240A:  MOVFF  02,7BA
0240E:  MOVFF  01,7B9
02412:  MOVFF  00,7B8
....................  
....................     if (timer != NULL) { 
02416:  MOVLB  A
02418:  MOVF   x18,F
0241A:  BNZ   2420
0241C:  MOVF   x19,F
0241E:  BZ    2438
....................         *timer = calendar_time; 
02420:  MOVFF  A18,FE9
02424:  MOVFF  A19,FEA
02428:  MOVFF  7B8,FEF
0242C:  MOVFF  7B9,FEC
02430:  MOVFF  7BA,FEC
02434:  MOVFF  7BB,FEC
....................     } 
....................  
....................     return calendar_time; 
02438:  MOVFF  7B8,00
0243C:  MOVFF  7B9,01
02440:  MOVFF  7BA,02
02444:  MOVFF  7BB,03
02448:  MOVLB  0
0244A:  RETURN 0
.................... } 
....................  
.................... /* Sets the current calendar time (in seconds) from the given time, 
....................  * and sets the time on and enables the built-in RTC 
....................  */ 
.................... void SetTime(struct_tm* nTime) 
.................... { 
....................     rtc_time_t datetime; 
....................     calendar_time = mktime(nTime); // will also set the yday and wday 
*
0BCFC:  MOVFF  A1D,A2E
0BD00:  MOVFF  A1C,A2D
0BD04:  CALL   1F56
0BD08:  MOVFF  03,7BB
0BD0C:  MOVFF  02,7BA
0BD10:  MOVFF  01,7B9
0BD14:  MOVFF  00,7B8
....................  
....................     // adjust date to be built-in RTC compatible 
....................     datetime.tm_year = nTime->tm_year - 100; // 20(00-99) 
0BD18:  MOVLW  05
0BD1A:  MOVLB  A
0BD1C:  ADDWF  x1C,W
0BD1E:  MOVWF  FE9
0BD20:  MOVLW  00
0BD22:  ADDWFC x1D,W
0BD24:  MOVWF  FEA
0BD26:  MOVFF  FEC,A28
0BD2A:  MOVF   FED,F
0BD2C:  MOVFF  FEF,A27
0BD30:  MOVLW  64
0BD32:  SUBWF  x27,W
0BD34:  MOVWF  x1E
....................     datetime.tm_mon = nTime->tm_mon + 1;     // 1-12 
0BD36:  MOVLW  04
0BD38:  ADDWF  x1C,W
0BD3A:  MOVWF  FE9
0BD3C:  MOVLW  00
0BD3E:  ADDWFC x1D,W
0BD40:  MOVWF  FEA
0BD42:  MOVLW  01
0BD44:  ADDWF  FEF,W
0BD46:  MOVWF  x21
....................     datetime.tm_mday = nTime->tm_mday + 1;   // 1-31 
0BD48:  MOVLW  03
0BD4A:  ADDWF  x1C,W
0BD4C:  MOVWF  FE9
0BD4E:  MOVLW  00
0BD50:  ADDWFC x1D,W
0BD52:  MOVWF  FEA
0BD54:  MOVLW  01
0BD56:  ADDWF  FEF,W
0BD58:  MOVWF  x20
....................     // datetime.tm_yday = 0; // Commented to avoid compiling error. 
....................  
....................     datetime.tm_hour = nTime->tm_hour; 
0BD5A:  MOVLW  02
0BD5C:  ADDWF  x1C,W
0BD5E:  MOVWF  FE9
0BD60:  MOVLW  00
0BD62:  ADDWFC x1D,W
0BD64:  MOVWF  FEA
0BD66:  MOVFF  FEF,A22
....................     datetime.tm_wday = nTime->tm_wday + 1; //1-7 
0BD6A:  MOVLW  07
0BD6C:  ADDWF  x1C,W
0BD6E:  MOVWF  FE9
0BD70:  MOVLW  00
0BD72:  ADDWFC x1D,W
0BD74:  MOVWF  FEA
0BD76:  MOVLW  01
0BD78:  ADDWF  FEF,W
0BD7A:  MOVWF  x23
....................     datetime.tm_sec = nTime->tm_sec; 
0BD7C:  MOVFF  A1C,FE9
0BD80:  MOVFF  A1D,FEA
0BD84:  MOVFF  FEF,A24
....................     datetime.tm_min = nTime->tm_min; 
0BD88:  MOVLW  01
0BD8A:  ADDWF  x1C,W
0BD8C:  MOVWF  FE9
0BD8E:  MOVLW  00
0BD90:  ADDWFC x1D,W
0BD92:  MOVWF  FEA
0BD94:  MOVFF  FEF,A25
0BD98:  MOVLB  F
....................  
....................     rtc_write(&datetime); 
0BD9A:  MOVLB  F
0BD9C:  MOVLW  55
0BD9E:  MOVWF  F7E
0BDA0:  MOVLW  AA
0BDA2:  MOVWF  F7E
0BDA4:  BSF    x5F.5
0BDA6:  BSF    x5F.0
0BDA8:  BSF    x5F.1
0BDAA:  MOVLW  0A
0BDAC:  MOVWF  FEA
0BDAE:  MOVLW  1E
0BDB0:  MOVWF  FE9
0BDB2:  MOVLW  04
0BDB4:  MOVWF  01
0BDB6:  MOVF   FEE,W
0BDB8:  MOVLB  0
0BDBA:  CALL   2862
0BDBE:  MOVLB  F
0BDC0:  MOVWF  x5C
0BDC2:  MOVF   FEE,W
0BDC4:  MOVLB  0
0BDC6:  CALL   2862
0BDCA:  MOVLB  F
0BDCC:  MOVWF  x5D
0BDCE:  DECFSZ 01,F
0BDD0:  BRA    BDB6
0BDD2:  BCF    x5F.5
0BDD4:  MOVLB  0
0BDD6:  GOTO   BFB4 (RETURN)
.................... } 
....................  
.................... /* Sets the current time on the built-in RTC given a time in seconds and 
....................  * sets the calendar time to this time. 
....................  */ 
.................... void SetTimeSec(time_t sTime) 
.................... { 
....................     struct_tm* nTime; 
....................     nTime = localtime(&sTime); 
*
02886:  MOVLW  0A
02888:  MOVLB  A
0288A:  MOVWF  x4D
0288C:  MOVLW  1C
0288E:  MOVWF  x4C
02890:  MOVLB  0
02892:  RCALL  246E
02894:  MOVFF  02,A21
02898:  MOVFF  01,A20
....................     calendar_time = sTime; 
0289C:  MOVFF  A1F,7BB
028A0:  MOVFF  A1E,7BA
028A4:  MOVFF  A1D,7B9
028A8:  MOVFF  A1C,7B8
....................  
....................     rtc_time_t datetime; 
....................  
....................     // adjust date to be built-in RTC compatible 
....................     datetime.tm_year = nTime->tm_year - 100; // 20(00-99) 
028AC:  MOVLW  05
028AE:  MOVLB  A
028B0:  ADDWF  x20,W
028B2:  MOVWF  FE9
028B4:  MOVLW  00
028B6:  ADDWFC x21,W
028B8:  MOVWF  FEA
028BA:  MOVFF  FEC,A2C
028BE:  MOVF   FED,F
028C0:  MOVFF  FEF,A2B
028C4:  MOVLW  64
028C6:  SUBWF  x2B,W
028C8:  MOVWF  x22
....................     datetime.tm_mon = nTime->tm_mon + 1;     // 1-12 
028CA:  MOVLW  04
028CC:  ADDWF  x20,W
028CE:  MOVWF  FE9
028D0:  MOVLW  00
028D2:  ADDWFC x21,W
028D4:  MOVWF  FEA
028D6:  MOVLW  01
028D8:  ADDWF  FEF,W
028DA:  MOVWF  x25
....................     datetime.tm_mday = nTime->tm_mday + 1;   // 1-31 
028DC:  MOVLW  03
028DE:  ADDWF  x20,W
028E0:  MOVWF  FE9
028E2:  MOVLW  00
028E4:  ADDWFC x21,W
028E6:  MOVWF  FEA
028E8:  MOVLW  01
028EA:  ADDWF  FEF,W
028EC:  MOVWF  x24
....................     datetime.tm_wday = nTime->tm_wday + 1;   // 1-7 
028EE:  MOVLW  07
028F0:  ADDWF  x20,W
028F2:  MOVWF  FE9
028F4:  MOVLW  00
028F6:  ADDWFC x21,W
028F8:  MOVWF  FEA
028FA:  MOVLW  01
028FC:  ADDWF  FEF,W
028FE:  MOVWF  x27
....................  
....................     datetime.tm_hour = nTime->tm_hour; 
02900:  MOVLW  02
02902:  ADDWF  x20,W
02904:  MOVWF  FE9
02906:  MOVLW  00
02908:  ADDWFC x21,W
0290A:  MOVWF  FEA
0290C:  MOVFF  FEF,A26
....................     datetime.tm_sec = nTime->tm_sec; 
02910:  MOVFF  A20,FE9
02914:  MOVFF  A21,FEA
02918:  MOVFF  FEF,A28
....................     datetime.tm_min = nTime->tm_min; 
0291C:  MOVLW  01
0291E:  ADDWF  x20,W
02920:  MOVWF  FE9
02922:  MOVLW  00
02924:  ADDWFC x21,W
02926:  MOVWF  FEA
02928:  MOVFF  FEF,A29
0292C:  MOVLB  F
....................  
....................     rtc_write(&datetime); 
0292E:  MOVLB  F
02930:  MOVLW  55
02932:  MOVWF  F7E
02934:  MOVLW  AA
02936:  MOVWF  F7E
02938:  BSF    x5F.5
0293A:  BSF    x5F.0
0293C:  BSF    x5F.1
0293E:  MOVLW  0A
02940:  MOVWF  FEA
02942:  MOVLW  22
02944:  MOVWF  FE9
02946:  MOVLW  04
02948:  MOVWF  01
0294A:  MOVF   FEE,W
0294C:  MOVLB  0
0294E:  RCALL  2862
02950:  MOVLB  F
02952:  MOVWF  x5C
02954:  MOVF   FEE,W
02956:  MOVLB  0
02958:  RCALL  2862
0295A:  MOVLB  F
0295C:  MOVWF  x5D
0295E:  DECFSZ 01,F
02960:  BRA    294A
02962:  BCF    x5F.5
02964:  MOVLB  0
02966:  RETURN 0
.................... } 
....................  
.................... /* Returns the current time from the built-in RTC as a time struct 
....................  */ 
.................... void GetTime(struct_tm* pRetTm) 
.................... { 
....................     struct_tm cTime; 
....................     rtc_time_t datetime; 
....................     rtc_read(&datetime); 
....................  
....................     // adjust date to be time.h compatible 
....................     cTime.tm_year = datetime.tm_year + 100; // starting at 1900 
....................     cTime.tm_mon = datetime.tm_mon - 1;     // 0-11 
....................     cTime.tm_mday = datetime.tm_mday - 1;   // 0-30 
....................     cTime.tm_wday = datetime.tm_wday - 1;   // 0-6 
....................  
....................     cTime.tm_hour = datetime.tm_hour; 
....................     cTime.tm_sec = datetime.tm_sec; 
....................     cTime.tm_min = datetime.tm_min; 
....................  
....................     memcpy(pRetTm, &cTime, sizeof(struct_tm)); 
.................... } 
....................  
.................... /* Initializes The Built-In RTC 
....................  */ 
.................... void TimeInit(void) 
.................... { 
....................     setup_rtc(RTC_ENABLE | RTC_OUTPUT_SECONDS, 0); 
.................... } 
....................  
.................... #endif //__RTCPERIPHERAL_C__ 
....................  
.................... uart_use(PC); 
*
029EE:  MOVFF  B1E,B1F
029F2:  CALL   1C34
029F6:  RETURN 0
*
02B7E:  MOVLW  00
02B80:  BTFSS  F82.7
02B82:  MOVLW  01
02B84:  MOVWF  01
02B86:  RETURN 0
*
02BD2:  RCALL  2B88
02BD4:  MOVF   01,W
02BD6:  RETURN 0
.................... uart_use(PCIB); 
*
02A00:  MOVLB  B
02A02:  MOVF   x1E,W
02A04:  MOVLB  0
02A06:  RCALL  29F8
02A08:  RETURN 0
*
02BD8:  MOVLW  00
02BDA:  BTFSC  F9E.5
02BDC:  MOVLW  01
02BDE:  MOVWF  01
02BE0:  RETURN 0
02BE2:  CALL   0A8C
02BE6:  MOVF   01,W
02BE8:  RETURN 0
.................... uart_use(COMM); 
*
02A16:  MOVLB  B
02A18:  MOVF   x1E,W
02A1A:  MOVLB  0
02A1C:  RCALL  2A0A
02A1E:  RETURN 0
*
02BEA:  MOVLW  00
02BEC:  BTFSC  FA4.5
02BEE:  MOVLW  01
02BF0:  MOVWF  01
02BF2:  RETURN 0
02BF4:  CALL   0E58
02BF8:  MOVF   01,W
02BFA:  RETURN 0
.................... uart_use(ADCS); 
*
02A66:  MOVFF  B1E,B1F
02A6A:  RCALL  2A20
02A6C:  RETURN 0
*
02BFC:  MOVLW  00
02BFE:  BTFSS  F85.6
02C00:  MOVLW  01
02C02:  MOVWF  01
02C04:  RETURN 0
*
02C50:  RCALL  2C06
02C52:  MOVF   01,W
02C54:  RETURN 0
.................... uart_use(FAB); 
*
02A7A:  MOVLB  B
02A7C:  MOVF   x1E,W
02A7E:  MOVLB  0
02A80:  RCALL  2A6E
02A82:  RETURN 0
*
02C56:  MOVLW  00
02C58:  BTFSC  FA6.5
02C5A:  MOVLW  01
02C5C:  MOVWF  01
02C5E:  RETURN 0
02C60:  CALL   1236
02C64:  MOVF   01,W
02C66:  RETURN 0
.................... uart_use(RST); 
*
02A90:  MOVLB  B
02A92:  MOVF   x1E,W
02A94:  MOVLB  0
02A96:  RCALL  2A84
02A98:  RETURN 0
*
02C68:  MOVLW  00
02C6A:  BTFSC  FA6.7
02C6C:  MOVLW  01
02C6E:  MOVWF  01
02C70:  RETURN 0
02C72:  CALL   1606
02C76:  MOVF   01,W
02C78:  RETURN 0
....................  
.................... #include "memory_setup.h" 
.................... #ifndef MEMORY_SETUP_H 
.................... #define MEMORY_SETUP_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
*
02AD6:  MOVFF  B1E,B1F
02ADA:  MOVLW  08
02ADC:  MOVLB  B
02ADE:  MOVWF  x20
02AE0:  MOVLB  0
02AE2:  RCALL  2A9A
02AE4:  RETURN 0
*
02C7A:  MOVLW  02
02C7C:  MOVLB  B
02C7E:  MOVWF  x1F
02C80:  MOVLW  08
02C82:  MOVWF  x20
02C84:  MOVLB  0
02C86:  RCALL  2A9A
02C88:  MOVF   01,W
02C8A:  RETURN 0
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
*
02B22:  MOVFF  B1E,B1F
02B26:  MOVLW  08
02B28:  MOVLB  B
02B2A:  MOVWF  x20
02B2C:  MOVLB  0
02B2E:  RCALL  2AE6
02B30:  RETURN 0
*
02C8C:  MOVLW  01
02C8E:  MOVLB  B
02C90:  MOVWF  x1F
02C92:  MOVLW  08
02C94:  MOVWF  x20
02C96:  MOVLB  0
02C98:  RCALL  2AE6
02C9A:  MOVF   01,W
02C9C:  RETURN 0
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
*
02B6E:  MOVFF  B1E,B1F
02B72:  MOVLW  08
02B74:  MOVLB  B
02B76:  MOVWF  x20
02B78:  MOVLB  0
02B7A:  RCALL  2B32
02B7C:  RETURN 0
*
02C9E:  MOVLW  03
02CA0:  MOVLB  B
02CA2:  MOVWF  x1F
02CA4:  MOVLW  08
02CA6:  MOVWF  x20
02CA8:  MOVLB  0
02CAA:  RCALL  2B32
02CAC:  MOVF   01,W
02CAE:  RETURN 0
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
*
039CA:  MOVLW  0A
039CC:  MOVLB  A
039CE:  MOVWF  xEA
039D0:  MOVLW  E2
039D2:  MOVFF  AEA,AE8
039D6:  MOVWF  xE7
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
039D8:  MOVLW  08
039DA:  ADDWF  xE0,W
039DC:  MOVWF  FE9
039DE:  MOVLW  00
039E0:  ADDWFC xE1,W
039E2:  MOVWF  FEA
039E4:  MOVFF  FEC,AEA
039E8:  MOVF   FED,F
039EA:  MOVFF  FEF,AE9
039EE:  MOVFF  AE9,B1D
039F2:  MOVLB  B
039F4:  CLRF   x1E
039F6:  MOVLW  0F
039F8:  MOVWF  x20
039FA:  MOVLW  89
039FC:  MOVWF  x1F
039FE:  MOVLB  0
03A00:  CALL   29AC
03A04:  MOVFF  AE9,B1D
03A08:  MOVLB  B
03A0A:  CLRF   x1E
03A0C:  MOVLW  0F
03A0E:  MOVWF  x20
03A10:  MOVLW  92
03A12:  MOVWF  x1F
03A14:  MOVLB  0
03A16:  CALL   29AC
....................     spi_functions->spi_send(ENABLE_WRITE); 
03A1A:  MOVFF  AE0,01
03A1E:  MOVFF  AE1,03
03A22:  MOVFF  AE0,AE9
03A26:  MOVFF  AE1,AEA
03A2A:  MOVFF  AE1,FEA
03A2E:  MOVFF  AE0,FE9
03A32:  MOVLW  06
03A34:  MOVLB  B
03A36:  MOVWF  x1E
03A38:  MOVLB  0
03A3A:  CALL   0204
....................     output_high(spi_functions->cs_pin); 
03A3E:  MOVLW  08
03A40:  MOVLB  A
03A42:  ADDWF  xE0,W
03A44:  MOVWF  FE9
03A46:  MOVLW  00
03A48:  ADDWFC xE1,W
03A4A:  MOVWF  FEA
03A4C:  MOVFF  FEC,AEA
03A50:  MOVF   FED,F
03A52:  MOVFF  FEF,AE9
03A56:  MOVFF  AE9,B1D
03A5A:  MOVLW  01
03A5C:  MOVLB  B
03A5E:  MOVWF  x1E
03A60:  MOVLW  0F
03A62:  MOVWF  x20
03A64:  MOVLW  89
03A66:  MOVWF  x1F
03A68:  MOVLB  0
03A6A:  CALL   29AC
03A6E:  MOVFF  AE9,B1D
03A72:  MOVLB  B
03A74:  CLRF   x1E
03A76:  MOVLW  0F
03A78:  MOVWF  x20
03A7A:  MOVLW  92
03A7C:  MOVWF  x1F
03A7E:  MOVLB  0
03A80:  CALL   29AC
....................     output_low(spi_functions->cs_pin); 
03A84:  MOVLW  08
03A86:  MOVLB  A
03A88:  ADDWF  xE0,W
03A8A:  MOVWF  FE9
03A8C:  MOVLW  00
03A8E:  ADDWFC xE1,W
03A90:  MOVWF  FEA
03A92:  MOVFF  FEC,AEA
03A96:  MOVF   FED,F
03A98:  MOVFF  FEF,AE9
03A9C:  MOVFF  AE9,B1D
03AA0:  MOVLB  B
03AA2:  CLRF   x1E
03AA4:  MOVLW  0F
03AA6:  MOVWF  x20
03AA8:  MOVLW  89
03AAA:  MOVWF  x1F
03AAC:  MOVLB  0
03AAE:  CALL   29AC
03AB2:  MOVFF  AE9,B1D
03AB6:  MOVLB  B
03AB8:  CLRF   x1E
03ABA:  MOVLW  0F
03ABC:  MOVWF  x20
03ABE:  MOVLW  92
03AC0:  MOVWF  x1F
03AC2:  MOVLB  0
03AC4:  CALL   29AC
....................     spi_functions->spi_send(WRITE_PAGE); 
03AC8:  MOVFF  AE0,01
03ACC:  MOVFF  AE1,03
03AD0:  MOVFF  AE0,AE9
03AD4:  MOVFF  AE1,AEA
03AD8:  MOVFF  AE1,FEA
03ADC:  MOVFF  AE0,FE9
03AE0:  MOVLW  12
03AE2:  MOVLB  B
03AE4:  MOVWF  x1E
03AE6:  MOVLB  0
03AE8:  CALL   0204
....................     spi_functions->spi_send(address[3]); 
03AEC:  MOVLB  A
03AEE:  MOVFF  AE0,01
03AF2:  MOVFF  AE1,03
03AF6:  MOVFF  AE0,AE9
03AFA:  MOVFF  AE1,AEA
03AFE:  MOVLW  03
03B00:  ADDWF  xE7,W
03B02:  MOVWF  FE9
03B04:  MOVLW  00
03B06:  ADDWFC xE8,W
03B08:  MOVWF  FEA
03B0A:  MOVFF  FEF,B1E
03B0E:  MOVFF  AE1,FEA
03B12:  MOVFF  AE0,FE9
03B16:  MOVLB  0
03B18:  CALL   0204
....................     spi_functions->spi_send(address[2]); 
03B1C:  MOVLB  A
03B1E:  MOVFF  AE0,01
03B22:  MOVFF  AE1,03
03B26:  MOVFF  AE0,AE9
03B2A:  MOVFF  AE1,AEA
03B2E:  MOVLW  02
03B30:  ADDWF  xE7,W
03B32:  MOVWF  FE9
03B34:  MOVLW  00
03B36:  ADDWFC xE8,W
03B38:  MOVWF  FEA
03B3A:  MOVFF  FEF,B1E
03B3E:  MOVFF  AE1,FEA
03B42:  MOVFF  AE0,FE9
03B46:  MOVLB  0
03B48:  CALL   0204
....................     spi_functions->spi_send(address[1]); 
03B4C:  MOVLB  A
03B4E:  MOVFF  AE0,01
03B52:  MOVFF  AE1,03
03B56:  MOVFF  AE0,AE9
03B5A:  MOVFF  AE1,AEA
03B5E:  MOVLW  01
03B60:  ADDWF  xE7,W
03B62:  MOVWF  FE9
03B64:  MOVLW  00
03B66:  ADDWFC xE8,W
03B68:  MOVWF  FEA
03B6A:  MOVFF  FEF,B1E
03B6E:  MOVFF  AE1,FEA
03B72:  MOVFF  AE0,FE9
03B76:  MOVLB  0
03B78:  CALL   0204
....................     spi_functions->spi_send(address[0]); 
03B7C:  MOVFF  AE0,01
03B80:  MOVFF  AE1,03
03B84:  MOVFF  AE0,AE9
03B88:  MOVFF  AE1,AEA
03B8C:  MOVFF  AE7,FE9
03B90:  MOVFF  AE8,FEA
03B94:  MOVFF  FEF,B1E
03B98:  MOVFF  AE1,FEA
03B9C:  MOVFF  AE0,FE9
03BA0:  MOVLB  0
03BA2:  CALL   0204
....................     spi_functions->spi_send(data); 
03BA6:  MOVFF  AE0,01
03BAA:  MOVFF  AE1,03
03BAE:  MOVFF  AE0,AE9
03BB2:  MOVFF  AE1,AEA
03BB6:  MOVFF  AE1,FEA
03BBA:  MOVFF  AE0,FE9
03BBE:  MOVFF  AE6,B1E
03BC2:  MOVLB  0
03BC4:  CALL   0204
....................     output_high(spi_functions->cs_pin); 
03BC8:  MOVLW  08
03BCA:  MOVLB  A
03BCC:  ADDWF  xE0,W
03BCE:  MOVWF  FE9
03BD0:  MOVLW  00
03BD2:  ADDWFC xE1,W
03BD4:  MOVWF  FEA
03BD6:  MOVFF  FEC,AEA
03BDA:  MOVF   FED,F
03BDC:  MOVFF  FEF,AE9
03BE0:  MOVFF  AE9,B1D
03BE4:  MOVLW  01
03BE6:  MOVLB  B
03BE8:  MOVWF  x1E
03BEA:  MOVLW  0F
03BEC:  MOVWF  x20
03BEE:  MOVLW  89
03BF0:  MOVWF  x1F
03BF2:  MOVLB  0
03BF4:  CALL   29AC
03BF8:  MOVFF  AE9,B1D
03BFC:  MOVLB  B
03BFE:  CLRF   x1E
03C00:  MOVLW  0F
03C02:  MOVWF  x20
03C04:  MOVLW  92
03C06:  MOVWF  x1F
03C08:  MOVLB  0
03C0A:  CALL   29AC
....................     delay_us(20); 
03C0E:  MOVLW  1A
03C10:  MOVWF  00
03C12:  DECFSZ 00,F
03C14:  BRA    3C12
03C16:  NOP   
03C18:  RETURN 0
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
*
02CB0:  MOVLW  0B
02CB2:  MOVLB  B
02CB4:  MOVWF  x1C
02CB6:  MOVLW  14
02CB8:  MOVFF  B1C,B19
02CBC:  MOVWF  x18
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
02CBE:  MOVLW  08
02CC0:  ADDWF  x12,W
02CC2:  MOVWF  FE9
02CC4:  MOVLW  00
02CC6:  ADDWFC x13,W
02CC8:  MOVWF  FEA
02CCA:  MOVFF  FEC,B1C
02CCE:  MOVF   FED,F
02CD0:  MOVFF  FEF,B1B
02CD4:  MOVFF  B1B,B1D
02CD8:  CLRF   x1E
02CDA:  MOVLW  0F
02CDC:  MOVWF  x20
02CDE:  MOVLW  89
02CE0:  MOVWF  x1F
02CE2:  MOVLB  0
02CE4:  RCALL  29AC
02CE6:  MOVFF  B1B,B1D
02CEA:  MOVLB  B
02CEC:  CLRF   x1E
02CEE:  MOVLW  0F
02CF0:  MOVWF  x20
02CF2:  MOVLW  92
02CF4:  MOVWF  x1F
02CF6:  MOVLB  0
02CF8:  RCALL  29AC
....................     spi_functions->spi_send(READ_DATA_BYTES); 
02CFA:  MOVLB  B
02CFC:  MOVFF  B12,01
02D00:  MOVFF  B13,03
02D04:  MOVFF  B12,B1B
02D08:  MOVFF  B13,B1C
02D0C:  MOVFF  B13,FEA
02D10:  MOVFF  B12,FE9
02D14:  MOVLW  13
02D16:  MOVWF  x1E
02D18:  MOVLB  0
02D1A:  CALL   0204
....................     spi_functions->spi_send(address[3]); 
02D1E:  MOVLB  B
02D20:  MOVFF  B12,01
02D24:  MOVFF  B13,03
02D28:  MOVFF  B12,B1B
02D2C:  MOVFF  B13,B1C
02D30:  MOVLW  03
02D32:  ADDWF  x18,W
02D34:  MOVWF  FE9
02D36:  MOVLW  00
02D38:  ADDWFC x19,W
02D3A:  MOVWF  FEA
02D3C:  MOVFF  FEF,B1E
02D40:  MOVFF  B13,FEA
02D44:  MOVFF  B12,FE9
02D48:  MOVLB  0
02D4A:  CALL   0204
....................     spi_functions->spi_send(address[2]); 
02D4E:  MOVLB  B
02D50:  MOVFF  B12,01
02D54:  MOVFF  B13,03
02D58:  MOVFF  B12,B1B
02D5C:  MOVFF  B13,B1C
02D60:  MOVLW  02
02D62:  ADDWF  x18,W
02D64:  MOVWF  FE9
02D66:  MOVLW  00
02D68:  ADDWFC x19,W
02D6A:  MOVWF  FEA
02D6C:  MOVFF  FEF,B1E
02D70:  MOVFF  B13,FEA
02D74:  MOVFF  B12,FE9
02D78:  MOVLB  0
02D7A:  CALL   0204
....................     spi_functions->spi_send(address[1]); 
02D7E:  MOVLB  B
02D80:  MOVFF  B12,01
02D84:  MOVFF  B13,03
02D88:  MOVFF  B12,B1B
02D8C:  MOVFF  B13,B1C
02D90:  MOVLW  01
02D92:  ADDWF  x18,W
02D94:  MOVWF  FE9
02D96:  MOVLW  00
02D98:  ADDWFC x19,W
02D9A:  MOVWF  FEA
02D9C:  MOVFF  FEF,B1E
02DA0:  MOVFF  B13,FEA
02DA4:  MOVFF  B12,FE9
02DA8:  MOVLB  0
02DAA:  CALL   0204
....................     spi_functions->spi_send(address[0]); 
02DAE:  MOVFF  B12,01
02DB2:  MOVFF  B13,03
02DB6:  MOVFF  B12,B1B
02DBA:  MOVFF  B13,B1C
02DBE:  MOVFF  B18,FE9
02DC2:  MOVFF  B19,FEA
02DC6:  MOVFF  FEF,B1E
02DCA:  MOVFF  B13,FEA
02DCE:  MOVFF  B12,FE9
02DD2:  MOVLB  0
02DD4:  CALL   0204
....................     uint8_t data = spi_functions->spi_receive(); 
02DD8:  MOVLW  04
02DDA:  MOVLB  B
02DDC:  ADDWF  x12,W
02DDE:  MOVWF  01
02DE0:  MOVLW  00
02DE2:  ADDWFC x13,W
02DE4:  MOVWF  03
02DE6:  MOVFF  01,B1B
02DEA:  MOVWF  x1C
02DEC:  MOVWF  FEA
02DEE:  MOVFF  01,FE9
02DF2:  MOVLB  0
02DF4:  CALL   0204
02DF8:  MOVFF  01,B1A
....................     output_high(spi_functions->cs_pin); 
02DFC:  MOVLW  08
02DFE:  MOVLB  B
02E00:  ADDWF  x12,W
02E02:  MOVWF  FE9
02E04:  MOVLW  00
02E06:  ADDWFC x13,W
02E08:  MOVWF  FEA
02E0A:  MOVFF  FEC,B1C
02E0E:  MOVF   FED,F
02E10:  MOVFF  FEF,B1B
02E14:  MOVFF  B1B,B1D
02E18:  MOVLW  01
02E1A:  MOVWF  x1E
02E1C:  MOVLW  0F
02E1E:  MOVWF  x20
02E20:  MOVLW  89
02E22:  MOVWF  x1F
02E24:  MOVLB  0
02E26:  RCALL  29AC
02E28:  MOVFF  B1B,B1D
02E2C:  MOVLB  B
02E2E:  CLRF   x1E
02E30:  MOVLW  0F
02E32:  MOVWF  x20
02E34:  MOVLW  92
02E36:  MOVWF  x1F
02E38:  MOVLB  0
02E3A:  RCALL  29AC
....................     return data; 
02E3C:  MOVLB  B
02E3E:  MOVFF  B1A,01
02E42:  MOVLB  0
02E44:  RETURN 0
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
*
0371C:  MOVLW  0A
0371E:  MOVLB  A
03720:  MOVWF  xDB
03722:  MOVLW  D3
03724:  MOVFF  ADB,AD9
03728:  MOVWF  xD8
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
0372A:  MOVLW  08
0372C:  ADDWF  xD1,W
0372E:  MOVWF  FE9
03730:  MOVLW  00
03732:  ADDWFC xD2,W
03734:  MOVWF  FEA
03736:  MOVFF  FEC,ADB
0373A:  MOVF   FED,F
0373C:  MOVFF  FEF,ADA
03740:  MOVFF  ADA,B1D
03744:  MOVLB  B
03746:  CLRF   x1E
03748:  MOVLW  0F
0374A:  MOVWF  x20
0374C:  MOVLW  89
0374E:  MOVWF  x1F
03750:  MOVLB  0
03752:  CALL   29AC
03756:  MOVFF  ADA,B1D
0375A:  MOVLB  B
0375C:  CLRF   x1E
0375E:  MOVLW  0F
03760:  MOVWF  x20
03762:  MOVLW  92
03764:  MOVWF  x1F
03766:  MOVLB  0
03768:  CALL   29AC
....................     spi_functions->spi_send(ENABLE_WRITE); 
0376C:  MOVFF  AD1,01
03770:  MOVFF  AD2,03
03774:  MOVFF  AD1,ADA
03778:  MOVFF  AD2,ADB
0377C:  MOVFF  AD2,FEA
03780:  MOVFF  AD1,FE9
03784:  MOVLW  06
03786:  MOVLB  B
03788:  MOVWF  x1E
0378A:  MOVLB  0
0378C:  CALL   0204
....................     output_high(spi_functions->cs_pin); 
03790:  MOVLW  08
03792:  MOVLB  A
03794:  ADDWF  xD1,W
03796:  MOVWF  FE9
03798:  MOVLW  00
0379A:  ADDWFC xD2,W
0379C:  MOVWF  FEA
0379E:  MOVFF  FEC,ADB
037A2:  MOVF   FED,F
037A4:  MOVFF  FEF,ADA
037A8:  MOVFF  ADA,B1D
037AC:  MOVLW  01
037AE:  MOVLB  B
037B0:  MOVWF  x1E
037B2:  MOVLW  0F
037B4:  MOVWF  x20
037B6:  MOVLW  89
037B8:  MOVWF  x1F
037BA:  MOVLB  0
037BC:  CALL   29AC
037C0:  MOVFF  ADA,B1D
037C4:  MOVLB  B
037C6:  CLRF   x1E
037C8:  MOVLW  0F
037CA:  MOVWF  x20
037CC:  MOVLW  92
037CE:  MOVWF  x1F
037D0:  MOVLB  0
037D2:  CALL   29AC
....................     output_low(spi_functions->cs_pin); 
037D6:  MOVLW  08
037D8:  MOVLB  A
037DA:  ADDWF  xD1,W
037DC:  MOVWF  FE9
037DE:  MOVLW  00
037E0:  ADDWFC xD2,W
037E2:  MOVWF  FEA
037E4:  MOVFF  FEC,ADB
037E8:  MOVF   FED,F
037EA:  MOVFF  FEF,ADA
037EE:  MOVFF  ADA,B1D
037F2:  MOVLB  B
037F4:  CLRF   x1E
037F6:  MOVLW  0F
037F8:  MOVWF  x20
037FA:  MOVLW  89
037FC:  MOVWF  x1F
037FE:  MOVLB  0
03800:  CALL   29AC
03804:  MOVFF  ADA,B1D
03808:  MOVLB  B
0380A:  CLRF   x1E
0380C:  MOVLW  0F
0380E:  MOVWF  x20
03810:  MOVLW  92
03812:  MOVWF  x1F
03814:  MOVLB  0
03816:  CALL   29AC
....................     delay_us(2); 
0381A:  MOVLW  02
0381C:  MOVWF  00
0381E:  DECFSZ 00,F
03820:  BRA    381E
03822:  NOP   
....................     spi_functions->spi_send(erase_command); 
03824:  MOVFF  AD1,01
03828:  MOVFF  AD2,03
0382C:  MOVFF  AD1,ADA
03830:  MOVFF  AD2,ADB
03834:  MOVFF  AD2,FEA
03838:  MOVFF  AD1,FE9
0383C:  MOVFF  AD7,B1E
03840:  MOVLB  0
03842:  CALL   0204
....................     spi_functions->spi_send(address[3]); 
03846:  MOVLB  A
03848:  MOVFF  AD1,01
0384C:  MOVFF  AD2,03
03850:  MOVFF  AD1,ADA
03854:  MOVFF  AD2,ADB
03858:  MOVLW  03
0385A:  ADDWF  xD8,W
0385C:  MOVWF  FE9
0385E:  MOVLW  00
03860:  ADDWFC xD9,W
03862:  MOVWF  FEA
03864:  MOVFF  FEF,B1E
03868:  MOVFF  AD2,FEA
0386C:  MOVFF  AD1,FE9
03870:  MOVLB  0
03872:  CALL   0204
....................     spi_functions->spi_send(address[2]); 
03876:  MOVLB  A
03878:  MOVFF  AD1,01
0387C:  MOVFF  AD2,03
03880:  MOVFF  AD1,ADA
03884:  MOVFF  AD2,ADB
03888:  MOVLW  02
0388A:  ADDWF  xD8,W
0388C:  MOVWF  FE9
0388E:  MOVLW  00
03890:  ADDWFC xD9,W
03892:  MOVWF  FEA
03894:  MOVFF  FEF,B1E
03898:  MOVFF  AD2,FEA
0389C:  MOVFF  AD1,FE9
038A0:  MOVLB  0
038A2:  CALL   0204
....................     spi_functions->spi_send(address[1]); 
038A6:  MOVLB  A
038A8:  MOVFF  AD1,01
038AC:  MOVFF  AD2,03
038B0:  MOVFF  AD1,ADA
038B4:  MOVFF  AD2,ADB
038B8:  MOVLW  01
038BA:  ADDWF  xD8,W
038BC:  MOVWF  FE9
038BE:  MOVLW  00
038C0:  ADDWFC xD9,W
038C2:  MOVWF  FEA
038C4:  MOVFF  FEF,B1E
038C8:  MOVFF  AD2,FEA
038CC:  MOVFF  AD1,FE9
038D0:  MOVLB  0
038D2:  CALL   0204
....................     spi_functions->spi_send(address[0]); 
038D6:  MOVFF  AD1,01
038DA:  MOVFF  AD2,03
038DE:  MOVFF  AD1,ADA
038E2:  MOVFF  AD2,ADB
038E6:  MOVFF  AD8,FE9
038EA:  MOVFF  AD9,FEA
038EE:  MOVFF  FEF,B1E
038F2:  MOVFF  AD2,FEA
038F6:  MOVFF  AD1,FE9
038FA:  MOVLB  0
038FC:  CALL   0204
....................     delay_us(2); 
03900:  MOVLW  02
03902:  MOVWF  00
03904:  DECFSZ 00,F
03906:  BRA    3904
03908:  NOP   
....................     output_high(spi_functions->cs_pin); 
0390A:  MOVLW  08
0390C:  MOVLB  A
0390E:  ADDWF  xD1,W
03910:  MOVWF  FE9
03912:  MOVLW  00
03914:  ADDWFC xD2,W
03916:  MOVWF  FEA
03918:  MOVFF  FEC,ADB
0391C:  MOVF   FED,F
0391E:  MOVFF  FEF,ADA
03922:  MOVFF  ADA,B1D
03926:  MOVLW  01
03928:  MOVLB  B
0392A:  MOVWF  x1E
0392C:  MOVLW  0F
0392E:  MOVWF  x20
03930:  MOVLW  89
03932:  MOVWF  x1F
03934:  MOVLB  0
03936:  CALL   29AC
0393A:  MOVFF  ADA,B1D
0393E:  MOVLB  B
03940:  CLRF   x1E
03942:  MOVLW  0F
03944:  MOVWF  x20
03946:  MOVLW  92
03948:  MOVWF  x1F
0394A:  MOVLB  0
0394C:  CALL   29AC
....................     delay_ms(750); 
03950:  MOVLW  03
03952:  MOVLB  A
03954:  MOVWF  xDA
03956:  MOVLW  FA
03958:  MOVWF  xDB
0395A:  MOVLB  0
0395C:  RCALL  36F2
0395E:  MOVLB  A
03960:  DECFSZ xDA,F
03962:  BRA    3956
03964:  MOVLB  0
03966:  RETURN 0
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include "boot_command.h" 
.................... #ifndef BOOT_COMMAND_H 
.................... #define BOOT_COMMAND_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include "flash_memory_fn.h" 
.................... #ifndef FLASH_MEMORY_FN_H 
.................... #define FLASH_MEMORY_FN_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
....................  
.................... // Erase all sectors from a given flash memory (spi_port). 
.................... void flash_erase_all_sectors(spi_fn* spi_functions) 
.................... { 
....................     uint32_t address = 0; 
....................     for (uint16_t i = 0; i < MEMORY_N_SECTORS; i++) { 
....................         flash_erase(spi_functions, address, ERASE_SECTOR); 
....................         address = address + MEMORY_SECTOR_SIZE; 
....................     } 
.................... } 
....................  
.................... // Transfer data from the flash memory (spi_port) to an uart device (uart_port), starting from a given 
.................... // address (page_address) and with a given total lenth (nbytes). 
.................... void flash_transfer_data_to_uart(spi_fn* from_spi_functions, uart_fn* to_uart_port, uint32_t page_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data = flash_read(from_spi_functions, page_address); 
....................         to_uart_port->put_char(data); 
....................         page_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data from one flash memory (from_spi_port) to another (to_spi_port), with different to and from page 
.................... // addresses and configurable length (nbytes). The same flash memory can be used as source and destination. 
.................... void flash_transfer_data_to_flash(spi_fn* from_spi_functions, uint32_t from_address, spi_fn* to_spi_functions, uint32_t to_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
*
0595C:  MOVLB  A
0595E:  CLRF   x37
05960:  CLRF   x36
05962:  CLRF   x35
05964:  CLRF   x34
05966:  MOVF   x37,W
05968:  SUBWF  x32,W
0596A:  BNC   59FA
0596C:  BNZ   5984
0596E:  MOVF   x36,W
05970:  SUBWF  x31,W
05972:  BNC   59FA
05974:  BNZ   5984
05976:  MOVF   x35,W
05978:  SUBWF  x30,W
0597A:  BNC   59FA
0597C:  BNZ   5984
0597E:  MOVF   x2F,W
05980:  SUBWF  x34,W
05982:  BC    59FA
....................         data = flash_read(from_spi_functions, from_address); 
05984:  MOVFF  A24,B13
05988:  MOVFF  A23,B12
0598C:  MOVFF  A28,B17
05990:  MOVFF  A27,B16
05994:  MOVFF  A26,B15
05998:  MOVFF  A25,B14
0599C:  MOVLB  0
0599E:  CALL   2CB0
059A2:  MOVFF  01,A33
....................         flash_write(to_spi_functions, to_address, data); 
059A6:  MOVFF  A2A,AE1
059AA:  MOVFF  A29,AE0
059AE:  MOVFF  A2E,AE5
059B2:  MOVFF  A2D,AE4
059B6:  MOVFF  A2C,AE3
059BA:  MOVFF  A2B,AE2
059BE:  MOVFF  A33,AE6
059C2:  CALL   39CA
....................         from_address++; 
059C6:  MOVLW  01
059C8:  MOVLB  A
059CA:  ADDWF  x25,F
059CC:  BTFSC  FD8.0
059CE:  INCF   x26,F
059D0:  BTFSC  FD8.2
059D2:  INCF   x27,F
059D4:  BTFSC  FD8.2
059D6:  INCF   x28,F
....................         to_address++; 
059D8:  MOVLW  01
059DA:  ADDWF  x2B,F
059DC:  BTFSC  FD8.0
059DE:  INCF   x2C,F
059E0:  BTFSC  FD8.2
059E2:  INCF   x2D,F
059E4:  BTFSC  FD8.2
059E6:  INCF   x2E,F
059E8:  MOVLW  01
059EA:  ADDWF  x34,F
059EC:  BTFSC  FD8.0
059EE:  INCF   x35,F
059F0:  BTFSC  FD8.2
059F2:  INCF   x36,F
059F4:  BTFSC  FD8.2
059F6:  INCF   x37,F
059F8:  BRA    5966
....................     } 
059FA:  MOVLB  0
059FC:  RETURN 0
.................... } 
....................  
.................... // Transfer data from ram to flash memory (to_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_from_ram(spi_fn* to_spi_functions, uint32_t to_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
*
03C1A:  MOVLB  A
03C1C:  CLRF   xDE
03C1E:  CLRF   xDD
03C20:  CLRF   xDC
03C22:  CLRF   xDB
03C24:  MOVF   xDE,W
03C26:  SUBWF  xDA,W
03C28:  BNC   3C92
03C2A:  BNZ   3C42
03C2C:  MOVF   xDD,W
03C2E:  SUBWF  xD9,W
03C30:  BNC   3C92
03C32:  BNZ   3C42
03C34:  MOVF   xDC,W
03C36:  SUBWF  xD8,W
03C38:  BNC   3C92
03C3A:  BNZ   3C42
03C3C:  MOVF   xD7,W
03C3E:  SUBWF  xDB,W
03C40:  BC    3C92
....................         flash_write(to_spi_functions, to_address, data[i]); 
03C42:  MOVF   xD5,W
03C44:  ADDWF  xDB,W
03C46:  MOVWF  FE9
03C48:  MOVF   xD6,W
03C4A:  ADDWFC xDC,W
03C4C:  MOVWF  FEA
03C4E:  MOVFF  FEF,AE6
03C52:  MOVFF  AD0,AE1
03C56:  MOVFF  ACF,AE0
03C5A:  MOVFF  AD4,AE5
03C5E:  MOVFF  AD3,AE4
03C62:  MOVFF  AD2,AE3
03C66:  MOVFF  AD1,AE2
03C6A:  MOVLB  0
03C6C:  RCALL  39CA
....................         to_address++; 
03C6E:  MOVLW  01
03C70:  MOVLB  A
03C72:  ADDWF  xD1,F
03C74:  BTFSC  FD8.0
03C76:  INCF   xD2,F
03C78:  BTFSC  FD8.2
03C7A:  INCF   xD3,F
03C7C:  BTFSC  FD8.2
03C7E:  INCF   xD4,F
03C80:  MOVLW  01
03C82:  ADDWF  xDB,F
03C84:  BTFSC  FD8.0
03C86:  INCF   xDC,F
03C88:  BTFSC  FD8.2
03C8A:  INCF   xDD,F
03C8C:  BTFSC  FD8.2
03C8E:  INCF   xDE,F
03C90:  BRA    3C24
....................     } 
03C92:  MOVLB  0
03C94:  RETURN 0
.................... } 
....................  
.................... // Transfer data to ram from flash memory (from_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_to_ram(spi_fn* to_spi_functions, uint32_t from_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
*
02E46:  MOVLB  B
02E48:  CLRF   x0F
02E4A:  CLRF   x0E
02E4C:  CLRF   x0D
02E4E:  CLRF   x0C
02E50:  MOVF   x0F,W
02E52:  SUBWF  x0B,W
02E54:  BNC   2ECC
02E56:  BNZ   2E6E
02E58:  MOVF   x0E,W
02E5A:  SUBWF  x0A,W
02E5C:  BNC   2ECC
02E5E:  BNZ   2E6E
02E60:  MOVF   x0D,W
02E62:  SUBWF  x09,W
02E64:  BNC   2ECC
02E66:  BNZ   2E6E
02E68:  MOVF   x08,W
02E6A:  SUBWF  x0C,W
02E6C:  BC    2ECC
....................         data[i] = flash_read(to_spi_functions, from_address); 
02E6E:  MOVF   x06,W
02E70:  ADDWF  x0C,W
02E72:  MOVWF  01
02E74:  MOVF   x07,W
02E76:  ADDWFC x0D,W
02E78:  MOVWF  03
02E7A:  MOVFF  01,B10
02E7E:  MOVWF  x11
02E80:  MOVFF  B01,B13
02E84:  MOVFF  B00,B12
02E88:  MOVFF  B05,B17
02E8C:  MOVFF  B04,B16
02E90:  MOVFF  B03,B15
02E94:  MOVFF  B02,B14
02E98:  MOVLB  0
02E9A:  RCALL  2CB0
02E9C:  MOVFF  B11,FEA
02EA0:  MOVFF  B10,FE9
02EA4:  MOVFF  01,FEF
....................         from_address++; 
02EA8:  MOVLW  01
02EAA:  MOVLB  B
02EAC:  ADDWF  x02,F
02EAE:  BTFSC  FD8.0
02EB0:  INCF   x03,F
02EB2:  BTFSC  FD8.2
02EB4:  INCF   x04,F
02EB6:  BTFSC  FD8.2
02EB8:  INCF   x05,F
02EBA:  MOVLW  01
02EBC:  ADDWF  x0C,F
02EBE:  BTFSC  FD8.0
02EC0:  INCF   x0D,F
02EC2:  BTFSC  FD8.2
02EC4:  INCF   x0E,F
02EC6:  BTFSC  FD8.2
02EC8:  INCF   x0F,F
02ECA:  BRA    2E50
....................     } 
02ECC:  MOVLB  0
02ECE:  RETURN 0
.................... } 
....................  
.................... // Erase memory pages around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to page allignment. 
....................  
.................... void flash_erase_pages(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_PAGE_SIZE) { 
*
03968:  MOVFF  A37,A3F
0396C:  MOVFF  A36,A3E
03970:  MOVFF  A35,A3D
03974:  MOVFF  A34,A3C
03978:  MOVLB  A
0397A:  MOVF   x3F,W
0397C:  SUBWF  x3B,W
0397E:  BNC   39C6
03980:  BNZ   3998
03982:  MOVF   x3E,W
03984:  SUBWF  x3A,W
03986:  BNC   39C6
03988:  BNZ   3998
0398A:  MOVF   x3D,W
0398C:  SUBWF  x39,W
0398E:  BNC   39C6
03990:  BNZ   3998
03992:  MOVF   x38,W
03994:  SUBWF  x3C,W
03996:  BC    39C6
....................         flash_erase(to_spi_functions, i, ERASE_PAGE); 
03998:  MOVFF  A33,AD2
0399C:  MOVFF  A32,AD1
039A0:  MOVFF  A3F,AD6
039A4:  MOVFF  A3E,AD5
039A8:  MOVFF  A3D,AD4
039AC:  MOVFF  A3C,AD3
039B0:  MOVLW  21
039B2:  MOVWF  xD7
039B4:  MOVLB  0
039B6:  RCALL  371C
039B8:  MOVLW  10
039BA:  MOVLB  A
039BC:  ADDWF  x3D,F
039BE:  MOVLW  00
039C0:  ADDWFC x3E,F
039C2:  ADDWFC x3F,F
039C4:  BRA    397A
....................     } 
039C6:  MOVLB  0
039C8:  RETURN 0
.................... } 
....................  
.................... // Erase memory sectors around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to sector allignment. 
.................... void flash_erase_sectors(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_SECTOR_SIZE) { 
....................         flash_erase(to_spi_functions, i, ERASE_SECTOR); 
....................     } 
.................... } 
....................  
.................... void flash_dump(spi_fn* spi_functions, uint32_t start, uint32_t end) 
*
0A078:  MOVLB  A
0A07A:  CLRF   x1D
0A07C:  CLRF   x1C
.................... { 
....................     uint8_t data; 
....................     uint16_t empty_blocks = 0; 
....................     for (uint32_t i = start; i < end; i++) { 
0A07E:  MOVFF  A16,A21
0A082:  MOVFF  A15,A20
0A086:  MOVFF  A14,A1F
0A08A:  MOVFF  A13,A1E
0A08E:  MOVF   x21,W
0A090:  SUBWF  x1A,W
0A092:  BTFSS  FD8.0
0A094:  BRA    A178
0A096:  BNZ   A0B0
0A098:  MOVF   x20,W
0A09A:  SUBWF  x19,W
0A09C:  BTFSS  FD8.0
0A09E:  BRA    A178
0A0A0:  BNZ   A0B0
0A0A2:  MOVF   x1F,W
0A0A4:  SUBWF  x18,W
0A0A6:  BNC   A178
0A0A8:  BNZ   A0B0
0A0AA:  MOVF   x17,W
0A0AC:  SUBWF  x1E,W
0A0AE:  BC    A178
....................         if (i % (TERMINAL_COLS / 2) == 0) 
0A0B0:  BSF    FD8.1
0A0B2:  MOVLW  0A
0A0B4:  MOVWF  FEA
0A0B6:  MOVLW  22
0A0B8:  MOVWF  FE9
0A0BA:  MOVFF  A21,A68
0A0BE:  MOVFF  A20,A67
0A0C2:  MOVFF  A1F,A66
0A0C6:  MOVFF  A1E,A65
0A0CA:  CLRF   x6C
0A0CC:  CLRF   x6B
0A0CE:  CLRF   x6A
0A0D0:  MOVLW  28
0A0D2:  MOVWF  x69
0A0D4:  MOVLB  0
0A0D6:  CALL   2ED0
0A0DA:  MOVFF  A25,A29
0A0DE:  MOVFF  A24,A28
0A0E2:  MOVFF  A23,A27
0A0E6:  MOVFF  A22,A26
0A0EA:  MOVLB  A
0A0EC:  MOVF   x26,F
0A0EE:  BNZ   A116
0A0F0:  MOVF   x27,F
0A0F2:  BNZ   A116
0A0F4:  MOVF   x28,F
0A0F6:  BNZ   A116
0A0F8:  MOVF   x29,F
0A0FA:  BNZ   A116
....................             fprintf(PC, "\r\n"); 
0A0FC:  MOVLW  0D
0A0FE:  MOVLB  B
0A100:  MOVWF  x1F
0A102:  MOVLB  0
0A104:  CALL   1C34
0A108:  MOVLW  0A
0A10A:  MOVLB  B
0A10C:  MOVWF  x1F
0A10E:  MOVLB  0
0A110:  CALL   1C34
0A114:  MOVLB  A
....................         data = flash_read(spi_functions, i); 
0A116:  MOVFF  A12,B13
0A11A:  MOVFF  A11,B12
0A11E:  MOVFF  A21,B17
0A122:  MOVFF  A20,B16
0A126:  MOVFF  A1F,B15
0A12A:  MOVFF  A1E,B14
0A12E:  MOVLB  0
0A130:  CALL   2CB0
0A134:  MOVFF  01,A1B
....................         fprintf(PC, "%02X", data); 
0A138:  MOVFF  A1B,A58
0A13C:  MOVLW  37
0A13E:  MOVLB  A
0A140:  MOVWF  x59
0A142:  MOVLB  0
0A144:  CALL   3142
....................         if (data == 0xFF) { 
0A148:  MOVLB  A
0A14A:  INCFSZ x1B,W
0A14C:  BRA    A156
....................             empty_blocks++; 
0A14E:  INCF   x1C,F
0A150:  BTFSC  FD8.2
0A152:  INCF   x1D,F
....................         } else { 
0A154:  BRA    A15A
....................             empty_blocks = 0; 
0A156:  CLRF   x1D
0A158:  CLRF   x1C
....................         } 
....................         if (empty_blocks >= EMPTY_BLOCKS_LIMIT) { 
0A15A:  MOVF   x1D,F
0A15C:  BNZ   A164
0A15E:  MOVF   x1C,W
0A160:  SUBLW  3F
0A162:  BC    A166
....................             break; 
0A164:  BRA    A178
....................         } 
0A166:  MOVLW  01
0A168:  ADDWF  x1E,F
0A16A:  BTFSC  FD8.0
0A16C:  INCF   x1F,F
0A16E:  BTFSC  FD8.2
0A170:  INCF   x20,F
0A172:  BTFSC  FD8.2
0A174:  INCF   x21,F
0A176:  BRA    A08E
....................     } 
0A178:  MOVLB  0
0A17A:  RETURN 0
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) 
.................... void flash_initialize_flash_ctrl(uint32_t start, 
....................     uint32_t end, 
....................     uint32_t current, 
....................     uint32_t packet_size, 
....................     flash_ctrl* fmem) 
.................... { 
....................     fmem->start = start; 
*
02F64:  MOVLB  A
02F66:  MOVFF  A49,FE9
02F6A:  MOVFF  A4A,FEA
02F6E:  MOVFF  A39,FEF
02F72:  MOVFF  A3A,FEC
02F76:  MOVFF  A3B,FEC
02F7A:  MOVFF  A3C,FEC
....................     fmem->end = end - (end - start) % packet_size; 
02F7E:  MOVLW  04
02F80:  ADDWF  x49,W
02F82:  MOVWF  01
02F84:  MOVLW  00
02F86:  ADDWFC x4A,W
02F88:  MOVWF  03
02F8A:  MOVFF  01,A4B
02F8E:  MOVWF  x4C
02F90:  MOVF   x39,W
02F92:  SUBWF  x3D,W
02F94:  MOVWF  x4D
02F96:  MOVF   x3A,W
02F98:  SUBWFB x3E,W
02F9A:  MOVWF  x4E
02F9C:  MOVF   x3B,W
02F9E:  SUBWFB x3F,W
02FA0:  MOVWF  x4F
02FA2:  MOVF   x3C,W
02FA4:  SUBWFB x40,W
02FA6:  MOVWF  x50
02FA8:  MOVFF  FEA,A52
02FAC:  MOVFF  FE9,A51
02FB0:  BSF    FD8.1
02FB2:  MOVLW  0A
02FB4:  MOVWF  FEA
02FB6:  MOVLW  53
02FB8:  MOVWF  FE9
02FBA:  MOVFF  A50,A68
02FBE:  MOVFF  A4F,A67
02FC2:  MOVFF  A4E,A66
02FC6:  MOVFF  A4D,A65
02FCA:  MOVFF  A48,A6C
02FCE:  MOVFF  A47,A6B
02FD2:  MOVFF  A46,A6A
02FD6:  MOVFF  A45,A69
02FDA:  MOVLB  0
02FDC:  RCALL  2ED0
02FDE:  MOVFF  A53,00
02FE2:  MOVFF  A52,FEA
02FE6:  MOVFF  A51,FE9
02FEA:  MOVF   00,W
02FEC:  MOVLB  A
02FEE:  SUBWF  x3D,W
02FF0:  MOVWF  00
02FF2:  MOVF   x54,W
02FF4:  SUBWFB x3E,W
02FF6:  MOVWF  01
02FF8:  MOVF   x55,W
02FFA:  SUBWFB x3F,W
02FFC:  MOVWF  02
02FFE:  MOVF   x56,W
03000:  SUBWFB x40,W
03002:  MOVFF  A4C,FEA
03006:  MOVFF  A4B,FE9
0300A:  MOVFF  00,FEF
0300E:  MOVFF  01,FEC
03012:  MOVFF  02,FEC
03016:  MOVWF  FEC
....................     fmem->current = current; 
03018:  MOVLW  08
0301A:  ADDWF  x49,W
0301C:  MOVWF  FE9
0301E:  MOVLW  00
03020:  ADDWFC x4A,W
03022:  MOVWF  FEA
03024:  MOVFF  A41,FEF
03028:  MOVFF  A42,FEC
0302C:  MOVFF  A43,FEC
03030:  MOVFF  A44,FEC
....................     fmem->delta = packet_size; 
03034:  MOVLW  0C
03036:  ADDWF  x49,W
03038:  MOVWF  FE9
0303A:  MOVLW  00
0303C:  ADDWFC x4A,W
0303E:  MOVWF  FEA
03040:  MOVFF  A45,FEF
03044:  MOVLB  0
03046:  RETURN 0
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) based on existing address information from flash 
.................... void flash_initialize_flash_ctrl_from_memory_date_based( 
....................     uint8_t sectors_per_day, 
....................     int8_t deployment_counter, 
....................     uint32_t candidate_address, 
....................     uint32_t first_address, 
....................     uint32_t telemetry_size, 
....................     uint8_t update_date, 
....................     flash_ctrl* fmem) 
.................... { 
....................      
....................     if(deployment_counter < 0) 
*
03214:  MOVLB  A
03216:  BTFSS  x1D.7
03218:  BRA    321C
....................         deployment_counter = 0; 
0321A:  CLRF   x1D
....................  
....................     uint32_t addr_start; 
....................     uint16_t day_of_the_year; 
....................  
....................     if(deployment_counter < 5){ 
0321C:  BTFSC  x1D.7
0321E:  BRA    3226
03220:  MOVF   x1D,W
03222:  SUBLW  04
03224:  BNC   32B2
....................         day_of_the_year = deployment_counter; 
03226:  CLRF   03
03228:  MOVFF  A1D,A31
0322C:  MOVFF  03,A32
....................         addr_start = first_address + (uint32_t)deployment_counter * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
03230:  CLRF   01
03232:  CLRF   02
03234:  CLRF   03
03236:  MOVFF  03,A5A
0323A:  MOVFF  02,A59
0323E:  MOVFF  01,A58
03242:  MOVFF  A1D,A39
03246:  MOVFF  A1C,00
0324A:  CLRF   01
0324C:  CLRF   02
0324E:  CLRF   03
03250:  MOVFF  03,A40
03254:  MOVFF  02,A3F
03258:  MOVFF  01,A3E
0325C:  MOVFF  A1C,A3D
03260:  MOVFF  A1D,A57
03264:  MOVFF  03,A5E
03268:  MOVFF  02,A5D
0326C:  MOVFF  01,A5C
03270:  MOVFF  A1C,A5B
03274:  MOVLB  0
03276:  CALL   1CB4
0327A:  MOVFF  03,A3C
0327E:  MOVFF  02,A3B
03282:  MOVFF  01,A3A
03286:  MOVFF  00,A39
0328A:  MOVFF  01,03
0328E:  MOVFF  00,02
03292:  CLRF   00
03294:  CLRF   01
03296:  MOVF   00,W
03298:  MOVLB  A
0329A:  ADDWF  x22,W
0329C:  MOVWF  x2D
0329E:  MOVF   01,W
032A0:  ADDWFC x23,W
032A2:  MOVWF  x2E
032A4:  MOVF   02,W
032A6:  ADDWFC x24,W
032A8:  MOVWF  x2F
032AA:  MOVF   03,W
032AC:  ADDWFC x25,W
032AE:  MOVWF  x30
....................     } 
032B0:  BRA    33DE
....................     else{ 
....................         if(update_date){ 
032B2:  MOVF   x2A,F
032B4:  BZ    32E4
....................             struct_tm* local_time = localtime(&current_time); 
032B6:  CLRF   x4D
032B8:  MOVLW  39
032BA:  MOVWF  x4C
032BC:  MOVLB  0
032BE:  CALL   246E
032C2:  MOVFF  02,A34
032C6:  MOVFF  01,A33
....................             day_of_the_year = local_time->tm_yday; // struct_tm::tm_yday is the day of the year (from 0-365) 
032CA:  MOVLW  08
032CC:  MOVLB  A
032CE:  ADDWF  x33,W
032D0:  MOVWF  FE9
032D2:  MOVLW  00
032D4:  ADDWFC x34,W
032D6:  MOVWF  FEA
032D8:  MOVFF  FEC,A32
032DC:  MOVF   FED,F
032DE:  MOVFF  FEF,A31
....................         } else{ 
032E2:  BRA    3348
....................             day_of_the_year = (candidate_address - first_address) / ((uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE); 
032E4:  MOVF   x22,W
032E6:  SUBWF  x1E,W
032E8:  MOVWF  x39
032EA:  MOVF   x23,W
032EC:  SUBWFB x1F,W
032EE:  MOVWF  x3A
032F0:  MOVF   x24,W
032F2:  SUBWFB x20,W
032F4:  MOVWF  x3B
032F6:  MOVF   x25,W
032F8:  SUBWFB x21,W
032FA:  MOVWF  x3C
032FC:  CLRF   x40
032FE:  CLRF   x3F
03300:  CLRF   x3E
03302:  MOVFF  A3E,03
03306:  MOVFF  A1C,02
0330A:  CLRF   00
0330C:  CLRF   01
0330E:  MOVFF  A3E,A6C
03312:  MOVFF  A1C,A3F
03316:  MOVFF  01,A3E
0331A:  MOVFF  00,A3D
0331E:  BCF    FD8.1
03320:  MOVWF  x68
03322:  MOVFF  A3B,A67
03326:  MOVFF  A3A,A66
0332A:  MOVFF  A39,A65
0332E:  MOVFF  A1C,A6B
03332:  MOVFF  01,A6A
03336:  MOVFF  00,A69
0333A:  MOVLB  0
0333C:  RCALL  2ED0
0333E:  MOVFF  01,A32
03342:  MOVFF  00,A31
03346:  MOVLB  A
....................         } 
....................         if (day_of_the_year > 366) 
03348:  MOVF   x32,W
0334A:  SUBLW  00
0334C:  BC    335C
0334E:  XORLW  FF
03350:  BNZ   3358
03352:  MOVF   x31,W
03354:  SUBLW  6E
03356:  BC    335C
....................             day_of_the_year = 0; 
03358:  CLRF   x32
0335A:  CLRF   x31
....................         addr_start = first_address + (uint32_t)day_of_the_year * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
0335C:  CLRF   x3C
0335E:  CLRF   x3B
03360:  MOVFF  A32,A3A
03364:  MOVFF  A31,A39
03368:  MOVFF  A1C,00
0336C:  CLRF   01
0336E:  CLRF   02
03370:  CLRF   03
03372:  MOVFF  03,A40
03376:  MOVFF  02,A3F
0337A:  MOVFF  01,A3E
0337E:  MOVFF  A1C,A3D
03382:  MOVFF  A3C,A5A
03386:  MOVFF  A3B,A59
0338A:  MOVFF  A32,A58
0338E:  MOVFF  A31,A57
03392:  MOVFF  03,A5E
03396:  MOVFF  02,A5D
0339A:  MOVFF  01,A5C
0339E:  MOVFF  A1C,A5B
033A2:  MOVLB  0
033A4:  CALL   1CB4
033A8:  MOVFF  03,A3C
033AC:  MOVFF  02,A3B
033B0:  MOVFF  01,A3A
033B4:  MOVFF  00,A39
033B8:  MOVFF  01,03
033BC:  MOVFF  00,02
033C0:  CLRF   00
033C2:  CLRF   01
033C4:  MOVF   00,W
033C6:  MOVLB  A
033C8:  ADDWF  x22,W
033CA:  MOVWF  x2D
033CC:  MOVF   01,W
033CE:  ADDWFC x23,W
033D0:  MOVWF  x2E
033D2:  MOVF   02,W
033D4:  ADDWFC x24,W
033D6:  MOVWF  x2F
033D8:  MOVF   03,W
033DA:  ADDWFC x25,W
033DC:  MOVWF  x30
....................     } 
....................     uint32_t addr_end = addr_start + (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
033DE:  CLRF   x3A
033E0:  CLRF   00
033E2:  CLRF   01
033E4:  MOVF   00,W
033E6:  ADDWF  x2D,W
033E8:  MOVWF  x35
033EA:  MOVF   01,W
033EC:  ADDWFC x2E,W
033EE:  MOVWF  x36
033F0:  MOVF   x1C,W
033F2:  ADDWFC x2F,W
033F4:  MOVWF  x37
033F6:  MOVF   x3A,W
033F8:  ADDWFC x30,W
033FA:  MOVWF  x38
....................     if(candidate_address >= addr_start && candidate_address < addr_end){ 
033FC:  MOVF   x30,W
033FE:  SUBWF  x21,W
03400:  BNC   3488
03402:  BNZ   341A
03404:  MOVF   x2F,W
03406:  SUBWF  x20,W
03408:  BNC   3488
0340A:  BNZ   341A
0340C:  MOVF   x2E,W
0340E:  SUBWF  x1F,W
03410:  BNC   3488
03412:  BNZ   341A
03414:  MOVF   x2D,W
03416:  SUBWF  x1E,W
03418:  BNC   3488
0341A:  MOVF   x21,W
0341C:  SUBWF  x38,W
0341E:  BNC   3488
03420:  BNZ   3438
03422:  MOVF   x20,W
03424:  SUBWF  x37,W
03426:  BNC   3488
03428:  BNZ   3438
0342A:  MOVF   x1F,W
0342C:  SUBWF  x36,W
0342E:  BNC   3488
03430:  BNZ   3438
03432:  MOVF   x35,W
03434:  SUBWF  x1E,W
03436:  BC    3488
....................         flash_initialize_flash_ctrl(addr_start, addr_end, candidate_address, telemetry_size, fmem); 
03438:  MOVFF  A30,A3C
0343C:  MOVFF  A2F,A3B
03440:  MOVFF  A2E,A3A
03444:  MOVFF  A2D,A39
03448:  MOVFF  A38,A40
0344C:  MOVFF  A37,A3F
03450:  MOVFF  A36,A3E
03454:  MOVFF  A35,A3D
03458:  MOVFF  A21,A44
0345C:  MOVFF  A20,A43
03460:  MOVFF  A1F,A42
03464:  MOVFF  A1E,A41
03468:  MOVFF  A29,A48
0346C:  MOVFF  A28,A47
03470:  MOVFF  A27,A46
03474:  MOVFF  A26,A45
03478:  MOVFF  A2C,A4A
0347C:  MOVFF  A2B,A49
03480:  MOVLB  0
03482:  RCALL  2F64
....................     } else { 
03484:  BRA    34D4
03486:  MOVLB  A
....................         flash_initialize_flash_ctrl(addr_start, addr_end, addr_start, telemetry_size, fmem); 
03488:  MOVFF  A30,A3C
0348C:  MOVFF  A2F,A3B
03490:  MOVFF  A2E,A3A
03494:  MOVFF  A2D,A39
03498:  MOVFF  A38,A40
0349C:  MOVFF  A37,A3F
034A0:  MOVFF  A36,A3E
034A4:  MOVFF  A35,A3D
034A8:  MOVFF  A30,A44
034AC:  MOVFF  A2F,A43
034B0:  MOVFF  A2E,A42
034B4:  MOVFF  A2D,A41
034B8:  MOVFF  A29,A48
034BC:  MOVFF  A28,A47
034C0:  MOVFF  A27,A46
034C4:  MOVFF  A26,A45
034C8:  MOVFF  A2C,A4A
034CC:  MOVFF  A2B,A49
034D0:  MOVLB  0
034D2:  RCALL  2F64
....................     } 
....................     fprintf(PC, "\r\nDay of the year = %lu\r\n", day_of_the_year + 1); 
034D4:  MOVLW  01
034D6:  MOVLB  A
034D8:  ADDWF  x31,W
034DA:  MOVWF  x39
034DC:  MOVLW  00
034DE:  ADDWFC x32,W
034E0:  MOVWF  x3A
034E2:  MOVLW  DA
034E4:  MOVWF  FF6
034E6:  MOVLW  02
034E8:  MOVWF  FF7
034EA:  MOVLW  00
034EC:  MOVWF  FF8
034EE:  MOVLW  14
034F0:  MOVWF  x3B
034F2:  MOVLB  0
034F4:  RCALL  3048
034F6:  MOVLW  10
034F8:  MOVWF  FE9
034FA:  MOVFF  A3A,A3C
034FE:  MOVFF  A39,A3B
03502:  RCALL  307A
03504:  MOVLW  0D
03506:  MOVLB  B
03508:  MOVWF  x1F
0350A:  MOVLB  0
0350C:  CALL   1C34
03510:  MOVLW  0A
03512:  MOVLB  B
03514:  MOVWF  x1F
03516:  MOVLB  0
03518:  CALL   1C34
....................     fprintf(PC, "Candidate telemetry address = 0x%8lX\r\n", candidate_address); 
0351C:  MOVLW  F4
0351E:  MOVWF  FF6
03520:  MOVLW  02
03522:  MOVWF  FF7
03524:  MOVLW  00
03526:  MOVWF  FF8
03528:  MOVLW  20
0352A:  MOVLB  A
0352C:  MOVWF  x3B
0352E:  MOVLB  0
03530:  RCALL  3048
03532:  MOVFF  A21,A58
03536:  MOVLW  37
03538:  MOVLB  A
0353A:  MOVWF  x59
0353C:  MOVLB  0
0353E:  RCALL  3142
03540:  MOVFF  A20,A58
03544:  MOVLW  37
03546:  MOVLB  A
03548:  MOVWF  x59
0354A:  MOVLB  0
0354C:  RCALL  3142
0354E:  MOVFF  A1F,A58
03552:  MOVLW  37
03554:  MOVLB  A
03556:  MOVWF  x59
03558:  MOVLB  0
0355A:  RCALL  3142
0355C:  MOVFF  A1E,A58
03560:  MOVLW  37
03562:  MOVLB  A
03564:  MOVWF  x59
03566:  MOVLB  0
03568:  RCALL  3142
0356A:  MOVLW  0D
0356C:  MOVLB  B
0356E:  MOVWF  x1F
03570:  MOVLB  0
03572:  CALL   1C34
03576:  MOVLW  0A
03578:  MOVLB  B
0357A:  MOVWF  x1F
0357C:  MOVLB  0
0357E:  CALL   1C34
....................     fprintf(PC, "Initial telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.start); 
03582:  MOVLW  1C
03584:  MOVWF  FF6
03586:  MOVLW  03
03588:  MOVWF  FF7
0358A:  MOVLW  00
0358C:  MOVWF  FF8
0358E:  MOVLW  1E
03590:  MOVLB  A
03592:  MOVWF  x3B
03594:  MOVLB  0
03596:  RCALL  3048
03598:  MOVFF  115,A58
0359C:  MOVLW  37
0359E:  MOVLB  A
035A0:  MOVWF  x59
035A2:  MOVLB  0
035A4:  RCALL  3142
035A6:  MOVFF  114,A58
035AA:  MOVLW  37
035AC:  MOVLB  A
035AE:  MOVWF  x59
035B0:  MOVLB  0
035B2:  RCALL  3142
035B4:  MOVFF  113,A58
035B8:  MOVLW  37
035BA:  MOVLB  A
035BC:  MOVWF  x59
035BE:  MOVLB  0
035C0:  RCALL  3142
035C2:  MOVFF  112,A58
035C6:  MOVLW  37
035C8:  MOVLB  A
035CA:  MOVWF  x59
035CC:  MOVLB  0
035CE:  RCALL  3142
035D0:  MOVLW  0D
035D2:  MOVLB  B
035D4:  MOVWF  x1F
035D6:  MOVLB  0
035D8:  CALL   1C34
035DC:  MOVLW  0A
035DE:  MOVLB  B
035E0:  MOVWF  x1F
035E2:  MOVLB  0
035E4:  CALL   1C34
....................     fprintf(PC, "Current telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.current); 
035E8:  MOVLW  42
035EA:  MOVWF  FF6
035EC:  MOVLW  03
035EE:  MOVWF  FF7
035F0:  MOVLW  00
035F2:  MOVWF  FF8
035F4:  MOVLW  1E
035F6:  MOVLB  A
035F8:  MOVWF  x3B
035FA:  MOVLB  0
035FC:  RCALL  3048
035FE:  MOVFF  11D,A58
03602:  MOVLW  37
03604:  MOVLB  A
03606:  MOVWF  x59
03608:  MOVLB  0
0360A:  RCALL  3142
0360C:  MOVFF  11C,A58
03610:  MOVLW  37
03612:  MOVLB  A
03614:  MOVWF  x59
03616:  MOVLB  0
03618:  RCALL  3142
0361A:  MOVFF  11B,A58
0361E:  MOVLW  37
03620:  MOVLB  A
03622:  MOVWF  x59
03624:  MOVLB  0
03626:  RCALL  3142
03628:  MOVFF  11A,A58
0362C:  MOVLW  37
0362E:  MOVLB  A
03630:  MOVWF  x59
03632:  MOVLB  0
03634:  RCALL  3142
03636:  MOVLW  0D
03638:  MOVLB  B
0363A:  MOVWF  x1F
0363C:  MOVLB  0
0363E:  CALL   1C34
03642:  MOVLW  0A
03644:  MOVLB  B
03646:  MOVWF  x1F
03648:  MOVLB  0
0364A:  CALL   1C34
....................     fprintf(PC, "Telemetry size = %u\r\n", addr_flags.flash_telemetry.delta); 
0364E:  MOVLW  68
03650:  MOVWF  FF6
03652:  MOVLW  03
03654:  MOVWF  FF7
03656:  MOVLW  00
03658:  MOVWF  FF8
0365A:  MOVLW  11
0365C:  MOVLB  A
0365E:  MOVWF  x3B
03660:  MOVLB  0
03662:  RCALL  3048
03664:  MOVFF  11E,A39
03668:  MOVLW  1B
0366A:  MOVLB  A
0366C:  MOVWF  x3A
0366E:  MOVLB  0
03670:  BRA    318C
03672:  MOVLW  0D
03674:  MOVLB  B
03676:  MOVWF  x1F
03678:  MOVLB  0
0367A:  CALL   1C34
0367E:  MOVLW  0A
03680:  MOVLB  B
03682:  MOVWF  x1F
03684:  MOVLB  0
03686:  CALL   1C34
....................     fprintf(PC, "Last telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.end); 
0368A:  MOVLW  7E
0368C:  MOVWF  FF6
0368E:  MOVLW  03
03690:  MOVWF  FF7
03692:  MOVLW  00
03694:  MOVWF  FF8
03696:  MOVLW  1B
03698:  MOVLB  A
0369A:  MOVWF  x3B
0369C:  MOVLB  0
0369E:  RCALL  3048
036A0:  MOVFF  119,A58
036A4:  MOVLW  37
036A6:  MOVLB  A
036A8:  MOVWF  x59
036AA:  MOVLB  0
036AC:  RCALL  3142
036AE:  MOVFF  118,A58
036B2:  MOVLW  37
036B4:  MOVLB  A
036B6:  MOVWF  x59
036B8:  MOVLB  0
036BA:  RCALL  3142
036BC:  MOVFF  117,A58
036C0:  MOVLW  37
036C2:  MOVLB  A
036C4:  MOVWF  x59
036C6:  MOVLB  0
036C8:  RCALL  3142
036CA:  MOVFF  116,A58
036CE:  MOVLW  37
036D0:  MOVLB  A
036D2:  MOVWF  x59
036D4:  MOVLB  0
036D6:  RCALL  3142
036D8:  MOVLW  0D
036DA:  MOVLB  B
036DC:  MOVWF  x1F
036DE:  MOVLB  0
036E0:  CALL   1C34
036E4:  MOVLW  0A
036E6:  MOVLB  B
036E8:  MOVWF  x1F
036EA:  MOVLB  0
036EC:  CALL   1C34
036F0:  RETURN 0
.................... } 
....................  
.................... // Writes data according to a flash control structure (fctrl) to a flash memory in spi_port 
.................... void flash_cycle_write(spi_fn* spi_functions, uint8_t* data, flash_ctrl* fctrl) 
.................... { 
....................     if (fctrl->current < fctrl->start || fctrl->current >= fctrl->end) 
*
03D34:  MOVLW  08
03D36:  MOVLB  A
03D38:  ADDWF  x1A,W
03D3A:  MOVWF  FE9
03D3C:  MOVLW  00
03D3E:  ADDWFC x1B,W
03D40:  MOVWF  FEA
03D42:  MOVFF  FEF,A21
03D46:  MOVFF  FEC,A22
03D4A:  MOVFF  FEC,A23
03D4E:  MOVFF  FEC,A24
03D52:  MOVFF  A1A,FE9
03D56:  MOVFF  A1B,FEA
03D5A:  MOVFF  FEF,00
03D5E:  MOVFF  FEC,01
03D62:  MOVFF  FEC,02
03D66:  MOVFF  FEC,03
03D6A:  MOVF   x24,W
03D6C:  SUBWF  03,W
03D6E:  BNC   3D88
03D70:  BNZ   3DDE
03D72:  MOVF   x23,W
03D74:  SUBWF  02,W
03D76:  BNC   3D88
03D78:  BNZ   3DDE
03D7A:  MOVF   x22,W
03D7C:  SUBWF  01,W
03D7E:  BNC   3D88
03D80:  BNZ   3DDE
03D82:  MOVF   00,W
03D84:  SUBWF  x21,W
03D86:  BNC   3DDE
03D88:  MOVLW  08
03D8A:  ADDWF  x1A,W
03D8C:  MOVWF  FE9
03D8E:  MOVLW  00
03D90:  ADDWFC x1B,W
03D92:  MOVWF  FEA
03D94:  MOVFF  FEF,A21
03D98:  MOVFF  FEC,A22
03D9C:  MOVFF  FEC,A23
03DA0:  MOVFF  FEC,A24
03DA4:  MOVLW  04
03DA6:  ADDWF  x1A,W
03DA8:  MOVWF  FE9
03DAA:  MOVLW  00
03DAC:  ADDWFC x1B,W
03DAE:  MOVWF  FEA
03DB0:  MOVFF  FEF,00
03DB4:  MOVFF  FEC,01
03DB8:  MOVFF  FEC,02
03DBC:  MOVFF  FEC,03
03DC0:  MOVF   03,W
03DC2:  SUBWF  x24,W
03DC4:  BNC   3E20
03DC6:  BNZ   3DDE
03DC8:  MOVF   02,W
03DCA:  SUBWF  x23,W
03DCC:  BNC   3E20
03DCE:  BNZ   3DDE
03DD0:  MOVF   01,W
03DD2:  SUBWF  x22,W
03DD4:  BNC   3E20
03DD6:  BNZ   3DDE
03DD8:  MOVF   00,W
03DDA:  SUBWF  x21,W
03DDC:  BNC   3E20
....................         fctrl->current = fctrl->start; 
03DDE:  MOVLW  08
03DE0:  ADDWF  x1A,W
03DE2:  MOVWF  01
03DE4:  MOVLW  00
03DE6:  ADDWFC x1B,W
03DE8:  MOVWF  03
03DEA:  MOVFF  01,A21
03DEE:  MOVWF  x22
03DF0:  MOVFF  A1A,FE9
03DF4:  MOVFF  A1B,FEA
03DF8:  MOVFF  FEF,00
03DFC:  MOVFF  FEC,01
03E00:  MOVFF  FEC,02
03E04:  MOVFF  FEC,03
03E08:  MOVFF  A22,FEA
03E0C:  MOVFF  A21,FE9
03E10:  MOVFF  00,FEF
03E14:  MOVFF  01,FEC
03E18:  MOVFF  02,FEC
03E1C:  MOVFF  03,FEC
....................     uint32_t remaining_addressess = (MEMORY_PAGE_SIZE - (fctrl->current % MEMORY_PAGE_SIZE)) % MEMORY_PAGE_SIZE; 
03E20:  MOVLW  08
03E22:  ADDWF  x1A,W
03E24:  MOVWF  FE9
03E26:  MOVLW  00
03E28:  ADDWFC x1B,W
03E2A:  MOVWF  FEA
03E2C:  MOVFF  FEF,00
03E30:  MOVFF  FEC,A22
03E34:  MOVFF  FEC,A23
03E38:  MOVFF  FEC,A24
03E3C:  MOVF   x22,W
03E3E:  ANDLW  0F
03E40:  MOVWF  01
03E42:  CLRF   02
03E44:  CLRF   03
03E46:  MOVLW  00
03E48:  BSF    FD8.0
03E4A:  SUBFWB 00,W
03E4C:  MOVWF  x21
03E4E:  MOVLW  10
03E50:  SUBFWB 01,W
03E52:  MOVWF  x22
03E54:  MOVLW  00
03E56:  SUBFWB 02,W
03E58:  MOVLW  00
03E5A:  SUBFWB 03,W
03E5C:  MOVFF  A21,A1C
03E60:  MOVF   x22,W
03E62:  ANDLW  0F
03E64:  MOVWF  x1D
03E66:  CLRF   x1E
03E68:  CLRF   x1F
....................     if (remaining_addressess < fctrl->delta) { 
03E6A:  MOVLW  0C
03E6C:  ADDWF  x1A,W
03E6E:  MOVWF  FE9
03E70:  MOVLW  00
03E72:  ADDWFC x1B,W
03E74:  MOVWF  FEA
03E76:  MOVF   FEF,W
03E78:  MOVF   x1F,F
03E7A:  BNZ   3ED6
03E7C:  MOVF   x1E,F
03E7E:  BNZ   3ED6
03E80:  MOVF   x1D,F
03E82:  BNZ   3ED6
03E84:  SUBWF  x1C,W
03E86:  BC    3ED6
....................         flash_erase(spi_functions, fctrl->current + remaining_addressess, ERASE_PAGE); 
03E88:  MOVLW  08
03E8A:  ADDWF  x1A,W
03E8C:  MOVWF  FE9
03E8E:  MOVLW  00
03E90:  ADDWFC x1B,W
03E92:  MOVWF  FEA
03E94:  MOVFF  FEF,A21
03E98:  MOVFF  FEC,A22
03E9C:  MOVFF  FEC,A23
03EA0:  MOVFF  FEC,A24
03EA4:  MOVF   x1C,W
03EA6:  ADDWF  x21,F
03EA8:  MOVF   x1D,W
03EAA:  ADDWFC x22,F
03EAC:  MOVF   x1E,W
03EAE:  ADDWFC x23,F
03EB0:  MOVF   x1F,W
03EB2:  ADDWFC x24,F
03EB4:  MOVFF  A17,AD2
03EB8:  MOVFF  A16,AD1
03EBC:  MOVFF  A24,AD6
03EC0:  MOVFF  A23,AD5
03EC4:  MOVFF  A22,AD4
03EC8:  MOVFF  A21,AD3
03ECC:  MOVLW  21
03ECE:  MOVWF  xD7
03ED0:  MOVLB  0
03ED2:  RCALL  371C
03ED4:  MOVLB  A
....................     } 
....................     for (int i = 0; i < fctrl->delta; i++) { 
03ED6:  CLRF   x20
03ED8:  MOVLW  0C
03EDA:  ADDWF  x1A,W
03EDC:  MOVWF  FE9
03EDE:  MOVLW  00
03EE0:  ADDWFC x1B,W
03EE2:  MOVWF  FEA
03EE4:  MOVF   FEF,W
03EE6:  SUBWF  x20,W
03EE8:  BC    3F40
....................         flash_write(spi_functions, fctrl->current, data[i]); 
03EEA:  MOVLW  08
03EEC:  ADDWF  x1A,W
03EEE:  MOVWF  FE9
03EF0:  MOVLW  00
03EF2:  ADDWFC x1B,W
03EF4:  MOVWF  FEA
03EF6:  MOVFF  FEF,AE2
03EFA:  MOVFF  FEC,AE3
03EFE:  MOVFF  FEC,AE4
03F02:  MOVFF  FEC,AE5
03F06:  MOVF   x20,W
03F08:  ADDWF  x18,W
03F0A:  MOVWF  FE9
03F0C:  MOVLW  00
03F0E:  ADDWFC x19,W
03F10:  MOVWF  FEA
03F12:  MOVFF  FEF,AE6
03F16:  MOVFF  A17,AE1
03F1A:  MOVFF  A16,AE0
03F1E:  MOVLB  0
03F20:  RCALL  39CA
....................         fctrl->current++; 
03F22:  MOVLW  08
03F24:  MOVLB  A
03F26:  ADDWF  x1A,W
03F28:  MOVWF  FE9
03F2A:  MOVLW  00
03F2C:  ADDWFC x1B,W
03F2E:  MOVWF  FEA
03F30:  MOVLW  01
03F32:  ADDWF  FEE,F
03F34:  MOVLW  00
03F36:  ADDWFC FEE,F
03F38:  ADDWFC FEE,F
03F3A:  ADDWFC FED,F
03F3C:  INCF   x20,F
03F3E:  BRA    3ED8
....................     } 
03F40:  MOVLB  0
03F42:  RETURN 0
.................... } 
....................  
.................... // Recover last available address from a flash control structure (fctrl) 
.................... void flash_recover_last_addr(spi_fn* spi_functions, flash_ctrl* fctrl) 
.................... { 
....................     uint8_t data; 
....................     for (fctrl->current = fctrl->end - fctrl->delta; fctrl->current >= fctrl->start; fctrl->current -= fctrl->delta) { 
*
0410A:  MOVLW  08
0410C:  MOVLB  9
0410E:  ADDWF  xD7,W
04110:  MOVWF  01
04112:  MOVLW  00
04114:  ADDWFC xD8,W
04116:  MOVWF  03
04118:  MOVFF  01,9DB
0411C:  MOVWF  xDC
0411E:  MOVLW  04
04120:  ADDWF  xD7,W
04122:  MOVWF  FE9
04124:  MOVLW  00
04126:  ADDWFC xD8,W
04128:  MOVWF  FEA
0412A:  MOVFF  FEF,9DD
0412E:  MOVFF  FEC,9DE
04132:  MOVFF  FEC,9DF
04136:  MOVFF  FEC,9E0
0413A:  MOVLW  0C
0413C:  ADDWF  xD7,W
0413E:  MOVWF  FE9
04140:  MOVLW  00
04142:  ADDWFC xD8,W
04144:  MOVWF  FEA
04146:  MOVF   FEF,W
04148:  SUBWF  xDD,W
0414A:  MOVWF  00
0414C:  MOVLW  00
0414E:  SUBWFB xDE,W
04150:  MOVWF  01
04152:  MOVLW  00
04154:  SUBWFB xDF,W
04156:  MOVWF  02
04158:  MOVLW  00
0415A:  SUBWFB xE0,W
0415C:  MOVWF  03
0415E:  MOVWF  xE0
04160:  MOVFF  02,9DF
04164:  MOVFF  01,9DE
04168:  MOVFF  00,9DD
0416C:  MOVFF  9DC,FEA
04170:  MOVFF  9DB,FE9
04174:  MOVFF  00,FEF
04178:  MOVFF  01,FEC
0417C:  MOVFF  02,FEC
04180:  MOVWF  FEC
04182:  MOVLW  08
04184:  ADDWF  xD7,W
04186:  MOVWF  FE9
04188:  MOVLW  00
0418A:  ADDWFC xD8,W
0418C:  MOVWF  FEA
0418E:  MOVFF  FEF,9DB
04192:  MOVFF  FEC,9DC
04196:  MOVFF  FEC,9DD
0419A:  MOVFF  FEC,9DE
0419E:  MOVFF  9D7,FE9
041A2:  MOVFF  9D8,FEA
041A6:  MOVFF  FEF,00
041AA:  MOVFF  FEC,01
041AE:  MOVFF  FEC,02
041B2:  MOVFF  FEC,03
041B6:  MOVF   03,W
041B8:  SUBWF  xDE,W
041BA:  BTFSS  FD8.0
041BC:  BRA    4318
041BE:  BNZ   41DC
041C0:  MOVF   02,W
041C2:  SUBWF  xDD,W
041C4:  BTFSS  FD8.0
041C6:  BRA    4318
041C8:  BNZ   41DC
041CA:  MOVF   01,W
041CC:  SUBWF  xDC,W
041CE:  BTFSS  FD8.0
041D0:  BRA    4318
041D2:  BNZ   41DC
041D4:  MOVF   00,W
041D6:  SUBWF  xDB,W
041D8:  BTFSS  FD8.0
041DA:  BRA    4318
....................         for (uint8_t i = 0; i < fctrl->delta; i++) { 
041DC:  CLRF   xDA
041DE:  MOVLW  0C
041E0:  ADDWF  xD7,W
041E2:  MOVWF  FE9
041E4:  MOVLW  00
041E6:  ADDWFC xD8,W
041E8:  MOVWF  FEA
041EA:  MOVF   FEF,W
041EC:  SUBWF  xDA,W
041EE:  BC    42A6
....................             data = flash_read(spi_functions, fctrl->current + i); 
041F0:  MOVLW  08
041F2:  ADDWF  xD7,W
041F4:  MOVWF  FE9
041F6:  MOVLW  00
041F8:  ADDWFC xD8,W
041FA:  MOVWF  FEA
041FC:  MOVFF  FEF,9DB
04200:  MOVFF  FEC,9DC
04204:  MOVFF  FEC,9DD
04208:  MOVFF  FEC,9DE
0420C:  MOVF   xDA,W
0420E:  ADDWF  xDB,F
04210:  MOVLW  00
04212:  ADDWFC xDC,F
04214:  ADDWFC xDD,F
04216:  ADDWFC xDE,F
04218:  MOVFF  9D6,B13
0421C:  MOVFF  9D5,B12
04220:  MOVFF  9DE,B17
04224:  MOVFF  9DD,B16
04228:  MOVFF  9DC,B15
0422C:  MOVFF  9DB,B14
04230:  MOVLB  0
04232:  CALL   2CB0
04236:  MOVFF  01,9D9
....................             if (data != 0xFF) { 
0423A:  MOVLB  9
0423C:  INCFSZ xD9,W
0423E:  BRA    4242
04240:  BRA    42A2
....................                 fctrl->current += fctrl->delta; 
04242:  MOVLW  08
04244:  ADDWF  xD7,W
04246:  MOVWF  01
04248:  MOVLW  00
0424A:  ADDWFC xD8,W
0424C:  MOVFF  01,9DB
04250:  MOVWF  xDC
04252:  MOVWF  FEA
04254:  MOVFF  01,FE9
04258:  MOVFF  FEF,9DD
0425C:  MOVFF  FEC,9DE
04260:  MOVFF  FEC,9DF
04264:  MOVFF  FEC,9E0
04268:  MOVLW  0C
0426A:  ADDWF  xD7,W
0426C:  MOVWF  FE9
0426E:  MOVLW  00
04270:  ADDWFC xD8,W
04272:  MOVWF  FEA
04274:  MOVF   FEF,W
04276:  ADDWF  xDD,W
04278:  MOVWF  00
0427A:  MOVLW  00
0427C:  ADDWFC xDE,W
0427E:  MOVWF  01
04280:  MOVLW  00
04282:  ADDWFC xDF,W
04284:  MOVWF  02
04286:  MOVLW  00
04288:  ADDWFC xE0,W
0428A:  MOVFF  9DC,FEA
0428E:  MOVFF  9DB,FE9
04292:  MOVFF  00,FEF
04296:  MOVFF  01,FEC
0429A:  MOVFF  02,FEC
0429E:  MOVWF  FEC
....................                 goto loop_end; 
042A0:  BRA    4318
....................             } 
042A2:  INCF   xDA,F
042A4:  BRA    41DE
....................         } 
042A6:  MOVLW  08
042A8:  ADDWF  xD7,W
042AA:  MOVWF  01
042AC:  MOVLW  00
042AE:  ADDWFC xD8,W
042B0:  MOVWF  03
042B2:  MOVFF  01,9DB
042B6:  MOVWF  xDC
042B8:  MOVWF  FEA
042BA:  MOVFF  01,FE9
042BE:  MOVFF  FEF,9DD
042C2:  MOVFF  FEC,9DE
042C6:  MOVFF  FEC,9DF
042CA:  MOVFF  FEC,9E0
042CE:  MOVLW  0C
042D0:  ADDWF  xD7,W
042D2:  MOVWF  FE9
042D4:  MOVLW  00
042D6:  ADDWFC xD8,W
042D8:  MOVWF  FEA
042DA:  MOVF   FEF,W
042DC:  SUBWF  xDD,W
042DE:  MOVWF  00
042E0:  MOVLW  00
042E2:  SUBWFB xDE,W
042E4:  MOVWF  01
042E6:  MOVLW  00
042E8:  SUBWFB xDF,W
042EA:  MOVWF  02
042EC:  MOVLW  00
042EE:  SUBWFB xE0,W
042F0:  MOVWF  03
042F2:  MOVWF  xE0
042F4:  MOVFF  02,9DF
042F8:  MOVFF  01,9DE
042FC:  MOVFF  00,9DD
04300:  MOVFF  9DC,FEA
04304:  MOVFF  9DB,FE9
04308:  MOVFF  00,FEF
0430C:  MOVFF  01,FEC
04310:  MOVFF  02,FEC
04314:  MOVWF  FEC
04316:  BRA    4182
....................     } 
.................... loop_end: 
....................     if (fctrl->current >= fctrl->end) 
04318:  MOVLW  08
0431A:  ADDWF  xD7,W
0431C:  MOVWF  FE9
0431E:  MOVLW  00
04320:  ADDWFC xD8,W
04322:  MOVWF  FEA
04324:  MOVFF  FEF,9DB
04328:  MOVFF  FEC,9DC
0432C:  MOVFF  FEC,9DD
04330:  MOVFF  FEC,9DE
04334:  MOVLW  04
04336:  ADDWF  xD7,W
04338:  MOVWF  FE9
0433A:  MOVLW  00
0433C:  ADDWFC xD8,W
0433E:  MOVWF  FEA
04340:  MOVFF  FEF,00
04344:  MOVFF  FEC,01
04348:  MOVFF  FEC,02
0434C:  MOVFF  FEC,03
04350:  MOVF   03,W
04352:  SUBWF  xDE,W
04354:  BNC   43B2
04356:  BNZ   436E
04358:  MOVF   02,W
0435A:  SUBWF  xDD,W
0435C:  BNC   43B2
0435E:  BNZ   436E
04360:  MOVF   01,W
04362:  SUBWF  xDC,W
04364:  BNC   43B2
04366:  BNZ   436E
04368:  MOVF   00,W
0436A:  SUBWF  xDB,W
0436C:  BNC   43B2
....................         fctrl->current = fctrl->start; 
0436E:  MOVLW  08
04370:  ADDWF  xD7,W
04372:  MOVWF  01
04374:  MOVLW  00
04376:  ADDWFC xD8,W
04378:  MOVWF  03
0437A:  MOVFF  01,9DB
0437E:  MOVFF  03,9DC
04382:  MOVFF  9D7,FE9
04386:  MOVFF  9D8,FEA
0438A:  MOVFF  FEF,00
0438E:  MOVFF  FEC,01
04392:  MOVFF  FEC,02
04396:  MOVFF  FEC,03
0439A:  MOVFF  9DC,FEA
0439E:  MOVFF  9DB,FE9
043A2:  MOVFF  00,FEF
043A6:  MOVFF  01,FEC
043AA:  MOVFF  02,FEC
043AE:  MOVFF  03,FEC
043B2:  MOVLB  0
043B4:  GOTO   4476 (RETURN)
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_FN_H 
....................  
.................... #include "scheduler.h" 
.................... #ifndef SCHEDULER_H 
.................... #define SCHEDULER_H 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
....................  
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled); 
....................  
.................... void scheduler_initialize() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
045C2:  MOVLB  9
045C4:  CLRF   xCB
045C6:  MOVF   xCB,W
045C8:  SUBLW  1F
045CA:  BNC   45FC
....................         scheduled_commands[i].time = TIME_T_MAX; 
045CC:  MOVLB  A
045CE:  CLRF   x5B
045D0:  MOVFF  9CB,A5A
045D4:  CLRF   x5D
045D6:  MOVLW  1D
045D8:  MOVWF  x5C
045DA:  MOVLB  0
045DC:  CALL   244C
045E0:  MOVLW  1F
045E2:  MOVLB  9
045E4:  ADDWF  01,W
045E6:  MOVWF  FE9
045E8:  MOVLW  01
045EA:  ADDWFC 02,W
045EC:  MOVWF  FEA
045EE:  SETF   FEF
045F0:  SETF   FEC
045F2:  SETF   FEC
045F4:  MOVLW  7F
045F6:  MOVWF  FEC
045F8:  INCF   xCB,F
045FA:  BRA    45C6
....................     } 
045FC:  MOVLB  0
045FE:  RETURN 0
.................... } 
....................  
.................... int scheduled_command_add(time_t time, uint8_t* command) 
.................... { 
....................     scheduled_command cmd; 
....................     cmd.time = time; 
04600:  MOVFF  A2E,A34
04604:  MOVFF  A2D,A33
04608:  MOVFF  A2C,A32
0460C:  MOVFF  A2B,A31
....................     memcpy(cmd.command, command, BUFF_LENGTH); 
04610:  MOVLW  0A
04612:  MOVWF  FEA
04614:  MOVLW  35
04616:  MOVWF  FE9
04618:  MOVFF  A30,FE2
0461C:  MOVFF  A2F,FE1
04620:  MOVLW  19
04622:  MOVWF  01
04624:  MOVFF  FE6,FEE
04628:  DECFSZ 01,F
0462A:  BRA    4624
....................  
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
0462C:  MOVLB  A
0462E:  CLRF   x4E
04630:  MOVF   x4E,W
04632:  SUBLW  1F
04634:  BNC   46D0
....................         if (scheduled_commands[i].time == TIME_T_MAX) { 
04636:  CLRF   x5B
04638:  MOVFF  A4E,A5A
0463C:  CLRF   x5D
0463E:  MOVLW  1D
04640:  MOVWF  x5C
04642:  MOVLB  0
04644:  CALL   244C
04648:  MOVFF  02,A50
0464C:  MOVFF  01,A4F
04650:  MOVLW  1F
04652:  MOVLB  A
04654:  ADDWF  01,W
04656:  MOVWF  FE9
04658:  MOVLW  01
0465A:  ADDWFC 02,W
0465C:  MOVWF  FEA
0465E:  MOVFF  FEF,A51
04662:  MOVFF  FEC,A52
04666:  MOVFF  FEC,A53
0466A:  MOVFF  FEC,A54
0466E:  INCFSZ x51,W
04670:  BRA    46CC
04672:  INCFSZ x52,W
04674:  BRA    46CC
04676:  INCFSZ x53,W
04678:  BRA    46CC
0467A:  MOVF   x54,W
0467C:  SUBLW  7F
0467E:  BNZ   46CC
....................             memcpy(&scheduled_commands[i], &cmd, sizeof(scheduled_command)); 
04680:  CLRF   x5B
04682:  MOVFF  A4E,A5A
04686:  CLRF   x5D
04688:  MOVLW  1D
0468A:  MOVWF  x5C
0468C:  MOVLB  0
0468E:  CALL   244C
04692:  MOVFF  02,03
04696:  MOVF   01,W
04698:  ADDLW  1F
0469A:  MOVWF  01
0469C:  MOVLW  01
0469E:  ADDWFC 03,F
046A0:  MOVFF  01,A4F
046A4:  MOVLB  A
046A6:  MOVFF  03,A50
046AA:  MOVFF  03,FEA
046AE:  MOVFF  01,FE9
046B2:  MOVLW  0A
046B4:  MOVWF  FE2
046B6:  MOVLW  31
046B8:  MOVWF  FE1
046BA:  MOVLW  1D
046BC:  MOVWF  01
046BE:  MOVFF  FE6,FEE
046C2:  DECFSZ 01,F
046C4:  BRA    46BE
....................             return 0; 
046C6:  MOVLW  00
046C8:  MOVWF  01
046CA:  BRA    46D4
....................         } 
046CC:  INCF   x4E,F
046CE:  BRA    4630
....................     } 
....................  
....................     return -1; // Error signaling 
046D0:  MOVLW  FF
046D2:  MOVWF  01
046D4:  MOVLB  0
046D6:  RETURN 0
.................... } 
....................  
.................... int scheduled_command_count() 
*
04CC4:  MOVLB  A
04CC6:  CLRF   x1A
.................... { 
....................     int count = 0; 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
04CC8:  CLRF   x1B
04CCA:  MOVF   x1B,W
04CCC:  SUBLW  1F
04CCE:  BNC   4D20
....................         if (scheduled_commands[i].time != TIME_T_MAX) { 
04CD0:  CLRF   x5B
04CD2:  MOVFF  A1B,A5A
04CD6:  CLRF   x5D
04CD8:  MOVLW  1D
04CDA:  MOVWF  x5C
04CDC:  MOVLB  0
04CDE:  CALL   244C
04CE2:  MOVFF  02,A1D
04CE6:  MOVFF  01,A1C
04CEA:  MOVLW  1F
04CEC:  MOVLB  A
04CEE:  ADDWF  01,W
04CF0:  MOVWF  FE9
04CF2:  MOVLW  01
04CF4:  ADDWFC 02,W
04CF6:  MOVWF  FEA
04CF8:  MOVFF  FEF,A1E
04CFC:  MOVFF  FEC,A1F
04D00:  MOVFF  FEC,A20
04D04:  MOVFF  FEC,A21
04D08:  INCFSZ x1E,W
04D0A:  BRA    4D1A
04D0C:  INCFSZ x1F,W
04D0E:  BRA    4D1A
04D10:  INCFSZ x20,W
04D12:  BRA    4D1A
04D14:  MOVF   x21,W
04D16:  SUBLW  7F
04D18:  BZ    4D1C
....................             count++; 
04D1A:  INCF   x1A,F
....................         } 
04D1C:  INCF   x1B,F
04D1E:  BRA    4CCA
....................     } 
....................     return count; 
04D20:  MOVFF  A1A,01
04D24:  MOVLB  0
04D26:  RETURN 0
.................... } 
....................  
.................... void scheduled_command_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
0B39C:  MOVLB  A
0B39E:  CLRF   x0A
0B3A0:  MOVF   x0A,W
0B3A2:  SUBLW  1F
0B3A4:  BNC   B3D4
....................         scheduled_commands[i].time = TIME_T_MAX; 
0B3A6:  CLRF   x5B
0B3A8:  MOVFF  A0A,A5A
0B3AC:  CLRF   x5D
0B3AE:  MOVLW  1D
0B3B0:  MOVWF  x5C
0B3B2:  MOVLB  0
0B3B4:  CALL   244C
0B3B8:  MOVLW  1F
0B3BA:  MOVLB  A
0B3BC:  ADDWF  01,W
0B3BE:  MOVWF  FE9
0B3C0:  MOVLW  01
0B3C2:  ADDWFC 02,W
0B3C4:  MOVWF  FEA
0B3C6:  SETF   FEF
0B3C8:  SETF   FEC
0B3CA:  SETF   FEC
0B3CC:  MOVLW  7F
0B3CE:  MOVWF  FEC
0B3D0:  INCF   x0A,F
0B3D2:  BRA    B3A0
....................     } 
0B3D4:  MOVLB  0
0B3D6:  RETURN 0
.................... } 
....................  
.................... void scheduled_command_clear_specified_command(uint8_t source, uint8_t command) 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
05888:  MOVLB  A
0588A:  CLRF   x57
0588C:  MOVF   x57,W
0588E:  SUBLW  1F
05890:  BNC   5938
....................         if (scheduled_commands[i].command[0] == source && scheduled_commands[i].command[1] == command) { 
05892:  CLRF   x5B
05894:  MOVFF  A57,A5A
05898:  CLRF   x5D
0589A:  MOVLW  1D
0589C:  MOVWF  x5C
0589E:  MOVLB  0
058A0:  CALL   244C
058A4:  MOVFF  02,A59
058A8:  MOVFF  01,A58
058AC:  MOVLW  04
058AE:  MOVLB  A
058B0:  ADDWF  x58,F
058B2:  MOVLW  00
058B4:  ADDWFC x59,F
058B6:  MOVLW  1F
058B8:  ADDWF  x58,W
058BA:  MOVWF  FE9
058BC:  MOVLW  01
058BE:  ADDWFC x59,W
058C0:  MOVWF  FEA
058C2:  MOVF   x55,W
058C4:  SUBWF  FEF,W
058C6:  BNZ   5934
058C8:  CLRF   x5B
058CA:  MOVFF  A57,A5A
058CE:  CLRF   x5D
058D0:  MOVLW  1D
058D2:  MOVWF  x5C
058D4:  MOVLB  0
058D6:  CALL   244C
058DA:  MOVFF  02,A5B
058DE:  MOVFF  01,A5A
058E2:  MOVLW  04
058E4:  MOVLB  A
058E6:  ADDWF  x5A,F
058E8:  MOVLW  00
058EA:  ADDWFC x5B,F
058EC:  MOVLW  01
058EE:  ADDWF  x5A,W
058F0:  MOVWF  01
058F2:  MOVLW  00
058F4:  ADDWFC x5B,W
058F6:  MOVWF  03
058F8:  MOVF   01,W
058FA:  ADDLW  1F
058FC:  MOVWF  FE9
058FE:  MOVLW  01
05900:  ADDWFC 03,W
05902:  MOVWF  FEA
05904:  MOVF   x56,W
05906:  SUBWF  FEF,W
05908:  BNZ   5934
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
0590A:  CLRF   x5B
0590C:  MOVFF  A57,A5A
05910:  CLRF   x5D
05912:  MOVLW  1D
05914:  MOVWF  x5C
05916:  MOVLB  0
05918:  CALL   244C
0591C:  MOVLW  1F
0591E:  MOVLB  A
05920:  ADDWF  01,W
05922:  MOVWF  FE9
05924:  MOVLW  01
05926:  ADDWFC 02,W
05928:  MOVWF  FEA
0592A:  SETF   FEF
0592C:  SETF   FEC
0592E:  SETF   FEC
05930:  MOVLW  7F
05932:  MOVWF  FEC
....................         } 
05934:  INCF   x57,F
05936:  BRA    588C
....................     } 
05938:  MOVLB  0
0593A:  RETURN 0
.................... } 
....................  
.................... void scheduled_command_check() 
.................... { 
....................     // time_t current_time = time(0); 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
*
0D594:  MOVLB  9
0D596:  CLRF   xC9
0D598:  MOVF   xC9,W
0D59A:  SUBLW  1F
0D59C:  BTFSS  FD8.0
0D59E:  BRA    D686
....................         if (current_time >= scheduled_commands[i].time) { 
0D5A0:  MOVLB  A
0D5A2:  CLRF   x5B
0D5A4:  MOVFF  9C9,A5A
0D5A8:  CLRF   x5D
0D5AA:  MOVLW  1D
0D5AC:  MOVWF  x5C
0D5AE:  MOVLB  0
0D5B0:  CALL   244C
0D5B4:  MOVFF  02,9CB
0D5B8:  MOVFF  01,9CA
0D5BC:  MOVLW  1F
0D5BE:  MOVLB  9
0D5C0:  ADDWF  01,W
0D5C2:  MOVWF  FE9
0D5C4:  MOVLW  01
0D5C6:  ADDWFC 02,W
0D5C8:  MOVWF  FEA
0D5CA:  MOVFF  FEF,00
0D5CE:  MOVFF  FEC,01
0D5D2:  MOVFF  FEC,02
0D5D6:  MOVFF  FEC,03
0D5DA:  BTFSS  03.7
0D5DC:  BRA    D5E4
0D5DE:  BTFSS  3C.7
0D5E0:  BRA    D606
0D5E2:  BRA    D5E8
0D5E4:  BTFSC  3C.7
0D5E6:  BRA    D682
0D5E8:  MOVF   03,W
0D5EA:  SUBWF  3C,W
0D5EC:  BNC   D682
0D5EE:  BNZ   D606
0D5F0:  MOVF   02,W
0D5F2:  SUBWF  3B,W
0D5F4:  BNC   D682
0D5F6:  BNZ   D606
0D5F8:  MOVF   01,W
0D5FA:  SUBWF  3A,W
0D5FC:  BNC   D682
0D5FE:  BNZ   D606
0D600:  MOVF   00,W
0D602:  SUBWF  39,W
0D604:  BNC   D682
....................             command_execute(scheduled_commands[i].command, MSG_COMM, 1); // scheduled commands can only be COMM commands 
0D606:  MOVLB  A
0D608:  CLRF   x5B
0D60A:  MOVFF  9C9,A5A
0D60E:  CLRF   x5D
0D610:  MOVLW  1D
0D612:  MOVWF  x5C
0D614:  MOVLB  0
0D616:  CALL   244C
0D61A:  MOVFF  01,9CA
0D61E:  MOVLW  04
0D620:  MOVLB  9
0D622:  ADDWF  01,W
0D624:  MOVWF  01
0D626:  MOVLW  00
0D628:  ADDWFC 02,W
0D62A:  MOVWF  03
0D62C:  MOVF   01,W
0D62E:  ADDLW  1F
0D630:  MOVWF  01
0D632:  MOVLW  01
0D634:  ADDWFC 03,F
0D636:  MOVFF  01,9CA
0D63A:  MOVFF  03,9CB
0D63E:  MOVFF  03,9F4
0D642:  MOVFF  01,9F3
0D646:  MOVLW  C0
0D648:  MOVWF  xF5
0D64A:  MOVLW  01
0D64C:  MOVWF  xF6
0D64E:  MOVLB  0
0D650:  CALL   C582
....................             scheduled_commands[i].time = TIME_T_MAX;                     // Disable the command from executing again (== reschedule it at infinity). 
0D654:  MOVLB  A
0D656:  CLRF   x5B
0D658:  MOVFF  9C9,A5A
0D65C:  CLRF   x5D
0D65E:  MOVLW  1D
0D660:  MOVWF  x5C
0D662:  MOVLB  0
0D664:  CALL   244C
0D668:  MOVLW  1F
0D66A:  MOVLB  9
0D66C:  ADDWF  01,W
0D66E:  MOVWF  FE9
0D670:  MOVLW  01
0D672:  ADDWFC 02,W
0D674:  MOVWF  FEA
0D676:  SETF   FEF
0D678:  SETF   FEC
0D67A:  SETF   FEC
0D67C:  MOVLW  7F
0D67E:  MOVWF  FEC
....................             i = 0; // Check the whole table again for changes 
0D680:  CLRF   xC9
....................         } 
0D682:  INCF   xC9,F
0D684:  BRA    D598
....................     } 
0D686:  MOVLB  0
0D688:  GOTO   E210 (RETURN)
.................... } 
....................  
.................... #ifndef PC_SIM 
.................... #define ZERO (0, 0) 
.................... #else 
.................... #define ZERO (0) 
.................... #endif 
....................  
.................... // Schedule a constant 
.................... #define schedule(time, ...)               \ 
....................     do {                                  \ 
....................         uint8_t cmd[] = __VA_ARGS__;      \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Schedule a variable 
.................... #define vschedule(time, cmd)              \ 
....................     do {                                  \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Execute a command immediately 
.................... #define execute(log, ...)                        \ 
....................     do {                                         \ 
....................         uint8_t cmd[] = __VA_ARGS__;             \ 
....................         command_execute(cmd, MSG_WILDCARD, log); \ 
....................     } while ZERO 
....................  
.................... #define periodic_command_clear_rx_flag(period, delta) \ 
....................     do {                                              \ 
....................         if ((current_time % period == delta)) {       \ 
....................             response_rx = 0;                          \ 
....................         }                                             \ 
....................     } while ZERO 
....................  
.................... #define periodic_command(period, delta, log, ...) \ 
....................     do {                                          \ 
....................         if ((current_time % period == delta)) {   \ 
....................             if (!response_rx)                     \ 
....................                 execute(log, __VA_ARGS__);        \ 
....................         }                                         \ 
....................     } while ZERO 
....................  
.................... #endif /* SCHEDULER_H */ 
....................  
....................  
.................... void boot_commands_write() 
*
03CDE:  MOVLW  06
03CE0:  MOVLB  A
03CE2:  MOVWF  x29
03CE4:  MOVLW  8B
03CE6:  MOVFF  A29,A27
03CEA:  MOVWF  x26
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_erase_pages(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, BOOT_COMMANDS_ADDR + sizeof(boot_commands)); 
03CEC:  MOVLW  09
03CEE:  MOVWF  x33
03CF0:  MOVLW  25
03CF2:  MOVWF  x32
03CF4:  CLRF   x37
03CF6:  CLRF   x36
03CF8:  CLRF   x35
03CFA:  CLRF   x34
03CFC:  CLRF   x3B
03CFE:  CLRF   x3A
03D00:  CLRF   x39
03D02:  MOVLW  E8
03D04:  MOVWF  x38
03D06:  MOVLB  0
03D08:  RCALL  3968
....................     flash_transfer_data_from_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
03D0A:  MOVLW  09
03D0C:  MOVLB  A
03D0E:  MOVWF  xD0
03D10:  MOVLW  25
03D12:  MOVWF  xCF
03D14:  CLRF   xD4
03D16:  CLRF   xD3
03D18:  CLRF   xD2
03D1A:  CLRF   xD1
03D1C:  MOVFF  A27,AD6
03D20:  MOVFF  A26,AD5
03D24:  CLRF   xDA
03D26:  CLRF   xD9
03D28:  CLRF   xD8
03D2A:  MOVLW  E8
03D2C:  MOVWF  xD7
03D2E:  MOVLB  0
03D30:  RCALL  3C1A
03D32:  RETURN 0
.................... } 
....................  
.................... void boot_commands_read() 
*
043B8:  MOVLW  06
043BA:  MOVLB  9
043BC:  MOVWF  xD8
043BE:  MOVLW  8B
043C0:  MOVFF  9D8,9D6
043C4:  MOVWF  xD5
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_transfer_data_to_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
043C6:  MOVLW  09
043C8:  MOVLB  B
043CA:  MOVWF  x01
043CC:  MOVLW  25
043CE:  MOVWF  x00
043D0:  CLRF   x05
043D2:  CLRF   x04
043D4:  CLRF   x03
043D6:  CLRF   x02
043D8:  MOVFF  9D6,B07
043DC:  MOVFF  9D5,B06
043E0:  CLRF   x0B
043E2:  CLRF   x0A
043E4:  CLRF   x09
043E6:  MOVLW  E8
043E8:  MOVWF  x08
043EA:  MOVLB  0
043EC:  CALL   2E46
043F0:  GOTO   45BE (RETURN)
.................... } 
....................  
.................... void boot_commands_clear_nth(uint8_t n) 
.................... { 
....................     if (n < BOOT_COMMANDS_MAX) 
*
03C96:  MOVLB  A
03C98:  MOVF   x0A,W
03C9A:  SUBLW  07
03C9C:  BNC   3CBE
....................         boot_commands[n].time = TIME_T_MAX; 
03C9E:  MOVF   x0A,W
03CA0:  MULLW  1D
03CA2:  MOVF   FF3,W
03CA4:  CLRF   x0C
03CA6:  MOVWF  x0B
03CA8:  MOVLW  8B
03CAA:  ADDWF  x0B,W
03CAC:  MOVWF  FE9
03CAE:  MOVLW  06
03CB0:  ADDWFC x0C,W
03CB2:  MOVWF  FEA
03CB4:  SETF   FEF
03CB6:  SETF   FEC
03CB8:  SETF   FEC
03CBA:  MOVLW  7F
03CBC:  MOVWF  FEC
03CBE:  MOVLB  0
03CC0:  RETURN 0
.................... } 
....................  
.................... void boot_commands_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
03CC2:  MOVLB  A
03CC4:  CLRF   x07
03CC6:  MOVF   x07,W
03CC8:  SUBLW  07
03CCA:  BNC   3CDA
....................         boot_commands_clear_nth(i); 
03CCC:  MOVFF  A07,A0A
03CD0:  MOVLB  0
03CD2:  RCALL  3C96
03CD4:  MOVLB  A
03CD6:  INCF   x07,F
03CD8:  BRA    3CC6
....................     } 
03CDA:  MOVLB  0
03CDC:  RETURN 0
.................... } 
....................  
.................... uint8_t boot_commands_add(boot_command bc) 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
*
06B3A:  MOVLB  A
06B3C:  CLRF   x43
06B3E:  MOVF   x43,W
06B40:  SUBLW  07
06B42:  BNC   6BBA
....................         if (boot_commands[i].time == TIME_T_MAX) { 
06B44:  MOVF   x43,W
06B46:  MULLW  1D
06B48:  MOVF   FF3,W
06B4A:  CLRF   x45
06B4C:  MOVWF  x44
06B4E:  MOVLW  8B
06B50:  ADDWF  x44,W
06B52:  MOVWF  FE9
06B54:  MOVLW  06
06B56:  ADDWFC x45,W
06B58:  MOVWF  FEA
06B5A:  MOVFF  FEF,A46
06B5E:  MOVFF  FEC,A47
06B62:  MOVFF  FEC,A48
06B66:  MOVFF  FEC,A49
06B6A:  INCFSZ x46,W
06B6C:  BRA    6BB6
06B6E:  INCFSZ x47,W
06B70:  BRA    6BB6
06B72:  INCFSZ x48,W
06B74:  BRA    6BB6
06B76:  MOVF   x49,W
06B78:  SUBLW  7F
06B7A:  BNZ   6BB6
....................             memcpy(&boot_commands[i], &bc, sizeof(boot_command)); 
06B7C:  MOVF   x43,W
06B7E:  MULLW  1D
06B80:  MOVF   FF3,W
06B82:  CLRF   03
06B84:  ADDLW  8B
06B86:  MOVWF  01
06B88:  MOVLW  06
06B8A:  ADDWFC 03,F
06B8C:  MOVFF  01,A44
06B90:  MOVFF  03,A45
06B94:  MOVFF  03,FEA
06B98:  MOVFF  01,FE9
06B9C:  MOVLW  0A
06B9E:  MOVWF  FE2
06BA0:  MOVLW  26
06BA2:  MOVWF  FE1
06BA4:  MOVLW  1D
06BA6:  MOVWF  01
06BA8:  MOVFF  FE6,FEE
06BAC:  DECFSZ 01,F
06BAE:  BRA    6BA8
....................             return i; 
06BB0:  MOVFF  A43,01
06BB4:  BRA    6BBE
....................         } 
06BB6:  INCF   x43,F
06BB8:  BRA    6B3E
....................     } 
....................     return -1; 
06BBA:  MOVLW  FF
06BBC:  MOVWF  01
06BBE:  MOVLB  0
06BC0:  GOTO   6C90 (RETURN)
.................... } 
....................  
.................... void boot_commands_schedule() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
*
0BDDA:  MOVLB  A
0BDDC:  CLRF   x1C
0BDDE:  MOVF   x1C,W
0BDE0:  SUBLW  07
0BDE2:  BTFSS  FD8.0
0BDE4:  BRA    BEE4
....................         if(boot_commands[i].time > 0 && boot_commands[i].time < TIME_T_MAX) 
0BDE6:  MOVF   x1C,W
0BDE8:  MULLW  1D
0BDEA:  MOVF   FF3,W
0BDEC:  CLRF   x1E
0BDEE:  MOVWF  x1D
0BDF0:  MOVLW  8B
0BDF2:  ADDWF  x1D,W
0BDF4:  MOVWF  FE9
0BDF6:  MOVLW  06
0BDF8:  ADDWFC x1E,W
0BDFA:  MOVWF  FEA
0BDFC:  MOVFF  FEF,A1F
0BE00:  MOVFF  FEC,A20
0BE04:  MOVFF  FEC,A21
0BE08:  MOVFF  FEC,A22
0BE0C:  BTFSC  x22.7
0BE0E:  BRA    BEE0
0BE10:  MOVF   x22,F
0BE12:  BNZ   BE22
0BE14:  MOVF   x21,F
0BE16:  BNZ   BE22
0BE18:  MOVF   x20,F
0BE1A:  BNZ   BE22
0BE1C:  MOVF   x1F,W
0BE1E:  SUBLW  00
0BE20:  BC    BEE0
0BE22:  MOVF   x1C,W
0BE24:  MULLW  1D
0BE26:  MOVF   FF3,W
0BE28:  CLRF   x20
0BE2A:  MOVWF  x1F
0BE2C:  MOVLW  8B
0BE2E:  ADDWF  x1F,W
0BE30:  MOVWF  FE9
0BE32:  MOVLW  06
0BE34:  ADDWFC x20,W
0BE36:  MOVWF  FEA
0BE38:  MOVFF  FEF,A21
0BE3C:  MOVFF  FEC,A22
0BE40:  MOVFF  FEC,A23
0BE44:  MOVFF  FEC,A24
0BE48:  INCFSZ x21,W
0BE4A:  BRA    BE5A
0BE4C:  INCFSZ x22,W
0BE4E:  BRA    BE5A
0BE50:  INCFSZ x23,W
0BE52:  BRA    BE5A
0BE54:  MOVF   x24,W
0BE56:  SUBLW  7F
0BE58:  BZ    BEE0
....................             vschedule(current_time + boot_commands[i].time, boot_commands[i].command); 
0BE5A:  MOVF   x1C,W
0BE5C:  MULLW  1D
0BE5E:  MOVF   FF3,W
0BE60:  CLRF   x1E
0BE62:  MOVWF  x1D
0BE64:  MOVLW  8B
0BE66:  ADDWF  x1D,W
0BE68:  MOVWF  FE9
0BE6A:  MOVLW  06
0BE6C:  ADDWFC x1E,W
0BE6E:  MOVWF  FEA
0BE70:  MOVFF  FEF,00
0BE74:  MOVFF  FEC,01
0BE78:  MOVFF  FEC,02
0BE7C:  MOVFF  FEC,03
0BE80:  MOVF   00,W
0BE82:  ADDWF  39,W
0BE84:  MOVWF  x1F
0BE86:  MOVF   01,W
0BE88:  ADDWFC 3A,W
0BE8A:  MOVWF  x20
0BE8C:  MOVF   02,W
0BE8E:  ADDWFC 3B,W
0BE90:  MOVWF  x21
0BE92:  MOVF   03,W
0BE94:  ADDWFC 3C,W
0BE96:  MOVWF  x22
0BE98:  MOVF   x1C,W
0BE9A:  MULLW  1D
0BE9C:  MOVF   FF3,W
0BE9E:  CLRF   x24
0BEA0:  MOVWF  x23
0BEA2:  MOVLW  04
0BEA4:  ADDWF  x23,W
0BEA6:  MOVWF  01
0BEA8:  MOVLW  00
0BEAA:  ADDWFC x24,W
0BEAC:  MOVWF  03
0BEAE:  MOVF   01,W
0BEB0:  ADDLW  8B
0BEB2:  MOVWF  01
0BEB4:  MOVLW  06
0BEB6:  ADDWFC 03,F
0BEB8:  MOVFF  01,A23
0BEBC:  MOVFF  03,A24
0BEC0:  MOVFF  A22,A2E
0BEC4:  MOVFF  A21,A2D
0BEC8:  MOVFF  A20,A2C
0BECC:  MOVFF  A1F,A2B
0BED0:  MOVFF  03,A30
0BED4:  MOVFF  01,A2F
0BED8:  MOVLB  0
0BEDA:  CALL   4600
0BEDE:  MOVLB  A
0BEE0:  INCF   x1C,F
0BEE2:  BRA    BDDE
....................     } 
0BEE4:  MOVLB  0
0BEE6:  GOTO   C1D4 (RETURN)
.................... } 
....................  
.................... #endif /* BOOT_COMMAND_H */ 
....................  
.................... #include "interpreter.h" 
.................... #ifndef INTERPRETER_H 
.................... #define INTERPRETER_H 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "scheduler.h" 
.................... #ifndef SCHEDULER_H 
.................... #define SCHEDULER_H 
....................  
.................... #include <string.h> 
.................... #include "definitions.h" 
....................  
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled); 
....................  
.................... void scheduler_initialize() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... int scheduled_command_add(time_t time, uint8_t* command) 
.................... { 
....................     scheduled_command cmd; 
....................     cmd.time = time; 
....................     memcpy(cmd.command, command, BUFF_LENGTH); 
....................  
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&scheduled_commands[i], &cmd, sizeof(scheduled_command)); 
....................             return 0; 
....................         } 
....................     } 
....................  
....................     return -1; // Error signaling 
.................... } 
....................  
.................... int scheduled_command_count() 
.................... { 
....................     int count = 0; 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time != TIME_T_MAX) { 
....................             count++; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
.................... void scheduled_command_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... void scheduled_command_clear_specified_command(uint8_t source, uint8_t command) 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].command[0] == source && scheduled_commands[i].command[1] == command) { 
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
....................         } 
....................     } 
.................... } 
....................  
.................... void scheduled_command_check() 
.................... { 
....................     // time_t current_time = time(0); 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (current_time >= scheduled_commands[i].time) { 
....................             command_execute(scheduled_commands[i].command, MSG_COMM, 1); // scheduled commands can only be COMM commands 
....................             scheduled_commands[i].time = TIME_T_MAX;                     // Disable the command from executing again (== reschedule it at infinity). 
....................             i = 0; // Check the whole table again for changes 
....................         } 
....................     } 
.................... } 
....................  
.................... #ifndef PC_SIM 
.................... #define ZERO (0, 0) 
.................... #else 
.................... #define ZERO (0) 
.................... #endif 
....................  
.................... // Schedule a constant 
.................... #define schedule(time, ...)               \ 
....................     do {                                  \ 
....................         uint8_t cmd[] = __VA_ARGS__;      \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Schedule a variable 
.................... #define vschedule(time, cmd)              \ 
....................     do {                                  \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Execute a command immediately 
.................... #define execute(log, ...)                        \ 
....................     do {                                         \ 
....................         uint8_t cmd[] = __VA_ARGS__;             \ 
....................         command_execute(cmd, MSG_WILDCARD, log); \ 
....................     } while ZERO 
....................  
.................... #define periodic_command_clear_rx_flag(period, delta) \ 
....................     do {                                              \ 
....................         if ((current_time % period == delta)) {       \ 
....................             response_rx = 0;                          \ 
....................         }                                             \ 
....................     } while ZERO 
....................  
.................... #define periodic_command(period, delta, log, ...) \ 
....................     do {                                          \ 
....................         if ((current_time % period == delta)) {   \ 
....................             if (!response_rx)                     \ 
....................                 execute(log, __VA_ARGS__);        \ 
....................         }                                         \ 
....................     } while ZERO 
....................  
.................... #endif /* SCHEDULER_H */ 
....................  
.................... #include "crc16.h" 
.................... #ifndef CRC16_H 
.................... #define CRC16_H 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // CRC calculation function 
.................... uint16_t mk_crc(uint8_t* data, uint8_t size) 
*
06C9C:  MOVLB  A
06C9E:  CLRF   x35
06CA0:  CLRF   x34
06CA2:  SETF   x33
06CA4:  SETF   x32
06CA6:  CLRF   x39
06CA8:  CLRF   x38
06CAA:  MOVLW  84
06CAC:  MOVWF  x37
06CAE:  MOVLW  08
06CB0:  MOVWF  x36
.................... { 
....................     uint32_t crcreg = 0xffff; 
....................     uint32_t calc = 0x8408; 
....................     for (uint32_t k = 0; k < size; k++) { 
06CB2:  CLRF   x3D
06CB4:  CLRF   x3C
06CB6:  CLRF   x3B
06CB8:  CLRF   x3A
06CBA:  MOVF   x3D,F
06CBC:  BNZ   6D48
06CBE:  MOVF   x3C,F
06CC0:  BNZ   6D48
06CC2:  MOVF   x3B,F
06CC4:  BNZ   6D48
06CC6:  MOVF   x31,W
06CC8:  SUBWF  x3A,W
06CCA:  BC    6D48
....................         uint8_t cal_data = data[k]; 
06CCC:  MOVF   x2F,W
06CCE:  ADDWF  x3A,W
06CD0:  MOVWF  FE9
06CD2:  MOVF   x30,W
06CD4:  ADDWFC x3B,W
06CD6:  MOVWF  FEA
06CD8:  MOVFF  FEF,A3E
....................         for (uint32_t i = 0; i < 8; i++) { 
06CDC:  CLRF   x42
06CDE:  CLRF   x41
06CE0:  CLRF   x40
06CE2:  CLRF   x3F
06CE4:  MOVF   x42,F
06CE6:  BNZ   6D36
06CE8:  MOVF   x41,F
06CEA:  BNZ   6D36
06CEC:  MOVF   x40,F
06CEE:  BNZ   6D36
06CF0:  MOVF   x3F,W
06CF2:  SUBLW  07
06CF4:  BNC   6D36
....................             uint8_t w = (crcreg ^ cal_data) & 0x0001; 
06CF6:  MOVF   x32,W
06CF8:  XORWF  x3E,W
06CFA:  MOVWF  x44
06CFC:  MOVF   x44,W
06CFE:  ANDLW  01
06D00:  MOVWF  x43
....................             crcreg = crcreg >> 1; 
06D02:  BCF    FD8.0
06D04:  RRCF   x35,F
06D06:  RRCF   x34,F
06D08:  RRCF   x33,F
06D0A:  RRCF   x32,F
....................             if (w == 1) { 
06D0C:  DECFSZ x43,W
06D0E:  BRA    6D20
....................                 crcreg = crcreg ^ calc; 
06D10:  MOVF   x36,W
06D12:  XORWF  x32,F
06D14:  MOVF   x37,W
06D16:  XORWF  x33,F
06D18:  MOVF   x38,W
06D1A:  XORWF  x34,F
06D1C:  MOVF   x39,W
06D1E:  XORWF  x35,F
....................             } 
....................             cal_data = cal_data >> 1; 
06D20:  BCF    FD8.0
06D22:  RRCF   x3E,F
06D24:  MOVLW  01
06D26:  ADDWF  x3F,F
06D28:  BTFSC  FD8.0
06D2A:  INCF   x40,F
06D2C:  BTFSC  FD8.2
06D2E:  INCF   x41,F
06D30:  BTFSC  FD8.2
06D32:  INCF   x42,F
06D34:  BRA    6CE4
....................         } 
06D36:  MOVLW  01
06D38:  ADDWF  x3A,F
06D3A:  BTFSC  FD8.0
06D3C:  INCF   x3B,F
06D3E:  BTFSC  FD8.2
06D40:  INCF   x3C,F
06D42:  BTFSC  FD8.2
06D44:  INCF   x3D,F
06D46:  BRA    6CBA
....................     } 
....................     crcreg = crcreg ^ 0xffff; 
06D48:  MOVLW  FF
06D4A:  XORWF  x32,F
06D4C:  XORWF  x33,F
....................     return crcreg; 
06D4E:  MOVFF  A32,01
06D52:  MOVFF  A33,02
06D56:  MOVLB  0
06D58:  RETURN 0
.................... } 
....................  
.................... #endif /* CRC16_H */ 
....................  
.................... #include "libuart_fn.h" 
.................... #ifndef LIBUART_FN_H 
.................... #define LIBUART_FN_H 
....................  
.................... #include "definitions.h" 
....................  
.................... void uart_print_pc_hex(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size - 1; i++) { 
....................         fprintf(PC, "%02X ", data[i]); 
....................     } 
....................     fprintf(PC, "%02X", data[size - 1]); 
.................... } 
....................  
.................... void uart_print_pc_hex_short(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size; i++) { 
....................         fprintf(PC, "%02X", data[i]); 
....................     } 
.................... } 
....................  
.................... void uart_download_packet(uart_fn* port, uint8_t* buffer, uint32_t size, uint32_t timeout) 
.................... { 
....................     uint8_t n = 0; 
....................     for (uint32_t i = 0; i < timeout; i++) { 
....................         if (port->bytes_available()) { 
....................             buffer[n++] = port->get_char(); 
....................             if (n >= size) 
....................                 break; 
....................         } 
....................     } 
.................... } 
....................  
.................... // Send packet macro; buffer is of type uint8_t*; 
.................... void uart_send_packet(uart_fn* port, uint8_t* buffer, uint32_t size) 
.................... { 
....................     for (uint8_t* i = buffer; i < size + buffer; i++) { 
....................         port->put_char(*i); 
....................     } 
.................... } 
....................  
.................... void uart_send_packet_repeat(uart_fn* port, uint8_t* buffer, uint32_t size, uint8_t repetitions, uint32_t delay) 
.................... { 
....................     for(uint8_t i=0; i<repetitions; i++){ 
....................         uart_send_packet(port, buffer, size); 
....................         delay_ms(delay); 
....................     } 
.................... } 
....................  
.................... #endif // !LIBUART_FN_H 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include "xmodem.h" 
.................... #ifndef XMODEM_H 
.................... #define XMODEM_H 
....................  
.................... // Based on: 
.................... // https://web.mit.edu/6.115/www/amulet/xmodem.htm 
.................... // https://pythonhosted.org/xmodem/xmodem.html#data-flow-example-including-error-recovery 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include "libuart_fn.h" 
.................... #ifndef LIBUART_FN_H 
.................... #define LIBUART_FN_H 
....................  
.................... #include "definitions.h" 
....................  
.................... void uart_print_pc_hex(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size - 1; i++) { 
....................         fprintf(PC, "%02X ", data[i]); 
....................     } 
....................     fprintf(PC, "%02X", data[size - 1]); 
.................... } 
....................  
.................... void uart_print_pc_hex_short(uint8_t* data, int size) 
.................... { 
....................     for (int i = 0; i < size; i++) { 
....................         fprintf(PC, "%02X", data[i]); 
....................     } 
.................... } 
....................  
.................... void uart_download_packet(uart_fn* port, uint8_t* buffer, uint32_t size, uint32_t timeout) 
.................... { 
....................     uint8_t n = 0; 
....................     for (uint32_t i = 0; i < timeout; i++) { 
....................         if (port->bytes_available()) { 
....................             buffer[n++] = port->get_char(); 
....................             if (n >= size) 
....................                 break; 
....................         } 
....................     } 
.................... } 
....................  
.................... // Send packet macro; buffer is of type uint8_t*; 
.................... void uart_send_packet(uart_fn* port, uint8_t* buffer, uint32_t size) 
.................... { 
....................     for (uint8_t* i = buffer; i < size + buffer; i++) { 
....................         port->put_char(*i); 
....................     } 
.................... } 
....................  
.................... void uart_send_packet_repeat(uart_fn* port, uint8_t* buffer, uint32_t size, uint8_t repetitions, uint32_t delay) 
.................... { 
....................     for(uint8_t i=0; i<repetitions; i++){ 
....................         uart_send_packet(port, buffer, size); 
....................         delay_ms(delay); 
....................     } 
.................... } 
....................  
.................... #endif // !LIBUART_FN_H 
....................  
....................  
.................... #define XMODEM_SOH 0x01                   // Start of Header 
.................... #define XMODEM_EOT 0x04                   // End of Transmission 
.................... #define XMODEM_ACK 0x06                   // Acknowledge 
.................... #define XMODEM_NAK 0x15                   // Not Acknowledge 
.................... #define XMODEM_DLENGTH 128                // Data length 
.................... #define XMODEM_PLENGTH XMODEM_DLENGTH + 4 // Packet length 
....................  
.................... typedef struct xmodem_packet { 
....................     uint8_t header; 
....................     uint8_t packet_no; 
....................     uint8_t packet_no_; 
....................     uint8_t packet_data[XMODEM_DLENGTH]; 
....................     uint8_t checksum; 
.................... } xmodem_packet; 
....................  
.................... uint8_t xmodem_calc_chksum(uint8_t* ptr, uint8_t count) 
*
08F5E:  MOVLB  B
08F60:  CLRF   x05
.................... { 
....................     uint8_t result = 0; 
....................     for (uint8_t* i = ptr; i < ptr + count; i++) { 
08F62:  MOVFF  B03,B07
08F66:  MOVFF  B02,B06
08F6A:  MOVF   x04,W
08F6C:  ADDWF  x02,W
08F6E:  MOVWF  01
08F70:  MOVLW  00
08F72:  ADDWFC x03,W
08F74:  MOVWF  03
08F76:  MOVF   x07,W
08F78:  SUBWF  03,W
08F7A:  BNC   8F9C
08F7C:  BNZ   8F84
08F7E:  MOVF   01,W
08F80:  SUBWF  x06,W
08F82:  BC    8F9C
....................         result += *i; 
08F84:  MOVFF  B07,03
08F88:  MOVFF  B06,FE9
08F8C:  MOVFF  03,FEA
08F90:  MOVF   FEF,W
08F92:  ADDWF  x05,F
08F94:  INCF   x06,F
08F96:  BTFSC  FD8.2
08F98:  INCF   x07,F
08F9A:  BRA    8F6A
....................     } 
....................     return result; 
08F9C:  MOVFF  B05,01
08FA0:  MOVLB  0
08FA2:  RETURN 0
.................... } 
....................  
.................... void xmodem_create_packet(spi_fn* spi_port, uint32_t fm_address, uint32_t packet_no, uint8_t* packet_data) 
08FA4:  MOVFF  AFB,AFD
08FA8:  MOVFF  AFA,AFC
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)packet_data; 
....................     packet->header = XMODEM_SOH; 
08FAC:  MOVLB  A
08FAE:  MOVFF  AFC,FE9
08FB2:  MOVFF  AFD,FEA
08FB6:  MOVLW  01
08FB8:  MOVWF  FEF
....................     packet->packet_no = packet_no & 0xFF; 
08FBA:  ADDWF  xFC,W
08FBC:  MOVWF  FE9
08FBE:  MOVLW  00
08FC0:  ADDWFC xFD,W
08FC2:  MOVWF  FEA
08FC4:  MOVFF  AF6,FEF
....................     packet->packet_no_ = 0xFF - packet->packet_no; 
08FC8:  MOVLW  02
08FCA:  ADDWF  xFC,W
08FCC:  MOVWF  01
08FCE:  MOVLW  00
08FD0:  ADDWFC xFD,W
08FD2:  MOVWF  03
08FD4:  MOVLW  01
08FD6:  ADDWF  xFC,W
08FD8:  MOVWF  FE9
08FDA:  MOVLW  00
08FDC:  ADDWFC xFD,W
08FDE:  MOVWF  FEA
08FE0:  MOVF   FEF,W
08FE2:  SUBLW  FF
08FE4:  MOVLB  B
08FE6:  MOVFF  03,FEA
08FEA:  MOVFF  01,FE9
08FEE:  MOVWF  FEF
....................     flash_transfer_data_to_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
08FF0:  MOVLW  03
08FF2:  MOVLB  A
08FF4:  ADDWF  xFC,W
08FF6:  MOVWF  01
08FF8:  MOVLW  00
08FFA:  ADDWFC xFD,W
08FFC:  MOVWF  03
08FFE:  MOVFF  01,AFE
09002:  MOVWF  xFF
09004:  MOVFF  AF1,B01
09008:  MOVFF  AF0,B00
0900C:  MOVFF  AF5,B05
09010:  MOVFF  AF4,B04
09014:  MOVFF  AF3,B03
09018:  MOVFF  AF2,B02
0901C:  MOVFF  FE8,B07
09020:  MOVFF  01,B06
09024:  MOVLB  B
09026:  CLRF   x0B
09028:  CLRF   x0A
0902A:  CLRF   x09
0902C:  MOVLW  80
0902E:  MOVWF  x08
09030:  MOVLB  0
09032:  CALL   2E46
....................     packet->checksum = xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH); 
09036:  MOVLW  83
09038:  MOVLB  A
0903A:  ADDWF  xFC,W
0903C:  MOVWF  01
0903E:  MOVLW  00
09040:  ADDWFC xFD,W
09042:  MOVWF  03
09044:  MOVFF  01,AFE
09048:  MOVWF  xFF
0904A:  MOVLW  03
0904C:  ADDWF  xFC,W
0904E:  MOVWF  01
09050:  MOVLW  00
09052:  ADDWFC xFD,W
09054:  MOVWF  03
09056:  MOVFF  01,B00
0905A:  MOVLB  B
0905C:  MOVWF  x01
0905E:  MOVWF  x03
09060:  MOVFF  01,B02
09064:  MOVLW  80
09066:  MOVWF  x04
09068:  MOVLB  0
0906A:  RCALL  8F5E
0906C:  MOVFF  AFF,FEA
09070:  MOVFF  AFE,FE9
09074:  MOVFF  01,FEF
09078:  GOTO   9190 (RETURN)
.................... } 
....................  
.................... int8_t xmodem_send(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address, uint16_t n_packets) 
0907C:  MOVLB  A
0907E:  CLRF   x66
09080:  MOVLW  01
09082:  MOVWF  x65
.................... { 
....................     const uint32_t timeout = 5000000; 
....................     uint16_t current_packet = 1; 
....................     uint8_t packet[XMODEM_PLENGTH]; 
....................     for (uint32_t t = 0; t < timeout; t++) { 
09084:  CLRF   xEE
09086:  CLRF   xED
09088:  CLRF   xEC
0908A:  CLRF   xEB
0908C:  MOVF   xEE,F
0908E:  BTFSS  FD8.2
09090:  BRA    91C6
09092:  MOVF   xED,W
09094:  SUBLW  4C
09096:  BTFSS  FD8.0
09098:  BRA    91C6
0909A:  BNZ   90AE
0909C:  MOVF   xEC,W
0909E:  SUBLW  4B
090A0:  BTFSS  FD8.0
090A2:  BRA    91C6
090A4:  BNZ   90AE
090A6:  MOVF   xEB,W
090A8:  SUBLW  3F
090AA:  BTFSS  FD8.0
090AC:  BRA    91C6
....................         if (uart_stream->bytes_available()) { 
090AE:  MOVFF  A5B,01
090B2:  MOVFF  A5C,03
090B6:  MOVFF  A5B,AF0
090BA:  MOVFF  A5C,AF1
090BE:  MOVFF  A5C,FEA
090C2:  MOVFF  A5B,FE9
090C6:  MOVLB  0
090C8:  CALL   0204
090CC:  MOVF   01,F
090CE:  BTFSC  FD8.2
090D0:  BRA    91B2
....................             uint8_t command = uart_stream->get_char(); 
090D2:  MOVLW  04
090D4:  MOVLB  A
090D6:  ADDWF  x5B,W
090D8:  MOVWF  01
090DA:  MOVLW  00
090DC:  ADDWFC x5C,W
090DE:  MOVWF  03
090E0:  MOVFF  01,AF0
090E4:  MOVWF  xF1
090E6:  MOVWF  FEA
090E8:  MOVFF  01,FE9
090EC:  MOVLB  0
090EE:  CALL   0204
090F2:  MOVFF  01,AEF
....................             t = 0; 
090F6:  MOVLB  A
090F8:  CLRF   xEE
090FA:  CLRF   xED
090FC:  CLRF   xEC
090FE:  CLRF   xEB
....................             switch (command) { 
09100:  MOVF   xEF,W
09102:  XORLW  06
09104:  MOVLB  0
09106:  BZ    910E
09108:  XORLW  13
0910A:  BZ    915E
0910C:  BRA    91B2
....................             case XMODEM_ACK: 
....................                 current_packet++; 
0910E:  MOVLB  A
09110:  INCF   x65,F
09112:  BTFSC  FD8.2
09114:  INCF   x66,F
....................                 fm_address += XMODEM_DLENGTH; 
09116:  MOVLW  80
09118:  ADDWF  x5F,F
0911A:  MOVLW  00
0911C:  ADDWFC x60,F
0911E:  ADDWFC x61,F
09120:  ADDWFC x62,F
....................                 if (current_packet > n_packets) { 
09122:  MOVF   x64,W
09124:  SUBWF  x66,W
09126:  BNC   915C
09128:  BNZ   9130
0912A:  MOVF   x65,W
0912C:  SUBWF  x63,W
0912E:  BC    915C
....................                     uart_stream->put_char(XMODEM_EOT); 
09130:  MOVLW  08
09132:  ADDWF  x5B,W
09134:  MOVWF  01
09136:  MOVLW  00
09138:  ADDWFC x5C,W
0913A:  MOVWF  03
0913C:  MOVFF  01,AF0
09140:  MOVWF  xF1
09142:  MOVWF  FEA
09144:  MOVFF  01,FE9
09148:  MOVLW  04
0914A:  MOVLB  B
0914C:  MOVWF  x1E
0914E:  MOVLB  0
09150:  CALL   0204
....................                     return 0; 
09154:  MOVLW  00
09156:  MOVWF  01
09158:  BRA    91CC
0915A:  MOVLB  A
0915C:  MOVLB  0
....................                 } 
....................             case XMODEM_NAK: 
....................                 xmodem_create_packet(spi_port, fm_address, current_packet, packet); 
0915E:  MOVFF  A5E,AF1
09162:  MOVFF  A5D,AF0
09166:  MOVFF  A62,AF5
0916A:  MOVFF  A61,AF4
0916E:  MOVFF  A60,AF3
09172:  MOVFF  A5F,AF2
09176:  MOVLB  A
09178:  CLRF   xF9
0917A:  CLRF   xF8
0917C:  MOVFF  A66,AF7
09180:  MOVFF  A65,AF6
09184:  MOVLW  0A
09186:  MOVWF  xFB
09188:  MOVLW  67
0918A:  MOVWF  xFA
0918C:  MOVLB  0
0918E:  BRA    8FA4
....................                 uart_send_packet(uart_stream, packet, XMODEM_PLENGTH); 
09190:  MOVFF  A5C,AF1
09194:  MOVFF  A5B,AF0
09198:  MOVLW  0A
0919A:  MOVLB  A
0919C:  MOVWF  xF3
0919E:  MOVLW  67
091A0:  MOVWF  xF2
091A2:  CLRF   xF7
091A4:  CLRF   xF6
091A6:  CLRF   xF5
091A8:  MOVLW  84
091AA:  MOVWF  xF4
091AC:  MOVLB  0
091AE:  RCALL  8C4E
....................                 break; 
091B0:  BRA    91B2
....................             default: 
....................                 break; 
....................             } 
....................         } 
091B2:  MOVLW  01
091B4:  MOVLB  A
091B6:  ADDWF  xEB,F
091B8:  BTFSC  FD8.0
091BA:  INCF   xEC,F
091BC:  BTFSC  FD8.2
091BE:  INCF   xED,F
091C0:  BTFSC  FD8.2
091C2:  INCF   xEE,F
091C4:  BRA    908C
....................     } 
....................     return -1; 
091C6:  MOVLW  FF
091C8:  MOVWF  01
091CA:  MOVLB  0
091CC:  RETURN 0
.................... } 
....................  
.................... uint8_t xmodem_validate(uint8_t* buffer, uint16_t packet_no) 
*
0955C:  MOVFF  ACE,AD2
09560:  MOVFF  ACD,AD1
09564:  MOVLB  A
09566:  MOVFF  AD1,FE9
0956A:  MOVFF  AD2,FEA
0956E:  DECFSZ FEF,W
09570:  BRA    9574
09572:  BRA    9578
09574:  MOVLW  00
09576:  BRA    957A
09578:  MOVLW  01
0957A:  MOVWF  xD3
0957C:  MOVLW  01
0957E:  ADDWF  xD1,W
09580:  MOVWF  FE9
09582:  MOVLW  00
09584:  ADDWFC xD2,W
09586:  MOVWF  FEA
09588:  MOVFF  FEF,AD7
0958C:  MOVFF  ACF,00
09590:  CLRF   03
09592:  MOVF   xCF,W
09594:  SUBWF  xD7,W
09596:  BNZ   959C
09598:  MOVF   03,F
0959A:  BZ    95A0
0959C:  MOVLW  00
0959E:  BRA    95A2
095A0:  MOVLW  01
095A2:  MOVWF  xD4
095A4:  MOVLW  02
095A6:  ADDWF  xD1,W
095A8:  MOVWF  FE9
095AA:  MOVLW  00
095AC:  ADDWFC xD2,W
095AE:  MOVWF  FEA
095B0:  MOVFF  FEF,AD7
095B4:  CLRF   03
095B6:  MOVF   xCF,W
095B8:  SUBLW  FF
095BA:  MOVWF  00
095BC:  MOVLW  00
095BE:  SUBFWB 03,F
095C0:  MOVF   00,W
095C2:  SUBWF  xD7,W
095C4:  BNZ   95CA
095C6:  MOVF   03,F
095C8:  BZ    95CE
095CA:  MOVLW  00
095CC:  BRA    95D0
095CE:  MOVLW  01
095D0:  MOVWF  xD5
095D2:  MOVLW  83
095D4:  ADDWF  xD1,W
095D6:  MOVWF  FE9
095D8:  MOVLW  00
095DA:  ADDWFC xD2,W
095DC:  MOVWF  FEA
095DE:  MOVFF  FEF,AD7
095E2:  MOVLW  03
095E4:  ADDWF  xD1,W
095E6:  MOVWF  01
095E8:  MOVLW  00
095EA:  ADDWFC xD2,W
095EC:  MOVWF  03
095EE:  MOVFF  01,AD8
095F2:  MOVWF  xD9
095F4:  MOVFF  FE8,B03
095F8:  MOVFF  01,B02
095FC:  MOVLW  80
095FE:  MOVLB  B
09600:  MOVWF  x04
09602:  MOVLB  0
09604:  RCALL  8F5E
09606:  MOVF   01,W
09608:  MOVLB  A
0960A:  SUBWF  xD7,W
0960C:  BZ    9612
0960E:  MOVLW  00
09610:  BRA    9614
09612:  MOVLW  01
09614:  MOVWF  xD6
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uint8_t correct_header = (packet->header == XMODEM_SOH); 
....................     uint8_t correct_no = (packet->packet_no == (packet_no & 0xFF)); 
....................     uint8_t correct_no_ = (packet->packet_no_ == 0xFF - (packet_no & 0xFF)); 
....................     uint8_t correct_checksum = (packet->checksum == xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH)); 
....................     return correct_header && correct_no && correct_no_ && correct_checksum; 
09616:  MOVF   xD3,F
09618:  BZ    9626
0961A:  MOVF   xD4,F
0961C:  BZ    9626
0961E:  MOVF   xD5,F
09620:  BZ    9626
09622:  MOVF   xD6,F
09624:  BNZ   962A
09626:  MOVLW  00
09628:  BRA    962C
0962A:  MOVLW  01
0962C:  MOVWF  01
0962E:  MOVLB  0
09630:  GOTO   980C (RETURN)
.................... } 
....................  
.................... int16_t xmodem_receive(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address) 
09634:  MOVLB  A
09636:  CLRF   x3E
09638:  MOVLW  02
0963A:  MOVWF  x3D
0963C:  CLRF   x40
0963E:  MOVLW  01
09640:  MOVWF  x3F
09642:  CLRF   x42
09644:  CLRF   x41
*
0974E:  MOVLW  0A
09750:  MOVWF  xCE
09752:  MOVLW  43
09754:  MOVFF  ACE,AC8
09758:  MOVWF  xC7
.................... { 
....................     const uint32_t uart_timeout = 1000000; 
....................     uint16_t max_nak = 2; 
....................     uint16_t packet_no = 1; 
....................     uint16_t nak_count = 0; 
....................     uint8_t buffer[XMODEM_PLENGTH] = { 0 }; 
*
09646:  CLRF   x43
09648:  CLRF   x44
0964A:  CLRF   x45
0964C:  CLRF   x46
0964E:  CLRF   x47
09650:  CLRF   x48
09652:  CLRF   x49
09654:  CLRF   x4A
09656:  CLRF   x4B
09658:  CLRF   x4C
0965A:  CLRF   x4D
0965C:  CLRF   x4E
0965E:  CLRF   x4F
09660:  CLRF   x50
09662:  CLRF   x51
09664:  CLRF   x52
09666:  CLRF   x53
09668:  CLRF   x54
0966A:  CLRF   x55
0966C:  CLRF   x56
0966E:  CLRF   x57
09670:  CLRF   x58
09672:  CLRF   x59
09674:  CLRF   x5A
09676:  CLRF   x5B
09678:  CLRF   x5C
0967A:  CLRF   x5D
0967C:  CLRF   x5E
0967E:  CLRF   x5F
09680:  CLRF   x60
09682:  CLRF   x61
09684:  CLRF   x62
09686:  CLRF   x63
09688:  CLRF   x64
0968A:  CLRF   x65
0968C:  CLRF   x66
0968E:  CLRF   x67
09690:  CLRF   x68
09692:  CLRF   x69
09694:  CLRF   x6A
09696:  CLRF   x6B
09698:  CLRF   x6C
0969A:  CLRF   x6D
0969C:  CLRF   x6E
0969E:  CLRF   x6F
096A0:  CLRF   x70
096A2:  CLRF   x71
096A4:  CLRF   x72
096A6:  CLRF   x73
096A8:  CLRF   x74
096AA:  CLRF   x75
096AC:  CLRF   x76
096AE:  CLRF   x77
096B0:  CLRF   x78
096B2:  CLRF   x79
096B4:  CLRF   x7A
096B6:  CLRF   x7B
096B8:  CLRF   x7C
096BA:  CLRF   x7D
096BC:  CLRF   x7E
096BE:  CLRF   x7F
096C0:  CLRF   x80
096C2:  CLRF   x81
096C4:  CLRF   x82
096C6:  CLRF   x83
096C8:  CLRF   x84
096CA:  CLRF   x85
096CC:  CLRF   x86
096CE:  CLRF   x87
096D0:  CLRF   x88
096D2:  CLRF   x89
096D4:  CLRF   x8A
096D6:  CLRF   x8B
096D8:  CLRF   x8C
096DA:  CLRF   x8D
096DC:  CLRF   x8E
096DE:  CLRF   x8F
096E0:  CLRF   x90
096E2:  CLRF   x91
096E4:  CLRF   x92
096E6:  CLRF   x93
096E8:  CLRF   x94
096EA:  CLRF   x95
096EC:  CLRF   x96
096EE:  CLRF   x97
096F0:  CLRF   x98
096F2:  CLRF   x99
096F4:  CLRF   x9A
096F6:  CLRF   x9B
096F8:  CLRF   x9C
096FA:  CLRF   x9D
096FC:  CLRF   x9E
096FE:  CLRF   x9F
09700:  CLRF   xA0
09702:  CLRF   xA1
09704:  CLRF   xA2
09706:  CLRF   xA3
09708:  CLRF   xA4
0970A:  CLRF   xA5
0970C:  CLRF   xA6
0970E:  CLRF   xA7
09710:  CLRF   xA8
09712:  CLRF   xA9
09714:  CLRF   xAA
09716:  CLRF   xAB
09718:  CLRF   xAC
0971A:  CLRF   xAD
0971C:  CLRF   xAE
0971E:  CLRF   xAF
09720:  CLRF   xB0
09722:  CLRF   xB1
09724:  CLRF   xB2
09726:  CLRF   xB3
09728:  CLRF   xB4
0972A:  CLRF   xB5
0972C:  CLRF   xB6
0972E:  CLRF   xB7
09730:  CLRF   xB8
09732:  CLRF   xB9
09734:  CLRF   xBA
09736:  CLRF   xBB
09738:  CLRF   xBC
0973A:  CLRF   xBD
0973C:  CLRF   xBE
0973E:  CLRF   xBF
09740:  CLRF   xC0
09742:  CLRF   xC1
09744:  CLRF   xC2
09746:  CLRF   xC3
09748:  CLRF   xC4
0974A:  CLRF   xC5
0974C:  CLRF   xC6
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uart_stream->put_char(XMODEM_NAK); // Request 1st packet 
*
0975A:  MOVLW  08
0975C:  ADDWF  x35,W
0975E:  MOVWF  01
09760:  MOVLW  00
09762:  ADDWFC x36,W
09764:  MOVWF  03
09766:  MOVFF  01,ACD
0976A:  MOVWF  xCE
0976C:  MOVWF  FEA
0976E:  MOVFF  01,FE9
09772:  MOVLW  15
09774:  MOVLB  B
09776:  MOVWF  x1E
09778:  MOVLB  0
0977A:  CALL   0204
....................     while (nak_count < max_nak) { 
0977E:  MOVLB  A
09780:  MOVF   x42,W
09782:  SUBWF  x3E,W
09784:  BTFSS  FD8.0
09786:  BRA    993E
09788:  BNZ   9792
0978A:  MOVF   x3D,W
0978C:  SUBWF  x41,W
0978E:  BTFSC  FD8.0
09790:  BRA    993E
....................         uart_download_packet(uart_stream, buffer, XMODEM_PLENGTH, uart_timeout); 
09792:  MOVFF  A36,ACE
09796:  MOVFF  A35,ACD
0979A:  MOVLW  0A
0979C:  MOVWF  xD0
0979E:  MOVLW  43
097A0:  MOVWF  xCF
097A2:  CLRF   xD4
097A4:  CLRF   xD3
097A6:  CLRF   xD2
097A8:  MOVLW  84
097AA:  MOVWF  xD1
097AC:  CLRF   xD8
097AE:  MOVLW  0F
097B0:  MOVWF  xD7
097B2:  MOVLW  42
097B4:  MOVWF  xD6
097B6:  MOVLW  40
097B8:  MOVWF  xD5
097BA:  MOVLB  0
097BC:  CALL   726A
....................         if (buffer[0] == XMODEM_EOT) { 
097C0:  MOVLB  A
097C2:  MOVF   x43,W
097C4:  SUBLW  04
097C6:  BNZ   97F8
....................             uart_stream->put_char(XMODEM_ACK); 
097C8:  MOVLW  08
097CA:  ADDWF  x35,W
097CC:  MOVWF  01
097CE:  MOVLW  00
097D0:  ADDWFC x36,W
097D2:  MOVWF  03
097D4:  MOVFF  01,ACD
097D8:  MOVWF  xCE
097DA:  MOVWF  FEA
097DC:  MOVFF  01,FE9
097E0:  MOVLW  06
097E2:  MOVLB  B
097E4:  MOVWF  x1E
097E6:  MOVLB  0
097E8:  CALL   0204
....................             return packet_no; 
097EC:  MOVLB  A
097EE:  MOVFF  A3F,01
097F2:  MOVFF  A40,02
097F6:  BRA    9944
....................         } 
....................         if (xmodem_validate(buffer, packet_no)) { 
097F8:  MOVLW  0A
097FA:  MOVWF  xCE
097FC:  MOVLW  43
097FE:  MOVWF  xCD
09800:  MOVFF  A40,AD0
09804:  MOVFF  A3F,ACF
09808:  MOVLB  0
0980A:  BRA    955C
0980C:  MOVF   01,F
0980E:  BTFSC  FD8.2
09810:  BRA    990A
....................             // uart_send_packet(uart_stream, packet->packet_data, XMODEM_DLENGTH); // for debug 
....................             uint32_t remaining_addressess = (MEMORY_SECTOR_SIZE - (fm_address % MEMORY_SECTOR_SIZE)) % MEMORY_SECTOR_SIZE; 
09812:  MOVLB  A
09814:  CLRF   02
09816:  CLRF   03
09818:  MOVLW  00
0981A:  BSF    FD8.0
0981C:  SUBFWB x39,W
0981E:  MOVWF  xCD
09820:  MOVLW  00
09822:  SUBFWB x3A,W
09824:  MOVWF  xCE
09826:  MOVLW  01
09828:  SUBFWB 02,W
0982A:  MOVLW  00
0982C:  SUBFWB 03,W
0982E:  MOVFF  ACD,AC9
09832:  MOVFF  ACE,ACA
09836:  CLRF   xCB
09838:  CLRF   xCC
....................             if (remaining_addressess < XMODEM_DLENGTH) { 
0983A:  MOVF   xCC,F
0983C:  BNZ   9886
0983E:  MOVF   xCB,F
09840:  BNZ   9886
09842:  MOVF   xCA,F
09844:  BNZ   9886
09846:  MOVF   xC9,W
09848:  SUBLW  7F
0984A:  BNC   9886
....................                 flash_erase(spi_port, fm_address + remaining_addressess, ERASE_SECTOR); 
0984C:  MOVF   xC9,W
0984E:  ADDWF  x39,W
09850:  MOVWF  xCD
09852:  MOVF   xCA,W
09854:  ADDWFC x3A,W
09856:  MOVWF  xCE
09858:  MOVF   xCB,W
0985A:  ADDWFC x3B,W
0985C:  MOVWF  xCF
0985E:  MOVF   xCC,W
09860:  ADDWFC x3C,W
09862:  MOVWF  xD0
09864:  MOVFF  A38,AD2
09868:  MOVFF  A37,AD1
0986C:  MOVWF  xD6
0986E:  MOVFF  ACF,AD5
09872:  MOVFF  ACE,AD4
09876:  MOVFF  ACD,AD3
0987A:  MOVLW  DC
0987C:  MOVWF  xD7
0987E:  MOVLB  0
09880:  CALL   371C
09884:  MOVLB  A
....................             } 
....................             flash_transfer_data_from_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
09886:  MOVLW  03
09888:  ADDWF  xC7,W
0988A:  MOVWF  01
0988C:  MOVLW  00
0988E:  ADDWFC xC8,W
09890:  MOVWF  03
09892:  MOVFF  01,ACD
09896:  MOVWF  xCE
09898:  MOVFF  A38,AD0
0989C:  MOVFF  A37,ACF
098A0:  MOVFF  A3C,AD4
098A4:  MOVFF  A3B,AD3
098A8:  MOVFF  A3A,AD2
098AC:  MOVFF  A39,AD1
098B0:  MOVWF  xD6
098B2:  MOVFF  01,AD5
098B6:  CLRF   xDA
098B8:  CLRF   xD9
098BA:  CLRF   xD8
098BC:  MOVLW  80
098BE:  MOVWF  xD7
098C0:  MOVLB  0
098C2:  CALL   3C1A
....................             packet_no++; 
098C6:  MOVLB  A
098C8:  INCF   x3F,F
098CA:  BTFSC  FD8.2
098CC:  INCF   x40,F
....................             fm_address += XMODEM_DLENGTH; 
098CE:  MOVLW  80
098D0:  ADDWF  x39,F
098D2:  MOVLW  00
098D4:  ADDWFC x3A,F
098D6:  ADDWFC x3B,F
098D8:  ADDWFC x3C,F
....................             nak_count = 0; 
098DA:  CLRF   x42
098DC:  CLRF   x41
....................             max_nak = 64; // Increase max number of nak once communication is established 
098DE:  CLRF   x3E
098E0:  MOVLW  40
098E2:  MOVWF  x3D
....................             uart_stream->put_char(XMODEM_ACK); 
098E4:  MOVLW  08
098E6:  ADDWF  x35,W
098E8:  MOVWF  01
098EA:  MOVLW  00
098EC:  ADDWFC x36,W
098EE:  MOVWF  03
098F0:  MOVFF  01,ACD
098F4:  MOVWF  xCE
098F6:  MOVWF  FEA
098F8:  MOVFF  01,FE9
098FC:  MOVLW  06
098FE:  MOVLB  B
09900:  MOVWF  x1E
09902:  MOVLB  0
09904:  CALL   0204
....................         } else { 
09908:  BRA    993A
....................             uart_stream->put_char(XMODEM_NAK); 
0990A:  MOVLW  08
0990C:  MOVLB  A
0990E:  ADDWF  x35,W
09910:  MOVWF  01
09912:  MOVLW  00
09914:  ADDWFC x36,W
09916:  MOVWF  03
09918:  MOVFF  01,ACD
0991C:  MOVWF  xCE
0991E:  MOVWF  FEA
09920:  MOVFF  01,FE9
09924:  MOVLW  15
09926:  MOVLB  B
09928:  MOVWF  x1E
0992A:  MOVLB  0
0992C:  CALL   0204
....................             nak_count++; 
09930:  MOVLB  A
09932:  INCF   x41,F
09934:  BTFSC  FD8.2
09936:  INCF   x42,F
09938:  MOVLB  0
....................         } 
0993A:  BRA    977E
0993C:  MOVLB  A
....................     } 
....................     return -1; 
0993E:  MOVLW  FF
09940:  MOVWF  01
09942:  MOVWF  02
09944:  MOVLB  0
09946:  RETURN 0
.................... } 
....................  
.................... #endif /* XMODEM_H */ 
....................  
.................... #include "log_control.h" 
.................... #ifndef LOG_CONTROL_H 
.................... #define LOG_CONTROL_H 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "definitions.h" 
.................... #ifndef DEFINITIONS_H 
.................... #define DEFINITIONS_H 
....................  
.................... #include "device.h" 
.................... #include <time.h> 
.................... #include <stdint.h> 
....................  
.................... uart_declare(PC); 
.................... uart_declare(COMM); 
.................... uart_declare(RST); 
.................... uart_declare(FAB); 
.................... uart_declare(PCIB); 
.................... uart_declare(ADCS); 
....................  
.................... spi_declare(MAIN_FM); 
.................... spi_declare(COM_FM); 
.................... spi_declare(MISSION_FM); 
....................  
.................... #ifndef EM 
.................... #warning "Building for FM" 
.................... #define SPACECRAFT_ID 0x55 
.................... #else 
.................... #warning "Building for EM" 
.................... #define SPACECRAFT_ID 0x56 
.................... #endif // !EM 
....................  
.................... #define BUFF_LENGTH 25        // Must accomodate messages of all UART sources that may be scheduled 
.................... #define MAX_LENGTH 108        // Maximum UART length 
.................... #define TERMINAL_COLS 80      // Number of columns in terminal 
.................... #define EMPTY_BLOCKS_LIMIT 64 // Stop after reading n bytes of empty data on flash 
....................  
.................... #define MSG_WILDCARD 0xFF // This has permission to run all commands 
....................  
.................... // OBC -> subsystem commands 
.................... #define MSG_OBC 0x0B 
....................  
.................... // Debug commands 
.................... #define MSG_PC 0xDB 
.................... #define MSG_LENGTH_PC 25 
.................... #define MSG_CHECKSUM_PC true 
....................  
.................... // Com PIC commands 
.................... #define MSG_COMM 0xC0 
.................... #define MSG_LENGTH_COMM 25 
.................... #define MSG_CHECKSUM_COMM true 
....................  
.................... // PCIB commands 
.................... #define MSG_PCIB 0xAB 
.................... #define MSG_LENGTH_PCIB 36 
.................... #define MSG_CHECKSUM_PCIB true 
....................  
.................... // Reset pic commands 
.................... #define MSG_RST 0xB0 
.................... #define MSG_LENGTH_RST 36 
.................... #define MSG_CHECKSUM_RST false 
....................  
.................... // EPS1 commands 
.................... #define MSG_FAB 0xE0 
.................... #define MSG_LENGTH_FAB 60 
.................... #define MSG_CHECKSUM_FAB false 
....................  
.................... // ADCS commands 
.................... #define MSG_ADCS 0xAD 
.................... #define MSG_LENGTH_ADCS 43 
.................... #define MSG_CHECKSUM_ADCS true 
....................  
.................... #define BOOT_FLAGS_ADDRESS 0x00000000 
.................... #define OBC_FLAGS_ADDRESS BOOT_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define ADDR_FLAGS_ADDRESS OBC_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
.................... #define SCHEDULED_CMD_ADDRESS ADDR_FLAGS_ADDRESS + MEMORY_PAGE_SIZE 
....................  
.................... time_t current_time, previous_time; 
....................  
.................... #define T0 946684800        // earliest time possible for RTC (Jan 1st 2000, 00:00:00) 
.................... #define T_ANTENNA 946686630 // Antenna deployment time 
.................... #define Tn 2147483646       // latest time possible for RTC (Jan 19th 2038, 3:14:06) 
....................  
.................... typedef struct telemetry_time_str { // Stores the time when telemetry is received 
....................     time_t reset_time; 
....................     time_t fab_time; 
....................     time_t pcib_time; 
....................     time_t adcs_time; 
....................     time_t com_time; 
.................... } telemetry_time_str; 
....................  
.................... typedef struct telemetry_str { // Stores the telemetry of the last period, before being written to flash 
....................     uint8_t reset_time; 
....................     uint8_t reset_message[MSG_LENGTH_RST - 12]; 
....................     uint8_t fab_time; 
....................     uint8_t fab_message[MSG_LENGTH_FAB - 6]; 
....................     uint8_t pcib_time; 
....................     uint8_t pcib_message[MSG_LENGTH_PCIB - 26]; 
....................     uint8_t adcs_time; 
....................     uint8_t adcs_message[MSG_LENGTH_ADCS - 4]; 
....................     uint8_t com_time; 
....................     uint16_t com_rssi; 
....................     time_t obc_time; 
....................     uint8_t master_footer[2]; 
.................... } telemetry_str; 
....................  
.................... telemetry_str telemetry; 
.................... telemetry_time_str telemetry_time; 
....................  
.................... #define CW_PAGES 2 
.................... #define CW_LENGTH 6              // in bytes 
.................... uint8_t cw[CW_PAGES][CW_LENGTH]; // Stores the CW beacon string for the last 50s 
....................  
.................... // Flash memory addresses 
.................... #define FLASH_ADDR_START ADDR_FLAGS_ADDRESS 
.................... #define FLASH_ADDR_END SCHEDULED_CMD_ADDRESS 
.................... #define FLASH_ADDR_DELTA 8 // log and telemetry -- 4 bytes each 
....................  
.................... #define FLASH_LOG_START (1 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_END (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_LOG_DELTA 7 // time,origin,command,return 
....................  
.................... #define FLASH_TELEMETRY_START (17 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_END (749 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_TELEMETRY_DELTA sizeof(telemetry) 
.................... #define FLASH_TELEMETRY_SECTORS_PER_DAY 2 
....................  
.................... // Sectors 749 to 1517 (-1) are free to be allocated 
....................  
.................... #define FLASH_ADCS_HS_START (1517 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_HS_END (1524 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_GPS_START (1524 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_GPS_END (1529 * MEMORY_SECTOR_SIZE) 
....................  
.................... #define FLASH_ADCS_TELEMETRY_START (1529 * MEMORY_SECTOR_SIZE) 
.................... #define FLASH_ADCS_TELEMETRY_END (1785 * MEMORY_SECTOR_SIZE) 
....................  
.................... // From 1785-2048 there are 263 sectors of free space 
....................  
.................... typedef struct flash_ctrl { 
....................     uint32_t start; 
....................     uint32_t end; 
....................     uint32_t current; 
....................     uint8_t delta; 
.................... } flash_ctrl; 
....................  
.................... // Store the OBC boot variables 
.................... typedef struct bflags { 
....................     uint8_t deployment_flag; 
.................... } bflags; 
....................  
.................... // Store the OBC variables 
.................... typedef struct oflags { 
....................     int8_t leap_seconds; 
....................     uint8_t adcs_on_off; 
....................     uint8_t pcib_on_off; 
....................     uint8_t gps_time_sync_state; 
....................     int8_t adcs_initial_value; 
....................     uint8_t cw_mode;                 // 0: never send CW; 1: follow ADCS; 2: Send CW always 
....................     uint16_t heater_ref_temperature; // battery heater 
....................     uint16_t heater_ref_voltage;     // battery heater 
.................... } oflags; 
....................  
.................... // Store the address variables 
.................... typedef struct aflags { 
....................     flash_ctrl flash_addr; 
....................     flash_ctrl flash_log; 
....................     flash_ctrl flash_telemetry; 
.................... } aflags; 
....................  
.................... bflags boot_flags = { 0xFF }; 
.................... oflags obc_flags = { 0, 1, 1, 0, 0, 2, 0xC3F, 0xC48 }; // Update to reference values 
.................... aflags addr_flags = { 0 }; 
....................  
.................... void print_flags() 
.................... { 
....................     fprintf(PC, "leap_seconds = %d\r\n", obc_flags.leap_seconds); 
....................     fprintf(PC, "adcs_on_off = %d\r\n", obc_flags.adcs_on_off); 
....................     fprintf(PC, "pcib_on_off = %d\r\n", obc_flags.pcib_on_off); 
....................     fprintf(PC, "gps_time_sync_state = %d\r\n", obc_flags.gps_time_sync_state); 
....................     fprintf(PC, "adcs_initial_value = %d\r\n", obc_flags.adcs_initial_value); 
....................     fprintf(PC, "cw_mode = %d\r\n", obc_flags.cw_mode); 
....................     fprintf(PC, "heater_ref_temperature = %02lX\r\n", obc_flags.heater_ref_temperature); 
....................     fprintf(PC, "heater_ref_voltage = %02lX\r\n", obc_flags.heater_ref_voltage); 
....................     fprintf(PC, "\r\n"); 
.................... } 
....................  
.................... #define SCHEDULED_COMMANDS_MAX 32 // Requires 1600 bytes = 40 * (36 + 4) 
.................... #define TIME_T_MAX 0x7FFFFFFF 
....................  
.................... // A structure that defines a scheduled command. 
.................... typedef struct scheduled_command { 
....................     time_t time; // Unix time (seconds after Jan 1st 1970) 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } scheduled_command; 
....................  
.................... scheduled_command scheduled_commands[SCHEDULED_COMMANDS_MAX]; 
....................  
.................... #define MAX_LOGS_IN_RAM 64 
....................  
.................... uint8_t memory_busy = false; // True if flash memory is used by COM 
....................  
.................... // A structure that defines a log entry. 
.................... typedef struct log_entry { 
....................     time_t time; 
....................     uint8_t origin; 
....................     uint8_t command; 
....................     uint8_t return_value; 
.................... } log_entry; 
....................  
.................... log_entry log_buffer[MAX_LOGS_IN_RAM]; // Stores logs in RAM before they are flushed to flash 
.................... int log_index = 0;                     // The index of current log in RAM 
....................  
.................... int clock_update = 0; // Periodical flag that indicates that periodic functions should run 
....................  
.................... inline void sync() 
.................... { 
....................     while (!clock_update) { } 
.................... } 
....................  
.................... int uart_mux = 1;              // Used to chose which UART is being listened to 
.................... int response_rx = 0;           // Indicates a response was received 
.................... time_t reset_time = T0;        // Stores the time of last reset 
.................... int rst_clock_update = 0;      // Update local clock with reset pic 
.................... int rst_clock_updated = false; // Becomes true after reset pic clock sync 
.................... int adcs_mode = 12;            // ADCS desired mode (by OBC) 
....................  
.................... // Struct to hold a boot command. 
.................... typedef struct boot_command { 
....................     time_t time; // Time to run the command after boot. 
....................     uint8_t command[BUFF_LENGTH]; 
.................... } boot_command; 
....................  
.................... #define BOOT_COMMANDS_MAX 8 
.................... #define BOOT_COMMANDS_ADDR 0 // Dedicated memory 
....................  
.................... boot_command boot_commands[BOOT_COMMANDS_MAX]; 
....................  
.................... typedef struct xmodem_address { 
....................     uint32_t source_address; 
....................     uint32_t destination_address; 
....................     uint32_t n_packets; 
.................... } xmodem_address; 
....................  
.................... #define STM32_SIZE 32 
.................... uint8_t stm32_command_uhf[STM32_SIZE]; 
....................  
.................... #endif /* DEFINITIONS_H */ 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
....................  
.................... // Adds a log entry to buffer in RAM 
.................... void log_add(log_entry e) 
.................... { 
....................     if (log_index < MAX_LOGS_IN_RAM) { 
*
0C528:  MOVLB  6
0C52A:  MOVF   x80,W
0C52C:  SUBLW  3F
0C52E:  BNC   C57C
....................         memcpy(&log_buffer[log_index], &e, sizeof(log_entry)); 
0C530:  MOVLB  A
0C532:  CLRF   x5B
0C534:  MOVFF  680,A5A
0C538:  CLRF   x5D
0C53A:  MOVLW  07
0C53C:  MOVWF  x5C
0C53E:  MOVLB  0
0C540:  CALL   244C
0C544:  MOVFF  02,03
0C548:  MOVF   01,W
0C54A:  ADDLW  C0
0C54C:  MOVWF  01
0C54E:  MOVLW  04
0C550:  ADDWFC 03,F
0C552:  MOVFF  01,A0C
0C556:  MOVLB  A
0C558:  MOVFF  03,A0D
0C55C:  MOVFF  03,FEA
0C560:  MOVFF  01,FE9
0C564:  MOVLW  0A
0C566:  MOVWF  FE2
0C568:  MOVLW  05
0C56A:  MOVWF  FE1
0C56C:  MOVLW  07
0C56E:  MOVWF  01
0C570:  MOVFF  FE6,FEE
0C574:  DECFSZ 01,F
0C576:  BRA    C570
....................         log_index++; 
0C578:  MOVLB  6
0C57A:  INCF   x80,F
....................     } 
0C57C:  MOVLB  0
0C57E:  GOTO   D15C (RETURN)
.................... } 
....................  
.................... // Clears buffer in RAM 
.................... void log_clear() 
.................... { 
....................     log_index = 0; 
.................... } 
....................  
.................... // Flushes RAM buffer to flash memory 
.................... void log_flush() 
.................... { 
....................     for(uint8_t i=0; i<log_index; i++){ 
*
0AF30:  MOVLB  A
0AF32:  CLRF   x13
0AF34:  MOVLB  6
0AF36:  MOVF   x80,W
0AF38:  MOVLB  A
0AF3A:  SUBWF  x13,W
0AF3C:  BC    AF8C
....................         uint8_t *ptr = (uint8_t*)&log_buffer[i]; 
0AF3E:  CLRF   x5B
0AF40:  MOVFF  A13,A5A
0AF44:  CLRF   x5D
0AF46:  MOVLW  07
0AF48:  MOVWF  x5C
0AF4A:  MOVLB  0
0AF4C:  CALL   244C
0AF50:  MOVFF  02,03
0AF54:  MOVF   01,W
0AF56:  ADDLW  C0
0AF58:  MOVWF  01
0AF5A:  MOVLW  04
0AF5C:  ADDWFC 03,F
0AF5E:  MOVFF  01,A14
0AF62:  MOVLB  A
0AF64:  MOVFF  03,A15
....................         flash_cycle_write(&spi_port_COM_FM, ptr, &addr_flags.flash_log); 
0AF68:  MOVLW  09
0AF6A:  MOVWF  x17
0AF6C:  MOVLW  1B
0AF6E:  MOVWF  x16
0AF70:  MOVFF  A15,A19
0AF74:  MOVFF  A14,A18
0AF78:  MOVLW  01
0AF7A:  MOVWF  x1B
0AF7C:  MOVLW  05
0AF7E:  MOVWF  x1A
0AF80:  MOVLB  0
0AF82:  CALL   3D34
0AF86:  MOVLB  A
0AF88:  INCF   x13,F
0AF8A:  BRA    AF34
....................     } 
....................     fprintf(PC, "Log: 0x%08lX => 0x%08lX", addr_flags.flash_log.current - log_index*sizeof(log_entry), addr_flags.flash_log.current); 
0AF8C:  MOVLB  6
0AF8E:  MOVF   x80,W
0AF90:  MULLW  07
0AF92:  MOVF   FF3,W
0AF94:  MOVLB  1
0AF96:  SUBWF  x0D,W
0AF98:  MOVLB  A
0AF9A:  MOVWF  x16
0AF9C:  MOVLW  00
0AF9E:  MOVLB  1
0AFA0:  SUBWFB x0E,W
0AFA2:  MOVLB  A
0AFA4:  MOVWF  x17
0AFA6:  MOVLW  00
0AFA8:  MOVLB  1
0AFAA:  SUBWFB x0F,W
0AFAC:  MOVLB  A
0AFAE:  MOVWF  x18
0AFB0:  MOVLW  00
0AFB2:  MOVLB  1
0AFB4:  SUBWFB x10,W
0AFB6:  MOVLB  A
0AFB8:  MOVWF  x19
0AFBA:  MOVLW  A0
0AFBC:  MOVWF  FF6
0AFBE:  MOVLW  03
0AFC0:  MOVWF  FF7
0AFC2:  MOVLW  00
0AFC4:  MOVWF  FF8
0AFC6:  MOVLW  07
0AFC8:  MOVWF  x3B
0AFCA:  MOVLB  0
0AFCC:  CALL   3048
0AFD0:  MOVFF  A19,A58
0AFD4:  MOVLW  37
0AFD6:  MOVLB  A
0AFD8:  MOVWF  x59
0AFDA:  MOVLB  0
0AFDC:  CALL   3142
0AFE0:  MOVFF  A18,A58
0AFE4:  MOVLW  37
0AFE6:  MOVLB  A
0AFE8:  MOVWF  x59
0AFEA:  MOVLB  0
0AFEC:  CALL   3142
0AFF0:  MOVFF  A17,A58
0AFF4:  MOVLW  37
0AFF6:  MOVLB  A
0AFF8:  MOVWF  x59
0AFFA:  MOVLB  0
0AFFC:  CALL   3142
0B000:  MOVFF  A16,A58
0B004:  MOVLW  37
0B006:  MOVLB  A
0B008:  MOVWF  x59
0B00A:  MOVLB  0
0B00C:  CALL   3142
0B010:  MOVLW  AC
0B012:  MOVWF  FF6
0B014:  MOVLW  03
0B016:  MOVWF  FF7
0B018:  MOVLW  00
0B01A:  MOVWF  FF8
0B01C:  MOVLW  06
0B01E:  MOVLB  A
0B020:  MOVWF  x3B
0B022:  MOVLB  0
0B024:  CALL   3048
0B028:  MOVFF  110,A58
0B02C:  MOVLW  37
0B02E:  MOVLB  A
0B030:  MOVWF  x59
0B032:  MOVLB  0
0B034:  CALL   3142
0B038:  MOVFF  10F,A58
0B03C:  MOVLW  37
0B03E:  MOVLB  A
0B040:  MOVWF  x59
0B042:  MOVLB  0
0B044:  CALL   3142
0B048:  MOVFF  10E,A58
0B04C:  MOVLW  37
0B04E:  MOVLB  A
0B050:  MOVWF  x59
0B052:  MOVLB  0
0B054:  CALL   3142
0B058:  MOVFF  10D,A58
0B05C:  MOVLW  37
0B05E:  MOVLB  A
0B060:  MOVWF  x59
0B062:  MOVLB  0
0B064:  CALL   3142
....................     log_index = 0; 
0B068:  MOVLB  6
0B06A:  CLRF   x80
0B06C:  MOVLB  0
0B06E:  GOTO   B330 (RETURN)
.................... } 
....................  
.................... #endif /* LOG_CONTROL_H */ 
....................  
.................... #include "boot_command.h" 
.................... #ifndef BOOT_COMMAND_H 
.................... #define BOOT_COMMAND_H 
....................  
.................... #include "definitions.h" 
.................... #include "flash_memory.h" 
.................... #include "flash_memory_fn.h" 
.................... #include "scheduler.h" 
....................  
.................... void boot_commands_write() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_erase_pages(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, BOOT_COMMANDS_ADDR + sizeof(boot_commands)); 
....................     flash_transfer_data_from_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_read() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_transfer_data_to_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_clear_nth(uint8_t n) 
.................... { 
....................     if (n < BOOT_COMMANDS_MAX) 
....................         boot_commands[n].time = TIME_T_MAX; 
.................... } 
....................  
.................... void boot_commands_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         boot_commands_clear_nth(i); 
....................     } 
.................... } 
....................  
.................... uint8_t boot_commands_add(boot_command bc) 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if (boot_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&boot_commands[i], &bc, sizeof(boot_command)); 
....................             return i; 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... void boot_commands_schedule() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if(boot_commands[i].time > 0 && boot_commands[i].time < TIME_T_MAX) 
....................             vschedule(current_time + boot_commands[i].time, boot_commands[i].command); 
....................     } 
.................... } 
....................  
.................... #endif /* BOOT_COMMAND_H */ 
....................  
....................  
.................... // Interpreter: The procedures here are concerned with interpreting 
.................... // received commands and executing the appropriate commands. 
....................  
.................... // Definition of commands. Should follow the prototype: "uint8_t command_name(uint8_t *data)" 
.................... // Return value = 0 indicates that the command was successful 
.................... // Return value > 0 indicates that there was an error 
....................  
.................... // ============ Helper functions ============ 
....................  
.................... void get_com_shared_fm_access() 
.................... { 
....................     if (memory_busy) { 
*
0593C:  MOVLB  4
0593E:  MOVF   xBF,F
05940:  BZ    5958
....................         scheduled_command_clear_specified_command(0xC0, 0x58); // Disable scheduled command to regain access to memory in the future 
05942:  MOVLW  C0
05944:  MOVLB  A
05946:  MOVWF  x55
05948:  MOVLW  58
0594A:  MOVWF  x56
0594C:  MOVLB  0
0594E:  RCALL  5888
....................         output_low(MUX_SEL_COM_SHARED_FM);                     // Regain access to memory now 
05950:  BCF    F94.5
05952:  BCF    F8B.5
....................         memory_busy = 0;                                       // Now memory is free 
05954:  MOVLB  4
05956:  CLRF   xBF
....................     } 
05958:  MOVLB  0
0595A:  RETURN 0
.................... } 
....................  
.................... // Helper function to calculate OBC checksum 
.................... void checksum_obc(uint8_t* data, uint8_t size) 
*
0712A:  MOVLB  A
0712C:  CLRF   x5A
.................... { 
....................     uint8_t checksum = 0; 
....................     for (uint8_t i = 1; i < size - 2; i++) { 
0712E:  MOVLW  01
07130:  MOVWF  x5B
07132:  MOVLW  02
07134:  SUBWF  x59,W
07136:  SUBWF  x5B,W
07138:  BC    714E
....................         checksum ^= data[i]; 
0713A:  MOVF   x5B,W
0713C:  ADDWF  x57,W
0713E:  MOVWF  FE9
07140:  MOVLW  00
07142:  ADDWFC x58,W
07144:  MOVWF  FEA
07146:  MOVF   FEF,W
07148:  XORWF  x5A,F
0714A:  INCF   x5B,F
0714C:  BRA    7132
....................     } 
....................     data[size - 2] = checksum; 
0714E:  MOVLW  02
07150:  SUBWF  x59,W
07152:  ADDWF  x57,W
07154:  MOVWF  FE9
07156:  MOVLW  00
07158:  ADDWFC x58,W
0715A:  MOVWF  FEA
0715C:  MOVFF  A5A,FEF
....................     data[size - 1] = data[0] + 1; // Footer 
07160:  MOVLW  01
07162:  SUBWF  x59,W
07164:  ADDWF  x57,W
07166:  MOVWF  01
07168:  MOVLW  00
0716A:  ADDWFC x58,W
0716C:  MOVWF  03
0716E:  MOVFF  A57,FE9
07172:  MOVFF  A58,FEA
07176:  MOVLW  01
07178:  ADDWF  FEF,W
0717A:  MOVFF  03,FEA
0717E:  MOVFF  01,FE9
07182:  MOVWF  FEF
07184:  MOVLB  0
07186:  RETURN 0
.................... } 
....................  
.................... // Helper function to check if uplink is valid 
.................... uint8_t uplink_valid(uint8_t* buffer) 
*
06D5A:  MOVFF  A28,A2A
06D5E:  MOVFF  A27,A29
.................... { 
....................     const uint8_t cmd_length = 22;        // Extended packet length 
....................     const uint8_t cmd_legacy_length = 14; // Legacy packet length 
....................  
....................     struct packet { 
....................         uint8_t packet_format_id; 
....................         uint8_t satellite_id; 
....................         uint8_t cmd_format_id; 
....................     }* packet = (struct packet*)buffer; 
....................  
....................     uint16_t cr, pk;                                                                 // these are the crc check variables 
....................     if (packet->packet_format_id == 0x42 && packet->satellite_id == SPACECRAFT_ID) { // This packet is meant for CURTIS 
06D62:  MOVLB  A
06D64:  MOVFF  A29,FE9
06D68:  MOVFF  A2A,FEA
06D6C:  MOVF   FEF,W
06D6E:  SUBLW  42
06D70:  BNZ   6E1E
06D72:  MOVLW  01
06D74:  ADDWF  x29,W
06D76:  MOVWF  FE9
06D78:  MOVLW  00
06D7A:  ADDWFC x2A,W
06D7C:  MOVWF  FEA
06D7E:  MOVF   FEF,W
06D80:  SUBLW  55
06D82:  BNZ   6E1E
....................         if (packet->cmd_format_id == 0xCC) {                                         // Extended KITSUNE format (22 bytes) 
06D84:  MOVLW  02
06D86:  ADDWF  x29,W
06D88:  MOVWF  FE9
06D8A:  MOVLW  00
06D8C:  ADDWFC x2A,W
06D8E:  MOVWF  FEA
06D90:  MOVF   FEF,W
06D92:  SUBLW  CC
06D94:  BNZ   6DD2
....................             cr = mk_crc(buffer, cmd_length - 2); 
06D96:  MOVFF  A28,A30
06D9A:  MOVFF  A27,A2F
06D9E:  MOVLW  14
06DA0:  MOVWF  x31
06DA2:  MOVLB  0
06DA4:  RCALL  6C9C
06DA6:  MOVFF  02,A2C
06DAA:  MOVFF  01,A2B
....................             pk = make16(buffer[cmd_length - 1], buffer[cmd_length - 2]); 
06DAE:  MOVLW  15
06DB0:  MOVLB  A
06DB2:  ADDWF  x27,W
06DB4:  MOVWF  FE9
06DB6:  MOVLW  00
06DB8:  ADDWFC x28,W
06DBA:  MOVWF  FEA
06DBC:  MOVFF  FEF,A2E
06DC0:  MOVLW  14
06DC2:  ADDWF  x27,W
06DC4:  MOVWF  FE9
06DC6:  MOVLW  00
06DC8:  ADDWFC x28,W
06DCA:  MOVWF  FEA
06DCC:  MOVFF  FEF,A2D
....................         } else { // Herritage BIRDS format (14 bytes) 
06DD0:  BRA    6E0C
....................             cr = mk_crc(buffer, cmd_legacy_length - 2); 
06DD2:  MOVFF  A28,A30
06DD6:  MOVFF  A27,A2F
06DDA:  MOVLW  0C
06DDC:  MOVWF  x31
06DDE:  MOVLB  0
06DE0:  RCALL  6C9C
06DE2:  MOVFF  02,A2C
06DE6:  MOVFF  01,A2B
....................             pk = make16(buffer[cmd_legacy_length - 1], buffer[cmd_legacy_length - 2]); 
06DEA:  MOVLW  0D
06DEC:  MOVLB  A
06DEE:  ADDWF  x27,W
06DF0:  MOVWF  FE9
06DF2:  MOVLW  00
06DF4:  ADDWFC x28,W
06DF6:  MOVWF  FEA
06DF8:  MOVFF  FEF,A2E
06DFC:  MOVLW  0C
06DFE:  ADDWF  x27,W
06E00:  MOVWF  FE9
06E02:  MOVLW  00
06E04:  ADDWFC x28,W
06E06:  MOVWF  FEA
06E08:  MOVFF  FEF,A2D
....................         } 
....................         if (cr == pk) { // CRC is good to go 
06E0C:  MOVF   x2D,W
06E0E:  SUBWF  x2B,W
06E10:  BNZ   6E1E
06E12:  MOVF   x2E,W
06E14:  SUBWF  x2C,W
06E16:  BNZ   6E1E
....................             return 1;   // Packet is valid 
06E18:  MOVLW  01
06E1A:  MOVWF  01
06E1C:  BRA    6E22
....................         } 
....................     } 
....................     return 0; // Packet is invalid 
06E1E:  MOVLW  00
06E20:  MOVWF  01
06E22:  MOVLB  0
06E24:  GOTO   6F08 (RETURN)
.................... } 
....................  
.................... // Helper function to send an acknowledge back to COM 
.................... void send_com_ack(uint8_t* data) 
.................... { 
....................     uint8_t cmd[24] = { 0 }; 
*
04C36:  MOVLB  A
04C38:  CLRF   x1D
04C3A:  CLRF   x1E
04C3C:  CLRF   x1F
04C3E:  CLRF   x20
04C40:  CLRF   x21
04C42:  CLRF   x22
04C44:  CLRF   x23
04C46:  CLRF   x24
04C48:  CLRF   x25
04C4A:  CLRF   x26
04C4C:  CLRF   x27
04C4E:  CLRF   x28
04C50:  CLRF   x29
04C52:  CLRF   x2A
04C54:  CLRF   x2B
04C56:  CLRF   x2C
04C58:  CLRF   x2D
04C5A:  CLRF   x2E
04C5C:  CLRF   x2F
04C5E:  CLRF   x30
04C60:  CLRF   x31
04C62:  CLRF   x32
04C64:  CLRF   x33
04C66:  CLRF   x34
....................     cmd[0] = 0x0B; 
04C68:  MOVLW  0B
04C6A:  MOVWF  x1D
....................     cmd[1] = 0xAA; 
04C6C:  MOVLW  AA
04C6E:  MOVWF  x1E
....................     cmd[2] = 0xCC; 
04C70:  MOVLW  CC
04C72:  MOVWF  x1F
....................     memcpy(cmd + 3, data, 8); 
04C74:  MOVLW  0A
04C76:  MOVWF  FEA
04C78:  MOVLW  20
04C7A:  MOVWF  FE9
04C7C:  MOVFF  A1C,FE2
04C80:  MOVFF  A1B,FE1
04C84:  MOVLW  08
04C86:  MOVWF  01
04C88:  MOVFF  FE6,FEE
04C8C:  DECFSZ 01,F
04C8E:  BRA    4C88
....................     cmd[12] = 0x66; 
04C90:  MOVLW  66
04C92:  MOVWF  x29
....................     cmd[23] = 0x0C; 
04C94:  MOVLW  0C
04C96:  MOVWF  x34
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
04C98:  CLRF   x35
04C9A:  MOVF   x35,W
04C9C:  SUBLW  17
04C9E:  BNC   4CC0
....................         fputc(cmd[i], COMM); 
04CA0:  CLRF   03
04CA2:  MOVF   x35,W
04CA4:  ADDLW  1D
04CA6:  MOVWF  FE9
04CA8:  MOVLW  0A
04CAA:  ADDWFC 03,W
04CAC:  MOVWF  FEA
04CAE:  MOVFF  FEF,A36
04CB2:  MOVF   x36,W
04CB4:  MOVLB  0
04CB6:  CALL   2A0A
04CBA:  MOVLB  A
04CBC:  INCF   x35,F
04CBE:  BRA    4C9A
....................     } 
04CC0:  MOVLB  0
04CC2:  RETURN 0
.................... } 
....................  
.................... // Helper function to change reset time 
.................... void reset_pic_update_clock(time_t time) 
*
0506E:  MOVLW  0A
05070:  MOVLB  A
05072:  MOVWF  x4D
05074:  MOVLW  18
05076:  MOVWF  x4C
05078:  MOVLB  0
0507A:  CALL   246E
0507E:  MOVFF  02,A1D
05082:  MOVFF  01,A1C
.................... { 
....................     struct_tm* tstr = localtime(&time); 
....................     struct rst_msg { 
....................         uint8_t rst_command; 
....................         uint8_t year; 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................     } msg; 
....................  
....................     msg.rst_command = 0x70; 
05086:  MOVLW  70
05088:  MOVLB  A
0508A:  MOVWF  x1E
....................     msg.year = tstr->tm_year - 100; 
0508C:  MOVLW  05
0508E:  ADDWF  x1C,W
05090:  MOVWF  FE9
05092:  MOVLW  00
05094:  ADDWFC x1D,W
05096:  MOVWF  FEA
05098:  MOVFF  FEC,A4D
0509C:  MOVF   FED,F
0509E:  MOVFF  FEF,A4C
050A2:  MOVLW  64
050A4:  SUBWF  x4C,W
050A6:  MOVWF  x1F
....................     msg.month = tstr->tm_mon + 1; 
050A8:  MOVLW  04
050AA:  ADDWF  x1C,W
050AC:  MOVWF  FE9
050AE:  MOVLW  00
050B0:  ADDWFC x1D,W
050B2:  MOVWF  FEA
050B4:  MOVLW  01
050B6:  ADDWF  FEF,W
050B8:  MOVWF  x20
....................     msg.day = tstr->tm_mday; 
050BA:  MOVLW  03
050BC:  ADDWF  x1C,W
050BE:  MOVWF  FE9
050C0:  MOVLW  00
050C2:  ADDWFC x1D,W
050C4:  MOVWF  FEA
050C6:  MOVFF  FEF,A21
....................     msg.hour = tstr->tm_hour; 
050CA:  MOVLW  02
050CC:  ADDWF  x1C,W
050CE:  MOVWF  FE9
050D0:  MOVLW  00
050D2:  ADDWFC x1D,W
050D4:  MOVWF  FEA
050D6:  MOVFF  FEF,A22
....................     msg.minute = tstr->tm_min; 
050DA:  MOVLW  01
050DC:  ADDWF  x1C,W
050DE:  MOVWF  FE9
050E0:  MOVLW  00
050E2:  ADDWFC x1D,W
050E4:  MOVWF  FEA
050E6:  MOVFF  FEF,A23
....................     msg.second = tstr->tm_sec; 
050EA:  MOVFF  A1C,FE9
050EE:  MOVFF  A1D,FEA
050F2:  MOVFF  FEF,A24
....................  
....................     uint8_t i; 
....................     uint8_t cmd[36] = { 0 }; 
050F6:  CLRF   x26
050F8:  CLRF   x27
050FA:  CLRF   x28
050FC:  CLRF   x29
050FE:  CLRF   x2A
05100:  CLRF   x2B
05102:  CLRF   x2C
05104:  CLRF   x2D
05106:  CLRF   x2E
05108:  CLRF   x2F
0510A:  CLRF   x30
0510C:  CLRF   x31
0510E:  CLRF   x32
05110:  CLRF   x33
05112:  CLRF   x34
05114:  CLRF   x35
05116:  CLRF   x36
05118:  CLRF   x37
0511A:  CLRF   x38
0511C:  CLRF   x39
0511E:  CLRF   x3A
05120:  CLRF   x3B
05122:  CLRF   x3C
05124:  CLRF   x3D
05126:  CLRF   x3E
05128:  CLRF   x3F
0512A:  CLRF   x40
0512C:  CLRF   x41
0512E:  CLRF   x42
05130:  CLRF   x43
05132:  CLRF   x44
05134:  CLRF   x45
05136:  CLRF   x46
05138:  CLRF   x47
0513A:  CLRF   x48
0513C:  CLRF   x49
....................     cmd[0] = 0xB0; 
0513E:  MOVLW  B0
05140:  MOVWF  x26
....................     uint8_t* ptr = (uint8_t*)&msg; 
05142:  MOVLW  0A
05144:  MOVWF  x4D
05146:  MOVLW  1E
05148:  MOVFF  A4D,A4B
0514C:  MOVWF  x4A
....................     for (i = 0; i < sizeof(msg); i++) { 
0514E:  CLRF   x25
05150:  MOVF   x25,W
05152:  SUBLW  06
05154:  BNC   5184
....................         cmd[i + 1] = ptr[i]; 
05156:  MOVLW  01
05158:  ADDWF  x25,W
0515A:  CLRF   03
0515C:  ADDLW  26
0515E:  MOVWF  01
05160:  MOVLW  0A
05162:  ADDWFC 03,F
05164:  MOVF   x25,W
05166:  ADDWF  x4A,W
05168:  MOVWF  FE9
0516A:  MOVLW  00
0516C:  ADDWFC x4B,W
0516E:  MOVWF  FEA
05170:  MOVFF  FEF,A4E
05174:  MOVFF  03,FEA
05178:  MOVFF  01,FE9
0517C:  MOVFF  A4E,FEF
05180:  INCF   x25,F
05182:  BRA    5150
....................     } 
....................     cmd[35] = 0xB1; 
05184:  MOVLW  B1
05186:  MOVWF  x49
....................     for (i = 0; i < sizeof(cmd); i++) { 
05188:  CLRF   x25
0518A:  MOVF   x25,W
0518C:  SUBLW  23
0518E:  BNC   51B0
....................         fputc(cmd[i], RST); 
05190:  CLRF   03
05192:  MOVF   x25,W
05194:  ADDLW  26
05196:  MOVWF  FE9
05198:  MOVLW  0A
0519A:  ADDWFC 03,W
0519C:  MOVWF  FEA
0519E:  MOVFF  FEF,A4C
051A2:  MOVF   x4C,W
051A4:  MOVLB  0
051A6:  CALL   2A84
051AA:  MOVLB  A
051AC:  INCF   x25,F
051AE:  BRA    518A
....................     } 
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
051B0:  MOVLW  0A
051B2:  MOVWF  x54
051B4:  MOVLW  26
051B6:  MOVWF  x53
051B8:  MOVLW  24
051BA:  MOVWF  x55
051BC:  MOVLB  0
051BE:  RCALL  4EF0
051C0:  RETURN 0
.................... } 
....................  
.................... // Helper function to print binary data 
.................... void print_binary16(uint16_t data) 
.................... { 
....................     const uint8_t size = 16; 
....................     for (uint8_t i = 1; i <= size; i++) { 
*
0A3FC:  MOVLW  01
0A3FE:  MOVLB  A
0A400:  MOVWF  x0A
0A402:  MOVF   x0A,W
0A404:  SUBLW  10
0A406:  BNC   A444
....................         fprintf(PC, "%Lu", ((data >> (size - i)) & 1)); 
0A408:  MOVLW  10
0A40A:  BSF    FD8.0
0A40C:  SUBFWB x0A,W
0A40E:  MOVWF  00
0A410:  MOVFF  A09,A0C
0A414:  MOVFF  A08,A0B
0A418:  MOVF   00,F
0A41A:  BZ    A426
0A41C:  BCF    FD8.0
0A41E:  RRCF   x0C,F
0A420:  RRCF   x0B,F
0A422:  DECFSZ 00,F
0A424:  BRA    A41C
0A426:  MOVLW  01
0A428:  ANDWF  x0B,F
0A42A:  CLRF   x0C
0A42C:  MOVLW  10
0A42E:  MOVWF  FE9
0A430:  MOVFF  A0C,A3C
0A434:  MOVFF  A0B,A3B
0A438:  MOVLB  0
0A43A:  CALL   307A
0A43E:  MOVLB  A
0A440:  INCF   x0A,F
0A442:  BRA    A402
....................     } 
....................     fputc('\r', PC); 
0A444:  MOVLW  0D
0A446:  MOVLB  B
0A448:  MOVWF  x1F
0A44A:  MOVLB  0
0A44C:  CALL   1C34
....................     fputc('\n', PC); 
0A450:  MOVLW  0A
0A452:  MOVLB  B
0A454:  MOVWF  x1F
0A456:  MOVLB  0
0A458:  CALL   1C34
0A45C:  RETURN 0
.................... } 
....................  
.................... // Helper funtion to initialize the telemetry array. 
.................... void initialize_telemetry() 
.................... { 
....................     memset(&telemetry_time, 0, sizeof(telemetry_time)); 
*
02982:  CLRF   FEA
02984:  MOVLW  CD
02986:  MOVWF  FE9
02988:  CLRF   00
0298A:  CLRF   02
0298C:  MOVLW  14
0298E:  MOVWF  01
02990:  RCALL  2968
....................     memset(&telemetry, 0, sizeof(telemetry)); 
02992:  CLRF   FEA
02994:  MOVLW  41
02996:  MOVWF  FE9
02998:  CLRF   00
0299A:  CLRF   02
0299C:  MOVLW  8C
0299E:  MOVWF  01
029A0:  RCALL  2968
....................     telemetry.master_footer[0] = 0xB0; 
029A2:  MOVLW  B0
029A4:  MOVWF  xCB
....................     telemetry.master_footer[1] = 0x0B; 
029A6:  MOVLW  0B
029A8:  MOVWF  xCC
029AA:  RETURN 0
.................... } 
....................  
.................... // Convert gyro data 16 -> 8 bits (-128 to 127 with LSB = 1deg/s, with overflow protection) 
.................... int8_t gyro_to_cw(uint8_t msb, uint8_t lsb) 
*
09E5E:  MOVFF  A1A,A22
09E62:  MOVFF  A1B,A21
09E66:  MOVFF  A1A,A24
09E6A:  MOVFF  A1B,A23
09E6E:  BRA    9D56
09E70:  MOVFF  03,A34
09E74:  MOVFF  02,A33
09E78:  MOVFF  01,A32
09E7C:  MOVFF  00,A31
09E80:  MOVLW  29
09E82:  MOVLB  A
09E84:  MOVWF  x38
09E86:  MOVLW  5C
09E88:  MOVWF  x37
09E8A:  MOVLW  0F
09E8C:  MOVWF  x36
09E8E:  MOVLW  78
09E90:  MOVWF  x35
09E92:  MOVLB  0
09E94:  CALL   83EC
09E98:  MOVFF  03,A20
09E9C:  MOVFF  02,A1F
09EA0:  MOVFF  01,A1E
09EA4:  MOVFF  00,A1D
.................... { 
....................     int8_t gyro_cw; 
....................     float gyro = ((int16_t)make16(msb, lsb)) * 8.75e-3; 
....................     if (gyro > 127.) { 
09EA8:  MOVLB  A
09EAA:  CLRF   x24
09EAC:  CLRF   x23
09EAE:  MOVLW  7E
09EB0:  MOVWF  x22
09EB2:  MOVLW  85
09EB4:  MOVWF  x21
09EB6:  MOVFF  A20,A28
09EBA:  MOVFF  A1F,A27
09EBE:  MOVFF  A1E,A26
09EC2:  MOVFF  A1D,A25
09EC6:  MOVLB  0
09EC8:  RCALL  9DA8
09ECA:  BNC   9ED4
....................         gyro_cw = 127; 
09ECC:  MOVLW  7F
09ECE:  MOVLB  A
09ED0:  MOVWF  x1C
....................     } else if (gyro < -128.) { 
09ED2:  BRA    9F9A
09ED4:  MOVFF  A20,A24
09ED8:  MOVFF  A1F,A23
09EDC:  MOVFF  A1E,A22
09EE0:  MOVFF  A1D,A21
09EE4:  MOVLB  A
09EE6:  CLRF   x28
09EE8:  CLRF   x27
09EEA:  MOVLW  80
09EEC:  MOVWF  x26
09EEE:  MOVLW  86
09EF0:  MOVWF  x25
09EF2:  MOVLB  0
09EF4:  RCALL  9DA8
09EF6:  BNC   9F02
....................         gyro_cw = -128; 
09EF8:  MOVLW  80
09EFA:  MOVLB  A
09EFC:  MOVWF  x1C
....................     } else { 
09EFE:  BRA    9F9A
09F00:  MOVLB  0
....................         if (gyro > 0.) { 
09F02:  MOVLB  A
09F04:  CLRF   x24
09F06:  CLRF   x23
09F08:  CLRF   x22
09F0A:  CLRF   x21
09F0C:  MOVFF  A20,A28
09F10:  MOVFF  A1F,A27
09F14:  MOVFF  A1E,A26
09F18:  MOVFF  A1D,A25
09F1C:  MOVLB  0
09F1E:  RCALL  9DA8
09F20:  BNC   9F5E
....................             gyro_cw = (int8_t)(gyro + 0.5); 
09F22:  BCF    FD8.1
09F24:  MOVFF  A20,A33
09F28:  MOVFF  A1F,A32
09F2C:  MOVFF  A1E,A31
09F30:  MOVFF  A1D,A30
09F34:  MOVLB  A
09F36:  CLRF   x37
09F38:  CLRF   x36
09F3A:  CLRF   x35
09F3C:  MOVLW  7E
09F3E:  MOVWF  x34
09F40:  MOVLB  0
09F42:  CALL   84E2
09F46:  MOVFF  03,A24
09F4A:  MOVFF  02,A23
09F4E:  MOVFF  01,A22
09F52:  MOVFF  00,A21
09F56:  RCALL  9E22
09F58:  MOVFF  01,A1C
....................         } else { 
09F5C:  BRA    9F98
....................             gyro_cw = (int8_t)(gyro - 0.5); 
09F5E:  BSF    FD8.1
09F60:  MOVFF  A20,A33
09F64:  MOVFF  A1F,A32
09F68:  MOVFF  A1E,A31
09F6C:  MOVFF  A1D,A30
09F70:  MOVLB  A
09F72:  CLRF   x37
09F74:  CLRF   x36
09F76:  CLRF   x35
09F78:  MOVLW  7E
09F7A:  MOVWF  x34
09F7C:  MOVLB  0
09F7E:  CALL   84E2
09F82:  MOVFF  03,A24
09F86:  MOVFF  02,A23
09F8A:  MOVFF  01,A22
09F8E:  MOVFF  00,A21
09F92:  RCALL  9E22
09F94:  MOVFF  01,A1C
09F98:  MOVLB  A
....................         } 
....................     } 
....................     return gyro_cw; 
09F9A:  MOVFF  A1C,01
09F9E:  MOVLB  0
09FA0:  RETURN 0
.................... } 
....................  
.................... // Helper funtion to initialize the cw beacon array. 
.................... void build_cw() 
*
0AB06:  CALL   4CC4
0AB0A:  MOVFF  01,A13
0AB0E:  MOVFF  9D,A14
0AB12:  MOVLB  6
0AB14:  MOVF   x84,W
0AB16:  SUBWF  39,W
0AB18:  MOVLB  A
0AB1A:  MOVWF  x1A
0AB1C:  MOVLB  6
0AB1E:  MOVF   x85,W
0AB20:  SUBWFB 3A,W
0AB22:  MOVLB  A
0AB24:  MOVWF  x1B
0AB26:  MOVLB  6
0AB28:  MOVF   x86,W
0AB2A:  SUBWFB 3B,W
0AB2C:  MOVLB  A
0AB2E:  MOVWF  x1C
0AB30:  MOVLB  6
0AB32:  MOVF   x87,W
0AB34:  SUBWFB 3C,W
0AB36:  MOVLB  A
0AB38:  MOVWF  x1D
0AB3A:  MOVFF  FEA,A1F
0AB3E:  MOVFF  FE9,A1E
0AB42:  BCF    FD8.1
0AB44:  MOVWF  x5E
0AB46:  MOVFF  A1C,A5D
0AB4A:  MOVFF  A1B,A5C
0AB4E:  MOVFF  A1A,A5B
0AB52:  CLRF   x62
0AB54:  CLRF   x61
0AB56:  MOVLW  0E
0AB58:  MOVWF  x60
0AB5A:  MOVLW  10
0AB5C:  MOVWF  x5F
0AB5E:  MOVLB  0
0AB60:  CALL   1E6C
0AB64:  MOVFF  A1F,FEA
0AB68:  MOVFF  A1E,FE9
0AB6C:  MOVFF  03,A18
0AB70:  MOVFF  02,A17
0AB74:  MOVFF  01,A16
0AB78:  MOVFF  00,A15
0AB7C:  MOVLB  A
0AB7E:  BTFSC  x18.7
0AB80:  BRA    AB98
0AB82:  MOVF   x18,F
0AB84:  BNZ   AB94
0AB86:  MOVF   x17,F
0AB88:  BNZ   AB94
0AB8A:  MOVF   x16,F
0AB8C:  BNZ   AB94
0AB8E:  MOVF   x15,W
0AB90:  SUBLW  18
0AB92:  BC    AB98
0AB94:  MOVLW  1F
0AB96:  BRA    AB9A
0AB98:  MOVF   x15,W
0AB9A:  MOVWF  x19
.................... { 
....................     uint8_t sc = scheduled_command_count(); 
....................     uint8_t adcs_mode = telemetry.adcs_message[0]; 
....................     time_t time_after_reset = (current_time - reset_time) / 3600; 
....................     uint8_t time_after_reset_ = time_after_reset > 24 ? 0x1F : time_after_reset; 
....................  
....................     memset(&cw, 0, sizeof(cw)); // Erase old data. 
0AB9C:  CLRF   FEA
0AB9E:  MOVLW  E1
0ABA0:  MOVWF  FE9
0ABA2:  CLRF   00
0ABA4:  CLRF   02
0ABA6:  MOVLW  0C
0ABA8:  MOVWF  01
0ABAA:  MOVLB  0
0ABAC:  CALL   2968
....................  
....................     // Page 0 
....................     cw[0][0] = (telemetry.reset_message[6] << 4) | (telemetry.reset_message[7] >> 4);      // Battery voltage 
0ABB0:  SWAPF  48,W
0ABB2:  MOVLB  A
0ABB4:  MOVWF  x1A
0ABB6:  MOVLW  F0
0ABB8:  ANDWF  x1A,F
0ABBA:  SWAPF  49,W
0ABBC:  MOVWF  00
0ABBE:  MOVLW  0F
0ABC0:  ANDWF  00,F
0ABC2:  MOVF   00,W
0ABC4:  IORWF  x1A,W
0ABC6:  MOVLB  0
0ABC8:  MOVWF  xE1
....................     cw[0][1] = (telemetry.fab_message[48] << 4) | (telemetry.fab_message[49] >> 4);        // Battery current, 12 -> 8 bit 
0ABCA:  SWAPF  x8B,W
0ABCC:  MOVLB  A
0ABCE:  MOVWF  x1A
0ABD0:  MOVLW  F0
0ABD2:  ANDWF  x1A,F
0ABD4:  MOVLB  0
0ABD6:  SWAPF  x8C,W
0ABD8:  MOVWF  00
0ABDA:  MOVLW  0F
0ABDC:  ANDWF  00,F
0ABDE:  MOVF   00,W
0ABE0:  MOVLB  A
0ABE2:  IORWF  x1A,W
0ABE4:  MOVLB  0
0ABE6:  MOVWF  xE2
....................     cw[0][2] = (telemetry.fab_message[50] << 4) | (telemetry.fab_message[51] >> 4);        // Battery temperature, 12 -> 8 bit 
0ABE8:  SWAPF  x8D,W
0ABEA:  MOVLB  A
0ABEC:  MOVWF  x1A
0ABEE:  MOVLW  F0
0ABF0:  ANDWF  x1A,F
0ABF2:  MOVLB  0
0ABF4:  SWAPF  x8E,W
0ABF6:  MOVWF  00
0ABF8:  MOVLW  0F
0ABFA:  ANDWF  00,F
0ABFC:  MOVF   00,W
0ABFE:  MOVLB  A
0AC00:  IORWF  x1A,W
0AC02:  MOVLB  0
0AC04:  MOVWF  xE3
....................     cw[0][3] = (telemetry.fab_message[10] << 4) | (telemetry.fab_message[11] >> 4);        // CPLD temperature 
0AC06:  SWAPF  x65,W
0AC08:  MOVLB  A
0AC0A:  MOVWF  x1A
0AC0C:  MOVLW  F0
0AC0E:  ANDWF  x1A,F
0AC10:  MOVLB  0
0AC12:  SWAPF  x66,W
0AC14:  MOVWF  00
0AC16:  MOVLW  0F
0AC18:  ANDWF  00,F
0AC1A:  MOVF   00,W
0AC1C:  MOVLB  A
0AC1E:  IORWF  x1A,W
0AC20:  MOVLB  0
0AC22:  MOVWF  xE4
....................     cw[0][4] = (make16(telemetry.fab_message[28], telemetry.fab_message[29]) > 0x229) << 7 // +X sun / no sun 
....................         | (make16(telemetry.fab_message[30], telemetry.fab_message[31]) > 0x223) << 6      // -X sun / no sun 
....................         | (make16(telemetry.fab_message[26], telemetry.fab_message[27]) > 0x2E8) << 5      // +Y sun / no sun 
....................         | (make16(telemetry.fab_message[32], telemetry.fab_message[33]) > 0x03E) << 4      // -Y sun / no sun 
....................         | (make16(telemetry.fab_message[36], telemetry.fab_message[37]) > 0x081) << 3      // +Z sun / no sun 
....................         | (make16(telemetry.fab_message[34], telemetry.fab_message[35]) > 0x065) << 2      // -Z sun / no sun 
....................         | (boot_flags.deployment_flag >= 5) << 1                                           // OBC mode 
....................         | ((time_after_reset_ >> 4) & 0x1);                                                // Time after reset bit 5 
0AC24:  MOVFF  77,A1B
0AC28:  MOVFF  78,A1A
0AC2C:  MOVLB  A
0AC2E:  MOVF   x1B,W
0AC30:  SUBLW  01
0AC32:  BC    AC3E
0AC34:  XORLW  FF
0AC36:  BNZ   AC42
0AC38:  MOVF   x1A,W
0AC3A:  SUBLW  29
0AC3C:  BNC   AC42
0AC3E:  MOVLW  00
0AC40:  BRA    AC44
0AC42:  MOVLW  01
0AC44:  MOVWF  00
0AC46:  CLRF   x1A
0AC48:  BTFSC  FE8.0
0AC4A:  BSF    x1A.7
0AC4C:  MOVFF  79,A1C
0AC50:  MOVFF  7A,A1B
0AC54:  MOVF   x1C,W
0AC56:  SUBLW  01
0AC58:  BC    AC64
0AC5A:  XORLW  FF
0AC5C:  BNZ   AC68
0AC5E:  MOVF   x1B,W
0AC60:  SUBLW  23
0AC62:  BNC   AC68
0AC64:  MOVLW  00
0AC66:  BRA    AC6A
0AC68:  MOVLW  01
0AC6A:  MOVWF  00
0AC6C:  SWAPF  00,F
0AC6E:  RLCF   00,F
0AC70:  RLCF   00,F
0AC72:  MOVLW  C0
0AC74:  ANDWF  00,F
0AC76:  MOVF   00,W
0AC78:  IORWF  x1A,F
0AC7A:  MOVFF  75,A1C
0AC7E:  MOVFF  76,A1B
0AC82:  MOVF   x1C,W
0AC84:  SUBLW  01
0AC86:  BC    AC92
0AC88:  XORLW  FF
0AC8A:  BNZ   AC96
0AC8C:  MOVF   x1B,W
0AC8E:  SUBLW  E8
0AC90:  BNC   AC96
0AC92:  MOVLW  00
0AC94:  BRA    AC98
0AC96:  MOVLW  01
0AC98:  MOVWF  00
0AC9A:  SWAPF  00,F
0AC9C:  RLCF   00,F
0AC9E:  MOVLW  E0
0ACA0:  ANDWF  00,F
0ACA2:  MOVF   00,W
0ACA4:  IORWF  x1A,F
0ACA6:  MOVFF  7B,A1C
0ACAA:  MOVFF  7C,A1B
0ACAE:  MOVF   x1C,F
0ACB0:  BNZ   ACBC
0ACB2:  MOVF   x1B,W
0ACB4:  SUBLW  3E
0ACB6:  BNC   ACBC
0ACB8:  MOVLW  00
0ACBA:  BRA    ACBE
0ACBC:  MOVLW  01
0ACBE:  MOVWF  00
0ACC0:  SWAPF  00,F
0ACC2:  MOVLW  F0
0ACC4:  ANDWF  00,F
0ACC6:  MOVF   00,W
0ACC8:  IORWF  x1A,F
0ACCA:  MOVFF  7F,A1C
0ACCE:  MOVFF  80,A1B
0ACD2:  MOVF   x1C,F
0ACD4:  BNZ   ACE0
0ACD6:  MOVF   x1B,W
0ACD8:  SUBLW  81
0ACDA:  BNC   ACE0
0ACDC:  MOVLW  00
0ACDE:  BRA    ACE2
0ACE0:  MOVLW  01
0ACE2:  MOVWF  00
0ACE4:  RLCF   00,F
0ACE6:  RLCF   00,F
0ACE8:  RLCF   00,F
0ACEA:  MOVLW  F8
0ACEC:  ANDWF  00,F
0ACEE:  MOVF   00,W
0ACF0:  IORWF  x1A,F
0ACF2:  MOVFF  7D,A1C
0ACF6:  MOVFF  7E,A1B
0ACFA:  MOVF   x1C,F
0ACFC:  BNZ   AD08
0ACFE:  MOVF   x1B,W
0AD00:  SUBLW  65
0AD02:  BNC   AD08
0AD04:  MOVLW  00
0AD06:  BRA    AD0A
0AD08:  MOVLW  01
0AD0A:  MOVWF  00
0AD0C:  RLCF   00,F
0AD0E:  RLCF   00,F
0AD10:  MOVLW  FC
0AD12:  ANDWF  00,F
0AD14:  MOVF   00,W
0AD16:  IORWF  x1A,F
0AD18:  MOVLB  0
0AD1A:  MOVF   xED,W
0AD1C:  SUBLW  04
0AD1E:  BNC   AD24
0AD20:  MOVLW  00
0AD22:  BRA    AD26
0AD24:  MOVLW  01
0AD26:  MOVWF  00
0AD28:  BCF    FD8.0
0AD2A:  RLCF   00,F
0AD2C:  MOVF   00,W
0AD2E:  MOVLB  A
0AD30:  IORWF  x1A,F
0AD32:  SWAPF  x19,W
0AD34:  MOVWF  00
0AD36:  MOVLW  0F
0AD38:  ANDWF  00,F
0AD3A:  MOVF   00,W
0AD3C:  ANDLW  01
0AD3E:  IORWF  x1A,W
0AD40:  MOVLB  0
0AD42:  MOVWF  xE5
....................     cw[0][5] = (time_after_reset_ & 0x0F) << 4                                             // Time after reset bits 0-4 
....................         | (telemetry.fab_message[52] & 0x1) << 3                                           // Battery heater on/off 
....................         | (telemetry.fab_message[53] & 0x1) << 2                                           // Kill switch Main PIC 
....................         | ((telemetry.fab_message[53] & 0x10) >> 4) << 1                                   // Kill switch EPS PIC 
....................         | 0x0;                                                                             // Format identifier 
0AD44:  MOVLB  A
0AD46:  MOVF   x19,W
0AD48:  ANDLW  0F
0AD4A:  MOVWF  00
0AD4C:  SWAPF  00,W
0AD4E:  MOVWF  x1A
0AD50:  MOVLW  F0
0AD52:  ANDWF  x1A,F
0AD54:  MOVLB  0
0AD56:  MOVF   x8F,W
0AD58:  ANDLW  01
0AD5A:  MOVWF  00
0AD5C:  RLCF   00,F
0AD5E:  RLCF   00,F
0AD60:  RLCF   00,F
0AD62:  MOVLW  F8
0AD64:  ANDWF  00,F
0AD66:  MOVF   00,W
0AD68:  MOVLB  A
0AD6A:  IORWF  x1A,F
0AD6C:  MOVLB  0
0AD6E:  MOVF   x90,W
0AD70:  ANDLW  01
0AD72:  MOVWF  00
0AD74:  RLCF   00,F
0AD76:  RLCF   00,F
0AD78:  MOVLW  FC
0AD7A:  ANDWF  00,F
0AD7C:  MOVF   00,W
0AD7E:  MOVLB  A
0AD80:  IORWF  x1A,F
0AD82:  MOVLB  0
0AD84:  MOVF   x90,W
0AD86:  ANDLW  10
0AD88:  MOVWF  00
0AD8A:  SWAPF  00,F
0AD8C:  MOVLW  0F
0AD8E:  ANDWF  00,F
0AD90:  MOVF   00,W
0AD92:  BCF    FD8.0
0AD94:  RLCF   00,F
0AD96:  MOVF   00,W
0AD98:  MOVLB  A
0AD9A:  IORWF  x1A,W
0AD9C:  MOVLB  0
0AD9E:  MOVWF  xE6
....................  
....................     // Page 1 
....................     cw[1][0] = gyro_to_cw(telemetry.adcs_message[1], telemetry.adcs_message[2]); // Gyro X axis (deg/s), 16 -> 8 bits (-128 to 127 with LSB = 1deg/s) 
0ADA0:  MOVFF  9E,A1A
0ADA4:  MOVFF  9F,A1B
0ADA8:  CALL   9E5E
0ADAC:  MOVFF  01,E7
....................     cw[1][1] = gyro_to_cw(telemetry.adcs_message[3], telemetry.adcs_message[4]); // Gyro Y axis (deg/s), 16 -> 8 bits (-128 to 127 with LSB = 1deg/s) 
0ADB0:  MOVFF  A0,A1A
0ADB4:  MOVFF  A1,A1B
0ADB8:  CALL   9E5E
0ADBC:  MOVFF  01,E8
....................     cw[1][2] = gyro_to_cw(telemetry.adcs_message[5], telemetry.adcs_message[6]); // Gyro Z axis (deg/s), 16 -> 8 bits (-128 to 127 with LSB = 1deg/s) 
0ADC0:  MOVFF  A2,A1A
0ADC4:  MOVFF  A3,A1B
0ADC8:  CALL   9E5E
0ADCC:  MOVFF  01,E9
....................     cw[1][3] = ((telemetry.adcs_message[37] >> 2) & 0x1) << 7                    // Magnetometer X axis sign bit 
....................         | ((telemetry.adcs_message[37] >> 1) & 0x1) << 6                         // Magnetometer Y axis sign bit 
....................         | (telemetry.adcs_message[37] & 0x1) << 5                                // Magnetometer Z axis sign bit 
....................         | (adcs_mode < 8 ? adcs_mode : 7) << 2                                   // ADCS mode 
....................         | ((sc < 4 ? sc : 3) & 0x03);                                            // No. of scheduled commands 
0ADD0:  RRCF   xC2,W
0ADD2:  MOVWF  00
0ADD4:  RRCF   00,F
0ADD6:  MOVLW  3F
0ADD8:  ANDWF  00,F
0ADDA:  MOVF   00,W
0ADDC:  ANDLW  01
0ADDE:  MOVWF  00
0ADE0:  MOVLB  A
0ADE2:  CLRF   x1A
0ADE4:  BTFSC  FE8.0
0ADE6:  BSF    x1A.7
0ADE8:  BCF    FD8.0
0ADEA:  MOVLB  0
0ADEC:  RRCF   xC2,W
0ADEE:  ANDLW  01
0ADF0:  MOVWF  00
0ADF2:  SWAPF  00,F
0ADF4:  RLCF   00,F
0ADF6:  RLCF   00,F
0ADF8:  MOVLW  C0
0ADFA:  ANDWF  00,F
0ADFC:  MOVF   00,W
0ADFE:  MOVLB  A
0AE00:  IORWF  x1A,F
0AE02:  MOVLB  0
0AE04:  MOVF   xC2,W
0AE06:  ANDLW  01
0AE08:  MOVWF  00
0AE0A:  SWAPF  00,F
0AE0C:  RLCF   00,F
0AE0E:  MOVLW  E0
0AE10:  ANDWF  00,F
0AE12:  MOVF   00,W
0AE14:  MOVLB  A
0AE16:  IORWF  x1A,F
0AE18:  MOVF   x14,W
0AE1A:  SUBLW  07
0AE1C:  BNC   AE22
0AE1E:  MOVF   x14,W
0AE20:  BRA    AE24
0AE22:  MOVLW  07
0AE24:  MOVWF  00
0AE26:  RLCF   00,F
0AE28:  RLCF   00,F
0AE2A:  MOVLW  FC
0AE2C:  ANDWF  00,F
0AE2E:  MOVF   00,W
0AE30:  IORWF  x1A,F
0AE32:  MOVF   x13,W
0AE34:  SUBLW  03
0AE36:  BNC   AE3C
0AE38:  MOVF   x13,W
0AE3A:  BRA    AE3E
0AE3C:  MOVLW  03
0AE3E:  ANDLW  03
0AE40:  IORWF  x1A,W
0AE42:  MOVLB  0
0AE44:  MOVWF  xEA
....................  
....................     cw[1][4] = ((telemetry_time.reset_time > 0) 
....................                    + (telemetry_time.fab_time > 0) 
....................                    + (telemetry_time.pcib_time > 0) 
....................                    + (telemetry_time.adcs_time > 0)) 
....................             << 5 // Number of subsystems communicating with OBC 
....................         | 0;     // 5 bits free for assignment here 
0AE46:  BTFSC  xD0.7
0AE48:  BRA    AE5C
0AE4A:  MOVF   xD0,F
0AE4C:  BNZ   AE60
0AE4E:  MOVF   xCF,F
0AE50:  BNZ   AE60
0AE52:  MOVF   xCE,F
0AE54:  BNZ   AE60
0AE56:  MOVF   xCD,W
0AE58:  SUBLW  00
0AE5A:  BNC   AE60
0AE5C:  MOVLW  00
0AE5E:  BRA    AE62
0AE60:  MOVLW  01
0AE62:  MOVLB  A
0AE64:  MOVWF  x1A
0AE66:  MOVLB  0
0AE68:  BTFSC  xD4.7
0AE6A:  BRA    AE7E
0AE6C:  MOVF   xD4,F
0AE6E:  BNZ   AE82
0AE70:  MOVF   xD3,F
0AE72:  BNZ   AE82
0AE74:  MOVF   xD2,F
0AE76:  BNZ   AE82
0AE78:  MOVF   xD1,W
0AE7A:  SUBLW  00
0AE7C:  BNC   AE82
0AE7E:  MOVLW  00
0AE80:  BRA    AE84
0AE82:  MOVLW  01
0AE84:  MOVLB  A
0AE86:  ADDWF  x1A,F
0AE88:  MOVLB  0
0AE8A:  BTFSC  xD8.7
0AE8C:  BRA    AEA0
0AE8E:  MOVF   xD8,F
0AE90:  BNZ   AEA4
0AE92:  MOVF   xD7,F
0AE94:  BNZ   AEA4
0AE96:  MOVF   xD6,F
0AE98:  BNZ   AEA4
0AE9A:  MOVF   xD5,W
0AE9C:  SUBLW  00
0AE9E:  BNC   AEA4
0AEA0:  MOVLW  00
0AEA2:  BRA    AEA6
0AEA4:  MOVLW  01
0AEA6:  MOVLB  A
0AEA8:  ADDWF  x1A,F
0AEAA:  MOVLB  0
0AEAC:  BTFSC  xDC.7
0AEAE:  BRA    AEC2
0AEB0:  MOVF   xDC,F
0AEB2:  BNZ   AEC6
0AEB4:  MOVF   xDB,F
0AEB6:  BNZ   AEC6
0AEB8:  MOVF   xDA,F
0AEBA:  BNZ   AEC6
0AEBC:  MOVF   xD9,W
0AEBE:  SUBLW  00
0AEC0:  BNC   AEC6
0AEC2:  MOVLW  00
0AEC4:  BRA    AEC8
0AEC6:  MOVLW  01
0AEC8:  MOVLB  A
0AECA:  ADDWF  x1A,W
0AECC:  MOVWF  00
0AECE:  SWAPF  00,F
0AED0:  RLCF   00,F
0AED2:  MOVLW  E0
0AED4:  ANDWF  00,F
0AED6:  MOVFF  00,EB
0AEDA:  MOVLB  0
....................  
....................     cw[1][5] = 0 // 7 bits free for assignment here 
....................         | 0x1;   // Format identifier 
0AEDC:  MOVLW  01
0AEDE:  MOVWF  xEC
....................  
....................     fprintf(PC, "CW: 0x"); 
0AEE0:  MOVLW  B8
0AEE2:  MOVWF  FF6
0AEE4:  MOVLW  03
0AEE6:  MOVWF  FF7
0AEE8:  MOVLW  00
0AEEA:  MOVWF  FF8
0AEEC:  CALL   1C7A
....................     uart_print_pc_hex_short(cw[0], sizeof(cw[0])); 
0AEF0:  MOVLB  A
0AEF2:  CLRF   x1B
0AEF4:  MOVLW  E1
0AEF6:  MOVWF  x1A
0AEF8:  MOVLW  06
0AEFA:  MOVWF  x1C
0AEFC:  MOVLB  0
0AEFE:  RCALL  AAD8
....................     fprintf(PC, " 0x"); 
0AF00:  MOVLW  C0
0AF02:  MOVWF  FF6
0AF04:  MOVLW  03
0AF06:  MOVWF  FF7
0AF08:  MOVLW  00
0AF0A:  MOVWF  FF8
0AF0C:  CALL   1C7A
....................     uart_print_pc_hex_short(cw[1], sizeof(cw[1])); 
0AF10:  MOVLB  A
0AF12:  CLRF   x1B
0AF14:  MOVLW  E7
0AF16:  MOVWF  x1A
0AF18:  MOVLW  06
0AF1A:  MOVWF  x1C
0AF1C:  MOVLB  0
0AF1E:  RCALL  AAD8
....................     fputc(' ', PC); 
0AF20:  MOVLW  20
0AF22:  MOVLB  B
0AF24:  MOVWF  x1F
0AF26:  MOVLB  0
0AF28:  CALL   1C34
0AF2C:  GOTO   B32A (RETURN)
.................... } 
....................  
.................... // Helper function to save state to flash 
.................... void save_state(uint8_t current_command) 
.................... { 
....................     get_com_shared_fm_access(); 
*
074CE:  CALL   593C
....................  
....................     // Save state of obc_flags: 
....................     flash_erase_pages(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, OBC_FLAGS_ADDRESS + sizeof(obc_flags)); 
074D2:  MOVLW  09
074D4:  MOVLB  A
074D6:  MOVWF  x33
074D8:  MOVLW  1B
074DA:  MOVWF  x32
074DC:  CLRF   x37
074DE:  CLRF   x36
074E0:  MOVLW  10
074E2:  MOVWF  x35
074E4:  CLRF   x34
074E6:  CLRF   x3B
074E8:  CLRF   x3A
074EA:  MOVWF  x39
074EC:  MOVLW  0A
074EE:  MOVWF  x38
074F0:  MOVLB  0
074F2:  CALL   3968
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
074F6:  MOVLB  A
074F8:  CLRF   x15
074FA:  MOVLW  EE
074FC:  MOVFF  A15,A10
07500:  MOVWF  x0F
....................     flash_transfer_data_from_ram( 
....................         &spi_port_COM_FM, 
....................         OBC_FLAGS_ADDRESS, 
....................         obc_flag_ptr, 
....................         sizeof(obc_flags)); 
07502:  MOVLW  09
07504:  MOVWF  xD0
07506:  MOVLW  1B
07508:  MOVWF  xCF
0750A:  CLRF   xD4
0750C:  CLRF   xD3
0750E:  MOVLW  10
07510:  MOVWF  xD2
07512:  CLRF   xD1
07514:  MOVFF  A10,AD6
07518:  MOVFF  A0F,AD5
0751C:  CLRF   xDA
0751E:  CLRF   xD9
07520:  CLRF   xD8
07522:  MOVLW  0A
07524:  MOVWF  xD7
07526:  MOVLB  0
07528:  CALL   3C1A
....................  
....................     // Disable the current command before saving 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
0752C:  MOVLB  A
0752E:  CLRF   x11
07530:  MOVF   x11,W
07532:  SUBLW  1F
07534:  BTFSS  FD8.0
07536:  BRA    7642
....................         if (scheduled_commands[i].command[0] == MSG_COMM && scheduled_commands[i].command[1] == current_command && scheduled_commands[i].time <= current_time) { 
07538:  CLRF   x5B
0753A:  MOVFF  A11,A5A
0753E:  CLRF   x5D
07540:  MOVLW  1D
07542:  MOVWF  x5C
07544:  MOVLB  0
07546:  CALL   244C
0754A:  MOVFF  02,A15
0754E:  MOVFF  01,A14
07552:  MOVLW  04
07554:  MOVLB  A
07556:  ADDWF  x14,F
07558:  MOVLW  00
0755A:  ADDWFC x15,F
0755C:  MOVLW  1F
0755E:  ADDWF  x14,W
07560:  MOVWF  FE9
07562:  MOVLW  01
07564:  ADDWFC x15,W
07566:  MOVWF  FEA
07568:  MOVF   FEF,W
0756A:  SUBLW  C0
0756C:  BNZ   763E
0756E:  CLRF   x5B
07570:  MOVFF  A11,A5A
07574:  CLRF   x5D
07576:  MOVLW  1D
07578:  MOVWF  x5C
0757A:  MOVLB  0
0757C:  CALL   244C
07580:  MOVFF  02,A17
07584:  MOVFF  01,A16
07588:  MOVLW  04
0758A:  MOVLB  A
0758C:  ADDWF  x16,F
0758E:  MOVLW  00
07590:  ADDWFC x17,F
07592:  MOVLW  01
07594:  ADDWF  x16,W
07596:  MOVWF  01
07598:  MOVLW  00
0759A:  ADDWFC x17,W
0759C:  MOVWF  03
0759E:  MOVF   01,W
075A0:  ADDLW  1F
075A2:  MOVWF  FE9
075A4:  MOVLW  01
075A6:  ADDWFC 03,W
075A8:  MOVWF  FEA
075AA:  MOVF   x0E,W
075AC:  SUBWF  FEF,W
075AE:  BNZ   763E
075B0:  CLRF   x5B
075B2:  MOVFF  A11,A5A
075B6:  CLRF   x5D
075B8:  MOVLW  1D
075BA:  MOVWF  x5C
075BC:  MOVLB  0
075BE:  CALL   244C
075C2:  MOVFF  02,A17
075C6:  MOVFF  01,A16
075CA:  MOVLW  1F
075CC:  MOVLB  A
075CE:  ADDWF  01,W
075D0:  MOVWF  FE9
075D2:  MOVLW  01
075D4:  ADDWFC 02,W
075D6:  MOVWF  FEA
075D8:  MOVFF  FEF,A18
075DC:  MOVFF  FEC,A19
075E0:  MOVFF  FEC,A1A
075E4:  MOVFF  FEC,A1B
075E8:  BTFSS  x1B.7
075EA:  BRA    75F2
075EC:  BTFSS  3C.7
075EE:  BRA    7614
075F0:  BRA    75F6
075F2:  BTFSC  3C.7
075F4:  BRA    763E
075F6:  MOVF   x1B,W
075F8:  SUBWF  3C,W
075FA:  BNC   763E
075FC:  BNZ   7614
075FE:  MOVF   x1A,W
07600:  SUBWF  3B,W
07602:  BNC   763E
07604:  BNZ   7614
07606:  MOVF   x19,W
07608:  SUBWF  3A,W
0760A:  BNC   763E
0760C:  BNZ   7614
0760E:  MOVF   x18,W
07610:  SUBWF  39,W
07612:  BNC   763E
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
07614:  CLRF   x5B
07616:  MOVFF  A11,A5A
0761A:  CLRF   x5D
0761C:  MOVLW  1D
0761E:  MOVWF  x5C
07620:  MOVLB  0
07622:  CALL   244C
07626:  MOVLW  1F
07628:  MOVLB  A
0762A:  ADDWF  01,W
0762C:  MOVWF  FE9
0762E:  MOVLW  01
07630:  ADDWFC 02,W
07632:  MOVWF  FEA
07634:  SETF   FEF
07636:  SETF   FEC
07638:  SETF   FEC
0763A:  MOVLW  7F
0763C:  MOVWF  FEC
....................         } 
0763E:  INCF   x11,F
07640:  BRA    7530
....................     } 
....................  
....................     // Save state of scheduled commands: 
....................     flash_erase_pages(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, SCHEDULED_CMD_ADDRESS + sizeof(scheduled_commands)); 
07642:  MOVLW  09
07644:  MOVWF  x33
07646:  MOVLW  1B
07648:  MOVWF  x32
0764A:  CLRF   x37
0764C:  CLRF   x36
0764E:  MOVLW  30
07650:  MOVWF  x35
07652:  CLRF   x34
07654:  CLRF   x3B
07656:  CLRF   x3A
07658:  MOVLW  33
0765A:  MOVWF  x39
0765C:  MOVLW  A0
0765E:  MOVWF  x38
07660:  MOVLB  0
07662:  CALL   3968
....................     uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
07666:  MOVLW  01
07668:  MOVLB  A
0766A:  MOVWF  x15
0766C:  MOVLW  1F
0766E:  MOVFF  A15,A13
07672:  MOVWF  x12
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, cmd_ptr, sizeof(scheduled_commands)); 
07674:  MOVLW  09
07676:  MOVWF  xD0
07678:  MOVLW  1B
0767A:  MOVWF  xCF
0767C:  CLRF   xD4
0767E:  CLRF   xD3
07680:  MOVLW  30
07682:  MOVWF  xD2
07684:  CLRF   xD1
07686:  MOVFF  A13,AD6
0768A:  MOVFF  A12,AD5
0768E:  CLRF   xDA
07690:  CLRF   xD9
07692:  MOVLW  03
07694:  MOVWF  xD8
07696:  MOVLW  A0
07698:  MOVWF  xD7
0769A:  MOVLB  0
0769C:  CALL   3C1A
076A0:  RETURN 0
.................... } 
....................  
.................... // ============ Commands for Telemetry request ============ 
....................  
.................... // Request for reset telemetry 
.................... uint8_t command_request_reset(uint8_t* data) 
.................... { 
....................     uart_clean(RST); 
*
07BA0:  MOVLW  08
07BA2:  MOVLB  B
07BA4:  MOVWF  x3A
07BA6:  MOVLW  E2
07BA8:  MOVWF  x39
....................     uart_mux = 1; 
*
07C10:  MOVLW  01
07C12:  MOVLB  6
07C14:  MOVWF  x82
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
07C16:  MOVLB  A
07C18:  CLRF   x07
07C1A:  MOVF   x07,W
07C1C:  SUBLW  23
07C1E:  BNC   7C34
....................         fputc(cmd[i], RST); 
07C20:  CLRF   03
07C22:  MOVF   x07,W
07C24:  MOVLB  0
07C26:  CALL   0194
07C2A:  CALL   2A84
07C2E:  MOVLB  A
07C30:  INCF   x07,F
07C32:  BRA    7C1A
....................     } 
....................     return 0; 
07C34:  MOVLW  00
07C36:  MOVWF  01
07C38:  MOVLB  0
07C3A:  GOTO   CE0E (RETURN)
.................... } 
....................  
.................... // Request for eps telemetry 
.................... uint8_t command_request_eps(uint8_t* data) 
.................... { 
....................     uart_clean(FAB); 
07C3E:  MOVLW  08
07C40:  MOVLB  B
07C42:  MOVWF  x3A
07C44:  MOVLW  91
07C46:  MOVWF  x39
....................     uart_mux = 1; 
*
07CAE:  MOVLW  01
07CB0:  MOVLB  6
07CB2:  MOVWF  x82
....................  
....................     uint8_t i; 
....................     enum { cmd_size = 6 }; 
....................  
....................     uint8_t cmd[cmd_size] = { 0 }; 
07CB4:  MOVLB  A
07CB6:  CLRF   x08
07CB8:  CLRF   x09
07CBA:  CLRF   x0A
07CBC:  CLRF   x0B
07CBE:  CLRF   x0C
07CC0:  CLRF   x0D
....................  
....................     cmd[0] = 0xE0; 
07CC2:  MOVLW  E0
07CC4:  MOVWF  x08
....................     cmd[1] = 0x61; 
07CC6:  MOVLW  61
07CC8:  MOVWF  x09
....................     *(uint32_t*)&cmd[2] = current_time; 
07CCA:  MOVLW  0A
07CCC:  MOVWF  FE9
07CCE:  MOVWF  FEA
07CD0:  MOVFF  39,FEF
07CD4:  MOVFF  3A,FEC
07CD8:  MOVFF  3B,FEC
07CDC:  MOVFF  3C,FEC
....................  
....................     for (i = 0; i < sizeof(cmd); i++) { 
07CE0:  CLRF   x07
07CE2:  MOVF   x07,W
07CE4:  SUBLW  05
07CE6:  BNC   7D08
....................         fputc(cmd[i], FAB); 
07CE8:  CLRF   03
07CEA:  MOVF   x07,W
07CEC:  ADDLW  08
07CEE:  MOVWF  FE9
07CF0:  MOVLW  0A
07CF2:  ADDWFC 03,W
07CF4:  MOVWF  FEA
07CF6:  MOVFF  FEF,A0E
07CFA:  MOVF   x0E,W
07CFC:  MOVLB  0
07CFE:  CALL   2A6E
07D02:  MOVLB  A
07D04:  INCF   x07,F
07D06:  BRA    7CE2
....................     } 
....................  
....................     return 0; 
07D08:  MOVLW  00
07D0A:  MOVWF  01
07D0C:  MOVLB  0
07D0E:  GOTO   CE20 (RETURN)
.................... } 
....................  
.................... // Request for pcib (ADB) telemetry 
.................... uint8_t command_request_pcib(uint8_t* data) 
07D12:  MOVLW  0A
07D14:  MOVLB  A
07D16:  MOVWF  x2F
07D18:  MOVLW  07
07D1A:  MOVFF  A2F,A2C
07D1E:  MOVWF  x2B
.................... { 
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_PCIB - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
....................     memset(cmd, 0, sizeof(request)); 
07D20:  MOVFF  A2C,FEA
07D24:  MOVFF  A2B,FE9
07D28:  CLRF   00
07D2A:  CLRF   02
07D2C:  MOVLW  24
07D2E:  MOVWF  01
07D30:  MOVLB  0
07D32:  CALL   2968
....................  
....................     request.origin = 0x0B; 
07D36:  MOVLW  0B
07D38:  MOVLB  A
07D3A:  MOVWF  x07
....................     request.cmd = 0xAA; 
07D3C:  MOVLW  AA
07D3E:  MOVWF  x08
....................     request.obc_time = current_time; 
07D40:  MOVFF  3C,A0C
07D44:  MOVFF  3B,A0B
07D48:  MOVFF  3A,A0A
07D4C:  MOVFF  39,A09
....................  
....................     uart_mux = 1; 
07D50:  MOVLW  01
07D52:  MOVLB  6
07D54:  MOVWF  x82
....................     checksum_obc(cmd, sizeof(request)); 
07D56:  MOVFF  A2C,A58
07D5A:  MOVFF  A2B,A57
07D5E:  MOVLW  24
07D60:  MOVLB  A
07D62:  MOVWF  x59
07D64:  MOVLB  0
07D66:  CALL   712A
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
07D6A:  MOVLB  A
07D6C:  CLRF   x2D
07D6E:  MOVF   x2D,W
07D70:  SUBLW  23
07D72:  BNC   7D92
....................         fputc(cmd[i], PCIB); 
07D74:  MOVF   x2D,W
07D76:  ADDWF  x2B,W
07D78:  MOVWF  FE9
07D7A:  MOVLW  00
07D7C:  ADDWFC x2C,W
07D7E:  MOVWF  FEA
07D80:  MOVFF  FEF,A2E
07D84:  MOVF   x2E,W
07D86:  MOVLB  0
07D88:  CALL   29F8
07D8C:  MOVLB  A
07D8E:  INCF   x2D,F
07D90:  BRA    7D6E
....................     } 
....................     return 0; 
07D92:  MOVLW  00
07D94:  MOVWF  01
07D96:  MOVLB  0
07D98:  GOTO   CE32 (RETURN)
.................... } 
....................  
.................... // request for adcs telemetry 
.................... uint8_t command_request_adcs(uint8_t* data) 
.................... { 
....................     uart_clean(ADCS); 
07D9C:  MOVLW  08
07D9E:  MOVLB  B
07DA0:  MOVWF  x3A
07DA2:  MOVLW  51
07DA4:  MOVWF  x39
....................     uart_mux = 0; 
*
07E0C:  MOVLB  6
07E0E:  CLRF   x82
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B }; 
07E10:  MOVLW  0B
07E12:  MOVLB  A
07E14:  MOVWF  x07
07E16:  CLRF   x08
07E18:  CLRF   x09
07E1A:  CLRF   x0A
07E1C:  CLRF   x0B
07E1E:  CLRF   x0C
07E20:  CLRF   x0D
07E22:  CLRF   x0E
07E24:  CLRF   x0F
07E26:  CLRF   x10
07E28:  CLRF   x11
07E2A:  CLRF   x12
07E2C:  CLRF   x13
07E2E:  CLRF   x14
07E30:  CLRF   x15
07E32:  CLRF   x16
07E34:  CLRF   x17
07E36:  CLRF   x18
07E38:  CLRF   x19
07E3A:  CLRF   x1A
07E3C:  CLRF   x1B
07E3E:  CLRF   x1C
07E40:  CLRF   x1D
07E42:  CLRF   x1E
07E44:  CLRF   x1F
07E46:  CLRF   x20
07E48:  CLRF   x21
07E4A:  CLRF   x22
07E4C:  CLRF   x23
07E4E:  CLRF   x24
07E50:  CLRF   x25
07E52:  CLRF   x26
07E54:  CLRF   x27
07E56:  CLRF   x28
07E58:  CLRF   x29
07E5A:  CLRF   x2A
07E5C:  CLRF   x2B
07E5E:  CLRF   x2C
07E60:  CLRF   x2D
07E62:  CLRF   x2E
07E64:  CLRF   x2F
07E66:  CLRF   x30
07E68:  CLRF   x31
....................     adcs_command[1] = 0xAB; 
07E6A:  MOVLW  AB
07E6C:  MOVWF  x08
....................     *(time_t*)&adcs_command[2] = current_time; 
07E6E:  MOVLW  0A
07E70:  MOVWF  x34
07E72:  MOVLW  09
07E74:  MOVWF  FE9
07E76:  MOVFF  A34,FEA
07E7A:  MOVFF  39,FEF
07E7E:  MOVFF  3A,FEC
07E82:  MOVFF  3B,FEC
07E86:  MOVFF  3C,FEC
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
07E8A:  MOVLW  0A
07E8C:  MOVWF  x58
07E8E:  MOVLW  07
07E90:  MOVWF  x57
07E92:  MOVLW  2B
07E94:  MOVWF  x59
07E96:  MOVLB  0
07E98:  CALL   712A
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
07E9C:  MOVLB  A
07E9E:  CLRF   x32
07EA0:  MOVF   x32,W
07EA2:  SUBLW  2A
07EA4:  BNC   7EC4
....................         fputc(adcs_command[i], ADCS); 
07EA6:  CLRF   03
07EA8:  MOVF   x32,W
07EAA:  ADDLW  07
07EAC:  MOVWF  FE9
07EAE:  MOVLW  0A
07EB0:  ADDWFC 03,W
07EB2:  MOVWF  FEA
07EB4:  MOVFF  FEF,B1F
07EB8:  MOVLB  0
07EBA:  CALL   2A20
07EBE:  MOVLB  A
07EC0:  INCF   x32,F
07EC2:  BRA    7EA0
....................     } 
....................     // fprintf(PC, "ADCS REQ: "); 
....................     // uart_print_pc_hex(adcs_command, MSG_LENGTH_ADCS); 
....................     // fprintf(PC, "\r\n"); 
....................     return 0; 
07EC4:  MOVLW  00
07EC6:  MOVWF  01
07EC8:  MOVLB  0
07ECA:  GOTO   CE44 (RETURN)
.................... } 
....................  
.................... // ============ ADCS Commands ============ 
....................  
.................... enum { // updated on 2023/05/01 
....................     adcs_mode_tumbling = 0, 
....................     adcs_mode_detumbling = 1, 
....................     adcs_mode_detumble_sun_tracking_auto = 2, 
....................     adcs_mode_sun_tracking = 3, 
....................     adcs_mode_nadir_sband = 4, 
....................     adcs_mode_nadir_camera = 5, 
....................     adcs_mode_target = 6, 
....................     adcs_mode_sun_tracking_quat = 7, 
....................     adcs_mode_target_camera = 8, 
....................     adcs_mode_horizon_camera = 9, 
....................     adcs_mode_nadir_sband_pz = 10, 
....................     adcs_mode_nadir_camera_pz = 11 
.................... }; 
....................  
.................... // Helper function to send STM32 commands (up to 32-bytes) 
.................... void stm32_raw_command(uint8_t* data, uint8_t length, uint8_t tle) 
.................... { 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B, 0x06 }; 
*
07188:  MOVLW  0B
0718A:  MOVLB  A
0718C:  MOVWF  x27
0718E:  MOVLW  06
07190:  MOVWF  x28
07192:  CLRF   x29
07194:  CLRF   x2A
07196:  CLRF   x2B
07198:  CLRF   x2C
0719A:  CLRF   x2D
0719C:  CLRF   x2E
0719E:  CLRF   x2F
071A0:  CLRF   x30
071A2:  CLRF   x31
071A4:  CLRF   x32
071A6:  CLRF   x33
071A8:  CLRF   x34
071AA:  CLRF   x35
071AC:  CLRF   x36
071AE:  CLRF   x37
071B0:  CLRF   x38
071B2:  CLRF   x39
071B4:  CLRF   x3A
071B6:  CLRF   x3B
071B8:  CLRF   x3C
071BA:  CLRF   x3D
071BC:  CLRF   x3E
071BE:  CLRF   x3F
071C0:  CLRF   x40
071C2:  CLRF   x41
071C4:  CLRF   x42
071C6:  CLRF   x43
071C8:  CLRF   x44
071CA:  CLRF   x45
071CC:  CLRF   x46
071CE:  CLRF   x47
071D0:  CLRF   x48
071D2:  CLRF   x49
071D4:  CLRF   x4A
071D6:  CLRF   x4B
071D8:  CLRF   x4C
071DA:  CLRF   x4D
071DC:  CLRF   x4E
071DE:  CLRF   x4F
071E0:  CLRF   x50
071E2:  CLRF   x51
....................     if (tle) { 
071E4:  MOVF   x26,F
071E6:  BZ    71EC
....................         adcs_command[1] = 0x07; 
071E8:  MOVLW  07
071EA:  MOVWF  x28
....................     } 
....................     memcpy(adcs_command + 2, data, length); 
071EC:  MOVLW  0A
071EE:  MOVWF  FEA
071F0:  MOVLW  29
071F2:  MOVWF  FE9
071F4:  MOVFF  A24,FE2
071F8:  MOVFF  A23,FE1
071FC:  MOVF   x25,W
071FE:  MOVWF  01
07200:  BZ    720A
07202:  MOVFF  FE6,FEE
07206:  DECFSZ 01,F
07208:  BRA    7202
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
0720A:  MOVLW  0A
0720C:  MOVWF  x58
0720E:  MOVLW  27
07210:  MOVWF  x57
07212:  MOVLW  2B
07214:  MOVWF  x59
07216:  MOVLB  0
07218:  RCALL  712A
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
0721A:  MOVLB  A
0721C:  CLRF   x52
0721E:  MOVF   x52,W
07220:  SUBLW  2A
07222:  BNC   7242
....................         fputc(adcs_command[i], ADCS); 
07224:  CLRF   03
07226:  MOVF   x52,W
07228:  ADDLW  27
0722A:  MOVWF  FE9
0722C:  MOVLW  0A
0722E:  ADDWFC 03,W
07230:  MOVWF  FEA
07232:  MOVFF  FEF,B1F
07236:  MOVLB  0
07238:  CALL   2A20
0723C:  MOVLB  A
0723E:  INCF   x52,F
07240:  BRA    721E
....................     } 
....................     fprintf(PC, "STM RAW CMD: "); 
07242:  MOVLW  C4
07244:  MOVWF  FF6
07246:  MOVLW  03
07248:  MOVWF  FF7
0724A:  MOVLW  00
0724C:  MOVWF  FF8
0724E:  MOVLB  0
07250:  CALL   1C7A
....................     uart_print_pc_hex(adcs_command, sizeof(adcs_command)); 
07254:  MOVLW  0A
07256:  MOVLB  A
07258:  MOVWF  x54
0725A:  MOVLW  27
0725C:  MOVWF  x53
0725E:  MOVLW  2B
07260:  MOVWF  x55
07262:  MOVLB  0
07264:  CALL   4EF0
07268:  RETURN 0
.................... } 
....................  
.................... // Change ADCS mode internally and externally 
.................... uint8_t command_adcs_mode(uint8_t* data) 
*
08A72:  MOVFF  A06,A08
08A76:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; // when true, change mode permanently 
....................     }* packet = (struct packet*)data; 
....................     uint8_t adcs_command[3] = { 0x01 }; 
08A7A:  MOVLW  01
08A7C:  MOVLB  A
08A7E:  MOVWF  x09
08A80:  CLRF   x0A
08A82:  CLRF   x0B
....................     adcs_mode = packet->mode; 
08A84:  MOVLW  02
08A86:  ADDWF  x07,W
08A88:  MOVWF  FE9
08A8A:  MOVLW  00
08A8C:  ADDWFC x08,W
08A8E:  MOVWF  FEA
08A90:  MOVFF  FEF,68A
....................     adcs_command[1] = packet->mode; 
08A94:  MOVLW  02
08A96:  ADDWF  x07,W
08A98:  MOVWF  FE9
08A9A:  MOVLW  00
08A9C:  ADDWFC x08,W
08A9E:  MOVWF  FEA
08AA0:  MOVFF  FEF,A0A
....................     adcs_command[2] = packet->permanent; 
08AA4:  MOVLW  03
08AA6:  ADDWF  x07,W
08AA8:  MOVWF  FE9
08AAA:  MOVLW  00
08AAC:  ADDWFC x08,W
08AAE:  MOVWF  FEA
08AB0:  MOVFF  FEF,A0B
....................     stm32_raw_command(adcs_command, sizeof(adcs_command), 0); 
08AB4:  MOVLW  0A
08AB6:  MOVWF  x24
08AB8:  MOVLW  09
08ABA:  MOVWF  x23
08ABC:  MOVLW  03
08ABE:  MOVWF  x25
08AC0:  CLRF   x26
08AC2:  MOVLB  0
08AC4:  CALL   7188
....................     return packet->mode; 
08AC8:  MOVLW  02
08ACA:  MOVLB  A
08ACC:  ADDWF  x07,W
08ACE:  MOVWF  FE9
08AD0:  MOVLW  00
08AD2:  ADDWFC x08,W
08AD4:  MOVWF  FEA
08AD6:  MOVFF  FEF,01
08ADA:  MOVLB  0
08ADC:  GOTO   CEB0 (RETURN)
.................... } 
....................  
.................... // Change ADCS default mode 
.................... uint8_t command_adcs_default_mode(uint8_t* data) 
*
07FA8:  MOVFF  A06,A08
07FAC:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t new_mode; 
....................     }* packet = (struct packet*)data; 
....................  
....................     // Change stored vale in OBC 
....................     obc_flags.adcs_initial_value = packet->new_mode; 
07FB0:  MOVLW  02
07FB2:  MOVLB  A
07FB4:  ADDWF  x07,W
07FB6:  MOVWF  FE9
07FB8:  MOVLW  00
07FBA:  ADDWFC x08,W
07FBC:  MOVWF  FEA
07FBE:  MOVFF  FEF,F2
07FC2:  MOVLB  0
....................     adcs_mode = obc_flags.adcs_initial_value; 
07FC4:  MOVFF  F2,68A
....................     save_state(packet->command); 
07FC8:  MOVLW  01
07FCA:  MOVLB  A
07FCC:  ADDWF  x07,W
07FCE:  MOVWF  FE9
07FD0:  MOVLW  00
07FD2:  ADDWFC x08,W
07FD4:  MOVWF  FEA
07FD6:  MOVFF  FEF,A0E
07FDA:  MOVLB  0
07FDC:  CALL   74CE
....................  
....................     // Change stored value in ADCS 
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................     adcs_mode_st.origin = MSG_COMM; 
07FE0:  MOVLW  C0
07FE2:  MOVLB  A
07FE4:  MOVWF  x09
....................     adcs_mode_st.command = 0xAD; 
07FE6:  MOVLW  AD
07FE8:  MOVWF  x0A
....................     adcs_mode_st.mode = packet->new_mode; 
07FEA:  MOVLW  02
07FEC:  ADDWF  x07,W
07FEE:  MOVWF  FE9
07FF0:  MOVLW  00
07FF2:  ADDWFC x08,W
07FF4:  MOVWF  FEA
07FF6:  MOVFF  FEF,A0B
....................     adcs_mode_st.permanent = true; 
07FFA:  MOVLW  01
07FFC:  MOVWF  x0C
....................     vschedule(current_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
07FFE:  MOVLW  0A
08000:  MOVWF  x0E
08002:  MOVLW  09
08004:  MOVWF  x0D
08006:  MOVFF  3C,A2E
0800A:  MOVFF  3B,A2D
0800E:  MOVFF  3A,A2C
08012:  MOVFF  39,A2B
08016:  MOVFF  A0E,A30
0801A:  MOVWF  x2F
0801C:  MOVLB  0
0801E:  CALL   4600
....................  
....................     return adcs_mode; 
08022:  MOVLB  6
08024:  MOVFF  68A,01
08028:  MOVLB  0
0802A:  GOTO   CE7A (RETURN)
.................... } 
....................  
.................... // Schedule ADCS mode (without coordinates) 
.................... uint8_t command_schedule_mode(uint8_t* data) 
*
0A9CE:  MOVFF  A06,A08
0A9D2:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_mode; 
....................         time_t mode_scheduled_time; 
....................         uint16_t total_duration; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (packet->mode_scheduled_time == 0) { // debug case 
0A9D6:  MOVLW  03
0A9D8:  MOVLB  A
0A9DA:  ADDWF  x07,W
0A9DC:  MOVWF  FE9
0A9DE:  MOVLW  00
0A9E0:  ADDWFC x08,W
0A9E2:  MOVWF  FEA
0A9E4:  MOVFF  FEF,A0D
0A9E8:  MOVFF  FEC,A0E
0A9EC:  MOVFF  FEC,A0F
0A9F0:  MOVFF  FEC,A10
0A9F4:  MOVF   x0D,F
0A9F6:  BNZ   AA20
0A9F8:  MOVF   x0E,F
0A9FA:  BNZ   AA20
0A9FC:  MOVF   x0F,F
0A9FE:  BNZ   AA20
0AA00:  MOVF   x10,F
0AA02:  BNZ   AA20
....................         packet->mode_scheduled_time = current_time; 
0AA04:  MOVLW  03
0AA06:  ADDWF  x07,W
0AA08:  MOVWF  FE9
0AA0A:  MOVLW  00
0AA0C:  ADDWFC x08,W
0AA0E:  MOVWF  FEA
0AA10:  MOVFF  39,FEF
0AA14:  MOVFF  3A,FEC
0AA18:  MOVFF  3B,FEC
0AA1C:  MOVFF  3C,FEC
....................     } 
....................  
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................  
....................     adcs_mode_st.origin = MSG_COMM; 
0AA20:  MOVLW  C0
0AA22:  MOVWF  x09
....................     adcs_mode_st.command = 0xAD; 
0AA24:  MOVLW  AD
0AA26:  MOVWF  x0A
....................     adcs_mode_st.mode = packet->adcs_mode; 
0AA28:  MOVLW  02
0AA2A:  ADDWF  x07,W
0AA2C:  MOVWF  FE9
0AA2E:  MOVLW  00
0AA30:  ADDWFC x08,W
0AA32:  MOVWF  FEA
0AA34:  MOVFF  FEF,A0B
....................     adcs_mode_st.permanent = false; 
0AA38:  CLRF   x0C
....................     vschedule(packet->mode_scheduled_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
0AA3A:  MOVLW  03
0AA3C:  ADDWF  x07,W
0AA3E:  MOVWF  FE9
0AA40:  MOVLW  00
0AA42:  ADDWFC x08,W
0AA44:  MOVWF  FEA
0AA46:  MOVFF  FEF,A2B
0AA4A:  MOVFF  FEC,A2C
0AA4E:  MOVFF  FEC,A2D
0AA52:  MOVFF  FEC,A2E
0AA56:  MOVLW  0A
0AA58:  MOVWF  x12
0AA5A:  MOVLW  09
0AA5C:  MOVWF  x11
0AA5E:  MOVFF  A12,A30
0AA62:  MOVWF  x2F
0AA64:  MOVLB  0
0AA66:  CALL   4600
....................  
....................     adcs_mode_st.mode = obc_flags.adcs_initial_value; 
0AA6A:  MOVFF  F2,A0B
....................     vschedule(packet->mode_scheduled_time + packet->total_duration, (uint8_t*)&adcs_mode_st); // ADCS back to default mode 
0AA6E:  MOVLW  03
0AA70:  MOVLB  A
0AA72:  ADDWF  x07,W
0AA74:  MOVWF  FE9
0AA76:  MOVLW  00
0AA78:  ADDWFC x08,W
0AA7A:  MOVWF  FEA
0AA7C:  MOVFF  FEF,A0D
0AA80:  MOVFF  FEC,A0E
0AA84:  MOVFF  FEC,A0F
0AA88:  MOVFF  FEC,A10
0AA8C:  MOVLW  07
0AA8E:  ADDWF  x07,W
0AA90:  MOVWF  FE9
0AA92:  MOVLW  00
0AA94:  ADDWFC x08,W
0AA96:  MOVWF  FEA
0AA98:  MOVFF  FEC,03
0AA9C:  MOVF   FED,F
0AA9E:  MOVF   FEF,W
0AAA0:  ADDWF  x0D,F
0AAA2:  MOVF   03,W
0AAA4:  ADDWFC x0E,F
0AAA6:  MOVLW  00
0AAA8:  ADDWFC x0F,F
0AAAA:  ADDWFC x10,F
0AAAC:  MOVLW  0A
0AAAE:  MOVWF  x12
0AAB0:  MOVLW  09
0AAB2:  MOVWF  x11
0AAB4:  MOVFF  A10,A2E
0AAB8:  MOVFF  A0F,A2D
0AABC:  MOVFF  A0E,A2C
0AAC0:  MOVFF  A0D,A2B
0AAC4:  MOVFF  A12,A30
0AAC8:  MOVWF  x2F
0AACA:  MOVLB  0
0AACC:  CALL   4600
....................  
....................     return 0; 
0AAD0:  MOVLW  00
0AAD2:  MOVWF  01
0AAD4:  GOTO   CFBE (RETURN)
.................... } 
....................  
.................... // Print the satellite flags to the debug line 
.................... uint8_t command_print_flags(uint8_t* data) 
.................... { 
....................     print_flags(); 
*
0B3E2:  CALL   4A28
....................     return 0; 
0B3E6:  MOVLW  00
0B3E8:  MOVWF  01
0B3EA:  GOTO   CFF4 (RETURN)
.................... } 
....................  
.................... // Send a raw command to ADCS 
.................... uint8_t command_adcs_raw(uint8_t* data) 
*
08B72:  MOVFF  A06,A08
08B76:  MOVFF  A05,A07
.................... { 
....................     enum { adcs_cmd_size = 7 }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_command[adcs_cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t msg[MSG_LENGTH_ADCS] = { 0 }; 
08B7A:  MOVLB  A
08B7C:  CLRF   x09
08B7E:  CLRF   x0A
08B80:  CLRF   x0B
08B82:  CLRF   x0C
08B84:  CLRF   x0D
08B86:  CLRF   x0E
08B88:  CLRF   x0F
08B8A:  CLRF   x10
08B8C:  CLRF   x11
08B8E:  CLRF   x12
08B90:  CLRF   x13
08B92:  CLRF   x14
08B94:  CLRF   x15
08B96:  CLRF   x16
08B98:  CLRF   x17
08B9A:  CLRF   x18
08B9C:  CLRF   x19
08B9E:  CLRF   x1A
08BA0:  CLRF   x1B
08BA2:  CLRF   x1C
08BA4:  CLRF   x1D
08BA6:  CLRF   x1E
08BA8:  CLRF   x1F
08BAA:  CLRF   x20
08BAC:  CLRF   x21
08BAE:  CLRF   x22
08BB0:  CLRF   x23
08BB2:  CLRF   x24
08BB4:  CLRF   x25
08BB6:  CLRF   x26
08BB8:  CLRF   x27
08BBA:  CLRF   x28
08BBC:  CLRF   x29
08BBE:  CLRF   x2A
08BC0:  CLRF   x2B
08BC2:  CLRF   x2C
08BC4:  CLRF   x2D
08BC6:  CLRF   x2E
08BC8:  CLRF   x2F
08BCA:  CLRF   x30
08BCC:  CLRF   x31
08BCE:  CLRF   x32
08BD0:  CLRF   x33
....................     msg[0] = 0x0B; 
08BD2:  MOVLW  0B
08BD4:  MOVWF  x09
....................     memcpy(msg + 1, packet->adcs_command, adcs_cmd_size); 
08BD6:  MOVLW  02
08BD8:  ADDWF  x07,W
08BDA:  MOVWF  01
08BDC:  MOVLW  00
08BDE:  ADDWFC x08,W
08BE0:  MOVWF  03
08BE2:  MOVFF  01,A35
08BE6:  MOVWF  x36
08BE8:  MOVLW  0A
08BEA:  MOVWF  FEA
08BEC:  MOVWF  FE9
08BEE:  MOVFF  03,FE2
08BF2:  MOVFF  01,FE1
08BF6:  MOVLW  07
08BF8:  MOVWF  01
08BFA:  MOVFF  FE6,FEE
08BFE:  DECFSZ 01,F
08C00:  BRA    8BFA
....................     msg[MSG_LENGTH_ADCS - 1] = 0x0C; 
08C02:  MOVLW  0C
08C04:  MOVWF  x33
....................  
....................     uart_print_pc_hex(msg, sizeof(msg)); 
08C06:  MOVLW  0A
08C08:  MOVWF  x54
08C0A:  MOVLW  09
08C0C:  MOVWF  x53
08C0E:  MOVLW  2B
08C10:  MOVWF  x55
08C12:  MOVLB  0
08C14:  CALL   4EF0
....................  
....................     for (uint8_t i = 0; i < sizeof(msg); i++) { 
08C18:  MOVLB  A
08C1A:  CLRF   x34
08C1C:  MOVF   x34,W
08C1E:  SUBLW  2A
08C20:  BNC   8C40
....................         fputc(msg[i], ADCS); 
08C22:  CLRF   03
08C24:  MOVF   x34,W
08C26:  ADDLW  09
08C28:  MOVWF  FE9
08C2A:  MOVLW  0A
08C2C:  ADDWFC 03,W
08C2E:  MOVWF  FEA
08C30:  MOVFF  FEF,B1F
08C34:  MOVLB  0
08C36:  CALL   2A20
08C3A:  MOVLB  A
08C3C:  INCF   x34,F
08C3E:  BRA    8C1C
....................     } 
....................  
....................     uart_mux = 0; 
08C40:  MOVLB  6
08C42:  CLRF   x82
....................  
....................     return 0; 
08C44:  MOVLW  00
08C46:  MOVWF  01
08C48:  MOVLB  0
08C4A:  GOTO   CED4 (RETURN)
.................... } 
....................  
.................... uint8_t command_stm32_raw_8_16(uint8_t* data) 
*
07A3C:  MOVFF  A06,A08
07A40:  MOVFF  A05,A07
.................... { 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
07A44:  MOVLW  07
07A46:  MOVWF  FEA
07A48:  MOVLW  73
07A4A:  MOVWF  FE9
07A4C:  CLRF   00
07A4E:  CLRF   02
07A50:  MOVLW  20
07A52:  MOVWF  01
07A54:  CALL   2968
....................     memcpy(stm32_command_uhf, packet->part, length); 
07A58:  MOVLW  02
07A5A:  MOVLB  A
07A5C:  ADDWF  x07,W
07A5E:  MOVWF  01
07A60:  MOVLW  00
07A62:  ADDWFC x08,W
07A64:  MOVWF  03
07A66:  MOVFF  01,A09
07A6A:  MOVWF  x0A
07A6C:  MOVLW  07
07A6E:  MOVWF  FEA
07A70:  MOVLW  73
07A72:  MOVWF  FE9
07A74:  MOVFF  03,FE2
07A78:  MOVFF  01,FE1
07A7C:  MOVLW  10
07A7E:  MOVWF  01
07A80:  MOVFF  FE6,FEE
07A84:  DECFSZ 01,F
07A86:  BRA    7A80
....................     stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
07A88:  MOVLW  07
07A8A:  MOVWF  x24
07A8C:  MOVLW  73
07A8E:  MOVWF  x23
07A90:  MOVLW  20
07A92:  MOVWF  x25
07A94:  CLRF   x26
07A96:  MOVLB  0
07A98:  CALL   7188
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
07A9C:  MOVLW  07
07A9E:  MOVWF  FEA
07AA0:  MOVLW  73
07AA2:  MOVWF  FE9
07AA4:  CLRF   00
07AA6:  CLRF   02
07AA8:  MOVLW  20
07AAA:  MOVWF  01
07AAC:  CALL   2968
....................  
....................     fprintf(PC, "STM32 command (8/16)"); 
07AB0:  MOVLW  D2
07AB2:  MOVWF  FF6
07AB4:  MOVLW  03
07AB6:  MOVWF  FF7
07AB8:  MOVLW  00
07ABA:  MOVWF  FF8
07ABC:  CALL   1C7A
....................  
....................     return 0; 
07AC0:  MOVLW  00
07AC2:  MOVWF  01
07AC4:  GOTO   CDD8 (RETURN)
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32(uint8_t* data) 
07AC8:  MOVFF  A06,A08
07ACC:  MOVFF  A05,A07
07AD0:  MOVLW  01
07AD2:  MOVLB  A
07AD4:  ADDWF  x07,W
07AD6:  MOVWF  FE9
07AD8:  MOVLW  00
07ADA:  ADDWFC x08,W
07ADC:  MOVWF  FEA
07ADE:  MOVF   FEF,W
07AE0:  ANDLW  0F
07AE2:  ADDLW  FF
07AE4:  MOVWF  x09
.................... { 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
07AE6:  MOVF   x09,W
07AE8:  MULLW  10
07AEA:  MOVF   FF3,W
07AEC:  ADDLW  73
07AEE:  MOVWF  x0A
07AF0:  MOVLW  07
07AF2:  MOVWF  x0B
07AF4:  BTFSC  FD8.0
07AF6:  INCF   x0B,F
07AF8:  MOVLW  02
07AFA:  ADDWF  x07,W
07AFC:  MOVWF  01
07AFE:  MOVLW  00
07B00:  ADDWFC x08,W
07B02:  MOVWF  03
07B04:  MOVFF  01,A0C
07B08:  MOVWF  x0D
07B0A:  MOVFF  A0B,FEA
07B0E:  MOVFF  A0A,FE9
07B12:  MOVWF  FE2
07B14:  MOVFF  01,FE1
07B18:  MOVLW  10
07B1A:  MOVWF  01
07B1C:  MOVFF  FE6,FEE
07B20:  DECFSZ 01,F
07B22:  BRA    7B1C
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
07B24:  MOVLW  01
07B26:  ADDWF  x09,W
07B28:  MOVWF  x0A
07B2A:  MOVLW  E8
07B2C:  MOVWF  FF6
07B2E:  MOVLW  03
07B30:  MOVWF  FF7
07B32:  MOVLW  00
07B34:  MOVWF  FF8
07B36:  MOVLW  18
07B38:  MOVWF  x3B
07B3A:  MOVLB  0
07B3C:  CALL   3048
07B40:  MOVFF  A0A,A25
07B44:  MOVLW  18
07B46:  MOVLB  A
07B48:  MOVWF  x26
07B4A:  MOVLB  0
07B4C:  CALL   4960
07B50:  MOVLW  2E
07B52:  MOVLB  B
07B54:  MOVWF  x1F
07B56:  MOVLB  0
07B58:  CALL   1C34
07B5C:  MOVLW  20
07B5E:  MOVLB  B
07B60:  MOVWF  x1F
07B62:  MOVLB  0
07B64:  CALL   1C34
....................  
....................     if (part == 1) { 
07B68:  MOVLB  A
07B6A:  DECFSZ x09,W
07B6C:  BRA    7B98
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
07B6E:  MOVLW  07
07B70:  MOVWF  x24
07B72:  MOVLW  73
07B74:  MOVWF  x23
07B76:  MOVLW  20
07B78:  MOVWF  x25
07B7A:  CLRF   x26
07B7C:  MOVLB  0
07B7E:  CALL   7188
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
07B82:  MOVLW  07
07B84:  MOVWF  FEA
07B86:  MOVLW  73
07B88:  MOVWF  FE9
07B8A:  CLRF   00
07B8C:  CLRF   02
07B8E:  MOVLW  20
07B90:  MOVWF  01
07B92:  CALL   2968
07B96:  MOVLB  A
....................     } 
....................  
....................     return 0; 
07B98:  MOVLW  00
07B9A:  MOVWF  01
07B9C:  MOVLB  0
07B9E:  RETURN 0
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32_tle(uint8_t* data) 
*
07ECE:  MOVFF  A06,A08
07ED2:  MOVFF  A05,A07
07ED6:  MOVLW  01
07ED8:  MOVLB  A
07EDA:  ADDWF  x07,W
07EDC:  MOVWF  FE9
07EDE:  MOVLW  00
07EE0:  ADDWFC x08,W
07EE2:  MOVWF  FEA
07EE4:  MOVF   FEF,W
07EE6:  ANDLW  0F
07EE8:  ADDLW  FF
07EEA:  MOVWF  x09
.................... { 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
07EEC:  MOVF   x09,W
07EEE:  MULLW  10
07EF0:  MOVF   FF3,W
07EF2:  ADDLW  73
07EF4:  MOVWF  x0A
07EF6:  MOVLW  07
07EF8:  MOVWF  x0B
07EFA:  BTFSC  FD8.0
07EFC:  INCF   x0B,F
07EFE:  MOVLW  02
07F00:  ADDWF  x07,W
07F02:  MOVWF  01
07F04:  MOVLW  00
07F06:  ADDWFC x08,W
07F08:  MOVWF  03
07F0A:  MOVFF  01,A0C
07F0E:  MOVWF  x0D
07F10:  MOVFF  A0B,FEA
07F14:  MOVFF  A0A,FE9
07F18:  MOVWF  FE2
07F1A:  MOVFF  01,FE1
07F1E:  MOVLW  10
07F20:  MOVWF  01
07F22:  MOVFF  FE6,FEE
07F26:  DECFSZ 01,F
07F28:  BRA    7F22
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
07F2A:  MOVLW  01
07F2C:  ADDWF  x09,W
07F2E:  MOVWF  x0A
07F30:  MOVLW  06
07F32:  MOVWF  FF6
07F34:  MOVLW  04
07F36:  MOVWF  FF7
07F38:  MOVLW  00
07F3A:  MOVWF  FF8
07F3C:  MOVLW  18
07F3E:  MOVWF  x3B
07F40:  MOVLB  0
07F42:  CALL   3048
07F46:  MOVFF  A0A,A25
07F4A:  MOVLW  18
07F4C:  MOVLB  A
07F4E:  MOVWF  x26
07F50:  MOVLB  0
07F52:  CALL   4960
07F56:  MOVLW  2E
07F58:  MOVLB  B
07F5A:  MOVWF  x1F
07F5C:  MOVLB  0
07F5E:  CALL   1C34
07F62:  MOVLW  20
07F64:  MOVLB  B
07F66:  MOVWF  x1F
07F68:  MOVLB  0
07F6A:  CALL   1C34
....................  
....................     if (part == 1) { 
07F6E:  MOVLB  A
07F70:  DECFSZ x09,W
07F72:  BRA    7FA0
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, true); 
07F74:  MOVLW  07
07F76:  MOVWF  x24
07F78:  MOVLW  73
07F7A:  MOVWF  x23
07F7C:  MOVLW  20
07F7E:  MOVWF  x25
07F80:  MOVLW  01
07F82:  MOVWF  x26
07F84:  MOVLB  0
07F86:  CALL   7188
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
07F8A:  MOVLW  07
07F8C:  MOVWF  FEA
07F8E:  MOVLW  73
07F90:  MOVWF  FE9
07F92:  CLRF   00
07F94:  CLRF   02
07F96:  MOVLW  20
07F98:  MOVWF  01
07F9A:  CALL   2968
07F9E:  MOVLB  A
....................     } 
....................  
....................     return 0; 
07FA0:  MOVLW  00
07FA2:  MOVWF  01
07FA4:  MOVLB  0
07FA6:  RETURN 0
.................... } 
....................  
.................... // Receive ADCS telemetry 
.................... uint8_t command_adcs_telemetry(uint8_t* data) 
.................... { 
....................     response_rx = 1; // Received a reply 
*
04FB0:  MOVLW  01
04FB2:  MOVLB  6
04FB4:  MOVWF  x83
....................     uart_mux = 1; 
04FB6:  MOVWF  x82
....................  
....................     fprintf(PC, "ADCS: "); 
04FB8:  MOVLW  24
04FBA:  MOVWF  FF6
04FBC:  MOVLW  04
04FBE:  MOVWF  FF7
04FC0:  MOVLW  00
04FC2:  MOVWF  FF8
04FC4:  MOVLB  0
04FC6:  CALL   1C7A
....................     fprintf(PC, "Mode=%X | ", data[2]); 
04FCA:  MOVLW  02
04FCC:  MOVLB  A
04FCE:  ADDWF  x05,W
04FD0:  MOVWF  FE9
04FD2:  MOVLW  00
04FD4:  ADDWFC x06,W
04FD6:  MOVWF  FEA
04FD8:  MOVFF  FEF,A07
04FDC:  MOVLW  2C
04FDE:  MOVWF  FF6
04FE0:  MOVLW  04
04FE2:  MOVWF  FF7
04FE4:  MOVLW  00
04FE6:  MOVWF  FF8
04FE8:  MOVLW  05
04FEA:  MOVWF  x3B
04FEC:  MOVLB  0
04FEE:  CALL   3048
04FF2:  MOVFF  A07,A58
04FF6:  MOVLW  37
04FF8:  MOVLB  A
04FFA:  MOVWF  x59
04FFC:  MOVLB  0
04FFE:  CALL   3142
05002:  MOVLW  33
05004:  MOVWF  FF6
05006:  MOVLW  04
05008:  MOVWF  FF7
0500A:  MOVLW  00
0500C:  MOVWF  FF8
0500E:  MOVLW  03
05010:  MOVLB  A
05012:  MOVWF  x3B
05014:  MOVLB  0
05016:  CALL   3048
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
0501A:  MOVFF  A06,A54
0501E:  MOVFF  A05,A53
05022:  MOVLW  2B
05024:  MOVLB  A
05026:  MOVWF  x55
05028:  MOVLB  0
0502A:  RCALL  4EF0
....................  
....................     telemetry_time.adcs_time = current_time; 
0502C:  MOVFF  3C,DC
05030:  MOVFF  3B,DB
05034:  MOVFF  3A,DA
05038:  MOVFF  39,D9
....................     memcpy(telemetry.adcs_message, data + 2, sizeof(telemetry.adcs_message)); 
0503C:  MOVLW  02
0503E:  MOVLB  A
05040:  ADDWF  x05,W
05042:  MOVWF  x07
05044:  MOVLW  00
05046:  ADDWFC x06,W
05048:  MOVWF  x08
0504A:  CLRF   FEA
0504C:  MOVLW  9D
0504E:  MOVWF  FE9
05050:  MOVFF  A08,FE2
05054:  MOVFF  A07,FE1
05058:  MOVLW  27
0505A:  MOVWF  01
0505C:  MOVFF  FE6,FEE
05060:  DECFSZ 01,F
05062:  BRA    505C
....................  
....................     return 0; 
05064:  MOVLW  00
05066:  MOVWF  01
05068:  MOVLB  0
0506A:  GOTO   CC70 (RETURN)
.................... } 
....................  
.................... // Receive GPS time from ADCS 
.................... uint8_t command_adcs_gps_time(uint8_t* data) 
*
051C2:  MOVFF  A06,A08
051C6:  MOVFF  A05,A07
051CA:  MOVLB  A
051CC:  CLRF   x09
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................         uint8_t day; 
....................         uint8_t month; 
....................         uint8_t year; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t valid_time = 0; 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
051CE:  MOVFF  A06,A54
051D2:  MOVFF  A05,A53
051D6:  MOVLW  2B
051D8:  MOVWF  x55
051DA:  MOVLB  0
051DC:  RCALL  4EF0
....................  
....................     if (packet->year == 0x00 || packet->year >= 38) { 
051DE:  MOVLW  07
051E0:  MOVLB  A
051E2:  ADDWF  x07,W
051E4:  MOVWF  FE9
051E6:  MOVLW  00
051E8:  ADDWFC x08,W
051EA:  MOVWF  FEA
051EC:  MOVF   FEF,F
051EE:  BZ    5202
051F0:  MOVLW  07
051F2:  ADDWF  x07,W
051F4:  MOVWF  FE9
051F6:  MOVLW  00
051F8:  ADDWFC x08,W
051FA:  MOVWF  FEA
051FC:  MOVF   FEF,W
051FE:  SUBLW  25
05200:  BC    5208
....................         valid_time = 2; 
05202:  MOVLW  02
05204:  MOVWF  x09
....................     } else if (obc_flags.gps_time_sync_state == 1 && boot_flags.deployment_flag >= 5) { 
05206:  BRA    53FE
05208:  MOVLB  0
0520A:  DECFSZ xF1,W
0520C:  BRA    53FC
0520E:  MOVF   xED,W
05210:  SUBLW  04
05212:  BTFSC  FD8.0
05214:  BRA    53FC
....................         valid_time = 1; 
05216:  MOVLW  01
05218:  MOVLB  A
0521A:  MOVWF  x09
....................         struct_tm gps_time; 
....................         gps_time.tm_year = packet->year + 100; 
0521C:  MOVLW  07
0521E:  ADDWF  x07,W
05220:  MOVWF  FE9
05222:  MOVLW  00
05224:  ADDWFC x08,W
05226:  MOVWF  FEA
05228:  MOVLW  64
0522A:  ADDWF  FEF,W
0522C:  MOVWF  x0F
0522E:  CLRF   x10
05230:  BTFSC  FD8.0
05232:  INCF   x0F,F
....................         gps_time.tm_mon = packet->month - 1; 
05234:  MOVLW  06
05236:  ADDWF  x07,W
05238:  MOVWF  FE9
0523A:  MOVLW  00
0523C:  ADDWFC x08,W
0523E:  MOVWF  FEA
05240:  MOVLW  01
05242:  SUBWF  FEF,W
05244:  MOVWF  x0E
....................         gps_time.tm_mday = packet->day; 
05246:  MOVLW  05
05248:  ADDWF  x07,W
0524A:  MOVWF  FE9
0524C:  MOVLW  00
0524E:  ADDWFC x08,W
05250:  MOVWF  FEA
05252:  MOVFF  FEF,A0D
....................         gps_time.tm_hour = packet->hour; 
05256:  MOVLW  02
05258:  ADDWF  x07,W
0525A:  MOVWF  FE9
0525C:  MOVLW  00
0525E:  ADDWFC x08,W
05260:  MOVWF  FEA
05262:  MOVFF  FEF,A0C
....................         gps_time.tm_min = packet->minute; 
05266:  MOVLW  03
05268:  ADDWF  x07,W
0526A:  MOVWF  FE9
0526C:  MOVLW  00
0526E:  ADDWFC x08,W
05270:  MOVWF  FEA
05272:  MOVFF  FEF,A0B
....................         gps_time.tm_sec = packet->second + obc_flags.leap_seconds; 
05276:  MOVLW  04
05278:  ADDWF  x07,W
0527A:  MOVWF  FE9
0527C:  MOVLW  00
0527E:  ADDWFC x08,W
05280:  MOVWF  FEA
05282:  MOVLB  0
05284:  MOVF   xEE,W
05286:  ADDWF  FEF,W
05288:  MOVLB  A
0528A:  MOVWF  x0A
....................  
....................         time_t unix_time = mktime(&gps_time); 
0528C:  MOVLW  0A
0528E:  MOVWF  x2E
05290:  MOVWF  x2D
05292:  MOVLB  0
05294:  CALL   1F56
05298:  MOVFF  03,A17
0529C:  MOVFF  02,A16
052A0:  MOVFF  01,A15
052A4:  MOVFF  00,A14
....................  
....................         SetTimeSec(unix_time + 1); 
052A8:  MOVLW  01
052AA:  MOVLB  A
052AC:  ADDWF  x14,W
052AE:  MOVWF  x18
052B0:  MOVLW  00
052B2:  ADDWFC x15,W
052B4:  MOVWF  x19
052B6:  MOVLW  00
052B8:  ADDWFC x16,W
052BA:  MOVWF  x1A
052BC:  MOVLW  00
052BE:  ADDWFC x17,W
052C0:  MOVWF  x1B
052C2:  MOVWF  x1F
052C4:  MOVFF  A1A,A1E
052C8:  MOVFF  A19,A1D
052CC:  MOVFF  A18,A1C
052D0:  MOVLB  0
052D2:  CALL   2886
....................         current_time = time(0); 
052D6:  MOVLB  A
052D8:  CLRF   x19
052DA:  CLRF   x18
052DC:  MOVLB  0
052DE:  CALL   23A6
052E2:  MOVFF  03,3C
052E6:  MOVFF  02,3B
052EA:  MOVFF  01,3A
052EE:  MOVFF  00,39
....................         reset_pic_update_clock(current_time); 
052F2:  MOVFF  3C,A1B
052F6:  MOVFF  3B,A1A
052FA:  MOVFF  3A,A19
052FE:  MOVFF  39,A18
05302:  RCALL  506E
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
05304:  MOVLW  02
05306:  MOVLB  A
05308:  MOVWF  x1C
0530A:  MOVFF  ED,A1D
0530E:  MOVFF  11D,A21
05312:  MOVFF  11C,A20
05316:  MOVFF  11B,A1F
0531A:  MOVFF  11A,A1E
0531E:  CLRF   x25
05320:  MOVLW  11
05322:  MOVWF  x24
05324:  CLRF   x23
05326:  CLRF   x22
05328:  CLRF   x29
0532A:  CLRF   x28
0532C:  CLRF   x27
0532E:  MOVLW  8C
05330:  MOVWF  x26
05332:  MOVLW  01
05334:  MOVWF  x2A
05336:  MOVWF  x2C
05338:  MOVLW  12
0533A:  MOVWF  x2B
0533C:  MOVLB  0
0533E:  CALL   3214
....................         fprintf(PC, "\r\nNew time: %04ld/%02d/%02d %02d:%02d:%02d", gps_time.tm_year + 1900, 
....................             (char)gps_time.tm_mon + 1, 
....................             gps_time.tm_mday, 
....................             gps_time.tm_hour, 
....................             gps_time.tm_min, 
....................             gps_time.tm_sec); 
05342:  MOVLW  6C
05344:  MOVLB  A
05346:  ADDWF  x0F,W
05348:  MOVWF  x18
0534A:  MOVLW  07
0534C:  ADDWFC x10,W
0534E:  MOVWF  x19
05350:  MOVLW  01
05352:  ADDWF  x0E,W
05354:  MOVWF  x1A
05356:  MOVLW  38
05358:  MOVWF  FF6
0535A:  MOVLW  04
0535C:  MOVWF  FF7
0535E:  MOVLW  00
05360:  MOVWF  FF8
05362:  MOVLW  0C
05364:  MOVWF  x3B
05366:  MOVLB  0
05368:  CALL   3048
0536C:  MOVLW  0A
0536E:  MOVWF  FE9
05370:  MOVFF  A19,A24
05374:  MOVFF  A18,A23
05378:  RCALL  4D28
0537A:  MOVLW  2F
0537C:  MOVLB  B
0537E:  MOVWF  x1F
05380:  MOVLB  0
05382:  CALL   1C34
05386:  MOVFF  A1A,A23
0538A:  MOVLW  01
0538C:  MOVLB  A
0538E:  MOVWF  x24
05390:  MOVLB  0
05392:  RCALL  4E28
05394:  MOVLW  2F
05396:  MOVLB  B
05398:  MOVWF  x1F
0539A:  MOVLB  0
0539C:  CALL   1C34
053A0:  MOVFF  A0D,A23
053A4:  MOVLW  01
053A6:  MOVLB  A
053A8:  MOVWF  x24
053AA:  MOVLB  0
053AC:  RCALL  4E28
053AE:  MOVLW  20
053B0:  MOVLB  B
053B2:  MOVWF  x1F
053B4:  MOVLB  0
053B6:  CALL   1C34
053BA:  MOVFF  A0C,A23
053BE:  MOVLW  01
053C0:  MOVLB  A
053C2:  MOVWF  x24
053C4:  MOVLB  0
053C6:  RCALL  4E28
053C8:  MOVLW  3A
053CA:  MOVLB  B
053CC:  MOVWF  x1F
053CE:  MOVLB  0
053D0:  CALL   1C34
053D4:  MOVFF  A0B,A23
053D8:  MOVLW  01
053DA:  MOVLB  A
053DC:  MOVWF  x24
053DE:  MOVLB  0
053E0:  RCALL  4E28
053E2:  MOVLW  3A
053E4:  MOVLB  B
053E6:  MOVWF  x1F
053E8:  MOVLB  0
053EA:  CALL   1C34
053EE:  MOVFF  A0A,A23
053F2:  MOVLW  01
053F4:  MOVLB  A
053F6:  MOVWF  x24
053F8:  MOVLB  0
053FA:  RCALL  4E28
053FC:  MOVLB  A
....................     } 
....................     return valid_time; 
053FE:  MOVFF  A09,01
05402:  MOVLB  0
05404:  GOTO   CC82 (RETURN)
.................... } 
....................  
.................... // ADCS copy high sampling data 
.................... uint8_t command_adcs_hs_copy(uint8_t* data) 
*
0879C:  MOVFF  A06,A08
087A0:  MOVFF  A05,A07
087A4:  MOVLW  02
087A6:  MOVLB  A
087A8:  ADDWF  x07,W
087AA:  MOVWF  FE9
087AC:  MOVLW  00
087AE:  ADDWFC x08,W
087B0:  MOVWF  FEA
087B2:  MOVFF  FEF,A21
087B6:  CLRF   01
087B8:  CLRF   02
087BA:  CLRF   03
087BC:  MOVFF  03,A24
087C0:  MOVFF  02,A23
087C4:  MOVFF  01,A22
087C8:  MOVLB  0
087CA:  BRA    83B2
087CC:  MOVLW  29
087CE:  MOVLB  A
087D0:  MOVWF  x34
087D2:  MOVLW  5C
087D4:  MOVWF  x33
087D6:  MOVLW  47
087D8:  MOVWF  x32
087DA:  MOVLW  81
087DC:  MOVWF  x31
087DE:  MOVFF  03,A38
087E2:  MOVFF  02,A37
087E6:  MOVFF  01,A36
087EA:  MOVFF  00,A35
087EE:  MOVLB  0
087F0:  RCALL  83EC
087F2:  MOVFF  FEA,A22
087F6:  MOVFF  FE9,A21
087FA:  BCF    FD8.1
087FC:  MOVLB  A
087FE:  CLRF   x33
08800:  MOVLW  E0
08802:  MOVWF  x32
08804:  MOVLW  64
08806:  MOVWF  x31
08808:  MOVLW  89
0880A:  MOVWF  x30
0880C:  MOVFF  03,A37
08810:  MOVFF  02,A36
08814:  MOVFF  01,A35
08818:  MOVFF  00,A34
0881C:  MOVLB  0
0881E:  RCALL  84E2
08820:  MOVFF  A22,FEA
08824:  MOVFF  A21,FE9
08828:  MOVFF  03,A26
0882C:  MOVFF  02,A25
08830:  MOVFF  01,A24
08834:  MOVFF  00,A23
08838:  MOVFF  03,A34
0883C:  MOVFF  02,A33
08840:  MOVFF  01,A32
08844:  MOVFF  00,A31
08848:  MOVLB  A
0884A:  CLRF   x38
0884C:  CLRF   x37
0884E:  CLRF   x36
08850:  MOVLW  8F
08852:  MOVWF  x35
08854:  MOVLB  0
08856:  RCALL  83EC
08858:  MOVFF  03,A34
0885C:  MOVFF  02,A33
08860:  MOVFF  01,A32
08864:  MOVFF  00,A31
08868:  RCALL  875A
0886A:  MOVFF  03,A0C
0886E:  MOVFF  02,A0B
08872:  MOVFF  01,A0A
08876:  MOVFF  00,A09
0887A:  MOVLW  05
0887C:  MOVLB  A
0887E:  MOVWF  x10
08880:  MOVLW  ED
08882:  MOVWF  x0F
08884:  CLRF   x0E
08886:  CLRF   x0D
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t slots_30m; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t source_address = (1831UL + 6.23 * (uint32_t)packet->slots_30m) * MEMORY_SECTOR_SIZE; 
....................     uint32_t destination_address = FLASH_ADCS_HS_START; 
....................     const uint32_t n_packets = 6.23 * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "\r\n"); 
08888:  MOVLW  0D
0888A:  MOVLB  B
0888C:  MOVWF  x1F
0888E:  MOVLB  0
08890:  CALL   1C34
08894:  MOVLW  0A
08896:  MOVLB  B
08898:  MOVWF  x1F
0889A:  MOVLB  0
0889C:  CALL   1C34
....................     fprintf(PC, "Copy ADCS HS data to Main PIC\r\n"); 
088A0:  MOVLW  64
088A2:  MOVWF  FF6
088A4:  MOVLW  04
088A6:  MOVWF  FF7
088A8:  MOVLW  00
088AA:  MOVWF  FF8
088AC:  CALL   1C7A
....................     fprintf(PC, "Source address      = 0x%8lX\r\n", source_address); 
088B0:  MOVLW  84
088B2:  MOVWF  FF6
088B4:  MOVLW  04
088B6:  MOVWF  FF7
088B8:  MOVLW  00
088BA:  MOVWF  FF8
088BC:  MOVLW  18
088BE:  MOVLB  A
088C0:  MOVWF  x3B
088C2:  MOVLB  0
088C4:  CALL   3048
088C8:  MOVFF  A0C,A58
088CC:  MOVLW  37
088CE:  MOVLB  A
088D0:  MOVWF  x59
088D2:  MOVLB  0
088D4:  CALL   3142
088D8:  MOVFF  A0B,A58
088DC:  MOVLW  37
088DE:  MOVLB  A
088E0:  MOVWF  x59
088E2:  MOVLB  0
088E4:  CALL   3142
088E8:  MOVFF  A0A,A58
088EC:  MOVLW  37
088EE:  MOVLB  A
088F0:  MOVWF  x59
088F2:  MOVLB  0
088F4:  CALL   3142
088F8:  MOVFF  A09,A58
088FC:  MOVLW  37
088FE:  MOVLB  A
08900:  MOVWF  x59
08902:  MOVLB  0
08904:  CALL   3142
08908:  MOVLW  0D
0890A:  MOVLB  B
0890C:  MOVWF  x1F
0890E:  MOVLB  0
08910:  CALL   1C34
08914:  MOVLW  0A
08916:  MOVLB  B
08918:  MOVWF  x1F
0891A:  MOVLB  0
0891C:  CALL   1C34
....................     fprintf(PC, "Destination address = 0x%8lX\r\n", destination_address); 
08920:  MOVLW  A4
08922:  MOVWF  FF6
08924:  MOVLW  04
08926:  MOVWF  FF7
08928:  MOVLW  00
0892A:  MOVWF  FF8
0892C:  MOVLW  18
0892E:  MOVLB  A
08930:  MOVWF  x3B
08932:  MOVLB  0
08934:  CALL   3048
08938:  MOVFF  A10,A58
0893C:  MOVLW  37
0893E:  MOVLB  A
08940:  MOVWF  x59
08942:  MOVLB  0
08944:  CALL   3142
08948:  MOVFF  A0F,A58
0894C:  MOVLW  37
0894E:  MOVLB  A
08950:  MOVWF  x59
08952:  MOVLB  0
08954:  CALL   3142
08958:  MOVFF  A0E,A58
0895C:  MOVLW  37
0895E:  MOVLB  A
08960:  MOVWF  x59
08962:  MOVLB  0
08964:  CALL   3142
08968:  MOVFF  A0D,A58
0896C:  MOVLW  37
0896E:  MOVLB  A
08970:  MOVWF  x59
08972:  MOVLB  0
08974:  CALL   3142
08978:  MOVLW  0D
0897A:  MOVLB  B
0897C:  MOVWF  x1F
0897E:  MOVLB  0
08980:  CALL   1C34
08984:  MOVLW  0A
08986:  MOVLB  B
08988:  MOVWF  x1F
0898A:  MOVLB  0
0898C:  CALL   1C34
....................     fprintf(PC, "Size                = %lu\r\n", n_packets); 
08990:  MOVLW  C4
08992:  MOVWF  FF6
08994:  MOVLW  04
08996:  MOVWF  FF7
08998:  MOVLW  00
0899A:  MOVWF  FF8
0899C:  MOVLW  16
0899E:  MOVLB  A
089A0:  MOVWF  x3B
089A2:  MOVLB  0
089A4:  CALL   3048
089A8:  MOVLW  41
089AA:  MOVWF  FE9
089AC:  MOVLB  A
089AE:  CLRF   x28
089B0:  CLRF   x27
089B2:  MOVLW  0C
089B4:  MOVWF  x26
089B6:  MOVLW  75
089B8:  MOVWF  x25
089BA:  MOVLB  0
089BC:  CALL   802E
089C0:  MOVLW  0D
089C2:  MOVLB  B
089C4:  MOVWF  x1F
089C6:  MOVLB  0
089C8:  CALL   1C34
089CC:  MOVLW  0A
089CE:  MOVLB  B
089D0:  MOVWF  x1F
089D2:  MOVLB  0
089D4:  CALL   1C34
....................  
....................     struct xmodem_command { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D1 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     } xmodem_command; 
....................     xmodem_command.origin = 0xC0; 
089D8:  MOVLW  C0
089DA:  MOVLB  A
089DC:  MOVWF  x11
....................     xmodem_command.command = 0xD1; 
089DE:  MOVLW  D1
089E0:  MOVWF  x12
....................     xmodem_command.destination_address = destination_address; 
089E2:  MOVFF  A10,A16
089E6:  MOVFF  A0F,A15
089EA:  MOVFF  A0E,A14
089EE:  MOVFF  A0D,A13
....................     xmodem_command.source = 3;      // ADCS 
089F2:  MOVLW  03
089F4:  MOVWF  x17
....................     xmodem_command.destination = 0; // 0: COM Shared FM 
089F6:  CLRF   x18
....................     xmodem_command.source_address = source_address; 
089F8:  MOVFF  A0C,A1C
089FC:  MOVFF  A0B,A1B
08A00:  MOVFF  A0A,A1A
08A04:  MOVFF  A09,A19
....................     xmodem_command.n_packets = n_packets; 
08A08:  CLRF   x20
08A0A:  CLRF   x1F
08A0C:  MOVLW  0C
08A0E:  MOVWF  x1E
08A10:  MOVLW  75
08A12:  MOVWF  x1D
....................  
....................     uart_print_pc_hex((uint8_t*)&xmodem_command, sizeof(xmodem_command)); 
08A14:  MOVLW  0A
08A16:  MOVWF  x22
08A18:  MOVLW  11
08A1A:  MOVWF  x21
08A1C:  MOVFF  A22,A54
08A20:  MOVWF  x53
08A22:  MOVLW  10
08A24:  MOVWF  x55
08A26:  MOVLB  0
08A28:  CALL   4EF0
....................     vschedule(current_time + 1, (uint8_t*)&xmodem_command); 
08A2C:  MOVLW  01
08A2E:  ADDWF  39,W
08A30:  MOVLB  A
08A32:  MOVWF  x21
08A34:  MOVLW  00
08A36:  ADDWFC 3A,W
08A38:  MOVWF  x22
08A3A:  MOVLW  00
08A3C:  ADDWFC 3B,W
08A3E:  MOVWF  x23
08A40:  MOVLW  00
08A42:  ADDWFC 3C,W
08A44:  MOVWF  x24
08A46:  MOVLW  0A
08A48:  MOVWF  x26
08A4A:  MOVLW  11
08A4C:  MOVWF  x25
08A4E:  MOVFF  A24,A2E
08A52:  MOVFF  A23,A2D
08A56:  MOVFF  A22,A2C
08A5A:  MOVFF  A21,A2B
08A5E:  MOVFF  A26,A30
08A62:  MOVWF  x2F
08A64:  MOVLB  0
08A66:  CALL   4600
....................     return 0; 
08A6A:  MOVLW  00
08A6C:  MOVWF  01
08A6E:  GOTO   CE9E (RETURN)
.................... } 
....................  
.................... // ADCS copy GPS data 
.................... uint8_t command_adcs_gps_copy(uint8_t* data) 
*
080F2:  MOVFF  A06,A08
080F6:  MOVFF  A05,A07
080FA:  MOVLW  02
080FC:  MOVLB  A
080FE:  ADDWF  x07,W
08100:  MOVWF  FE9
08102:  MOVLW  00
08104:  ADDWFC x08,W
08106:  MOVWF  FEA
08108:  MOVFF  FEF,00
0810C:  CLRF   01
0810E:  CLRF   02
08110:  CLRF   03
08112:  MOVFF  03,A24
08116:  MOVFF  02,A23
0811A:  MOVFF  01,A22
0811E:  MOVFF  00,A21
08122:  MOVFF  FEA,A26
08126:  MOVFF  FE9,A25
0812A:  CLRF   x5A
0812C:  CLRF   x59
0812E:  CLRF   x58
08130:  MOVLW  05
08132:  MOVWF  x57
08134:  MOVFF  03,A5E
08138:  MOVFF  02,A5D
0813C:  MOVFF  01,A5C
08140:  MOVFF  00,A5B
08144:  MOVLB  0
08146:  CALL   1CB4
0814A:  MOVFF  A26,FEA
0814E:  MOVFF  A25,FE9
08152:  MOVLW  C3
08154:  ADDWF  00,W
08156:  MOVLB  A
08158:  MOVWF  x21
0815A:  MOVLW  07
0815C:  ADDWFC 01,W
0815E:  MOVWF  x22
08160:  MOVLW  00
08162:  ADDWFC 02,W
08164:  MOVLW  00
08166:  ADDWFC 03,W
08168:  MOVFF  A22,A0C
0816C:  MOVFF  A21,A0B
08170:  CLRF   x09
08172:  CLRF   x0A
08174:  MOVLW  05
08176:  MOVWF  x10
08178:  MOVLW  F4
0817A:  MOVWF  x0F
0817C:  CLRF   x0E
0817E:  CLRF   x0D
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t slots_1h; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t source_address = (1987UL + 5UL * (uint32_t)packet->slots_1h) * MEMORY_SECTOR_SIZE; 
....................     uint32_t destination_address = FLASH_ADCS_GPS_START; 
....................     const uint32_t n_packets = 5UL * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "\r\n"); 
08180:  MOVLW  0D
08182:  MOVLB  B
08184:  MOVWF  x1F
08186:  MOVLB  0
08188:  CALL   1C34
0818C:  MOVLW  0A
0818E:  MOVLB  B
08190:  MOVWF  x1F
08192:  MOVLB  0
08194:  CALL   1C34
....................     fprintf(PC, "Copy GPS data to Main PIC\r\n"); 
08198:  MOVLW  E0
0819A:  MOVWF  FF6
0819C:  MOVLW  04
0819E:  MOVWF  FF7
081A0:  MOVLW  00
081A2:  MOVWF  FF8
081A4:  CALL   1C7A
....................     fprintf(PC, "1h slots            = %d\r\n", packet->slots_1h); 
081A8:  MOVLW  02
081AA:  MOVLB  A
081AC:  ADDWF  x07,W
081AE:  MOVWF  FE9
081B0:  MOVLW  00
081B2:  ADDWFC x08,W
081B4:  MOVWF  FEA
081B6:  MOVFF  FEF,A21
081BA:  MOVLW  FC
081BC:  MOVWF  FF6
081BE:  MOVLW  04
081C0:  MOVWF  FF7
081C2:  MOVLW  00
081C4:  MOVWF  FF8
081C6:  MOVLW  16
081C8:  MOVWF  x3B
081CA:  MOVLB  0
081CC:  CALL   3048
081D0:  MOVFF  A21,A25
081D4:  MOVLW  18
081D6:  MOVLB  A
081D8:  MOVWF  x26
081DA:  MOVLB  0
081DC:  CALL   4960
081E0:  MOVLW  0D
081E2:  MOVLB  B
081E4:  MOVWF  x1F
081E6:  MOVLB  0
081E8:  CALL   1C34
081EC:  MOVLW  0A
081EE:  MOVLB  B
081F0:  MOVWF  x1F
081F2:  MOVLB  0
081F4:  CALL   1C34
....................     fprintf(PC, "Source address      = 0x%8lX\r\n", source_address); 
081F8:  MOVLW  18
081FA:  MOVWF  FF6
081FC:  MOVLW  05
081FE:  MOVWF  FF7
08200:  MOVLW  00
08202:  MOVWF  FF8
08204:  MOVLW  18
08206:  MOVLB  A
08208:  MOVWF  x3B
0820A:  MOVLB  0
0820C:  CALL   3048
08210:  MOVFF  A0C,A58
08214:  MOVLW  37
08216:  MOVLB  A
08218:  MOVWF  x59
0821A:  MOVLB  0
0821C:  CALL   3142
08220:  MOVFF  A0B,A58
08224:  MOVLW  37
08226:  MOVLB  A
08228:  MOVWF  x59
0822A:  MOVLB  0
0822C:  CALL   3142
08230:  MOVFF  A0A,A58
08234:  MOVLW  37
08236:  MOVLB  A
08238:  MOVWF  x59
0823A:  MOVLB  0
0823C:  CALL   3142
08240:  MOVFF  A09,A58
08244:  MOVLW  37
08246:  MOVLB  A
08248:  MOVWF  x59
0824A:  MOVLB  0
0824C:  CALL   3142
08250:  MOVLW  0D
08252:  MOVLB  B
08254:  MOVWF  x1F
08256:  MOVLB  0
08258:  CALL   1C34
0825C:  MOVLW  0A
0825E:  MOVLB  B
08260:  MOVWF  x1F
08262:  MOVLB  0
08264:  CALL   1C34
....................     fprintf(PC, "Destination address = 0x%8lX\r\n", destination_address); 
08268:  MOVLW  38
0826A:  MOVWF  FF6
0826C:  MOVLW  05
0826E:  MOVWF  FF7
08270:  MOVLW  00
08272:  MOVWF  FF8
08274:  MOVLW  18
08276:  MOVLB  A
08278:  MOVWF  x3B
0827A:  MOVLB  0
0827C:  CALL   3048
08280:  MOVFF  A10,A58
08284:  MOVLW  37
08286:  MOVLB  A
08288:  MOVWF  x59
0828A:  MOVLB  0
0828C:  CALL   3142
08290:  MOVFF  A0F,A58
08294:  MOVLW  37
08296:  MOVLB  A
08298:  MOVWF  x59
0829A:  MOVLB  0
0829C:  CALL   3142
082A0:  MOVFF  A0E,A58
082A4:  MOVLW  37
082A6:  MOVLB  A
082A8:  MOVWF  x59
082AA:  MOVLB  0
082AC:  CALL   3142
082B0:  MOVFF  A0D,A58
082B4:  MOVLW  37
082B6:  MOVLB  A
082B8:  MOVWF  x59
082BA:  MOVLB  0
082BC:  CALL   3142
082C0:  MOVLW  0D
082C2:  MOVLB  B
082C4:  MOVWF  x1F
082C6:  MOVLB  0
082C8:  CALL   1C34
082CC:  MOVLW  0A
082CE:  MOVLB  B
082D0:  MOVWF  x1F
082D2:  MOVLB  0
082D4:  CALL   1C34
....................     fprintf(PC, "Size                = %lu\r\n", n_packets); 
082D8:  MOVLW  58
082DA:  MOVWF  FF6
082DC:  MOVLW  05
082DE:  MOVWF  FF7
082E0:  MOVLW  00
082E2:  MOVWF  FF8
082E4:  MOVLW  16
082E6:  MOVLB  A
082E8:  MOVWF  x3B
082EA:  MOVLB  0
082EC:  CALL   3048
082F0:  MOVLW  41
082F2:  MOVWF  FE9
082F4:  MOVLB  A
082F6:  CLRF   x28
082F8:  CLRF   x27
082FA:  MOVLW  0A
082FC:  MOVWF  x26
082FE:  CLRF   x25
08300:  MOVLB  0
08302:  RCALL  802E
08304:  MOVLW  0D
08306:  MOVLB  B
08308:  MOVWF  x1F
0830A:  MOVLB  0
0830C:  CALL   1C34
08310:  MOVLW  0A
08312:  MOVLB  B
08314:  MOVWF  x1F
08316:  MOVLB  0
08318:  CALL   1C34
....................  
....................     struct xmodem_command { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D1 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     } xmodem_command; 
....................     xmodem_command.origin = 0xC0; 
0831C:  MOVLW  C0
0831E:  MOVLB  A
08320:  MOVWF  x11
....................     xmodem_command.command = 0xD1; 
08322:  MOVLW  D1
08324:  MOVWF  x12
....................     xmodem_command.destination_address = destination_address; 
08326:  MOVFF  A10,A16
0832A:  MOVFF  A0F,A15
0832E:  MOVFF  A0E,A14
08332:  MOVFF  A0D,A13
....................     xmodem_command.source = 3;      // ADCS 
08336:  MOVLW  03
08338:  MOVWF  x17
....................     xmodem_command.destination = 0; // 0: COM Shared FM 
0833A:  CLRF   x18
....................     xmodem_command.source_address = source_address; 
0833C:  MOVFF  A0C,A1C
08340:  MOVFF  A0B,A1B
08344:  MOVFF  A0A,A1A
08348:  MOVFF  A09,A19
....................     xmodem_command.n_packets = n_packets; 
0834C:  CLRF   x20
0834E:  CLRF   x1F
08350:  MOVLW  0A
08352:  MOVWF  x1E
08354:  CLRF   x1D
....................  
....................     uart_print_pc_hex((uint8_t*)&xmodem_command, sizeof(xmodem_command)); 
08356:  MOVWF  x22
08358:  MOVLW  11
0835A:  MOVWF  x21
0835C:  MOVFF  A22,A54
08360:  MOVWF  x53
08362:  MOVLW  10
08364:  MOVWF  x55
08366:  MOVLB  0
08368:  CALL   4EF0
....................     vschedule(current_time + 1, (uint8_t*)&xmodem_command); 
0836C:  MOVLW  01
0836E:  ADDWF  39,W
08370:  MOVLB  A
08372:  MOVWF  x21
08374:  MOVLW  00
08376:  ADDWFC 3A,W
08378:  MOVWF  x22
0837A:  MOVLW  00
0837C:  ADDWFC 3B,W
0837E:  MOVWF  x23
08380:  MOVLW  00
08382:  ADDWFC 3C,W
08384:  MOVWF  x24
08386:  MOVLW  0A
08388:  MOVWF  x26
0838A:  MOVLW  11
0838C:  MOVWF  x25
0838E:  MOVFF  A24,A2E
08392:  MOVFF  A23,A2D
08396:  MOVFF  A22,A2C
0839A:  MOVFF  A21,A2B
0839E:  MOVFF  A26,A30
083A2:  MOVWF  x2F
083A4:  MOVLB  0
083A6:  CALL   4600
....................     return 0; 
083AA:  MOVLW  00
083AC:  MOVWF  01
083AE:  GOTO   CE8C (RETURN)
.................... } 
....................  
.................... // Copy ADCS data to COM shared FM 
.................... uint8_t command_copy_adcs_data_to_uhf(uint8_t* data) 
*
0A554:  MOVFF  A06,A08
0A558:  MOVFF  A05,A07
0A55C:  MOVLW  02
0A55E:  MOVLB  A
0A560:  ADDWF  x07,W
0A562:  MOVWF  FE9
0A564:  MOVLW  00
0A566:  ADDWFC x08,W
0A568:  MOVWF  FEA
0A56A:  MOVFF  FEC,03
0A56E:  MOVF   FED,F
0A570:  MOVFF  FEF,A57
0A574:  MOVFF  03,A26
0A578:  CLRF   x27
0A57A:  CLRF   x28
0A57C:  MOVFF  FEA,A2A
0A580:  MOVFF  FE9,A29
0A584:  MOVFF  A28,A5A
0A588:  MOVFF  A27,A59
0A58C:  MOVFF  03,A58
0A590:  CLRF   x5E
0A592:  CLRF   x5D
0A594:  CLRF   x5C
0A596:  MOVLW  05
0A598:  MOVWF  x5B
0A59A:  MOVLB  0
0A59C:  CALL   1CB4
0A5A0:  MOVFF  A2A,FEA
0A5A4:  MOVFF  A29,FE9
0A5A8:  MOVLW  01
0A5AA:  ADDWF  00,W
0A5AC:  MOVLB  A
0A5AE:  MOVWF  x25
0A5B0:  MOVLW  00
0A5B2:  ADDWFC 01,W
0A5B4:  MOVWF  x26
0A5B6:  MOVLW  00
0A5B8:  ADDWFC 02,W
0A5BA:  MOVWF  x27
0A5BC:  MOVLW  00
0A5BE:  ADDWFC 03,W
0A5C0:  MOVWF  x28
0A5C2:  MOVFF  A26,A0C
0A5C6:  MOVFF  A25,A0B
0A5CA:  CLRF   x09
0A5CC:  CLRF   x0A
0A5CE:  MOVLW  04
0A5D0:  ADDWF  x07,W
0A5D2:  MOVWF  FE9
0A5D4:  MOVLW  00
0A5D6:  ADDWFC x08,W
0A5D8:  MOVWF  FEA
0A5DA:  MOVF   FEF,W
0A5DC:  CLRF   x28
0A5DE:  CLRF   x27
0A5E0:  CLRF   x26
0A5E2:  MOVWF  x25
0A5E4:  MOVFF  FEA,A2C
0A5E8:  MOVFF  FE9,A2B
0A5EC:  MOVFF  A28,A5A
0A5F0:  MOVFF  A27,A59
0A5F4:  MOVFF  A26,A58
0A5F8:  MOVWF  x57
0A5FA:  CLRF   x5E
0A5FC:  CLRF   x5D
0A5FE:  CLRF   x5C
0A600:  MOVLW  05
0A602:  MOVWF  x5B
0A604:  MOVLB  0
0A606:  CALL   1CB4
0A60A:  MOVFF  A2C,FEA
0A60E:  MOVFF  A2B,FE9
0A612:  MOVFF  03,A28
0A616:  MOVFF  02,A27
0A61A:  MOVFF  01,A26
0A61E:  MOVFF  00,A25
0A622:  MOVFF  01,03
0A626:  MOVFF  00,02
0A62A:  CLRF   00
0A62C:  CLRF   01
0A62E:  MOVFF  00,A0D
0A632:  MOVLB  A
0A634:  MOVFF  01,A0E
0A638:  MOVLW  F9
0A63A:  ADDWF  02,W
0A63C:  MOVWF  x0F
0A63E:  MOVLW  05
0A640:  ADDWFC 03,W
0A642:  MOVWF  x10
0A644:  CLRF   x14
0A646:  CLRF   x13
0A648:  MOVLW  0A
0A64A:  MOVWF  x12
0A64C:  CLRF   x11
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t day_of_the_year; 
....................         uint8_t slot; 
....................     }* packet = (struct packet*)data; 
....................  
....................     const uint8_t sectors_per_day = 5; 
....................     uint32_t source_address = (1UL + (uint32_t)packet->day_of_the_year * (uint32_t)sectors_per_day) * MEMORY_SECTOR_SIZE; 
....................     uint32_t destination_address = FLASH_ADCS_TELEMETRY_START + (uint32_t)packet->slot * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     uint32_t n_packets = 5UL * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "\r\n"); 
0A64E:  MOVLW  0D
0A650:  MOVLB  B
0A652:  MOVWF  x1F
0A654:  MOVLB  0
0A656:  CALL   1C34
0A65A:  MOVLW  0A
0A65C:  MOVLB  B
0A65E:  MOVWF  x1F
0A660:  MOVLB  0
0A662:  CALL   1C34
....................     fprintf(PC, "Copy ADCS data to Main PIC\r\n"); 
0A666:  MOVLW  74
0A668:  MOVWF  FF6
0A66A:  MOVLW  05
0A66C:  MOVWF  FF7
0A66E:  MOVLW  00
0A670:  MOVWF  FF8
0A672:  CALL   1C7A
....................     fprintf(PC, "Day of the year     = %lu\r\n", packet->day_of_the_year + 1); 
0A676:  MOVLW  02
0A678:  MOVLB  A
0A67A:  ADDWF  x07,W
0A67C:  MOVWF  FE9
0A67E:  MOVLW  00
0A680:  ADDWFC x08,W
0A682:  MOVWF  FEA
0A684:  MOVFF  FEC,A26
0A688:  MOVF   FED,F
0A68A:  MOVFF  FEF,A25
0A68E:  MOVLW  01
0A690:  ADDWF  x25,F
0A692:  MOVLW  00
0A694:  ADDWFC x26,F
0A696:  MOVLW  92
0A698:  MOVWF  FF6
0A69A:  MOVLW  05
0A69C:  MOVWF  FF7
0A69E:  MOVLW  00
0A6A0:  MOVWF  FF8
0A6A2:  MOVLW  16
0A6A4:  MOVWF  x3B
0A6A6:  MOVLB  0
0A6A8:  CALL   3048
0A6AC:  MOVLW  10
0A6AE:  MOVWF  FE9
0A6B0:  MOVFF  A26,A3C
0A6B4:  MOVFF  A25,A3B
0A6B8:  CALL   307A
0A6BC:  MOVLW  0D
0A6BE:  MOVLB  B
0A6C0:  MOVWF  x1F
0A6C2:  MOVLB  0
0A6C4:  CALL   1C34
0A6C8:  MOVLW  0A
0A6CA:  MOVLB  B
0A6CC:  MOVWF  x1F
0A6CE:  MOVLB  0
0A6D0:  CALL   1C34
....................     fprintf(PC, "Source address      = 0x%8lX\r\n", source_address); 
0A6D4:  MOVLW  AE
0A6D6:  MOVWF  FF6
0A6D8:  MOVLW  05
0A6DA:  MOVWF  FF7
0A6DC:  MOVLW  00
0A6DE:  MOVWF  FF8
0A6E0:  MOVLW  18
0A6E2:  MOVLB  A
0A6E4:  MOVWF  x3B
0A6E6:  MOVLB  0
0A6E8:  CALL   3048
0A6EC:  MOVFF  A0C,A58
0A6F0:  MOVLW  37
0A6F2:  MOVLB  A
0A6F4:  MOVWF  x59
0A6F6:  MOVLB  0
0A6F8:  CALL   3142
0A6FC:  MOVFF  A0B,A58
0A700:  MOVLW  37
0A702:  MOVLB  A
0A704:  MOVWF  x59
0A706:  MOVLB  0
0A708:  CALL   3142
0A70C:  MOVFF  A0A,A58
0A710:  MOVLW  37
0A712:  MOVLB  A
0A714:  MOVWF  x59
0A716:  MOVLB  0
0A718:  CALL   3142
0A71C:  MOVFF  A09,A58
0A720:  MOVLW  37
0A722:  MOVLB  A
0A724:  MOVWF  x59
0A726:  MOVLB  0
0A728:  CALL   3142
0A72C:  MOVLW  0D
0A72E:  MOVLB  B
0A730:  MOVWF  x1F
0A732:  MOVLB  0
0A734:  CALL   1C34
0A738:  MOVLW  0A
0A73A:  MOVLB  B
0A73C:  MOVWF  x1F
0A73E:  MOVLB  0
0A740:  CALL   1C34
....................     fprintf(PC, "Destination address = 0x%8lX\r\n", destination_address); 
0A744:  MOVLW  CE
0A746:  MOVWF  FF6
0A748:  MOVLW  05
0A74A:  MOVWF  FF7
0A74C:  MOVLW  00
0A74E:  MOVWF  FF8
0A750:  MOVLW  18
0A752:  MOVLB  A
0A754:  MOVWF  x3B
0A756:  MOVLB  0
0A758:  CALL   3048
0A75C:  MOVFF  A10,A58
0A760:  MOVLW  37
0A762:  MOVLB  A
0A764:  MOVWF  x59
0A766:  MOVLB  0
0A768:  CALL   3142
0A76C:  MOVFF  A0F,A58
0A770:  MOVLW  37
0A772:  MOVLB  A
0A774:  MOVWF  x59
0A776:  MOVLB  0
0A778:  CALL   3142
0A77C:  MOVFF  A0E,A58
0A780:  MOVLW  37
0A782:  MOVLB  A
0A784:  MOVWF  x59
0A786:  MOVLB  0
0A788:  CALL   3142
0A78C:  MOVFF  A0D,A58
0A790:  MOVLW  37
0A792:  MOVLB  A
0A794:  MOVWF  x59
0A796:  MOVLB  0
0A798:  CALL   3142
0A79C:  MOVLW  0D
0A79E:  MOVLB  B
0A7A0:  MOVWF  x1F
0A7A2:  MOVLB  0
0A7A4:  CALL   1C34
0A7A8:  MOVLW  0A
0A7AA:  MOVLB  B
0A7AC:  MOVWF  x1F
0A7AE:  MOVLB  0
0A7B0:  CALL   1C34
....................     fprintf(PC, "Size                = %lu\r\n", n_packets); 
0A7B4:  MOVLW  EE
0A7B6:  MOVWF  FF6
0A7B8:  MOVLW  05
0A7BA:  MOVWF  FF7
0A7BC:  MOVLW  00
0A7BE:  MOVWF  FF8
0A7C0:  MOVLW  16
0A7C2:  MOVLB  A
0A7C4:  MOVWF  x3B
0A7C6:  MOVLB  0
0A7C8:  CALL   3048
0A7CC:  MOVLW  41
0A7CE:  MOVWF  FE9
0A7D0:  MOVFF  A14,A28
0A7D4:  MOVFF  A13,A27
0A7D8:  MOVFF  A12,A26
0A7DC:  MOVFF  A11,A25
0A7E0:  CALL   802E
0A7E4:  MOVLW  0D
0A7E6:  MOVLB  B
0A7E8:  MOVWF  x1F
0A7EA:  MOVLB  0
0A7EC:  CALL   1C34
0A7F0:  MOVLW  0A
0A7F2:  MOVLB  B
0A7F4:  MOVWF  x1F
0A7F6:  MOVLB  0
0A7F8:  CALL   1C34
....................  
....................     struct xmodem_command { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D1 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     } xmodem_command; 
....................     xmodem_command.origin = 0xC0; 
0A7FC:  MOVLW  C0
0A7FE:  MOVLB  A
0A800:  MOVWF  x15
....................     xmodem_command.command = 0xD1; 
0A802:  MOVLW  D1
0A804:  MOVWF  x16
....................     xmodem_command.destination_address = destination_address; 
0A806:  MOVFF  A10,A1A
0A80A:  MOVFF  A0F,A19
0A80E:  MOVFF  A0E,A18
0A812:  MOVFF  A0D,A17
....................     xmodem_command.source = 3;      // ADCS 
0A816:  MOVLW  03
0A818:  MOVWF  x1B
....................     xmodem_command.destination = 0; // 0: COM Shared FM 
0A81A:  CLRF   x1C
....................     xmodem_command.source_address = source_address; 
0A81C:  MOVFF  A0C,A20
0A820:  MOVFF  A0B,A1F
0A824:  MOVFF  A0A,A1E
0A828:  MOVFF  A09,A1D
....................     xmodem_command.n_packets = n_packets; 
0A82C:  MOVFF  A14,A24
0A830:  MOVFF  A13,A23
0A834:  MOVFF  A12,A22
0A838:  MOVFF  A11,A21
....................  
....................     uart_print_pc_hex((uint8_t*)&xmodem_command, sizeof(xmodem_command)); 
0A83C:  MOVLW  0A
0A83E:  MOVWF  x26
0A840:  MOVLW  15
0A842:  MOVWF  x25
0A844:  MOVFF  A26,A54
0A848:  MOVWF  x53
0A84A:  MOVLW  10
0A84C:  MOVWF  x55
0A84E:  MOVLB  0
0A850:  CALL   4EF0
....................     vschedule(current_time + 1, (uint8_t*)&xmodem_command); 
0A854:  MOVLW  01
0A856:  ADDWF  39,W
0A858:  MOVLB  A
0A85A:  MOVWF  x25
0A85C:  MOVLW  00
0A85E:  ADDWFC 3A,W
0A860:  MOVWF  x26
0A862:  MOVLW  00
0A864:  ADDWFC 3B,W
0A866:  MOVWF  x27
0A868:  MOVLW  00
0A86A:  ADDWFC 3C,W
0A86C:  MOVWF  x28
0A86E:  MOVLW  0A
0A870:  MOVWF  x2A
0A872:  MOVLW  15
0A874:  MOVWF  x29
0A876:  MOVFF  A28,A2E
0A87A:  MOVFF  A27,A2D
0A87E:  MOVFF  A26,A2C
0A882:  MOVFF  A25,A2B
0A886:  MOVFF  A2A,A30
0A88A:  MOVWF  x2F
0A88C:  MOVLB  0
0A88E:  CALL   4600
....................  
....................     return 0; 
0A892:  MOVLW  00
0A894:  MOVWF  01
0A896:  GOTO   CF88 (RETURN)
.................... } 
....................  
.................... // ============ COM Commands ============ 
....................  
.................... // Message from UHF 
.................... uint8_t command_uhf_message(uint8_t* data) 
*
06EAE:  MOVFF  A06,A08
06EB2:  MOVFF  A05,A07
.................... { 
....................     enum { length = 22 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t gs_message[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     static uint8_t last_upload[length] = { 0 }; // Stores the last uploaded command 
....................     static time_t last_upload_t = 0; 
....................  
....................     fprintf(PC, "Uplink: "); 
06EB6:  MOVLW  0A
06EB8:  MOVWF  FF6
06EBA:  MOVLW  06
06EBC:  MOVWF  FF7
06EBE:  MOVLW  00
06EC0:  MOVWF  FF8
06EC2:  CALL   1C7A
....................     uart_print_pc_hex(packet->gs_message, length); 
06EC6:  MOVLW  01
06EC8:  MOVLB  A
06ECA:  ADDWF  x07,W
06ECC:  MOVWF  01
06ECE:  MOVLW  00
06ED0:  ADDWFC x08,W
06ED2:  MOVWF  03
06ED4:  MOVFF  01,A25
06ED8:  MOVWF  x26
06EDA:  MOVWF  x54
06EDC:  MOVFF  01,A53
06EE0:  MOVLW  16
06EE2:  MOVWF  x55
06EE4:  MOVLB  0
06EE6:  CALL   4EF0
....................     uint8_t valid = uplink_valid(packet->gs_message); 
....................     uint8_t different = memcmp(last_upload, packet->gs_message, length) || (last_upload_t <= (current_time - 4 * 60)); // Commands are different within 4 min window 
06EEA:  MOVLW  01
06EEC:  MOVLB  A
06EEE:  ADDWF  x07,W
06EF0:  MOVWF  01
06EF2:  MOVLW  00
06EF4:  ADDWFC x08,W
06EF6:  MOVWF  03
06EF8:  MOVFF  01,A25
06EFC:  MOVWF  x26
06EFE:  MOVWF  x28
06F00:  MOVFF  01,A27
06F04:  MOVLB  0
06F06:  BRA    6D5A
06F08:  MOVFF  01,A09
06F0C:  MOVLW  01
06F0E:  MOVLB  A
06F10:  ADDWF  x07,W
06F12:  MOVWF  01
06F14:  MOVLW  00
06F16:  ADDWFC x08,W
06F18:  MOVWF  03
06F1A:  MOVFF  01,A25
06F1E:  MOVWF  x26
06F20:  MOVLW  09
06F22:  MOVWF  x28
06F24:  MOVLW  39
06F26:  MOVWF  x27
06F28:  MOVFF  03,A2A
06F2C:  MOVFF  01,A29
06F30:  CLRF   x2C
06F32:  MOVLW  16
06F34:  MOVWF  x2B
06F36:  MOVLB  0
06F38:  BRA    6E28
06F3A:  MOVF   01,F
06F3C:  BNZ   6FA4
06F3E:  MOVLW  F0
06F40:  SUBWF  39,W
06F42:  MOVWF  00
06F44:  MOVLW  00
06F46:  SUBWFB 3A,W
06F48:  MOVWF  01
06F4A:  MOVLW  00
06F4C:  SUBWFB 3B,W
06F4E:  MOVWF  02
06F50:  MOVLW  00
06F52:  SUBWFB 3C,W
06F54:  MOVWF  03
06F56:  MOVLB  9
06F58:  BTFSS  x52.7
06F5A:  BRA    6F66
06F5C:  BTFSC  03.7
06F5E:  BRA    6F64
06F60:  MOVLB  0
06F62:  BRA    6FA4
06F64:  BRA    6F6A
06F66:  BTFSC  03.7
06F68:  BRA    6FA0
06F6A:  MOVF   x52,W
06F6C:  SUBWF  03,W
06F6E:  BNC   6FA0
06F70:  BTFSC  FD8.2
06F72:  BRA    6F78
06F74:  MOVLB  0
06F76:  BRA    6FA4
06F78:  MOVF   x51,W
06F7A:  SUBWF  02,W
06F7C:  BNC   6FA0
06F7E:  BTFSC  FD8.2
06F80:  BRA    6F86
06F82:  MOVLB  0
06F84:  BRA    6FA4
06F86:  MOVF   x50,W
06F88:  SUBWF  01,W
06F8A:  BNC   6FA0
06F8C:  BTFSC  FD8.2
06F8E:  BRA    6F94
06F90:  MOVLB  0
06F92:  BRA    6FA4
06F94:  MOVF   x4F,W
06F96:  SUBWF  00,W
06F98:  BTFSS  FD8.0
06F9A:  BRA    6FA0
06F9C:  MOVLB  0
06F9E:  BRA    6FA4
06FA0:  MOVLW  00
06FA2:  BRA    6FA6
06FA4:  MOVLW  01
06FA6:  MOVLB  A
06FA8:  MOVWF  x0A
....................     memcpy(last_upload, packet->gs_message, length); 
06FAA:  MOVLW  01
06FAC:  ADDWF  x07,W
06FAE:  MOVWF  01
06FB0:  MOVLW  00
06FB2:  ADDWFC x08,W
06FB4:  MOVWF  03
06FB6:  MOVFF  01,A25
06FBA:  MOVWF  x26
06FBC:  MOVLW  09
06FBE:  MOVWF  FEA
06FC0:  MOVLW  39
06FC2:  MOVWF  FE9
06FC4:  MOVFF  03,FE2
06FC8:  MOVFF  01,FE1
06FCC:  MOVLW  16
06FCE:  MOVWF  01
06FD0:  MOVFF  FE6,FEE
06FD4:  DECFSZ 01,F
06FD6:  BRA    6FD0
....................     last_upload_t = current_time; 
06FD8:  MOVFF  3C,952
06FDC:  MOVFF  3B,951
06FE0:  MOVFF  3A,950
06FE4:  MOVFF  39,94F
....................     if (valid && different) { 
06FE8:  MOVF   x09,F
06FEA:  BZ    70AC
06FEC:  MOVF   x0A,F
06FEE:  BZ    70AC
....................         fprintf(PC, " Valid uplink"); 
06FF0:  MOVLW  14
06FF2:  MOVWF  FF6
06FF4:  MOVLW  06
06FF6:  MOVWF  FF7
06FF8:  MOVLW  00
06FFA:  MOVWF  FF8
06FFC:  MOVLB  0
06FFE:  CALL   1C7A
....................         uint8_t cmd[BUFF_LENGTH] = { MSG_COMM }; 
07002:  MOVLW  C0
07004:  MOVLB  A
07006:  MOVWF  x0B
07008:  CLRF   x0C
0700A:  CLRF   x0D
0700C:  CLRF   x0E
0700E:  CLRF   x0F
07010:  CLRF   x10
07012:  CLRF   x11
07014:  CLRF   x12
07016:  CLRF   x13
07018:  CLRF   x14
0701A:  CLRF   x15
0701C:  CLRF   x16
0701E:  CLRF   x17
07020:  CLRF   x18
07022:  CLRF   x19
07024:  CLRF   x1A
07026:  CLRF   x1B
07028:  CLRF   x1C
0702A:  CLRF   x1D
0702C:  CLRF   x1E
0702E:  CLRF   x1F
07030:  CLRF   x20
07032:  CLRF   x21
07034:  CLRF   x22
07036:  CLRF   x23
....................         uint8_t copy_size = packet->gs_message[2] != 0xCC ? 9 : length; // Don't pass CRC onwards for short commands 
07038:  MOVLW  03
0703A:  ADDWF  x07,W
0703C:  MOVWF  FE9
0703E:  MOVLW  00
07040:  ADDWFC x08,W
07042:  MOVWF  FEA
07044:  MOVF   FEF,W
07046:  SUBLW  CC
07048:  BZ    704E
0704A:  MOVLW  09
0704C:  BRA    7050
0704E:  MOVLW  16
07050:  MOVWF  x24
....................         memcpy(cmd + 1, packet->gs_message + 3, copy_size); 
07052:  MOVLW  01
07054:  ADDWF  x07,W
07056:  MOVWF  01
07058:  MOVLW  00
0705A:  ADDWFC x08,W
0705C:  MOVWF  03
0705E:  MOVFF  01,A25
07062:  MOVWF  x26
07064:  MOVLW  03
07066:  ADDWF  x25,F
07068:  MOVLW  00
0706A:  ADDWFC x26,F
0706C:  MOVLW  0A
0706E:  MOVWF  FEA
07070:  MOVLW  0C
07072:  MOVWF  FE9
07074:  MOVFF  A26,FE2
07078:  MOVFF  A25,FE1
0707C:  MOVF   x24,W
0707E:  MOVWF  01
07080:  BZ    708A
07082:  MOVFF  FE6,FEE
07086:  DECFSZ 01,F
07088:  BRA    7082
....................         vschedule(current_time, cmd); 
0708A:  MOVFF  3C,A2E
0708E:  MOVFF  3B,A2D
07092:  MOVFF  3A,A2C
07096:  MOVFF  39,A2B
0709A:  MOVLW  0A
0709C:  MOVWF  x30
0709E:  MOVLW  0B
070A0:  MOVWF  x2F
070A2:  MOVLB  0
070A4:  CALL   4600
....................     } else { 
070A8:  BRA    7112
070AA:  MOVLB  A
....................         fprintf(PC, " Invalid (%d) or identical (%d) uplink.", valid, different); 
070AC:  MOVLW  22
070AE:  MOVWF  FF6
070B0:  MOVLW  06
070B2:  MOVWF  FF7
070B4:  MOVLW  00
070B6:  MOVWF  FF8
070B8:  MOVLW  0A
070BA:  MOVWF  x3B
070BC:  MOVLB  0
070BE:  CALL   3048
070C2:  MOVFF  A09,A25
070C6:  MOVLW  18
070C8:  MOVLB  A
070CA:  MOVWF  x26
070CC:  MOVLB  0
070CE:  CALL   4960
070D2:  MOVLW  2E
070D4:  MOVWF  FF6
070D6:  MOVLW  06
070D8:  MOVWF  FF7
070DA:  MOVLW  00
070DC:  MOVWF  FF8
070DE:  MOVLW  10
070E0:  MOVLB  A
070E2:  MOVWF  x3B
070E4:  MOVLB  0
070E6:  CALL   3048
070EA:  MOVFF  A0A,A25
070EE:  MOVLW  18
070F0:  MOVLB  A
070F2:  MOVWF  x26
070F4:  MOVLB  0
070F6:  CALL   4960
070FA:  MOVLW  40
070FC:  MOVWF  FF6
070FE:  MOVLW  06
07100:  MOVWF  FF7
07102:  MOVLW  00
07104:  MOVWF  FF8
07106:  MOVLW  09
07108:  MOVLB  A
0710A:  MOVWF  x3B
0710C:  MOVLB  0
0710E:  CALL   3048
....................     } 
....................     return !(valid && different); 
07112:  MOVLB  A
07114:  MOVF   x09,F
07116:  BZ    7120
07118:  MOVF   x0A,F
0711A:  BZ    7120
0711C:  MOVLW  00
0711E:  BRA    7122
07120:  MOVLW  01
07122:  MOVWF  01
07124:  MOVLB  0
07126:  GOTO   CD36 (RETURN)
.................... } 
....................  
.................... // Change CW mode flags 
.................... uint8_t command_change_cw_mode_flags(uint8_t* data) 
.................... { 
....................     obc_flags.cw_mode = data[2]; // data[2] is the new flag status 
*
08DE2:  MOVLW  02
08DE4:  MOVLB  A
08DE6:  ADDWF  x05,W
08DE8:  MOVWF  FE9
08DEA:  MOVLW  00
08DEC:  ADDWFC x06,W
08DEE:  MOVWF  FEA
08DF0:  MOVFF  FEF,F3
08DF4:  MOVLB  0
....................     save_state(data[1]);         // data[1] is the current command ID 
08DF6:  MOVLW  01
08DF8:  MOVLB  A
08DFA:  ADDWF  x05,W
08DFC:  MOVWF  FE9
08DFE:  MOVLW  00
08E00:  ADDWFC x06,W
08E02:  MOVWF  FEA
08E04:  MOVFF  FEF,A0E
08E08:  MOVLB  0
08E0A:  CALL   74CE
....................     return obc_flags.cw_mode; 
08E0E:  MOVFF  F3,01
08E12:  GOTO   CEF8 (RETURN)
.................... } 
....................  
.................... // Ask ADCS if satellite is over Japan 
.................... uint8_t over_japan_check() 
.................... { 
....................     uint8_t command[] = { 0xFC }; 
*
07326:  MOVLW  FC
07328:  MOVLB  A
0732A:  MOVWF  x20
....................     stm32_raw_command(command, sizeof(command), false); // Send request to ADCS 
0732C:  MOVLW  0A
0732E:  MOVWF  x24
07330:  MOVLW  20
07332:  MOVWF  x23
07334:  MOVLW  01
07336:  MOVWF  x25
07338:  CLRF   x26
0733A:  MOVLB  0
0733C:  RCALL  7188
....................  
....................     uint8_t response[2] = { 0 }; 
0733E:  MOVLB  A
07340:  CLRF   x21
07342:  CLRF   x22
....................     uart_download_packet(&uart_port_ADCS, response, sizeof(response), 100000); // Try to get a response 
07344:  MOVLW  08
07346:  MOVWF  xCE
07348:  MOVLW  85
0734A:  MOVWF  xCD
0734C:  MOVLW  0A
0734E:  MOVWF  xD0
07350:  MOVLW  21
07352:  MOVWF  xCF
07354:  CLRF   xD4
07356:  CLRF   xD3
07358:  CLRF   xD2
0735A:  MOVLW  02
0735C:  MOVWF  xD1
0735E:  CLRF   xD8
07360:  MOVLW  01
07362:  MOVWF  xD7
07364:  MOVLW  86
07366:  MOVWF  xD6
07368:  MOVLW  A0
0736A:  MOVWF  xD5
0736C:  MOVLB  0
0736E:  RCALL  726A
....................  
....................     if (response[1] == 0xA5) { 
07370:  MOVLB  A
07372:  MOVF   x22,W
07374:  SUBLW  A5
07376:  BNZ   738E
....................         return ((int8_t)response[0] > 0); // Elevation > 0 degrees 
07378:  BTFSC  x21.7
0737A:  BRA    7382
0737C:  MOVF   x21,W
0737E:  SUBLW  00
07380:  BNC   7386
07382:  MOVLW  00
07384:  BRA    7388
07386:  MOVLW  01
07388:  MOVWF  01
0738A:  BRA    7392
....................     } else { 
0738C:  BRA    7392
....................         return false; 
0738E:  MOVLW  00
07390:  MOVWF  01
....................     } 
07392:  MOVLB  0
07394:  GOTO   73B0 (RETURN)
.................... } 
....................  
.................... // Decides if it is OK to send CW or not based on flags and ADCS 
.................... uint8_t ok_to_send_cw() 
.................... { 
....................     switch (obc_flags.cw_mode) { 
07398:  MOVF   xF3,W
0739A:  XORLW  00
0739C:  BZ    73A8
0739E:  XORLW  01
073A0:  BZ    73AE
073A2:  XORLW  03
073A4:  BZ    73B4
073A6:  BRA    73BA
....................     case 0: return false; 
073A8:  MOVLW  00
073AA:  MOVWF  01
073AC:  BRA    73BE
....................     case 1: return over_japan_check(); 
073AE:  BRA    7326
073B0:  MOVF   01,W
073B2:  BRA    73BE
....................     case 2: return true; 
073B4:  MOVLW  01
073B6:  MOVWF  01
073B8:  BRA    73BE
....................     default: return false; 
073BA:  MOVLW  00
073BC:  MOVWF  01
....................     } 
073BE:  GOTO   7462 (RETURN)
.................... } 
....................  
.................... // COM CW request 
.................... uint8_t command_com_cw(uint8_t* data) 
.................... { 
....................     enum { com_to_main_size = 25 }; 
....................  
....................     static uint8_t current_cw = 0; 
....................     telemetry.com_rssi = *(uint16_t*)&data[2]; 
073C2:  MOVLW  02
073C4:  MOVLB  A
073C6:  ADDWF  x05,W
073C8:  MOVWF  01
073CA:  MOVLW  00
073CC:  ADDWFC x06,W
073CE:  MOVFF  01,FE9
073D2:  MOVWF  FEA
073D4:  MOVFF  FEC,C6
073D8:  MOVF   FED,F
073DA:  MOVFF  FEF,C5
....................     telemetry_time.com_time = current_time; 
073DE:  MOVFF  3C,E0
073E2:  MOVFF  3B,DF
073E6:  MOVFF  3A,DE
073EA:  MOVFF  39,DD
....................  
....................     // Generate CW reply 
....................     uint8_t cmd[24] = { 0 }; 
073EE:  CLRF   x07
073F0:  CLRF   x08
073F2:  CLRF   x09
073F4:  CLRF   x0A
073F6:  CLRF   x0B
073F8:  CLRF   x0C
073FA:  CLRF   x0D
073FC:  CLRF   x0E
073FE:  CLRF   x0F
07400:  CLRF   x10
07402:  CLRF   x11
07404:  CLRF   x12
07406:  CLRF   x13
07408:  CLRF   x14
0740A:  CLRF   x15
0740C:  CLRF   x16
0740E:  CLRF   x17
07410:  CLRF   x18
07412:  CLRF   x19
07414:  CLRF   x1A
07416:  CLRF   x1B
07418:  CLRF   x1C
0741A:  CLRF   x1D
0741C:  CLRF   x1E
....................     cmd[0] = 0x0B; 
0741E:  MOVLW  0B
07420:  MOVWF  x07
....................     cmd[1] = 0x50; 
07422:  MOVLW  50
07424:  MOVWF  x08
....................     memcpy(cmd + 2, cw[current_cw], sizeof(cw[0])); 
07426:  MOVLB  9
07428:  MOVF   x53,W
0742A:  MULLW  06
0742C:  MOVF   FF3,W
0742E:  CLRF   03
07430:  ADDLW  E1
07432:  MOVWF  01
07434:  MOVLW  00
07436:  ADDWFC 03,F
07438:  MOVFF  01,A20
0743C:  MOVLB  A
0743E:  MOVFF  03,A21
07442:  MOVLW  0A
07444:  MOVWF  FEA
07446:  MOVLW  09
07448:  MOVWF  FE9
0744A:  MOVFF  03,FE2
0744E:  MOVFF  01,FE1
07452:  MOVLW  06
07454:  MOVWF  01
07456:  MOVFF  FE6,FEE
0745A:  DECFSZ 01,F
0745C:  BRA    7456
....................     cmd[sizeof(cw[0]) + 2] = ok_to_send_cw(); 
0745E:  MOVLB  0
07460:  BRA    7398
07462:  MOVFF  01,A0F
....................     cmd[23] = 0x0C; 
07466:  MOVLW  0C
07468:  MOVLB  A
0746A:  MOVWF  x1E
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
0746C:  CLRF   x1F
0746E:  MOVF   x1F,W
07470:  SUBLW  17
07472:  BNC   7494
....................         fputc(cmd[i], COMM); 
07474:  CLRF   03
07476:  MOVF   x1F,W
07478:  ADDLW  07
0747A:  MOVWF  FE9
0747C:  MOVLW  0A
0747E:  ADDWFC 03,W
07480:  MOVWF  FEA
07482:  MOVFF  FEF,A20
07486:  MOVF   x20,W
07488:  MOVLB  0
0748A:  CALL   2A0A
0748E:  MOVLB  A
07490:  INCF   x1F,F
07492:  BRA    746E
....................     } 
....................     current_cw++; 
07494:  MOVLB  9
07496:  INCF   x53,F
....................     if (current_cw >= sizeof(cw) / sizeof(cw[0])) 
07498:  MOVF   x53,W
0749A:  SUBLW  01
0749C:  BC    74A0
....................         current_cw = 0; 
0749E:  CLRF   x53
....................     fprintf(PC, "COM: "); 
074A0:  MOVLW  4A
074A2:  MOVWF  FF6
074A4:  MOVLW  06
074A6:  MOVWF  FF7
074A8:  MOVLW  00
074AA:  MOVWF  FF8
074AC:  MOVLB  0
074AE:  CALL   1C7A
....................     uart_print_pc_hex(data, com_to_main_size); 
074B2:  MOVFF  A06,A54
074B6:  MOVFF  A05,A53
074BA:  MOVLW  19
074BC:  MOVLB  A
074BE:  MOVWF  x55
074C0:  MOVLB  0
074C2:  CALL   4EF0
....................     return 0; 
074C6:  MOVLW  00
074C8:  MOVWF  01
074CA:  GOTO   CD48 (RETURN)
.................... } 
....................  
.................... // COM Access request 
.................... uint8_t command_com_access_request(uint8_t* data) 
*
0770C:  MOVFF  A06,A08
07710:  MOVFF  A05,A07
07714:  MOVLW  02
07716:  MOVLB  A
07718:  ADDWF  x07,W
0771A:  MOVWF  FE9
0771C:  MOVLW  00
0771E:  ADDWFC x08,W
07720:  MOVWF  FEA
07722:  MOVFF  FEF,00
07726:  CLRF   01
07728:  CLRF   02
0772A:  CLRF   03
0772C:  MOVFF  03,A1E
07730:  MOVFF  02,A1D
07734:  MOVFF  01,A1C
07738:  MOVFF  00,A1B
0773C:  MOVFF  FEA,A20
07740:  MOVFF  FE9,A1F
07744:  CLRF   x5A
07746:  CLRF   x59
07748:  CLRF   x58
0774A:  MOVLW  3C
0774C:  MOVWF  x57
0774E:  MOVFF  03,A5E
07752:  MOVFF  02,A5D
07756:  MOVFF  01,A5C
0775A:  MOVFF  00,A5B
0775E:  MOVLB  0
07760:  CALL   1CB4
07764:  MOVFF  A20,FEA
07768:  MOVFF  A1F,FE9
0776C:  MOVF   00,W
0776E:  ADDWF  39,W
07770:  MOVLB  A
07772:  MOVWF  x09
07774:  MOVF   01,W
07776:  ADDWFC 3A,W
07778:  MOVWF  x0A
0777A:  MOVF   02,W
0777C:  ADDWFC 3B,W
0777E:  MOVWF  x0B
07780:  MOVF   03,W
07782:  ADDWFC 3C,W
07784:  MOVWF  x0C
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x59 
....................         uint8_t time;    // in minutes 
....................     }* packet = (struct packet*)data; 
....................  
....................     time_t disable_time = current_time + (60 * (time_t)packet->time); 
....................     scheduled_command_clear_specified_command(0xC0, 0x58); 
07786:  MOVLW  C0
07788:  MOVWF  x55
0778A:  MOVLW  58
0778C:  MOVWF  x56
0778E:  MOVLB  0
07790:  CALL   5888
....................     schedule(current_time, { 0xC0, 0x58, 0x01 }); 
07794:  MOVLW  C0
07796:  MOVLB  A
07798:  MOVWF  x0D
0779A:  MOVLW  58
0779C:  MOVWF  x0E
0779E:  MOVLW  01
077A0:  MOVWF  x0F
077A2:  MOVFF  3C,A2E
077A6:  MOVFF  3B,A2D
077AA:  MOVFF  3A,A2C
077AE:  MOVFF  39,A2B
077B2:  MOVLW  0A
077B4:  MOVWF  x30
077B6:  MOVLW  0D
077B8:  MOVWF  x2F
077BA:  MOVLB  0
077BC:  CALL   4600
....................     schedule(disable_time, { 0xC0, 0x58, 0x00 }); 
077C0:  MOVLW  C0
077C2:  MOVLB  A
077C4:  MOVWF  x10
077C6:  MOVLW  58
077C8:  MOVWF  x11
077CA:  CLRF   x12
077CC:  MOVFF  A0C,A2E
077D0:  MOVFF  A0B,A2D
077D4:  MOVFF  A0A,A2C
077D8:  MOVFF  A09,A2B
077DC:  MOVLW  0A
077DE:  MOVWF  x30
077E0:  MOVLW  10
077E2:  MOVWF  x2F
077E4:  MOVLB  0
077E6:  CALL   4600
....................  
....................     uint8_t reply[8] = { 0 }; 
077EA:  MOVLB  A
077EC:  CLRF   x13
077EE:  CLRF   x14
077F0:  CLRF   x15
077F2:  CLRF   x16
077F4:  CLRF   x17
077F6:  CLRF   x18
077F8:  CLRF   x19
077FA:  CLRF   x1A
....................     send_com_ack(reply); 
077FC:  MOVLW  0A
077FE:  MOVWF  x1C
07800:  MOVLW  13
07802:  MOVWF  x1B
07804:  MOVLB  0
07806:  CALL   4C36
....................  
....................     return packet->time; 
0780A:  MOVLW  02
0780C:  MOVLB  A
0780E:  ADDWF  x07,W
07810:  MOVWF  FE9
07812:  MOVLW  00
07814:  ADDWFC x08,W
07816:  MOVWF  FEA
07818:  MOVFF  FEF,01
0781C:  MOVLB  0
0781E:  GOTO   CD7E (RETURN)
.................... } 
....................  
.................... // Change COM access 
.................... uint8_t command_com_access_change(uint8_t* data) 
*
076C4:  MOVFF  A06,A08
076C8:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x58 
....................         uint8_t state;   // 0: OBC side; 1: COM side 
....................     }* packet = (struct packet*)data; 
....................  
....................     output_bit(MUX_SEL_COM_SHARED_FM, packet->state); 
076CC:  MOVLW  02
076CE:  MOVLB  A
076D0:  ADDWF  x07,W
076D2:  MOVWF  FE9
076D4:  MOVLW  00
076D6:  ADDWFC x08,W
076D8:  MOVWF  FEA
076DA:  MOVF   FEF,F
076DC:  BNZ   76E2
076DE:  BCF    F8B.5
076E0:  BRA    76E4
076E2:  BSF    F8B.5
076E4:  BCF    F94.5
....................     memory_busy = packet->state; 
076E6:  MOVLW  02
076E8:  ADDWF  x07,W
076EA:  MOVWF  FE9
076EC:  MOVLW  00
076EE:  ADDWFC x08,W
076F0:  MOVWF  FEA
076F2:  MOVFF  FEF,4BF
....................  
....................     return packet->state; 
076F6:  MOVLW  02
076F8:  ADDWF  x07,W
076FA:  MOVWF  FE9
076FC:  MOVLW  00
076FE:  ADDWFC x08,W
07700:  MOVWF  FEA
07702:  MOVFF  FEF,01
07706:  MOVLB  0
07708:  GOTO   CD6C (RETURN)
.................... } 
....................  
.................... // ============ OBC/PCIB Commands ============ 
....................  
.................... // Schedule any command 
.................... uint8_t command_schedule_anything(uint8_t* data) 
*
0A982:  MOVFF  A06,A08
0A986:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t schedule_time; 
....................         uint8_t schedule_command[12]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     vschedule(packet->schedule_time, packet->schedule_command); 
0A98A:  MOVLW  02
0A98C:  MOVLB  A
0A98E:  ADDWF  x07,W
0A990:  MOVWF  FE9
0A992:  MOVLW  00
0A994:  ADDWFC x08,W
0A996:  MOVWF  FEA
0A998:  MOVFF  FEF,A2B
0A99C:  MOVFF  FEC,A2C
0A9A0:  MOVFF  FEC,A2D
0A9A4:  MOVFF  FEC,A2E
0A9A8:  MOVLW  06
0A9AA:  ADDWF  x07,W
0A9AC:  MOVWF  01
0A9AE:  MOVLW  00
0A9B0:  ADDWFC x08,W
0A9B2:  MOVWF  03
0A9B4:  MOVFF  01,A0D
0A9B8:  MOVWF  x0E
0A9BA:  MOVWF  x30
0A9BC:  MOVFF  01,A2F
0A9C0:  MOVLB  0
0A9C2:  CALL   4600
....................  
....................     return 0; 
0A9C6:  MOVLW  00
0A9C8:  MOVWF  01
0A9CA:  GOTO   CFAC (RETURN)
.................... } 
....................  
.................... uint8_t command_pcib_telemetry(uint8_t* data) 
.................... { 
....................     fprintf(PC, "RELAY: "); 
*
04F46:  MOVLW  50
04F48:  MOVWF  FF6
04F4A:  MOVLW  06
04F4C:  MOVWF  FF7
04F4E:  MOVLW  00
04F50:  MOVWF  FF8
04F52:  CALL   1C7A
....................     response_rx = 1; // Received a reply 
04F56:  MOVLW  01
04F58:  MOVLB  6
04F5A:  MOVWF  x83
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_PCIB); 
04F5C:  MOVFF  A06,A54
04F60:  MOVFF  A05,A53
04F64:  MOVLW  24
04F66:  MOVLB  A
04F68:  MOVWF  x55
04F6A:  MOVLB  0
04F6C:  RCALL  4EF0
....................  
....................     telemetry_time.pcib_time = current_time; 
04F6E:  MOVFF  3C,D8
04F72:  MOVFF  3B,D7
04F76:  MOVFF  3A,D6
04F7A:  MOVFF  39,D5
....................     memcpy(telemetry.pcib_message, data + 2, sizeof(telemetry.pcib_message)); 
04F7E:  MOVLW  02
04F80:  MOVLB  A
04F82:  ADDWF  x05,W
04F84:  MOVWF  x07
04F86:  MOVLW  00
04F88:  ADDWFC x06,W
04F8A:  MOVWF  x08
04F8C:  CLRF   FEA
04F8E:  MOVLW  92
04F90:  MOVWF  FE9
04F92:  MOVFF  A08,FE2
04F96:  MOVFF  A07,FE1
04F9A:  MOVLW  0A
04F9C:  MOVWF  01
04F9E:  MOVFF  FE6,FEE
04FA2:  DECFSZ 01,F
04FA4:  BRA    4F9E
....................  
....................     return 0; 
04FA6:  MOVLW  00
04FA8:  MOVWF  01
04FAA:  MOVLB  0
04FAC:  GOTO   CC5E (RETURN)
.................... } 
....................  
.................... // Set the clock to a given value (UNIX time, seconds after Jan 1st 1970) 
.................... uint8_t command_set_clock(uint8_t* data) 
*
054E2:  MOVFF  A06,A08
054E6:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t current_time; 
....................         int8_t leap_seconds; 
....................         uint8_t gps_time_sync_state; 
....................     }* packet = (struct packet*)data; 
....................     obc_flags.leap_seconds = packet->leap_seconds; 
054EA:  MOVLW  06
054EC:  MOVLB  A
054EE:  ADDWF  x07,W
054F0:  MOVWF  FE9
054F2:  MOVLW  00
054F4:  ADDWFC x08,W
054F6:  MOVWF  FEA
054F8:  MOVFF  FEF,EE
....................     obc_flags.gps_time_sync_state = packet->gps_time_sync_state; 
054FC:  MOVLW  07
054FE:  ADDWF  x07,W
05500:  MOVWF  FE9
05502:  MOVLW  00
05504:  ADDWFC x08,W
05506:  MOVWF  FEA
05508:  MOVFF  FEF,F1
....................  
....................     uint8_t time_updated = 0; 
0550C:  CLRF   x09
....................  
....................     if (packet->current_time < T0) { 
0550E:  MOVLW  02
05510:  ADDWF  x07,W
05512:  MOVWF  FE9
05514:  MOVLW  00
05516:  ADDWFC x08,W
05518:  MOVWF  FEA
0551A:  MOVFF  FEF,A0C
0551E:  MOVFF  FEC,A0D
05522:  MOVFF  FEC,A0E
05526:  MOVFF  FEC,A0F
0552A:  BTFSC  x0F.7
0552C:  BRA    554C
0552E:  MOVF   x0F,W
05530:  SUBLW  38
05532:  BNC   5580
05534:  BNZ   554C
05536:  MOVF   x0E,W
05538:  SUBLW  6D
0553A:  BNC   5580
0553C:  BNZ   554C
0553E:  MOVF   x0D,W
05540:  SUBLW  43
05542:  BNC   5580
05544:  BNZ   554C
05546:  MOVF   x0C,W
05548:  SUBLW  7F
0554A:  BNC   5580
....................         time_updated = 1; 
0554C:  MOVLW  01
0554E:  MOVWF  x09
....................         SetTimeSec(T0); // Set clock to as early as possible (Jan 1st 2000, 00:00:00); 
05550:  MOVLW  38
05552:  MOVWF  x1F
05554:  MOVLW  6D
05556:  MOVWF  x1E
05558:  MOVLW  43
0555A:  MOVWF  x1D
0555C:  MOVLW  80
0555E:  MOVWF  x1C
05560:  MOVLB  0
05562:  CALL   2886
....................         // mai_400_update_clock(T0); 
....................         reset_pic_update_clock(T0); 
05566:  MOVLW  38
05568:  MOVLB  A
0556A:  MOVWF  x1B
0556C:  MOVLW  6D
0556E:  MOVWF  x1A
05570:  MOVLW  43
05572:  MOVWF  x19
05574:  MOVLW  80
05576:  MOVWF  x18
05578:  MOVLB  0
0557A:  RCALL  506E
....................     } else { 
0557C:  BRA    562C
0557E:  MOVLB  A
....................         SetTimeSec(packet->current_time + obc_flags.leap_seconds); 
05580:  MOVLW  02
05582:  ADDWF  x07,W
05584:  MOVWF  FE9
05586:  MOVLW  00
05588:  ADDWFC x08,W
0558A:  MOVWF  FEA
0558C:  MOVFF  FEF,A0C
05590:  MOVFF  FEC,A0D
05594:  MOVFF  FEC,A0E
05598:  MOVFF  FEC,A0F
0559C:  MOVFF  EE,00
055A0:  CLRF   01
055A2:  CLRF   02
055A4:  CLRF   03
055A6:  BTFSS  00.7
055A8:  BRA    55B0
055AA:  DECF   01,F
055AC:  DECF   02,F
055AE:  DECF   03,F
055B0:  MOVF   00,W
055B2:  ADDWF  x0C,F
055B4:  MOVF   01,W
055B6:  ADDWFC x0D,F
055B8:  MOVF   02,W
055BA:  ADDWFC x0E,F
055BC:  MOVF   03,W
055BE:  ADDWFC x0F,F
055C0:  MOVFF  A0F,A1F
055C4:  MOVFF  A0E,A1E
055C8:  MOVFF  A0D,A1D
055CC:  MOVFF  A0C,A1C
055D0:  MOVLB  0
055D2:  CALL   2886
....................         reset_pic_update_clock(packet->current_time + obc_flags.leap_seconds); 
055D6:  MOVLW  02
055D8:  MOVLB  A
055DA:  ADDWF  x07,W
055DC:  MOVWF  FE9
055DE:  MOVLW  00
055E0:  ADDWFC x08,W
055E2:  MOVWF  FEA
055E4:  MOVFF  FEF,A0C
055E8:  MOVFF  FEC,A0D
055EC:  MOVFF  FEC,A0E
055F0:  MOVFF  FEC,A0F
055F4:  MOVFF  EE,00
055F8:  CLRF   01
055FA:  CLRF   02
055FC:  CLRF   03
055FE:  BTFSS  00.7
05600:  BRA    5608
05602:  DECF   01,F
05604:  DECF   02,F
05606:  DECF   03,F
05608:  MOVF   00,W
0560A:  ADDWF  x0C,F
0560C:  MOVF   01,W
0560E:  ADDWFC x0D,F
05610:  MOVF   02,W
05612:  ADDWFC x0E,F
05614:  MOVF   03,W
05616:  ADDWFC x0F,F
05618:  MOVFF  A0F,A1B
0561C:  MOVFF  A0E,A1A
05620:  MOVFF  A0D,A19
05624:  MOVFF  A0C,A18
05628:  MOVLB  0
0562A:  RCALL  506E
....................     } 
....................     current_time = time(0); 
0562C:  MOVLB  A
0562E:  CLRF   x19
05630:  CLRF   x18
05632:  MOVLB  0
05634:  CALL   23A6
05638:  MOVFF  03,3C
0563C:  MOVFF  02,3B
05640:  MOVFF  01,3A
05644:  MOVFF  00,39
....................  
....................     // Change memory location based on the new date 
....................     flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
05648:  MOVLW  02
0564A:  MOVLB  A
0564C:  MOVWF  x1C
0564E:  MOVFF  ED,A1D
05652:  MOVFF  11D,A21
05656:  MOVFF  11C,A20
0565A:  MOVFF  11B,A1F
0565E:  MOVFF  11A,A1E
05662:  CLRF   x25
05664:  MOVLW  11
05666:  MOVWF  x24
05668:  CLRF   x23
0566A:  CLRF   x22
0566C:  CLRF   x29
0566E:  CLRF   x28
05670:  CLRF   x27
05672:  MOVLW  8C
05674:  MOVWF  x26
05676:  MOVLW  01
05678:  MOVWF  x2A
0567A:  MOVWF  x2C
0567C:  MOVLW  12
0567E:  MOVWF  x2B
05680:  MOVLB  0
05682:  CALL   3214
....................  
....................     struct_tm* local_time = localtime(&current_time); 
05686:  MOVLB  A
05688:  CLRF   x4D
0568A:  MOVLW  39
0568C:  MOVWF  x4C
0568E:  MOVLB  0
05690:  CALL   246E
05694:  MOVFF  02,A0B
05698:  MOVFF  01,A0A
....................  
....................     fprintf(PC, "New time: %04ld/%02d/%02d %02d:%02d:%02d(0x%08lX) ", 
....................         local_time->tm_year + 1900, 
....................         (uint8_t)local_time->tm_mon + 1, 
....................         local_time->tm_mday, 
....................         local_time->tm_hour, 
....................         local_time->tm_min, 
....................         local_time->tm_sec, 
....................         current_time); 
0569C:  MOVLW  05
0569E:  MOVLB  A
056A0:  ADDWF  x0A,W
056A2:  MOVWF  FE9
056A4:  MOVLW  00
056A6:  ADDWFC x0B,W
056A8:  MOVWF  FEA
056AA:  MOVFF  FEC,A0D
056AE:  MOVF   FED,F
056B0:  MOVFF  FEF,A0C
056B4:  MOVLW  6C
056B6:  ADDWF  x0C,F
056B8:  MOVLW  07
056BA:  ADDWFC x0D,F
056BC:  MOVLW  04
056BE:  ADDWF  x0A,W
056C0:  MOVWF  FE9
056C2:  MOVLW  00
056C4:  ADDWFC x0B,W
056C6:  MOVWF  FEA
056C8:  MOVLW  01
056CA:  ADDWF  FEF,W
056CC:  MOVWF  x0E
056CE:  MOVLW  03
056D0:  ADDWF  x0A,W
056D2:  MOVWF  FE9
056D4:  MOVLW  00
056D6:  ADDWFC x0B,W
056D8:  MOVWF  FEA
056DA:  MOVFF  FEF,A0F
056DE:  MOVLW  02
056E0:  ADDWF  x0A,W
056E2:  MOVWF  FE9
056E4:  MOVLW  00
056E6:  ADDWFC x0B,W
056E8:  MOVWF  FEA
056EA:  MOVFF  FEF,A10
056EE:  MOVLW  01
056F0:  ADDWF  x0A,W
056F2:  MOVWF  FE9
056F4:  MOVLW  00
056F6:  ADDWFC x0B,W
056F8:  MOVWF  FEA
056FA:  MOVFF  FEF,A11
056FE:  MOVFF  A0A,FE9
05702:  MOVFF  A0B,FEA
05706:  MOVFF  FEF,A12
0570A:  MOVLW  58
0570C:  MOVWF  FF6
0570E:  MOVLW  06
05710:  MOVWF  FF7
05712:  MOVLW  00
05714:  MOVWF  FF8
05716:  MOVLW  0A
05718:  MOVWF  x3B
0571A:  MOVLB  0
0571C:  CALL   3048
05720:  MOVLW  0A
05722:  MOVWF  FE9
05724:  MOVFF  A0D,A24
05728:  MOVFF  A0C,A23
0572C:  CALL   4D28
05730:  MOVLW  2F
05732:  MOVLB  B
05734:  MOVWF  x1F
05736:  MOVLB  0
05738:  CALL   1C34
0573C:  MOVFF  A0E,A23
05740:  MOVLW  01
05742:  MOVLB  A
05744:  MOVWF  x24
05746:  MOVLB  0
05748:  CALL   4E28
0574C:  MOVLW  2F
0574E:  MOVLB  B
05750:  MOVWF  x1F
05752:  MOVLB  0
05754:  CALL   1C34
05758:  MOVFF  A0F,A23
0575C:  MOVLW  01
0575E:  MOVLB  A
05760:  MOVWF  x24
05762:  MOVLB  0
05764:  CALL   4E28
05768:  MOVLW  20
0576A:  MOVLB  B
0576C:  MOVWF  x1F
0576E:  MOVLB  0
05770:  CALL   1C34
05774:  MOVFF  A10,A23
05778:  MOVLW  01
0577A:  MOVLB  A
0577C:  MOVWF  x24
0577E:  MOVLB  0
05780:  CALL   4E28
05784:  MOVLW  3A
05786:  MOVLB  B
05788:  MOVWF  x1F
0578A:  MOVLB  0
0578C:  CALL   1C34
05790:  MOVFF  A11,A23
05794:  MOVLW  01
05796:  MOVLB  A
05798:  MOVWF  x24
0579A:  MOVLB  0
0579C:  CALL   4E28
057A0:  MOVLW  3A
057A2:  MOVLB  B
057A4:  MOVWF  x1F
057A6:  MOVLB  0
057A8:  CALL   1C34
057AC:  MOVFF  A12,A23
057B0:  MOVLW  01
057B2:  MOVLB  A
057B4:  MOVWF  x24
057B6:  MOVLB  0
057B8:  CALL   4E28
057BC:  MOVLW  80
057BE:  MOVWF  FF6
057C0:  MOVLW  06
057C2:  MOVWF  FF7
057C4:  MOVLW  00
057C6:  MOVWF  FF8
057C8:  MOVLW  03
057CA:  MOVLB  A
057CC:  MOVWF  x3B
057CE:  MOVLB  0
057D0:  CALL   3048
057D4:  MOVFF  3C,A58
057D8:  MOVLW  37
057DA:  MOVLB  A
057DC:  MOVWF  x59
057DE:  MOVLB  0
057E0:  CALL   3142
057E4:  MOVFF  3B,A58
057E8:  MOVLW  37
057EA:  MOVLB  A
057EC:  MOVWF  x59
057EE:  MOVLB  0
057F0:  CALL   3142
057F4:  MOVFF  3A,A58
057F8:  MOVLW  37
057FA:  MOVLB  A
057FC:  MOVWF  x59
057FE:  MOVLB  0
05800:  CALL   3142
05804:  MOVFF  39,A58
05808:  MOVLW  37
0580A:  MOVLB  A
0580C:  MOVWF  x59
0580E:  MOVLB  0
05810:  CALL   3142
05814:  MOVLW  29
05816:  MOVLB  B
05818:  MOVWF  x1F
0581A:  MOVLB  0
0581C:  CALL   1C34
05820:  MOVLW  20
05822:  MOVLB  B
05824:  MOVWF  x1F
05826:  MOVLB  0
05828:  CALL   1C34
....................  
....................     fprintf(PC, "Leap: %d GPS sync: 0x%02X", obc_flags.leap_seconds, obc_flags.gps_time_sync_state); 
0582C:  MOVLW  8C
0582E:  MOVWF  FF6
05830:  MOVLW  06
05832:  MOVWF  FF7
05834:  MOVLW  00
05836:  MOVWF  FF8
05838:  MOVLW  06
0583A:  MOVLB  A
0583C:  MOVWF  x3B
0583E:  MOVLB  0
05840:  CALL   3048
05844:  MOVFF  EE,A25
05848:  MOVLW  18
0584A:  MOVLB  A
0584C:  MOVWF  x26
0584E:  MOVLB  0
05850:  CALL   4960
05854:  MOVLW  94
05856:  MOVWF  FF6
05858:  MOVLW  06
0585A:  MOVWF  FF7
0585C:  MOVLW  00
0585E:  MOVWF  FF8
05860:  MOVLW  0D
05862:  MOVLB  A
05864:  MOVWF  x3B
05866:  MOVLB  0
05868:  CALL   3048
0586C:  MOVFF  F1,A58
05870:  MOVLW  37
05872:  MOVLB  A
05874:  MOVWF  x59
05876:  MOVLB  0
05878:  CALL   3142
....................     return time_updated; 
0587C:  MOVLB  A
0587E:  MOVFF  A09,01
05882:  MOVLB  0
05884:  GOTO   CCA6 (RETURN)
.................... } 
....................  
.................... // Display the TRIS status to debug port 
.................... uint8_t command_get_tris(uint8_t* data) 
.................... { 
....................     fprintf(PC, "\n         fedcba9876543210\r\n"); 
*
0A45E:  MOVLW  A6
0A460:  MOVWF  FF6
0A462:  MOVLW  06
0A464:  MOVWF  FF7
0A466:  MOVLW  00
0A468:  MOVWF  FF8
0A46A:  CALL   1C7A
....................     fprintf(PC, "tris_a = "); 
0A46E:  MOVLW  C4
0A470:  MOVWF  FF6
0A472:  MOVLW  06
0A474:  MOVWF  FF7
0A476:  MOVLW  00
0A478:  MOVWF  FF8
0A47A:  CALL   1C7A
....................     print_binary16(get_tris_a()); 
0A47E:  MOVFF  F92,A07
0A482:  MOVLB  A
0A484:  CLRF   x09
0A486:  MOVFF  F92,A08
0A48A:  MOVLB  0
0A48C:  RCALL  A3FC
....................     fprintf(PC, "tris_b = "); 
0A48E:  MOVLW  CE
0A490:  MOVWF  FF6
0A492:  MOVLW  06
0A494:  MOVWF  FF7
0A496:  MOVLW  00
0A498:  MOVWF  FF8
0A49A:  CALL   1C7A
....................     print_binary16(get_tris_b()); 
0A49E:  MOVFF  F93,A07
0A4A2:  MOVLB  A
0A4A4:  CLRF   x09
0A4A6:  MOVFF  F93,A08
0A4AA:  MOVLB  0
0A4AC:  RCALL  A3FC
....................     fprintf(PC, "tris_c = "); 
0A4AE:  MOVLW  D8
0A4B0:  MOVWF  FF6
0A4B2:  MOVLW  06
0A4B4:  MOVWF  FF7
0A4B6:  MOVLW  00
0A4B8:  MOVWF  FF8
0A4BA:  CALL   1C7A
....................     print_binary16(get_tris_c()); 
0A4BE:  MOVFF  F94,A07
0A4C2:  MOVLB  A
0A4C4:  CLRF   x09
0A4C6:  MOVFF  F94,A08
0A4CA:  MOVLB  0
0A4CC:  RCALL  A3FC
....................     fprintf(PC, "tris_d = "); 
0A4CE:  MOVLW  E2
0A4D0:  MOVWF  FF6
0A4D2:  MOVLW  06
0A4D4:  MOVWF  FF7
0A4D6:  MOVLW  00
0A4D8:  MOVWF  FF8
0A4DA:  CALL   1C7A
....................     print_binary16(get_tris_d()); 
0A4DE:  MOVFF  F95,A07
0A4E2:  MOVLB  A
0A4E4:  CLRF   x09
0A4E6:  MOVFF  F95,A08
0A4EA:  MOVLB  0
0A4EC:  RCALL  A3FC
....................     fprintf(PC, "tris_e = "); 
0A4EE:  MOVLW  EC
0A4F0:  MOVWF  FF6
0A4F2:  MOVLW  06
0A4F4:  MOVWF  FF7
0A4F6:  MOVLW  00
0A4F8:  MOVWF  FF8
0A4FA:  CALL   1C7A
....................     print_binary16(get_tris_e()); 
0A4FE:  MOVFF  F96,A07
0A502:  MOVLB  A
0A504:  CLRF   x09
0A506:  MOVFF  F96,A08
0A50A:  MOVLB  0
0A50C:  RCALL  A3FC
....................     fprintf(PC, "tris_f = "); 
0A50E:  MOVLW  F6
0A510:  MOVWF  FF6
0A512:  MOVLW  06
0A514:  MOVWF  FF7
0A516:  MOVLW  00
0A518:  MOVWF  FF8
0A51A:  CALL   1C7A
....................     print_binary16(get_tris_f()); 
0A51E:  MOVFF  F97,A07
0A522:  MOVLB  A
0A524:  CLRF   x09
0A526:  MOVFF  F97,A08
0A52A:  MOVLB  0
0A52C:  RCALL  A3FC
....................     fprintf(PC, "tris_g = "); 
0A52E:  MOVLW  00
0A530:  MOVWF  FF6
0A532:  MOVLW  07
0A534:  MOVWF  FF7
0A536:  MOVLW  00
0A538:  MOVWF  FF8
0A53A:  CALL   1C7A
....................     print_binary16(get_tris_g()); 
0A53E:  MOVFF  F98,A07
0A542:  MOVLB  A
0A544:  CLRF   x09
0A546:  MOVFF  F98,A08
0A54A:  MOVLB  0
0A54C:  RCALL  A3FC
....................     return 0xEE; 
0A54E:  MOVLW  EE
0A550:  MOVWF  01
0A552:  RETURN 0
.................... } 
....................  
.................... // Prints a memory address relative to satellite time (if ptr = 0x0000, prints satellite time). 
.................... uint8_t command_print_memory_address(uint8_t* data) 
*
05408:  MOVFF  A06,A08
0540C:  MOVFF  A05,A07
05410:  MOVLW  02
05412:  MOVLB  A
05414:  ADDWF  x07,W
05416:  MOVWF  FE9
05418:  MOVLW  00
0541A:  ADDWFC x08,W
0541C:  MOVWF  FEA
0541E:  MOVFF  FEF,00
05422:  MOVFF  FEC,01
05426:  MOVFF  FEC,02
0542A:  MOVFF  FEC,03
0542E:  MOVLW  39
05430:  ADDWF  00,W
05432:  MOVWF  x09
05434:  MOVLW  00
05436:  ADDWFC 01,W
05438:  MOVWF  x0A
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t ptr; 
....................     }* packet = (struct packet*)data; 
.................... #ifndef PC_SIM 
....................     uint32_t* addr = (uint32_t*)packet->ptr + &current_time; 
....................     fprintf(PC, "*%04lX = %08lX", addr, *addr); 
0543A:  MOVFF  A0A,03
0543E:  MOVFF  A09,FE9
05442:  MOVFF  A0A,FEA
05446:  MOVFF  FEF,A0B
0544A:  MOVFF  FEC,A0C
0544E:  MOVFF  FEC,A0D
05452:  MOVFF  FEC,A0E
05456:  MOVLW  2A
05458:  MOVLB  B
0545A:  MOVWF  x1F
0545C:  MOVLB  0
0545E:  CALL   1C34
05462:  MOVFF  A0A,A58
05466:  MOVLW  37
05468:  MOVLB  A
0546A:  MOVWF  x59
0546C:  MOVLB  0
0546E:  CALL   3142
05472:  MOVFF  A09,A58
05476:  MOVLW  37
05478:  MOVLB  A
0547A:  MOVWF  x59
0547C:  MOVLB  0
0547E:  CALL   3142
05482:  MOVLW  10
05484:  MOVWF  FF6
05486:  MOVLW  07
05488:  MOVWF  FF7
0548A:  MOVLW  00
0548C:  MOVWF  FF8
0548E:  MOVLW  03
05490:  MOVLB  A
05492:  MOVWF  x3B
05494:  MOVLB  0
05496:  CALL   3048
0549A:  MOVFF  A0E,A58
0549E:  MOVLW  37
054A0:  MOVLB  A
054A2:  MOVWF  x59
054A4:  MOVLB  0
054A6:  CALL   3142
054AA:  MOVFF  A0D,A58
054AE:  MOVLW  37
054B0:  MOVLB  A
054B2:  MOVWF  x59
054B4:  MOVLB  0
054B6:  CALL   3142
054BA:  MOVFF  A0C,A58
054BE:  MOVLW  37
054C0:  MOVLB  A
054C2:  MOVWF  x59
054C4:  MOVLB  0
054C6:  CALL   3142
054CA:  MOVFF  A0B,A58
054CE:  MOVLW  37
054D0:  MOVLB  A
054D2:  MOVWF  x59
054D4:  MOVLB  0
054D6:  CALL   3142
.................... #endif 
....................     return 0; 
054DA:  MOVLW  00
054DC:  MOVWF  01
054DE:  GOTO   CC94 (RETURN)
.................... } 
....................  
.................... // Sends the antenna deployment command to relay pic 
.................... uint8_t command_deploy_antenna(uint8_t* data) 
*
09BE2:  MOVFF  A06,A08
09BE6:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     const uint8_t n_tries = 5; // Number of times it try to send PCIB the request 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
09BEA:  BTFSC  3C.7
09BEC:  BRA    9D4A
09BEE:  MOVF   3C,W
09BF0:  SUBLW  37
09BF2:  BTFSC  FD8.0
09BF4:  BRA    9D4A
09BF6:  XORLW  FF
09BF8:  BNZ   9C1A
09BFA:  MOVF   3B,W
09BFC:  SUBLW  6C
09BFE:  BTFSC  FD8.0
09C00:  BRA    9D4A
09C02:  XORLW  FF
09C04:  BNZ   9C1A
09C06:  MOVF   3A,W
09C08:  SUBLW  49
09C0A:  BTFSC  FD8.0
09C0C:  BRA    9D4A
09C0E:  XORLW  FF
09C10:  BNZ   9C1A
09C12:  MOVF   39,W
09C14:  SUBLW  A5
09C16:  BTFSC  FD8.0
09C18:  BRA    9D4A
....................         // Increment deployment flag and save state 
....................         boot_flags.deployment_flag++; 
09C1A:  INCF   xED,F
....................         get_com_shared_fm_access(); 
09C1C:  CALL   593C
....................         uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
09C20:  MOVLB  A
09C22:  CLRF   x33
09C24:  MOVLW  ED
09C26:  MOVFF  A33,A0A
09C2A:  MOVWF  x09
....................         flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
09C2C:  MOVLW  09
09C2E:  MOVWF  x33
09C30:  MOVLW  1B
09C32:  MOVWF  x32
09C34:  CLRF   x37
09C36:  CLRF   x36
09C38:  CLRF   x35
09C3A:  CLRF   x34
09C3C:  CLRF   x3B
09C3E:  CLRF   x3A
09C40:  CLRF   x39
09C42:  MOVLW  01
09C44:  MOVWF  x38
09C46:  MOVLB  0
09C48:  CALL   3968
....................         flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
09C4C:  MOVLW  09
09C4E:  MOVLB  A
09C50:  MOVWF  xD0
09C52:  MOVLW  1B
09C54:  MOVWF  xCF
09C56:  CLRF   xD4
09C58:  CLRF   xD3
09C5A:  CLRF   xD2
09C5C:  CLRF   xD1
09C5E:  MOVFF  A0A,AD6
09C62:  MOVFF  A09,AD5
09C66:  CLRF   xDA
09C68:  CLRF   xD9
09C6A:  CLRF   xD8
09C6C:  MOVLW  01
09C6E:  MOVWF  xD7
09C70:  MOVLB  0
09C72:  CALL   3C1A
....................  
....................         uint8_t time = 30; // in seconds 
09C76:  MOVLW  1E
09C78:  MOVLB  A
09C7A:  MOVWF  x0B
....................         if (packet->time_s) { 
09C7C:  MOVLW  02
09C7E:  ADDWF  x07,W
09C80:  MOVWF  FE9
09C82:  MOVLW  00
09C84:  ADDWFC x08,W
09C86:  MOVWF  FEA
09C88:  MOVF   FEF,F
09C8A:  BZ    9C9C
....................             time = packet->time_s; 
09C8C:  MOVLW  02
09C8E:  ADDWF  x07,W
09C90:  MOVWF  FE9
09C92:  MOVLW  00
09C94:  ADDWFC x08,W
09C96:  MOVWF  FEA
09C98:  MOVFF  FEF,A0B
....................         } 
....................         uint8_t cmd[36] = { 0x0B, 0xDA }; 
09C9C:  MOVLW  0B
09C9E:  MOVWF  x0C
09CA0:  MOVLW  DA
09CA2:  MOVWF  x0D
09CA4:  CLRF   x0E
09CA6:  CLRF   x0F
09CA8:  CLRF   x10
09CAA:  CLRF   x11
09CAC:  CLRF   x12
09CAE:  CLRF   x13
09CB0:  CLRF   x14
09CB2:  CLRF   x15
09CB4:  CLRF   x16
09CB6:  CLRF   x17
09CB8:  CLRF   x18
09CBA:  CLRF   x19
09CBC:  CLRF   x1A
09CBE:  CLRF   x1B
09CC0:  CLRF   x1C
09CC2:  CLRF   x1D
09CC4:  CLRF   x1E
09CC6:  CLRF   x1F
09CC8:  CLRF   x20
09CCA:  CLRF   x21
09CCC:  CLRF   x22
09CCE:  CLRF   x23
09CD0:  CLRF   x24
09CD2:  CLRF   x25
09CD4:  CLRF   x26
09CD6:  CLRF   x27
09CD8:  CLRF   x28
09CDA:  CLRF   x29
09CDC:  CLRF   x2A
09CDE:  CLRF   x2B
09CE0:  CLRF   x2C
09CE2:  CLRF   x2D
09CE4:  CLRF   x2E
09CE6:  CLRF   x2F
....................         cmd[2] = time; 
09CE8:  MOVFF  A0B,A0E
....................         checksum_obc(cmd, sizeof(cmd)); 
09CEC:  MOVLW  0A
09CEE:  MOVWF  x58
09CF0:  MOVLW  0C
09CF2:  MOVWF  x57
09CF4:  MOVLW  24
09CF6:  MOVWF  x59
09CF8:  MOVLB  0
09CFA:  CALL   712A
....................         for (uint8_t j = 0; j < n_tries; j++) { 
09CFE:  MOVLB  A
09D00:  CLRF   x30
09D02:  MOVF   x30,W
09D04:  SUBLW  04
09D06:  BNC   9D40
....................             for (uint8_t i = 0; i < sizeof(cmd); i++) { 
09D08:  CLRF   x31
09D0A:  MOVF   x31,W
09D0C:  SUBLW  23
09D0E:  BNC   9D30
....................                 fputc(cmd[i], PCIB); 
09D10:  CLRF   03
09D12:  MOVF   x31,W
09D14:  ADDLW  0C
09D16:  MOVWF  FE9
09D18:  MOVLW  0A
09D1A:  ADDWFC 03,W
09D1C:  MOVWF  FEA
09D1E:  MOVFF  FEF,A32
09D22:  MOVF   x32,W
09D24:  MOVLB  0
09D26:  CALL   29F8
09D2A:  MOVLB  A
09D2C:  INCF   x31,F
09D2E:  BRA    9D0A
....................             } 
....................             delay_ms(100); 
09D30:  MOVLW  64
09D32:  MOVWF  xDB
09D34:  MOVLB  0
09D36:  CALL   36F2
09D3A:  MOVLB  A
09D3C:  INCF   x30,F
09D3E:  BRA    9D02
....................         } 
....................         return 0; 
09D40:  MOVLW  00
09D42:  MOVWF  01
09D44:  BRA    9D50
....................     } else { 
09D46:  BRA    9D50
09D48:  MOVLB  0
....................         return 1; 
09D4A:  MOVLW  01
09D4C:  MOVWF  01
09D4E:  MOVLB  A
....................     } 
09D50:  MOVLB  0
09D52:  GOTO   CF40 (RETURN)
.................... } 
....................  
.................... // Clear completely the main memory. 
.................... uint8_t command_clear_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
*
08E16:  CALL   593C
....................     flash_erase(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, ERASE_SECTOR); 
08E1A:  MOVLW  09
08E1C:  MOVLB  A
08E1E:  MOVWF  xD2
08E20:  MOVLW  1B
08E22:  MOVWF  xD1
08E24:  CLRF   xD6
08E26:  CLRF   xD5
08E28:  CLRF   xD4
08E2A:  CLRF   xD3
08E2C:  MOVLW  DC
08E2E:  MOVWF  xD7
08E30:  MOVLB  0
08E32:  CALL   371C
....................     fprintf(PC, "Waiting 10s for reset...\r\n"); 
08E36:  MOVLW  1A
08E38:  MOVWF  FF6
08E3A:  MOVLW  07
08E3C:  MOVWF  FF7
08E3E:  MOVLW  00
08E40:  MOVWF  FF8
08E42:  CALL   1C7A
....................     delay_ms(10000); 
08E46:  MOVLW  28
08E48:  MOVLB  A
08E4A:  MOVWF  x07
08E4C:  MOVLW  FA
08E4E:  MOVWF  xDB
08E50:  MOVLB  0
08E52:  CALL   36F2
08E56:  MOVLB  A
08E58:  DECFSZ x07,F
08E5A:  BRA    8E4C
....................     reset_cpu(); 
08E5C:  RESET
....................     return 0; 
08E5E:  MOVLW  00
08E60:  MOVWF  01
08E62:  MOVLB  0
08E64:  GOTO   CF0A (RETURN)
.................... } 
....................  
.................... // Save state to memory. 
.................... uint8_t command_save_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
*
076A2:  CALL   593C
....................     save_state(data[1]); // data[1] is the current command id 
076A6:  MOVLW  01
076A8:  MOVLB  A
076AA:  ADDWF  x05,W
076AC:  MOVWF  FE9
076AE:  MOVLW  00
076B0:  ADDWFC x06,W
076B2:  MOVWF  FEA
076B4:  MOVFF  FEF,A0E
076B8:  MOVLB  0
076BA:  RCALL  74CE
....................     return 0; 
076BC:  MOVLW  00
076BE:  MOVWF  01
076C0:  GOTO   CD5A (RETURN)
.................... } 
....................  
.................... // Dump state. 
.................... uint8_t command_dump_memory(uint8_t* data) 
*
0A17C:  MOVFF  A06,A08
0A180:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t start; 
....................         uint32_t size; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................     fprintf(PC, "\r\nHex dump start"); 
0A184:  MOVLW  36
0A186:  MOVWF  FF6
0A188:  MOVLW  07
0A18A:  MOVWF  FF7
0A18C:  MOVLW  00
0A18E:  MOVWF  FF8
0A190:  CALL   1C7A
....................     switch (packet->source) { 
0A194:  MOVLW  0A
0A196:  MOVLB  A
0A198:  ADDWF  x07,W
0A19A:  MOVWF  FE9
0A19C:  MOVLW  00
0A19E:  ADDWFC x08,W
0A1A0:  MOVWF  FEA
0A1A2:  MOVF   FEF,W
0A1A4:  XORLW  00
0A1A6:  MOVLB  0
0A1A8:  BZ    A1B6
0A1AA:  XORLW  01
0A1AC:  BZ    A23E
0A1AE:  XORLW  03
0A1B0:  BTFSC  FD8.2
0A1B2:  BRA    A2C2
0A1B4:  BRA    A34E
....................     case 0: 
....................         get_com_shared_fm_access(); 
0A1B6:  CALL   593C
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
0A1BA:  MOVLW  02
0A1BC:  MOVLB  A
0A1BE:  ADDWF  x07,W
0A1C0:  MOVWF  FE9
0A1C2:  MOVLW  00
0A1C4:  ADDWFC x08,W
0A1C6:  MOVWF  FEA
0A1C8:  MOVFF  FEF,A13
0A1CC:  MOVFF  FEC,A14
0A1D0:  MOVFF  FEC,A15
0A1D4:  MOVFF  FEC,A16
0A1D8:  MOVLW  02
0A1DA:  ADDWF  x07,W
0A1DC:  MOVWF  FE9
0A1DE:  MOVLW  00
0A1E0:  ADDWFC x08,W
0A1E2:  MOVWF  FEA
0A1E4:  MOVFF  FEF,A0D
0A1E8:  MOVFF  FEC,A0E
0A1EC:  MOVFF  FEC,A0F
0A1F0:  MOVFF  FEC,A10
0A1F4:  MOVLW  06
0A1F6:  ADDWF  x07,W
0A1F8:  MOVWF  FE9
0A1FA:  MOVLW  00
0A1FC:  ADDWFC x08,W
0A1FE:  MOVWF  FEA
0A200:  MOVFF  FEF,00
0A204:  MOVFF  FEC,01
0A208:  MOVFF  FEC,02
0A20C:  MOVFF  FEC,03
0A210:  MOVF   00,W
0A212:  ADDWF  x0D,F
0A214:  MOVF   01,W
0A216:  ADDWFC x0E,F
0A218:  MOVF   02,W
0A21A:  ADDWFC x0F,F
0A21C:  MOVF   03,W
0A21E:  ADDWFC x10,F
0A220:  MOVLW  09
0A222:  MOVWF  x12
0A224:  MOVLW  1B
0A226:  MOVWF  x11
0A228:  MOVFF  A10,A1A
0A22C:  MOVFF  A0F,A19
0A230:  MOVFF  A0E,A18
0A234:  MOVFF  A0D,A17
0A238:  MOVLB  0
0A23A:  RCALL  A078
....................         break; 
0A23C:  BRA    A3D4
....................     case 1: 
....................         flash_dump(&spi_port_MAIN_FM, packet->start, packet->start + packet->size); 
0A23E:  MOVLW  02
0A240:  MOVLB  A
0A242:  ADDWF  x07,W
0A244:  MOVWF  FE9
0A246:  MOVLW  00
0A248:  ADDWFC x08,W
0A24A:  MOVWF  FEA
0A24C:  MOVFF  FEF,A13
0A250:  MOVFF  FEC,A14
0A254:  MOVFF  FEC,A15
0A258:  MOVFF  FEC,A16
0A25C:  MOVLW  02
0A25E:  ADDWF  x07,W
0A260:  MOVWF  FE9
0A262:  MOVLW  00
0A264:  ADDWFC x08,W
0A266:  MOVWF  FEA
0A268:  MOVFF  FEF,A0D
0A26C:  MOVFF  FEC,A0E
0A270:  MOVFF  FEC,A0F
0A274:  MOVFF  FEC,A10
0A278:  MOVLW  06
0A27A:  ADDWF  x07,W
0A27C:  MOVWF  FE9
0A27E:  MOVLW  00
0A280:  ADDWFC x08,W
0A282:  MOVWF  FEA
0A284:  MOVFF  FEF,00
0A288:  MOVFF  FEC,01
0A28C:  MOVFF  FEC,02
0A290:  MOVFF  FEC,03
0A294:  MOVF   00,W
0A296:  ADDWF  x0D,F
0A298:  MOVF   01,W
0A29A:  ADDWFC x0E,F
0A29C:  MOVF   02,W
0A29E:  ADDWFC x0F,F
0A2A0:  MOVF   03,W
0A2A2:  ADDWFC x10,F
0A2A4:  MOVLW  09
0A2A6:  MOVWF  x12
0A2A8:  MOVLW  25
0A2AA:  MOVWF  x11
0A2AC:  MOVFF  A10,A1A
0A2B0:  MOVFF  A0F,A19
0A2B4:  MOVFF  A0E,A18
0A2B8:  MOVFF  A0D,A17
0A2BC:  MOVLB  0
0A2BE:  RCALL  A078
....................         break; 
0A2C0:  BRA    A3D4
....................     case 2: 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0A2C2:  BCF    F92.5
0A2C4:  BCF    F89.5
....................         flash_dump(&spi_port_MISSION_FM, packet->start, packet->start + packet->size); 
0A2C6:  MOVLW  02
0A2C8:  MOVLB  A
0A2CA:  ADDWF  x07,W
0A2CC:  MOVWF  FE9
0A2CE:  MOVLW  00
0A2D0:  ADDWFC x08,W
0A2D2:  MOVWF  FEA
0A2D4:  MOVFF  FEF,A13
0A2D8:  MOVFF  FEC,A14
0A2DC:  MOVFF  FEC,A15
0A2E0:  MOVFF  FEC,A16
0A2E4:  MOVLW  02
0A2E6:  ADDWF  x07,W
0A2E8:  MOVWF  FE9
0A2EA:  MOVLW  00
0A2EC:  ADDWFC x08,W
0A2EE:  MOVWF  FEA
0A2F0:  MOVFF  FEF,A0D
0A2F4:  MOVFF  FEC,A0E
0A2F8:  MOVFF  FEC,A0F
0A2FC:  MOVFF  FEC,A10
0A300:  MOVLW  06
0A302:  ADDWF  x07,W
0A304:  MOVWF  FE9
0A306:  MOVLW  00
0A308:  ADDWFC x08,W
0A30A:  MOVWF  FEA
0A30C:  MOVFF  FEF,00
0A310:  MOVFF  FEC,01
0A314:  MOVFF  FEC,02
0A318:  MOVFF  FEC,03
0A31C:  MOVF   00,W
0A31E:  ADDWF  x0D,F
0A320:  MOVF   01,W
0A322:  ADDWFC x0E,F
0A324:  MOVF   02,W
0A326:  ADDWFC x0F,F
0A328:  MOVF   03,W
0A32A:  ADDWFC x10,F
0A32C:  MOVLW  09
0A32E:  MOVWF  x12
0A330:  MOVLW  2F
0A332:  MOVWF  x11
0A334:  MOVFF  A10,A1A
0A338:  MOVFF  A0F,A19
0A33C:  MOVFF  A0E,A18
0A340:  MOVFF  A0D,A17
0A344:  MOVLB  0
0A346:  RCALL  A078
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0A348:  BCF    F92.5
0A34A:  BSF    F89.5
....................         break; 
0A34C:  BRA    A3D4
....................     default: 
....................         get_com_shared_fm_access(); 
0A34E:  CALL   593C
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
0A352:  MOVLW  02
0A354:  MOVLB  A
0A356:  ADDWF  x07,W
0A358:  MOVWF  FE9
0A35A:  MOVLW  00
0A35C:  ADDWFC x08,W
0A35E:  MOVWF  FEA
0A360:  MOVFF  FEF,A13
0A364:  MOVFF  FEC,A14
0A368:  MOVFF  FEC,A15
0A36C:  MOVFF  FEC,A16
0A370:  MOVLW  02
0A372:  ADDWF  x07,W
0A374:  MOVWF  FE9
0A376:  MOVLW  00
0A378:  ADDWFC x08,W
0A37A:  MOVWF  FEA
0A37C:  MOVFF  FEF,A0D
0A380:  MOVFF  FEC,A0E
0A384:  MOVFF  FEC,A0F
0A388:  MOVFF  FEC,A10
0A38C:  MOVLW  06
0A38E:  ADDWF  x07,W
0A390:  MOVWF  FE9
0A392:  MOVLW  00
0A394:  ADDWFC x08,W
0A396:  MOVWF  FEA
0A398:  MOVFF  FEF,00
0A39C:  MOVFF  FEC,01
0A3A0:  MOVFF  FEC,02
0A3A4:  MOVFF  FEC,03
0A3A8:  MOVF   00,W
0A3AA:  ADDWF  x0D,F
0A3AC:  MOVF   01,W
0A3AE:  ADDWFC x0E,F
0A3B0:  MOVF   02,W
0A3B2:  ADDWFC x0F,F
0A3B4:  MOVF   03,W
0A3B6:  ADDWFC x10,F
0A3B8:  MOVLW  09
0A3BA:  MOVWF  x12
0A3BC:  MOVLW  1B
0A3BE:  MOVWF  x11
0A3C0:  MOVFF  A10,A1A
0A3C4:  MOVFF  A0F,A19
0A3C8:  MOVFF  A0E,A18
0A3CC:  MOVFF  A0D,A17
0A3D0:  MOVLB  0
0A3D2:  RCALL  A078
....................         break; 
....................     } 
....................     fprintf(PC, "\r\nHex dump end\r\n"); 
0A3D4:  MOVLW  48
0A3D6:  MOVWF  FF6
0A3D8:  MOVLW  07
0A3DA:  MOVWF  FF7
0A3DC:  MOVLW  00
0A3DE:  MOVWF  FF8
0A3E0:  CALL   1C7A
....................     return packet->source; 
0A3E4:  MOVLW  0A
0A3E6:  MOVLB  A
0A3E8:  ADDWF  x07,W
0A3EA:  MOVWF  FE9
0A3EC:  MOVLW  00
0A3EE:  ADDWFC x08,W
0A3F0:  MOVWF  FEA
0A3F2:  MOVFF  FEF,01
0A3F6:  MOVLB  0
0A3F8:  GOTO   CF64 (RETURN)
.................... } 
....................  
.................... // Copy data between flash memories 
.................... uint8_t command_copy_memory_sector(uint8_t* data) 
*
060B6:  MOVFF  A06,A08
060BA:  MOVFF  A05,A07
060BE:  MOVLW  09
060C0:  MOVLB  A
060C2:  ADDWF  x07,W
060C4:  MOVWF  FE9
060C6:  MOVLW  00
060C8:  ADDWFC x08,W
060CA:  MOVWF  FEA
060CC:  MOVFF  FEF,A09
060D0:  MOVLW  08
060D2:  ADDWF  x07,W
060D4:  MOVWF  FE9
060D6:  MOVLW  00
060D8:  ADDWFC x08,W
060DA:  MOVWF  FEA
060DC:  MOVFF  FEF,A0A
060E0:  MOVLW  02
060E2:  ADDWF  x07,W
060E4:  MOVWF  FE9
060E6:  MOVLW  00
060E8:  ADDWFC x08,W
060EA:  MOVWF  FEA
060EC:  MOVFF  FEC,03
060F0:  MOVF   FED,F
060F2:  MOVFF  FEF,A0D
060F6:  MOVFF  03,A24
060FA:  CLRF   x25
060FC:  CLRF   x26
060FE:  MOVFF  03,A0E
06102:  CLRF   x0B
06104:  CLRF   x0C
06106:  MOVLW  04
06108:  ADDWF  x07,W
0610A:  MOVWF  FE9
0610C:  MOVLW  00
0610E:  ADDWFC x08,W
06110:  MOVWF  FEA
06112:  MOVFF  FEC,03
06116:  MOVF   FED,F
06118:  MOVFF  FEF,A11
0611C:  MOVFF  03,A24
06120:  CLRF   x25
06122:  CLRF   x26
06124:  MOVFF  03,A12
06128:  CLRF   x0F
0612A:  CLRF   x10
0612C:  MOVLW  06
0612E:  ADDWF  x07,W
06130:  MOVWF  FE9
06132:  MOVLW  00
06134:  ADDWFC x08,W
06136:  MOVWF  FEA
06138:  MOVFF  FEC,A16
0613C:  MOVF   FED,F
0613E:  MOVFF  FEF,A15
06142:  CLRF   x13
06144:  CLRF   x14
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t origin = packet->origin_port; 
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address_ = (uint32_t)packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t from_address_ = (uint32_t)packet->source_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_sectors * MEMORY_SECTOR_SIZE; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX", origin, dest, to_address_, from_address_, size); 
06146:  MOVLW  5A
06148:  MOVWF  FF6
0614A:  MOVLW  07
0614C:  MOVWF  FF7
0614E:  MOVLW  00
06150:  MOVWF  FF8
06152:  MOVLW  0C
06154:  MOVWF  x3B
06156:  MOVLB  0
06158:  CALL   3048
0615C:  MOVFF  A09,A25
06160:  MOVLW  18
06162:  MOVLB  A
06164:  MOVWF  x26
06166:  MOVLB  0
06168:  CALL   4960
0616C:  MOVLW  68
0616E:  MOVWF  FF6
06170:  MOVLW  07
06172:  MOVWF  FF7
06174:  MOVLW  00
06176:  MOVWF  FF8
06178:  MOVLW  06
0617A:  MOVLB  A
0617C:  MOVWF  x3B
0617E:  MOVLB  0
06180:  CALL   3048
06184:  MOVFF  A0A,A25
06188:  MOVLW  18
0618A:  MOVLB  A
0618C:  MOVWF  x26
0618E:  MOVLB  0
06190:  CALL   4960
06194:  MOVLW  70
06196:  MOVWF  FF6
06198:  MOVLW  07
0619A:  MOVWF  FF7
0619C:  MOVLW  00
0619E:  MOVWF  FF8
061A0:  MOVLW  09
061A2:  MOVLB  A
061A4:  MOVWF  x3B
061A6:  MOVLB  0
061A8:  CALL   3048
061AC:  MOVFF  A0E,A58
061B0:  MOVLW  37
061B2:  MOVLB  A
061B4:  MOVWF  x59
061B6:  MOVLB  0
061B8:  CALL   3142
061BC:  MOVFF  A0D,A58
061C0:  MOVLW  37
061C2:  MOVLB  A
061C4:  MOVWF  x59
061C6:  MOVLB  0
061C8:  CALL   3142
061CC:  MOVFF  A0C,A58
061D0:  MOVLW  37
061D2:  MOVLB  A
061D4:  MOVWF  x59
061D6:  MOVLB  0
061D8:  CALL   3142
061DC:  MOVFF  A0B,A58
061E0:  MOVLW  37
061E2:  MOVLB  A
061E4:  MOVWF  x59
061E6:  MOVLB  0
061E8:  CALL   3142
061EC:  MOVLW  7C
061EE:  MOVWF  FF6
061F0:  MOVLW  07
061F2:  MOVWF  FF7
061F4:  MOVLW  00
061F6:  MOVWF  FF8
061F8:  MOVLW  0B
061FA:  MOVLB  A
061FC:  MOVWF  x3B
061FE:  MOVLB  0
06200:  CALL   3048
06204:  MOVFF  A12,A58
06208:  MOVLW  37
0620A:  MOVLB  A
0620C:  MOVWF  x59
0620E:  MOVLB  0
06210:  CALL   3142
06214:  MOVFF  A11,A58
06218:  MOVLW  37
0621A:  MOVLB  A
0621C:  MOVWF  x59
0621E:  MOVLB  0
06220:  CALL   3142
06224:  MOVFF  A10,A58
06228:  MOVLW  37
0622A:  MOVLB  A
0622C:  MOVWF  x59
0622E:  MOVLB  0
06230:  CALL   3142
06234:  MOVFF  A0F,A58
06238:  MOVLW  37
0623A:  MOVLB  A
0623C:  MOVWF  x59
0623E:  MOVLB  0
06240:  CALL   3142
06244:  MOVLW  8A
06246:  MOVWF  FF6
06248:  MOVLW  07
0624A:  MOVWF  FF7
0624C:  MOVLW  00
0624E:  MOVWF  FF8
06250:  MOVLW  06
06252:  MOVLB  A
06254:  MOVWF  x3B
06256:  MOVLB  0
06258:  CALL   3048
0625C:  MOVFF  A16,A58
06260:  MOVLW  37
06262:  MOVLB  A
06264:  MOVWF  x59
06266:  MOVLB  0
06268:  CALL   3142
0626C:  MOVFF  A15,A58
06270:  MOVLW  37
06272:  MOVLB  A
06274:  MOVWF  x59
06276:  MOVLB  0
06278:  CALL   3142
0627C:  MOVFF  A14,A58
06280:  MOVLW  37
06282:  MOVLB  A
06284:  MOVWF  x59
06286:  MOVLB  0
06288:  CALL   3142
0628C:  MOVFF  A13,A58
06290:  MOVLW  37
06292:  MOVLB  A
06294:  MOVWF  x59
06296:  MOVLB  0
06298:  CALL   3142
....................  
....................     get_com_shared_fm_access(); 
0629C:  CALL   593C
....................  
....................     // Erase the pages before copying 
....................     if (dest == 0x00) { 
062A0:  MOVLB  A
062A2:  MOVF   x0A,F
062A4:  BNZ   6314
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
062A6:  CLRF   x1A
062A8:  CLRF   x19
062AA:  CLRF   x18
062AC:  CLRF   x17
062AE:  MOVF   x1A,W
062B0:  SUBWF  x16,W
062B2:  BNC   6312
062B4:  BNZ   62CC
062B6:  MOVF   x19,W
062B8:  SUBWF  x15,W
062BA:  BNC   6312
062BC:  BNZ   62CC
062BE:  MOVF   x18,W
062C0:  SUBWF  x14,W
062C2:  BNC   6312
062C4:  BNZ   62CC
062C6:  MOVF   x13,W
062C8:  SUBWF  x17,W
062CA:  BC    6312
....................             flash_erase(&spi_port_COM_FM, to_address_ + i, ERASE_SECTOR); 
062CC:  MOVF   x17,W
062CE:  ADDWF  x0B,W
062D0:  MOVWF  x23
062D2:  MOVF   x18,W
062D4:  ADDWFC x0C,W
062D6:  MOVWF  x24
062D8:  MOVF   x19,W
062DA:  ADDWFC x0D,W
062DC:  MOVWF  x25
062DE:  MOVF   x1A,W
062E0:  ADDWFC x0E,W
062E2:  MOVWF  x26
062E4:  MOVLW  09
062E6:  MOVWF  xD2
062E8:  MOVLW  1B
062EA:  MOVWF  xD1
062EC:  MOVFF  A26,AD6
062F0:  MOVFF  A25,AD5
062F4:  MOVFF  A24,AD4
062F8:  MOVFF  A23,AD3
062FC:  MOVLW  DC
062FE:  MOVWF  xD7
06300:  MOVLB  0
06302:  CALL   371C
06306:  MOVLW  01
06308:  MOVLB  A
0630A:  ADDWF  x19,F
0630C:  MOVLW  00
0630E:  ADDWFC x1A,F
06310:  BRA    62AE
....................         } 
....................     } else if (dest == 0x01) { 
06312:  BRA    6400
06314:  DECFSZ x0A,W
06316:  BRA    6386
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
06318:  CLRF   x1E
0631A:  CLRF   x1D
0631C:  CLRF   x1C
0631E:  CLRF   x1B
06320:  MOVF   x1E,W
06322:  SUBWF  x16,W
06324:  BNC   6384
06326:  BNZ   633E
06328:  MOVF   x1D,W
0632A:  SUBWF  x15,W
0632C:  BNC   6384
0632E:  BNZ   633E
06330:  MOVF   x1C,W
06332:  SUBWF  x14,W
06334:  BNC   6384
06336:  BNZ   633E
06338:  MOVF   x13,W
0633A:  SUBWF  x1B,W
0633C:  BC    6384
....................             flash_erase(&spi_port_MAIN_FM, to_address_ + i, ERASE_SECTOR); 
0633E:  MOVF   x1B,W
06340:  ADDWF  x0B,W
06342:  MOVWF  x23
06344:  MOVF   x1C,W
06346:  ADDWFC x0C,W
06348:  MOVWF  x24
0634A:  MOVF   x1D,W
0634C:  ADDWFC x0D,W
0634E:  MOVWF  x25
06350:  MOVF   x1E,W
06352:  ADDWFC x0E,W
06354:  MOVWF  x26
06356:  MOVLW  09
06358:  MOVWF  xD2
0635A:  MOVLW  25
0635C:  MOVWF  xD1
0635E:  MOVFF  A26,AD6
06362:  MOVFF  A25,AD5
06366:  MOVFF  A24,AD4
0636A:  MOVFF  A23,AD3
0636E:  MOVLW  DC
06370:  MOVWF  xD7
06372:  MOVLB  0
06374:  CALL   371C
06378:  MOVLW  01
0637A:  MOVLB  A
0637C:  ADDWF  x1D,F
0637E:  MOVLW  00
06380:  ADDWFC x1E,F
06382:  BRA    6320
....................         } 
....................     } else if (dest == 0x02) { 
06384:  BRA    6400
06386:  MOVF   x0A,W
06388:  SUBLW  02
0638A:  BNZ   6400
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
0638C:  CLRF   x22
0638E:  CLRF   x21
06390:  CLRF   x20
06392:  CLRF   x1F
06394:  MOVF   x22,W
06396:  SUBWF  x16,W
06398:  BNC   6400
0639A:  BNZ   63B2
0639C:  MOVF   x21,W
0639E:  SUBWF  x15,W
063A0:  BNC   6400
063A2:  BNZ   63B2
063A4:  MOVF   x20,W
063A6:  SUBWF  x14,W
063A8:  BNC   6400
063AA:  BNZ   63B2
063AC:  MOVF   x13,W
063AE:  SUBWF  x1F,W
063B0:  BC    6400
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
063B2:  BCF    F92.5
063B4:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address_ + i, ERASE_SECTOR); 
063B6:  MOVF   x1F,W
063B8:  ADDWF  x0B,W
063BA:  MOVWF  x23
063BC:  MOVF   x20,W
063BE:  ADDWFC x0C,W
063C0:  MOVWF  x24
063C2:  MOVF   x21,W
063C4:  ADDWFC x0D,W
063C6:  MOVWF  x25
063C8:  MOVF   x22,W
063CA:  ADDWFC x0E,W
063CC:  MOVWF  x26
063CE:  MOVLW  09
063D0:  MOVWF  xD2
063D2:  MOVLW  2F
063D4:  MOVWF  xD1
063D6:  MOVFF  A26,AD6
063DA:  MOVFF  A25,AD5
063DE:  MOVFF  A24,AD4
063E2:  MOVFF  A23,AD3
063E6:  MOVLW  DC
063E8:  MOVWF  xD7
063EA:  MOVLB  0
063EC:  CALL   371C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
063F0:  BCF    F92.5
063F2:  BSF    F89.5
063F4:  MOVLW  01
063F6:  MOVLB  A
063F8:  ADDWF  x21,F
063FA:  MOVLW  00
063FC:  ADDWFC x22,F
063FE:  BRA    6394
....................         } 
....................     } 
....................  
....................     if (origin == 0x00 && dest == 0x00) { 
06400:  MOVF   x09,F
06402:  BNZ   6452
06404:  MOVF   x0A,F
06406:  BNZ   6452
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
06408:  MOVLW  09
0640A:  MOVWF  x24
0640C:  MOVLW  1B
0640E:  MOVWF  x23
06410:  MOVFF  A12,A28
06414:  MOVFF  A11,A27
06418:  MOVFF  A10,A26
0641C:  MOVFF  A0F,A25
06420:  MOVLW  09
06422:  MOVWF  x2A
06424:  MOVLW  1B
06426:  MOVWF  x29
06428:  MOVFF  A0E,A2E
0642C:  MOVFF  A0D,A2D
06430:  MOVFF  A0C,A2C
06434:  MOVFF  A0B,A2B
06438:  MOVFF  A16,A32
0643C:  MOVFF  A15,A31
06440:  MOVFF  A14,A30
06444:  MOVFF  A13,A2F
06448:  MOVLB  0
0644A:  CALL   595C
....................  
....................     } else if (origin == 0x00 && dest == 0x01) { 
0644E:  BRA    671E
06450:  MOVLB  A
06452:  MOVF   x09,F
06454:  BNZ   64A4
06456:  DECFSZ x0A,W
06458:  BRA    64A4
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
0645A:  MOVLW  09
0645C:  MOVWF  x24
0645E:  MOVLW  1B
06460:  MOVWF  x23
06462:  MOVFF  A12,A28
06466:  MOVFF  A11,A27
0646A:  MOVFF  A10,A26
0646E:  MOVFF  A0F,A25
06472:  MOVLW  09
06474:  MOVWF  x2A
06476:  MOVLW  25
06478:  MOVWF  x29
0647A:  MOVFF  A0E,A2E
0647E:  MOVFF  A0D,A2D
06482:  MOVFF  A0C,A2C
06486:  MOVFF  A0B,A2B
0648A:  MOVFF  A16,A32
0648E:  MOVFF  A15,A31
06492:  MOVFF  A14,A30
06496:  MOVFF  A13,A2F
0649A:  MOVLB  0
0649C:  CALL   595C
....................  
....................     } else if (origin == 0x00 && dest == 0x02) { 
064A0:  BRA    671E
064A2:  MOVLB  A
064A4:  MOVF   x09,F
064A6:  BNZ   6500
064A8:  MOVF   x0A,W
064AA:  SUBLW  02
064AC:  BNZ   6500
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
064AE:  BCF    F92.5
064B0:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
064B2:  MOVLW  09
064B4:  MOVWF  x24
064B6:  MOVLW  1B
064B8:  MOVWF  x23
064BA:  MOVFF  A12,A28
064BE:  MOVFF  A11,A27
064C2:  MOVFF  A10,A26
064C6:  MOVFF  A0F,A25
064CA:  MOVLW  09
064CC:  MOVWF  x2A
064CE:  MOVLW  2F
064D0:  MOVWF  x29
064D2:  MOVFF  A0E,A2E
064D6:  MOVFF  A0D,A2D
064DA:  MOVFF  A0C,A2C
064DE:  MOVFF  A0B,A2B
064E2:  MOVFF  A16,A32
064E6:  MOVFF  A15,A31
064EA:  MOVFF  A14,A30
064EE:  MOVFF  A13,A2F
064F2:  MOVLB  0
064F4:  CALL   595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
064F8:  BCF    F92.5
064FA:  BSF    F89.5
....................  
....................     } else if (origin == 0x01 && dest == 0x00) { 
064FC:  BRA    671E
064FE:  MOVLB  A
06500:  DECFSZ x09,W
06502:  BRA    6552
06504:  MOVF   x0A,F
06506:  BNZ   6552
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
06508:  MOVLW  09
0650A:  MOVWF  x24
0650C:  MOVLW  25
0650E:  MOVWF  x23
06510:  MOVFF  A12,A28
06514:  MOVFF  A11,A27
06518:  MOVFF  A10,A26
0651C:  MOVFF  A0F,A25
06520:  MOVLW  09
06522:  MOVWF  x2A
06524:  MOVLW  1B
06526:  MOVWF  x29
06528:  MOVFF  A0E,A2E
0652C:  MOVFF  A0D,A2D
06530:  MOVFF  A0C,A2C
06534:  MOVFF  A0B,A2B
06538:  MOVFF  A16,A32
0653C:  MOVFF  A15,A31
06540:  MOVFF  A14,A30
06544:  MOVFF  A13,A2F
06548:  MOVLB  0
0654A:  CALL   595C
....................  
....................     } else if (origin == 0x01 && dest == 0x01) { 
0654E:  BRA    671E
06550:  MOVLB  A
06552:  DECFSZ x09,W
06554:  BRA    65A4
06556:  DECFSZ x0A,W
06558:  BRA    65A4
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
0655A:  MOVLW  09
0655C:  MOVWF  x24
0655E:  MOVLW  25
06560:  MOVWF  x23
06562:  MOVFF  A12,A28
06566:  MOVFF  A11,A27
0656A:  MOVFF  A10,A26
0656E:  MOVFF  A0F,A25
06572:  MOVLW  09
06574:  MOVWF  x2A
06576:  MOVLW  25
06578:  MOVWF  x29
0657A:  MOVFF  A0E,A2E
0657E:  MOVFF  A0D,A2D
06582:  MOVFF  A0C,A2C
06586:  MOVFF  A0B,A2B
0658A:  MOVFF  A16,A32
0658E:  MOVFF  A15,A31
06592:  MOVFF  A14,A30
06596:  MOVFF  A13,A2F
0659A:  MOVLB  0
0659C:  CALL   595C
....................  
....................     } else if (origin == 0x01 && dest == 0x02) { 
065A0:  BRA    671E
065A2:  MOVLB  A
065A4:  DECFSZ x09,W
065A6:  BRA    6600
065A8:  MOVF   x0A,W
065AA:  SUBLW  02
065AC:  BNZ   6600
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
065AE:  BCF    F92.5
065B0:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
065B2:  MOVLW  09
065B4:  MOVWF  x24
065B6:  MOVLW  25
065B8:  MOVWF  x23
065BA:  MOVFF  A12,A28
065BE:  MOVFF  A11,A27
065C2:  MOVFF  A10,A26
065C6:  MOVFF  A0F,A25
065CA:  MOVLW  09
065CC:  MOVWF  x2A
065CE:  MOVLW  2F
065D0:  MOVWF  x29
065D2:  MOVFF  A0E,A2E
065D6:  MOVFF  A0D,A2D
065DA:  MOVFF  A0C,A2C
065DE:  MOVFF  A0B,A2B
065E2:  MOVFF  A16,A32
065E6:  MOVFF  A15,A31
065EA:  MOVFF  A14,A30
065EE:  MOVFF  A13,A2F
065F2:  MOVLB  0
065F4:  CALL   595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
065F8:  BCF    F92.5
065FA:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x00) { 
065FC:  BRA    671E
065FE:  MOVLB  A
06600:  MOVF   x09,W
06602:  SUBLW  02
06604:  BNZ   665C
06606:  MOVF   x0A,F
06608:  BNZ   665C
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
0660A:  BCF    F92.5
0660C:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
0660E:  MOVLW  09
06610:  MOVWF  x24
06612:  MOVLW  2F
06614:  MOVWF  x23
06616:  MOVFF  A12,A28
0661A:  MOVFF  A11,A27
0661E:  MOVFF  A10,A26
06622:  MOVFF  A0F,A25
06626:  MOVLW  09
06628:  MOVWF  x2A
0662A:  MOVLW  1B
0662C:  MOVWF  x29
0662E:  MOVFF  A0E,A2E
06632:  MOVFF  A0D,A2D
06636:  MOVFF  A0C,A2C
0663A:  MOVFF  A0B,A2B
0663E:  MOVFF  A16,A32
06642:  MOVFF  A15,A31
06646:  MOVFF  A14,A30
0664A:  MOVFF  A13,A2F
0664E:  MOVLB  0
06650:  CALL   595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
06654:  BCF    F92.5
06656:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x01) { 
06658:  BRA    671E
0665A:  MOVLB  A
0665C:  MOVF   x09,W
0665E:  SUBLW  02
06660:  BNZ   66B8
06662:  DECFSZ x0A,W
06664:  BRA    66B8
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
06666:  BCF    F92.5
06668:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
0666A:  MOVLW  09
0666C:  MOVWF  x24
0666E:  MOVLW  2F
06670:  MOVWF  x23
06672:  MOVFF  A12,A28
06676:  MOVFF  A11,A27
0667A:  MOVFF  A10,A26
0667E:  MOVFF  A0F,A25
06682:  MOVLW  09
06684:  MOVWF  x2A
06686:  MOVLW  25
06688:  MOVWF  x29
0668A:  MOVFF  A0E,A2E
0668E:  MOVFF  A0D,A2D
06692:  MOVFF  A0C,A2C
06696:  MOVFF  A0B,A2B
0669A:  MOVFF  A16,A32
0669E:  MOVFF  A15,A31
066A2:  MOVFF  A14,A30
066A6:  MOVFF  A13,A2F
066AA:  MOVLB  0
066AC:  CALL   595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
066B0:  BCF    F92.5
066B2:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x02) { 
066B4:  BRA    671E
066B6:  MOVLB  A
066B8:  MOVF   x09,W
066BA:  SUBLW  02
066BC:  BNZ   6716
066BE:  MOVF   x0A,W
066C0:  SUBLW  02
066C2:  BNZ   6716
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
066C4:  BCF    F92.5
066C6:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
066C8:  MOVLW  09
066CA:  MOVWF  x24
066CC:  MOVLW  2F
066CE:  MOVWF  x23
066D0:  MOVFF  A12,A28
066D4:  MOVFF  A11,A27
066D8:  MOVFF  A10,A26
066DC:  MOVFF  A0F,A25
066E0:  MOVLW  09
066E2:  MOVWF  x2A
066E4:  MOVLW  2F
066E6:  MOVWF  x29
066E8:  MOVFF  A0E,A2E
066EC:  MOVFF  A0D,A2D
066F0:  MOVFF  A0C,A2C
066F4:  MOVFF  A0B,A2B
066F8:  MOVFF  A16,A32
066FC:  MOVFF  A15,A31
06700:  MOVFF  A14,A30
06704:  MOVFF  A13,A2F
06708:  MOVLB  0
0670A:  CALL   595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0670E:  BCF    F92.5
06710:  BSF    F89.5
....................  
....................     } else { 
06712:  BRA    671E
06714:  MOVLB  A
....................         return 1; 
06716:  MOVLW  01
06718:  MOVWF  01
0671A:  BRA    6724
0671C:  MOVLB  0
....................     } 
....................  
....................     return 0; 
0671E:  MOVLW  00
06720:  MOVWF  01
06722:  MOVLB  A
06724:  MOVLB  0
06726:  GOTO   CCCA (RETURN)
.................... } 
....................  
.................... // Copy data between flash memories 
.................... uint8_t command_copy_memory_page(uint8_t* data) 
*
059FE:  MOVFF  A06,A08
05A02:  MOVFF  A05,A07
05A06:  MOVLW  09
05A08:  MOVLB  A
05A0A:  ADDWF  x07,W
05A0C:  MOVWF  FE9
05A0E:  MOVLW  00
05A10:  ADDWFC x08,W
05A12:  MOVWF  FEA
05A14:  MOVFF  FEF,A09
05A18:  MOVLW  08
05A1A:  ADDWF  x07,W
05A1C:  MOVWF  FE9
05A1E:  MOVLW  00
05A20:  ADDWFC x08,W
05A22:  MOVWF  FEA
05A24:  MOVFF  FEF,A0A
05A28:  MOVLW  02
05A2A:  ADDWF  x07,W
05A2C:  MOVWF  FE9
05A2E:  MOVLW  00
05A30:  ADDWFC x08,W
05A32:  MOVWF  FEA
05A34:  MOVFF  FEC,A24
05A38:  MOVF   FED,F
05A3A:  MOVFF  FEF,A23
05A3E:  CLRF   x25
05A40:  CLRF   x26
05A42:  CLRF   x0B
05A44:  RLCF   x23,W
05A46:  MOVWF  x0C
05A48:  RLCF   x24,W
05A4A:  MOVWF  x0D
05A4C:  RLCF   x25,W
05A4E:  MOVWF  x0E
05A50:  RLCF   x0C,F
05A52:  RLCF   x0D,F
05A54:  RLCF   x0E,F
05A56:  RLCF   x0C,F
05A58:  RLCF   x0D,F
05A5A:  RLCF   x0E,F
05A5C:  RLCF   x0C,F
05A5E:  RLCF   x0D,F
05A60:  RLCF   x0E,F
05A62:  MOVLW  F0
05A64:  ANDWF  x0C,F
05A66:  MOVLW  04
05A68:  ADDWF  x07,W
05A6A:  MOVWF  FE9
05A6C:  MOVLW  00
05A6E:  ADDWFC x08,W
05A70:  MOVWF  FEA
05A72:  MOVFF  FEC,A24
05A76:  MOVF   FED,F
05A78:  MOVFF  FEF,A23
05A7C:  CLRF   x25
05A7E:  CLRF   x26
05A80:  CLRF   x0F
05A82:  RLCF   x23,W
05A84:  MOVWF  x10
05A86:  RLCF   x24,W
05A88:  MOVWF  x11
05A8A:  RLCF   x25,W
05A8C:  MOVWF  x12
05A8E:  RLCF   x10,F
05A90:  RLCF   x11,F
05A92:  RLCF   x12,F
05A94:  RLCF   x10,F
05A96:  RLCF   x11,F
05A98:  RLCF   x12,F
05A9A:  RLCF   x10,F
05A9C:  RLCF   x11,F
05A9E:  RLCF   x12,F
05AA0:  MOVLW  F0
05AA2:  ANDWF  x10,F
05AA4:  MOVLW  06
05AA6:  ADDWF  x07,W
05AA8:  MOVWF  FE9
05AAA:  MOVLW  00
05AAC:  ADDWFC x08,W
05AAE:  MOVWF  FEA
05AB0:  MOVFF  FEC,03
05AB4:  MOVF   FED,F
05AB6:  MOVFF  FEF,A23
05ABA:  CLRF   x25
05ABC:  CLRF   x13
05ABE:  RLCF   x23,W
05AC0:  MOVWF  x14
05AC2:  RLCF   03,W
05AC4:  MOVWF  x15
05AC6:  RLCF   x25,W
05AC8:  MOVWF  x16
05ACA:  RLCF   x14,F
05ACC:  RLCF   x15,F
05ACE:  RLCF   x16,F
05AD0:  RLCF   x14,F
05AD2:  RLCF   x15,F
05AD4:  RLCF   x16,F
05AD6:  RLCF   x14,F
05AD8:  RLCF   x15,F
05ADA:  RLCF   x16,F
05ADC:  MOVLW  F0
05ADE:  ANDWF  x14,F
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t source_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t origin = packet->origin_port; 
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address_ = (uint32_t)packet->destination_page * MEMORY_PAGE_SIZE; 
....................     uint32_t from_address_ = (uint32_t)packet->source_page * MEMORY_PAGE_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_pages * MEMORY_PAGE_SIZE; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX", origin, dest, to_address_, from_address_, size); 
05AE0:  MOVLW  94
05AE2:  MOVWF  FF6
05AE4:  MOVLW  07
05AE6:  MOVWF  FF7
05AE8:  MOVLW  00
05AEA:  MOVWF  FF8
05AEC:  MOVLW  0C
05AEE:  MOVWF  x3B
05AF0:  MOVLB  0
05AF2:  CALL   3048
05AF6:  MOVFF  A09,A25
05AFA:  MOVLW  18
05AFC:  MOVLB  A
05AFE:  MOVWF  x26
05B00:  MOVLB  0
05B02:  CALL   4960
05B06:  MOVLW  A2
05B08:  MOVWF  FF6
05B0A:  MOVLW  07
05B0C:  MOVWF  FF7
05B0E:  MOVLW  00
05B10:  MOVWF  FF8
05B12:  MOVLW  06
05B14:  MOVLB  A
05B16:  MOVWF  x3B
05B18:  MOVLB  0
05B1A:  CALL   3048
05B1E:  MOVFF  A0A,A25
05B22:  MOVLW  18
05B24:  MOVLB  A
05B26:  MOVWF  x26
05B28:  MOVLB  0
05B2A:  CALL   4960
05B2E:  MOVLW  AA
05B30:  MOVWF  FF6
05B32:  MOVLW  07
05B34:  MOVWF  FF7
05B36:  MOVLW  00
05B38:  MOVWF  FF8
05B3A:  MOVLW  09
05B3C:  MOVLB  A
05B3E:  MOVWF  x3B
05B40:  MOVLB  0
05B42:  CALL   3048
05B46:  MOVFF  A0E,A58
05B4A:  MOVLW  37
05B4C:  MOVLB  A
05B4E:  MOVWF  x59
05B50:  MOVLB  0
05B52:  CALL   3142
05B56:  MOVFF  A0D,A58
05B5A:  MOVLW  37
05B5C:  MOVLB  A
05B5E:  MOVWF  x59
05B60:  MOVLB  0
05B62:  CALL   3142
05B66:  MOVFF  A0C,A58
05B6A:  MOVLW  37
05B6C:  MOVLB  A
05B6E:  MOVWF  x59
05B70:  MOVLB  0
05B72:  CALL   3142
05B76:  MOVFF  A0B,A58
05B7A:  MOVLW  37
05B7C:  MOVLB  A
05B7E:  MOVWF  x59
05B80:  MOVLB  0
05B82:  CALL   3142
05B86:  MOVLW  B6
05B88:  MOVWF  FF6
05B8A:  MOVLW  07
05B8C:  MOVWF  FF7
05B8E:  MOVLW  00
05B90:  MOVWF  FF8
05B92:  MOVLW  0B
05B94:  MOVLB  A
05B96:  MOVWF  x3B
05B98:  MOVLB  0
05B9A:  CALL   3048
05B9E:  MOVFF  A12,A58
05BA2:  MOVLW  37
05BA4:  MOVLB  A
05BA6:  MOVWF  x59
05BA8:  MOVLB  0
05BAA:  CALL   3142
05BAE:  MOVFF  A11,A58
05BB2:  MOVLW  37
05BB4:  MOVLB  A
05BB6:  MOVWF  x59
05BB8:  MOVLB  0
05BBA:  CALL   3142
05BBE:  MOVFF  A10,A58
05BC2:  MOVLW  37
05BC4:  MOVLB  A
05BC6:  MOVWF  x59
05BC8:  MOVLB  0
05BCA:  CALL   3142
05BCE:  MOVFF  A0F,A58
05BD2:  MOVLW  37
05BD4:  MOVLB  A
05BD6:  MOVWF  x59
05BD8:  MOVLB  0
05BDA:  CALL   3142
05BDE:  MOVLW  C4
05BE0:  MOVWF  FF6
05BE2:  MOVLW  07
05BE4:  MOVWF  FF7
05BE6:  MOVLW  00
05BE8:  MOVWF  FF8
05BEA:  MOVLW  06
05BEC:  MOVLB  A
05BEE:  MOVWF  x3B
05BF0:  MOVLB  0
05BF2:  CALL   3048
05BF6:  MOVFF  A16,A58
05BFA:  MOVLW  37
05BFC:  MOVLB  A
05BFE:  MOVWF  x59
05C00:  MOVLB  0
05C02:  CALL   3142
05C06:  MOVFF  A15,A58
05C0A:  MOVLW  37
05C0C:  MOVLB  A
05C0E:  MOVWF  x59
05C10:  MOVLB  0
05C12:  CALL   3142
05C16:  MOVFF  A14,A58
05C1A:  MOVLW  37
05C1C:  MOVLB  A
05C1E:  MOVWF  x59
05C20:  MOVLB  0
05C22:  CALL   3142
05C26:  MOVFF  A13,A58
05C2A:  MOVLW  37
05C2C:  MOVLB  A
05C2E:  MOVWF  x59
05C30:  MOVLB  0
05C32:  CALL   3142
....................  
....................     get_com_shared_fm_access(); 
05C36:  RCALL  593C
....................  
....................     // Erase the pages before copying 
....................     if (dest == 0x00) { 
05C38:  MOVLB  A
05C3A:  MOVF   x0A,F
05C3C:  BNZ   5CAE
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
05C3E:  CLRF   x1A
05C40:  CLRF   x19
05C42:  CLRF   x18
05C44:  CLRF   x17
05C46:  MOVF   x1A,W
05C48:  SUBWF  x16,W
05C4A:  BNC   5CAC
05C4C:  BNZ   5C64
05C4E:  MOVF   x19,W
05C50:  SUBWF  x15,W
05C52:  BNC   5CAC
05C54:  BNZ   5C64
05C56:  MOVF   x18,W
05C58:  SUBWF  x14,W
05C5A:  BNC   5CAC
05C5C:  BNZ   5C64
05C5E:  MOVF   x13,W
05C60:  SUBWF  x17,W
05C62:  BC    5CAC
....................             flash_erase(&spi_port_COM_FM, to_address_ + i, ERASE_PAGE); 
05C64:  MOVF   x17,W
05C66:  ADDWF  x0B,W
05C68:  MOVWF  x23
05C6A:  MOVF   x18,W
05C6C:  ADDWFC x0C,W
05C6E:  MOVWF  x24
05C70:  MOVF   x19,W
05C72:  ADDWFC x0D,W
05C74:  MOVWF  x25
05C76:  MOVF   x1A,W
05C78:  ADDWFC x0E,W
05C7A:  MOVWF  x26
05C7C:  MOVLW  09
05C7E:  MOVWF  xD2
05C80:  MOVLW  1B
05C82:  MOVWF  xD1
05C84:  MOVFF  A26,AD6
05C88:  MOVFF  A25,AD5
05C8C:  MOVFF  A24,AD4
05C90:  MOVFF  A23,AD3
05C94:  MOVLW  21
05C96:  MOVWF  xD7
05C98:  MOVLB  0
05C9A:  CALL   371C
05C9E:  MOVLW  10
05CA0:  MOVLB  A
05CA2:  ADDWF  x18,F
05CA4:  MOVLW  00
05CA6:  ADDWFC x19,F
05CA8:  ADDWFC x1A,F
05CAA:  BRA    5C46
....................         } 
....................     } else if (dest == 0x01) { 
05CAC:  BRA    5D9E
05CAE:  DECFSZ x0A,W
05CB0:  BRA    5D22
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
05CB2:  CLRF   x1E
05CB4:  CLRF   x1D
05CB6:  CLRF   x1C
05CB8:  CLRF   x1B
05CBA:  MOVF   x1E,W
05CBC:  SUBWF  x16,W
05CBE:  BNC   5D20
05CC0:  BNZ   5CD8
05CC2:  MOVF   x1D,W
05CC4:  SUBWF  x15,W
05CC6:  BNC   5D20
05CC8:  BNZ   5CD8
05CCA:  MOVF   x1C,W
05CCC:  SUBWF  x14,W
05CCE:  BNC   5D20
05CD0:  BNZ   5CD8
05CD2:  MOVF   x13,W
05CD4:  SUBWF  x1B,W
05CD6:  BC    5D20
....................             flash_erase(&spi_port_MAIN_FM, to_address_ + i, ERASE_PAGE); 
05CD8:  MOVF   x1B,W
05CDA:  ADDWF  x0B,W
05CDC:  MOVWF  x23
05CDE:  MOVF   x1C,W
05CE0:  ADDWFC x0C,W
05CE2:  MOVWF  x24
05CE4:  MOVF   x1D,W
05CE6:  ADDWFC x0D,W
05CE8:  MOVWF  x25
05CEA:  MOVF   x1E,W
05CEC:  ADDWFC x0E,W
05CEE:  MOVWF  x26
05CF0:  MOVLW  09
05CF2:  MOVWF  xD2
05CF4:  MOVLW  25
05CF6:  MOVWF  xD1
05CF8:  MOVFF  A26,AD6
05CFC:  MOVFF  A25,AD5
05D00:  MOVFF  A24,AD4
05D04:  MOVFF  A23,AD3
05D08:  MOVLW  21
05D0A:  MOVWF  xD7
05D0C:  MOVLB  0
05D0E:  CALL   371C
05D12:  MOVLW  10
05D14:  MOVLB  A
05D16:  ADDWF  x1C,F
05D18:  MOVLW  00
05D1A:  ADDWFC x1D,F
05D1C:  ADDWFC x1E,F
05D1E:  BRA    5CBA
....................         } 
....................     } else if (dest == 0x02) { 
05D20:  BRA    5D9E
05D22:  MOVF   x0A,W
05D24:  SUBLW  02
05D26:  BNZ   5D9E
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
05D28:  CLRF   x22
05D2A:  CLRF   x21
05D2C:  CLRF   x20
05D2E:  CLRF   x1F
05D30:  MOVF   x22,W
05D32:  SUBWF  x16,W
05D34:  BNC   5D9E
05D36:  BNZ   5D4E
05D38:  MOVF   x21,W
05D3A:  SUBWF  x15,W
05D3C:  BNC   5D9E
05D3E:  BNZ   5D4E
05D40:  MOVF   x20,W
05D42:  SUBWF  x14,W
05D44:  BNC   5D9E
05D46:  BNZ   5D4E
05D48:  MOVF   x13,W
05D4A:  SUBWF  x1F,W
05D4C:  BC    5D9E
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
05D4E:  BCF    F92.5
05D50:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address_ + i, ERASE_PAGE); 
05D52:  MOVF   x1F,W
05D54:  ADDWF  x0B,W
05D56:  MOVWF  x23
05D58:  MOVF   x20,W
05D5A:  ADDWFC x0C,W
05D5C:  MOVWF  x24
05D5E:  MOVF   x21,W
05D60:  ADDWFC x0D,W
05D62:  MOVWF  x25
05D64:  MOVF   x22,W
05D66:  ADDWFC x0E,W
05D68:  MOVWF  x26
05D6A:  MOVLW  09
05D6C:  MOVWF  xD2
05D6E:  MOVLW  2F
05D70:  MOVWF  xD1
05D72:  MOVFF  A26,AD6
05D76:  MOVFF  A25,AD5
05D7A:  MOVFF  A24,AD4
05D7E:  MOVFF  A23,AD3
05D82:  MOVLW  21
05D84:  MOVWF  xD7
05D86:  MOVLB  0
05D88:  CALL   371C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
05D8C:  BCF    F92.5
05D8E:  BSF    F89.5
05D90:  MOVLW  10
05D92:  MOVLB  A
05D94:  ADDWF  x20,F
05D96:  MOVLW  00
05D98:  ADDWFC x21,F
05D9A:  ADDWFC x22,F
05D9C:  BRA    5D30
....................         } 
....................     } 
....................  
....................     if (origin == 0x00 && dest == 0x00) { 
05D9E:  MOVF   x09,F
05DA0:  BNZ   5DEE
05DA2:  MOVF   x0A,F
05DA4:  BNZ   5DEE
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
05DA6:  MOVLW  09
05DA8:  MOVWF  x24
05DAA:  MOVLW  1B
05DAC:  MOVWF  x23
05DAE:  MOVFF  A12,A28
05DB2:  MOVFF  A11,A27
05DB6:  MOVFF  A10,A26
05DBA:  MOVFF  A0F,A25
05DBE:  MOVLW  09
05DC0:  MOVWF  x2A
05DC2:  MOVLW  1B
05DC4:  MOVWF  x29
05DC6:  MOVFF  A0E,A2E
05DCA:  MOVFF  A0D,A2D
05DCE:  MOVFF  A0C,A2C
05DD2:  MOVFF  A0B,A2B
05DD6:  MOVFF  A16,A32
05DDA:  MOVFF  A15,A31
05DDE:  MOVFF  A14,A30
05DE2:  MOVFF  A13,A2F
05DE6:  MOVLB  0
05DE8:  RCALL  595C
....................  
....................     } else if (origin == 0x00 && dest == 0x01) { 
05DEA:  BRA    60AA
05DEC:  MOVLB  A
05DEE:  MOVF   x09,F
05DF0:  BNZ   5E3E
05DF2:  DECFSZ x0A,W
05DF4:  BRA    5E3E
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
05DF6:  MOVLW  09
05DF8:  MOVWF  x24
05DFA:  MOVLW  1B
05DFC:  MOVWF  x23
05DFE:  MOVFF  A12,A28
05E02:  MOVFF  A11,A27
05E06:  MOVFF  A10,A26
05E0A:  MOVFF  A0F,A25
05E0E:  MOVLW  09
05E10:  MOVWF  x2A
05E12:  MOVLW  25
05E14:  MOVWF  x29
05E16:  MOVFF  A0E,A2E
05E1A:  MOVFF  A0D,A2D
05E1E:  MOVFF  A0C,A2C
05E22:  MOVFF  A0B,A2B
05E26:  MOVFF  A16,A32
05E2A:  MOVFF  A15,A31
05E2E:  MOVFF  A14,A30
05E32:  MOVFF  A13,A2F
05E36:  MOVLB  0
05E38:  RCALL  595C
....................  
....................     } else if (origin == 0x00 && dest == 0x02) { 
05E3A:  BRA    60AA
05E3C:  MOVLB  A
05E3E:  MOVF   x09,F
05E40:  BNZ   5E98
05E42:  MOVF   x0A,W
05E44:  SUBLW  02
05E46:  BNZ   5E98
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
05E48:  BCF    F92.5
05E4A:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
05E4C:  MOVLW  09
05E4E:  MOVWF  x24
05E50:  MOVLW  1B
05E52:  MOVWF  x23
05E54:  MOVFF  A12,A28
05E58:  MOVFF  A11,A27
05E5C:  MOVFF  A10,A26
05E60:  MOVFF  A0F,A25
05E64:  MOVLW  09
05E66:  MOVWF  x2A
05E68:  MOVLW  2F
05E6A:  MOVWF  x29
05E6C:  MOVFF  A0E,A2E
05E70:  MOVFF  A0D,A2D
05E74:  MOVFF  A0C,A2C
05E78:  MOVFF  A0B,A2B
05E7C:  MOVFF  A16,A32
05E80:  MOVFF  A15,A31
05E84:  MOVFF  A14,A30
05E88:  MOVFF  A13,A2F
05E8C:  MOVLB  0
05E8E:  RCALL  595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
05E90:  BCF    F92.5
05E92:  BSF    F89.5
....................  
....................     } else if (origin == 0x01 && dest == 0x00) { 
05E94:  BRA    60AA
05E96:  MOVLB  A
05E98:  DECFSZ x09,W
05E9A:  BRA    5EE8
05E9C:  MOVF   x0A,F
05E9E:  BNZ   5EE8
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
05EA0:  MOVLW  09
05EA2:  MOVWF  x24
05EA4:  MOVLW  25
05EA6:  MOVWF  x23
05EA8:  MOVFF  A12,A28
05EAC:  MOVFF  A11,A27
05EB0:  MOVFF  A10,A26
05EB4:  MOVFF  A0F,A25
05EB8:  MOVLW  09
05EBA:  MOVWF  x2A
05EBC:  MOVLW  1B
05EBE:  MOVWF  x29
05EC0:  MOVFF  A0E,A2E
05EC4:  MOVFF  A0D,A2D
05EC8:  MOVFF  A0C,A2C
05ECC:  MOVFF  A0B,A2B
05ED0:  MOVFF  A16,A32
05ED4:  MOVFF  A15,A31
05ED8:  MOVFF  A14,A30
05EDC:  MOVFF  A13,A2F
05EE0:  MOVLB  0
05EE2:  RCALL  595C
....................  
....................     } else if (origin == 0x01 && dest == 0x01) { 
05EE4:  BRA    60AA
05EE6:  MOVLB  A
05EE8:  DECFSZ x09,W
05EEA:  BRA    5F38
05EEC:  DECFSZ x0A,W
05EEE:  BRA    5F38
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
05EF0:  MOVLW  09
05EF2:  MOVWF  x24
05EF4:  MOVLW  25
05EF6:  MOVWF  x23
05EF8:  MOVFF  A12,A28
05EFC:  MOVFF  A11,A27
05F00:  MOVFF  A10,A26
05F04:  MOVFF  A0F,A25
05F08:  MOVLW  09
05F0A:  MOVWF  x2A
05F0C:  MOVLW  25
05F0E:  MOVWF  x29
05F10:  MOVFF  A0E,A2E
05F14:  MOVFF  A0D,A2D
05F18:  MOVFF  A0C,A2C
05F1C:  MOVFF  A0B,A2B
05F20:  MOVFF  A16,A32
05F24:  MOVFF  A15,A31
05F28:  MOVFF  A14,A30
05F2C:  MOVFF  A13,A2F
05F30:  MOVLB  0
05F32:  RCALL  595C
....................  
....................     } else if (origin == 0x01 && dest == 0x02) { 
05F34:  BRA    60AA
05F36:  MOVLB  A
05F38:  DECFSZ x09,W
05F3A:  BRA    5F92
05F3C:  MOVF   x0A,W
05F3E:  SUBLW  02
05F40:  BNZ   5F92
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
05F42:  BCF    F92.5
05F44:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
05F46:  MOVLW  09
05F48:  MOVWF  x24
05F4A:  MOVLW  25
05F4C:  MOVWF  x23
05F4E:  MOVFF  A12,A28
05F52:  MOVFF  A11,A27
05F56:  MOVFF  A10,A26
05F5A:  MOVFF  A0F,A25
05F5E:  MOVLW  09
05F60:  MOVWF  x2A
05F62:  MOVLW  2F
05F64:  MOVWF  x29
05F66:  MOVFF  A0E,A2E
05F6A:  MOVFF  A0D,A2D
05F6E:  MOVFF  A0C,A2C
05F72:  MOVFF  A0B,A2B
05F76:  MOVFF  A16,A32
05F7A:  MOVFF  A15,A31
05F7E:  MOVFF  A14,A30
05F82:  MOVFF  A13,A2F
05F86:  MOVLB  0
05F88:  RCALL  595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
05F8A:  BCF    F92.5
05F8C:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x00) { 
05F8E:  BRA    60AA
05F90:  MOVLB  A
05F92:  MOVF   x09,W
05F94:  SUBLW  02
05F96:  BNZ   5FEC
05F98:  MOVF   x0A,F
05F9A:  BNZ   5FEC
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
05F9C:  BCF    F92.5
05F9E:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
05FA0:  MOVLW  09
05FA2:  MOVWF  x24
05FA4:  MOVLW  2F
05FA6:  MOVWF  x23
05FA8:  MOVFF  A12,A28
05FAC:  MOVFF  A11,A27
05FB0:  MOVFF  A10,A26
05FB4:  MOVFF  A0F,A25
05FB8:  MOVLW  09
05FBA:  MOVWF  x2A
05FBC:  MOVLW  1B
05FBE:  MOVWF  x29
05FC0:  MOVFF  A0E,A2E
05FC4:  MOVFF  A0D,A2D
05FC8:  MOVFF  A0C,A2C
05FCC:  MOVFF  A0B,A2B
05FD0:  MOVFF  A16,A32
05FD4:  MOVFF  A15,A31
05FD8:  MOVFF  A14,A30
05FDC:  MOVFF  A13,A2F
05FE0:  MOVLB  0
05FE2:  RCALL  595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
05FE4:  BCF    F92.5
05FE6:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x01) { 
05FE8:  BRA    60AA
05FEA:  MOVLB  A
05FEC:  MOVF   x09,W
05FEE:  SUBLW  02
05FF0:  BNZ   6046
05FF2:  DECFSZ x0A,W
05FF4:  BRA    6046
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
05FF6:  BCF    F92.5
05FF8:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
05FFA:  MOVLW  09
05FFC:  MOVWF  x24
05FFE:  MOVLW  2F
06000:  MOVWF  x23
06002:  MOVFF  A12,A28
06006:  MOVFF  A11,A27
0600A:  MOVFF  A10,A26
0600E:  MOVFF  A0F,A25
06012:  MOVLW  09
06014:  MOVWF  x2A
06016:  MOVLW  25
06018:  MOVWF  x29
0601A:  MOVFF  A0E,A2E
0601E:  MOVFF  A0D,A2D
06022:  MOVFF  A0C,A2C
06026:  MOVFF  A0B,A2B
0602A:  MOVFF  A16,A32
0602E:  MOVFF  A15,A31
06032:  MOVFF  A14,A30
06036:  MOVFF  A13,A2F
0603A:  MOVLB  0
0603C:  RCALL  595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0603E:  BCF    F92.5
06040:  BSF    F89.5
....................  
....................     } else if (origin == 0x02 && dest == 0x02) { 
06042:  BRA    60AA
06044:  MOVLB  A
06046:  MOVF   x09,W
06048:  SUBLW  02
0604A:  BNZ   60A2
0604C:  MOVF   x0A,W
0604E:  SUBLW  02
06050:  BNZ   60A2
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
06052:  BCF    F92.5
06054:  BCF    F89.5
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
06056:  MOVLW  09
06058:  MOVWF  x24
0605A:  MOVLW  2F
0605C:  MOVWF  x23
0605E:  MOVFF  A12,A28
06062:  MOVFF  A11,A27
06066:  MOVFF  A10,A26
0606A:  MOVFF  A0F,A25
0606E:  MOVLW  09
06070:  MOVWF  x2A
06072:  MOVLW  2F
06074:  MOVWF  x29
06076:  MOVFF  A0E,A2E
0607A:  MOVFF  A0D,A2D
0607E:  MOVFF  A0C,A2C
06082:  MOVFF  A0B,A2B
06086:  MOVFF  A16,A32
0608A:  MOVFF  A15,A31
0608E:  MOVFF  A14,A30
06092:  MOVFF  A13,A2F
06096:  MOVLB  0
06098:  RCALL  595C
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
0609A:  BCF    F92.5
0609C:  BSF    F89.5
....................  
....................     } else { 
0609E:  BRA    60AA
060A0:  MOVLB  A
....................         return 1; 
060A2:  MOVLW  01
060A4:  MOVWF  01
060A6:  BRA    60B0
060A8:  MOVLB  0
....................     } 
....................  
....................     return 0; 
060AA:  MOVLW  00
060AC:  MOVWF  01
060AE:  MOVLB  A
060B0:  MOVLB  0
060B2:  GOTO   CCB8 (RETURN)
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_page(uint8_t* data) 
*
0672A:  MOVFF  A06,A08
0672E:  MOVFF  A05,A07
06732:  MOVLW  06
06734:  MOVLB  A
06736:  ADDWF  x07,W
06738:  MOVWF  FE9
0673A:  MOVLW  00
0673C:  ADDWFC x08,W
0673E:  MOVWF  FEA
06740:  MOVFF  FEF,A09
06744:  MOVLW  02
06746:  ADDWF  x07,W
06748:  MOVWF  FE9
0674A:  MOVLW  00
0674C:  ADDWFC x08,W
0674E:  MOVWF  FEA
06750:  MOVFF  FEC,A1F
06754:  MOVF   FED,F
06756:  MOVFF  FEF,A1E
0675A:  CLRF   x20
0675C:  CLRF   x21
0675E:  CLRF   x0A
06760:  RLCF   x1E,W
06762:  MOVWF  x0B
06764:  RLCF   x1F,W
06766:  MOVWF  x0C
06768:  RLCF   x20,W
0676A:  MOVWF  x0D
0676C:  RLCF   x0B,F
0676E:  RLCF   x0C,F
06770:  RLCF   x0D,F
06772:  RLCF   x0B,F
06774:  RLCF   x0C,F
06776:  RLCF   x0D,F
06778:  RLCF   x0B,F
0677A:  RLCF   x0C,F
0677C:  RLCF   x0D,F
0677E:  MOVLW  F0
06780:  ANDWF  x0B,F
06782:  MOVLW  04
06784:  ADDWF  x07,W
06786:  MOVWF  FE9
06788:  MOVLW  00
0678A:  ADDWFC x08,W
0678C:  MOVWF  FEA
0678E:  MOVFF  FEC,03
06792:  MOVF   FED,F
06794:  MOVFF  FEF,A1E
06798:  CLRF   x20
0679A:  CLRF   x0E
0679C:  RLCF   x1E,W
0679E:  MOVWF  x0F
067A0:  RLCF   03,W
067A2:  MOVWF  x10
067A4:  RLCF   x20,W
067A6:  MOVWF  x11
067A8:  RLCF   x0F,F
067AA:  RLCF   x10,F
067AC:  RLCF   x11,F
067AE:  RLCF   x0F,F
067B0:  RLCF   x10,F
067B2:  RLCF   x11,F
067B4:  RLCF   x0F,F
067B6:  RLCF   x10,F
067B8:  RLCF   x11,F
067BA:  MOVLW  F0
067BC:  ANDWF  x0F,F
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_page * MEMORY_PAGE_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_pages * MEMORY_PAGE_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
067BE:  MOVLB  0
067C0:  CALL   593C
....................  
....................     if (dest == 0x00) { 
067C4:  MOVLB  A
067C6:  MOVF   x09,F
067C8:  BNZ   683A
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
067CA:  CLRF   x15
067CC:  CLRF   x14
067CE:  CLRF   x13
067D0:  CLRF   x12
067D2:  MOVF   x15,W
067D4:  SUBWF  x11,W
067D6:  BNC   6838
067D8:  BNZ   67F0
067DA:  MOVF   x14,W
067DC:  SUBWF  x10,W
067DE:  BNC   6838
067E0:  BNZ   67F0
067E2:  MOVF   x13,W
067E4:  SUBWF  x0F,W
067E6:  BNC   6838
067E8:  BNZ   67F0
067EA:  MOVF   x0E,W
067EC:  SUBWF  x12,W
067EE:  BC    6838
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_PAGE); 
067F0:  MOVF   x12,W
067F2:  ADDWF  x0A,W
067F4:  MOVWF  x1E
067F6:  MOVF   x13,W
067F8:  ADDWFC x0B,W
067FA:  MOVWF  x1F
067FC:  MOVF   x14,W
067FE:  ADDWFC x0C,W
06800:  MOVWF  x20
06802:  MOVF   x15,W
06804:  ADDWFC x0D,W
06806:  MOVWF  x21
06808:  MOVLW  09
0680A:  MOVWF  xD2
0680C:  MOVLW  1B
0680E:  MOVWF  xD1
06810:  MOVFF  A21,AD6
06814:  MOVFF  A20,AD5
06818:  MOVFF  A1F,AD4
0681C:  MOVFF  A1E,AD3
06820:  MOVLW  21
06822:  MOVWF  xD7
06824:  MOVLB  0
06826:  CALL   371C
0682A:  MOVLW  10
0682C:  MOVLB  A
0682E:  ADDWF  x13,F
06830:  MOVLW  00
06832:  ADDWFC x14,F
06834:  ADDWFC x15,F
06836:  BRA    67D2
....................         } 
....................     } else if (dest == 0x01) { 
06838:  BRA    692A
0683A:  DECFSZ x09,W
0683C:  BRA    68AE
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
0683E:  CLRF   x19
06840:  CLRF   x18
06842:  CLRF   x17
06844:  CLRF   x16
06846:  MOVF   x19,W
06848:  SUBWF  x11,W
0684A:  BNC   68AC
0684C:  BNZ   6864
0684E:  MOVF   x18,W
06850:  SUBWF  x10,W
06852:  BNC   68AC
06854:  BNZ   6864
06856:  MOVF   x17,W
06858:  SUBWF  x0F,W
0685A:  BNC   68AC
0685C:  BNZ   6864
0685E:  MOVF   x0E,W
06860:  SUBWF  x16,W
06862:  BC    68AC
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_PAGE); 
06864:  MOVF   x16,W
06866:  ADDWF  x0A,W
06868:  MOVWF  x1E
0686A:  MOVF   x17,W
0686C:  ADDWFC x0B,W
0686E:  MOVWF  x1F
06870:  MOVF   x18,W
06872:  ADDWFC x0C,W
06874:  MOVWF  x20
06876:  MOVF   x19,W
06878:  ADDWFC x0D,W
0687A:  MOVWF  x21
0687C:  MOVLW  09
0687E:  MOVWF  xD2
06880:  MOVLW  25
06882:  MOVWF  xD1
06884:  MOVFF  A21,AD6
06888:  MOVFF  A20,AD5
0688C:  MOVFF  A1F,AD4
06890:  MOVFF  A1E,AD3
06894:  MOVLW  21
06896:  MOVWF  xD7
06898:  MOVLB  0
0689A:  CALL   371C
0689E:  MOVLW  10
068A0:  MOVLB  A
068A2:  ADDWF  x17,F
068A4:  MOVLW  00
068A6:  ADDWFC x18,F
068A8:  ADDWFC x19,F
068AA:  BRA    6846
....................         } 
....................     } else if (dest == 0x02) { 
068AC:  BRA    692A
068AE:  MOVF   x09,W
068B0:  SUBLW  02
068B2:  BNZ   692A
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
068B4:  CLRF   x1D
068B6:  CLRF   x1C
068B8:  CLRF   x1B
068BA:  CLRF   x1A
068BC:  MOVF   x1D,W
068BE:  SUBWF  x11,W
068C0:  BNC   692A
068C2:  BNZ   68DA
068C4:  MOVF   x1C,W
068C6:  SUBWF  x10,W
068C8:  BNC   692A
068CA:  BNZ   68DA
068CC:  MOVF   x1B,W
068CE:  SUBWF  x0F,W
068D0:  BNC   692A
068D2:  BNZ   68DA
068D4:  MOVF   x0E,W
068D6:  SUBWF  x1A,W
068D8:  BC    692A
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
068DA:  BCF    F92.5
068DC:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_PAGE); 
068DE:  MOVF   x1A,W
068E0:  ADDWF  x0A,W
068E2:  MOVWF  x1E
068E4:  MOVF   x1B,W
068E6:  ADDWFC x0B,W
068E8:  MOVWF  x1F
068EA:  MOVF   x1C,W
068EC:  ADDWFC x0C,W
068EE:  MOVWF  x20
068F0:  MOVF   x1D,W
068F2:  ADDWFC x0D,W
068F4:  MOVWF  x21
068F6:  MOVLW  09
068F8:  MOVWF  xD2
068FA:  MOVLW  2F
068FC:  MOVWF  xD1
068FE:  MOVFF  A21,AD6
06902:  MOVFF  A20,AD5
06906:  MOVFF  A1F,AD4
0690A:  MOVFF  A1E,AD3
0690E:  MOVLW  21
06910:  MOVWF  xD7
06912:  MOVLB  0
06914:  CALL   371C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
06918:  BCF    F92.5
0691A:  BSF    F89.5
0691C:  MOVLW  10
0691E:  MOVLB  A
06920:  ADDWF  x1B,F
06922:  MOVLW  00
06924:  ADDWFC x1C,F
06926:  ADDWFC x1D,F
06928:  BRA    68BC
....................         } 
....................     } 
....................  
....................     return 0; 
0692A:  MOVLW  00
0692C:  MOVWF  01
0692E:  MOVLB  0
06930:  GOTO   CCDC (RETURN)
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_sector(uint8_t* data) 
06934:  MOVFF  A06,A08
06938:  MOVFF  A05,A07
0693C:  MOVLW  06
0693E:  MOVLB  A
06940:  ADDWF  x07,W
06942:  MOVWF  FE9
06944:  MOVLW  00
06946:  ADDWFC x08,W
06948:  MOVWF  FEA
0694A:  MOVFF  FEF,A09
0694E:  MOVLW  02
06950:  ADDWF  x07,W
06952:  MOVWF  FE9
06954:  MOVLW  00
06956:  ADDWFC x08,W
06958:  MOVWF  FEA
0695A:  MOVFF  FEC,03
0695E:  MOVF   FED,F
06960:  MOVFF  FEF,A0C
06964:  MOVFF  03,A1F
06968:  CLRF   x20
0696A:  CLRF   x21
0696C:  MOVFF  03,A0D
06970:  CLRF   x0A
06972:  CLRF   x0B
06974:  MOVLW  04
06976:  ADDWF  x07,W
06978:  MOVWF  FE9
0697A:  MOVLW  00
0697C:  ADDWFC x08,W
0697E:  MOVWF  FEA
06980:  MOVFF  FEC,A11
06984:  MOVF   FED,F
06986:  MOVFF  FEF,A10
0698A:  CLRF   x0E
0698C:  CLRF   x0F
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_sectors * MEMORY_SECTOR_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
0698E:  MOVLB  0
06990:  CALL   593C
....................  
....................     if (dest == 0x00) { 
06994:  MOVLB  A
06996:  MOVF   x09,F
06998:  BNZ   6A08
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
0699A:  CLRF   x15
0699C:  CLRF   x14
0699E:  CLRF   x13
069A0:  CLRF   x12
069A2:  MOVF   x15,W
069A4:  SUBWF  x11,W
069A6:  BNC   6A06
069A8:  BNZ   69C0
069AA:  MOVF   x14,W
069AC:  SUBWF  x10,W
069AE:  BNC   6A06
069B0:  BNZ   69C0
069B2:  MOVF   x13,W
069B4:  SUBWF  x0F,W
069B6:  BNC   6A06
069B8:  BNZ   69C0
069BA:  MOVF   x0E,W
069BC:  SUBWF  x12,W
069BE:  BC    6A06
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_SECTOR); 
069C0:  MOVF   x12,W
069C2:  ADDWF  x0A,W
069C4:  MOVWF  x1E
069C6:  MOVF   x13,W
069C8:  ADDWFC x0B,W
069CA:  MOVWF  x1F
069CC:  MOVF   x14,W
069CE:  ADDWFC x0C,W
069D0:  MOVWF  x20
069D2:  MOVF   x15,W
069D4:  ADDWFC x0D,W
069D6:  MOVWF  x21
069D8:  MOVLW  09
069DA:  MOVWF  xD2
069DC:  MOVLW  1B
069DE:  MOVWF  xD1
069E0:  MOVFF  A21,AD6
069E4:  MOVFF  A20,AD5
069E8:  MOVFF  A1F,AD4
069EC:  MOVFF  A1E,AD3
069F0:  MOVLW  DC
069F2:  MOVWF  xD7
069F4:  MOVLB  0
069F6:  CALL   371C
069FA:  MOVLW  01
069FC:  MOVLB  A
069FE:  ADDWF  x14,F
06A00:  MOVLW  00
06A02:  ADDWFC x15,F
06A04:  BRA    69A2
....................         } 
....................     } else if (dest == 0x01) { 
06A06:  BRA    6AF4
06A08:  DECFSZ x09,W
06A0A:  BRA    6A7A
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
06A0C:  CLRF   x19
06A0E:  CLRF   x18
06A10:  CLRF   x17
06A12:  CLRF   x16
06A14:  MOVF   x19,W
06A16:  SUBWF  x11,W
06A18:  BNC   6A78
06A1A:  BNZ   6A32
06A1C:  MOVF   x18,W
06A1E:  SUBWF  x10,W
06A20:  BNC   6A78
06A22:  BNZ   6A32
06A24:  MOVF   x17,W
06A26:  SUBWF  x0F,W
06A28:  BNC   6A78
06A2A:  BNZ   6A32
06A2C:  MOVF   x0E,W
06A2E:  SUBWF  x16,W
06A30:  BC    6A78
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_SECTOR); 
06A32:  MOVF   x16,W
06A34:  ADDWF  x0A,W
06A36:  MOVWF  x1E
06A38:  MOVF   x17,W
06A3A:  ADDWFC x0B,W
06A3C:  MOVWF  x1F
06A3E:  MOVF   x18,W
06A40:  ADDWFC x0C,W
06A42:  MOVWF  x20
06A44:  MOVF   x19,W
06A46:  ADDWFC x0D,W
06A48:  MOVWF  x21
06A4A:  MOVLW  09
06A4C:  MOVWF  xD2
06A4E:  MOVLW  25
06A50:  MOVWF  xD1
06A52:  MOVFF  A21,AD6
06A56:  MOVFF  A20,AD5
06A5A:  MOVFF  A1F,AD4
06A5E:  MOVFF  A1E,AD3
06A62:  MOVLW  DC
06A64:  MOVWF  xD7
06A66:  MOVLB  0
06A68:  CALL   371C
06A6C:  MOVLW  01
06A6E:  MOVLB  A
06A70:  ADDWF  x18,F
06A72:  MOVLW  00
06A74:  ADDWFC x19,F
06A76:  BRA    6A14
....................         } 
....................     } else if (dest == 0x02) { 
06A78:  BRA    6AF4
06A7A:  MOVF   x09,W
06A7C:  SUBLW  02
06A7E:  BNZ   6AF4
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
06A80:  CLRF   x1D
06A82:  CLRF   x1C
06A84:  CLRF   x1B
06A86:  CLRF   x1A
06A88:  MOVF   x1D,W
06A8A:  SUBWF  x11,W
06A8C:  BNC   6AF4
06A8E:  BNZ   6AA6
06A90:  MOVF   x1C,W
06A92:  SUBWF  x10,W
06A94:  BNC   6AF4
06A96:  BNZ   6AA6
06A98:  MOVF   x1B,W
06A9A:  SUBWF  x0F,W
06A9C:  BNC   6AF4
06A9E:  BNZ   6AA6
06AA0:  MOVF   x0E,W
06AA2:  SUBWF  x1A,W
06AA4:  BC    6AF4
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
06AA6:  BCF    F92.5
06AA8:  BCF    F89.5
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_SECTOR); 
06AAA:  MOVF   x1A,W
06AAC:  ADDWF  x0A,W
06AAE:  MOVWF  x1E
06AB0:  MOVF   x1B,W
06AB2:  ADDWFC x0B,W
06AB4:  MOVWF  x1F
06AB6:  MOVF   x1C,W
06AB8:  ADDWFC x0C,W
06ABA:  MOVWF  x20
06ABC:  MOVF   x1D,W
06ABE:  ADDWFC x0D,W
06AC0:  MOVWF  x21
06AC2:  MOVLW  09
06AC4:  MOVWF  xD2
06AC6:  MOVLW  2F
06AC8:  MOVWF  xD1
06ACA:  MOVFF  A21,AD6
06ACE:  MOVFF  A20,AD5
06AD2:  MOVFF  A1F,AD4
06AD6:  MOVFF  A1E,AD3
06ADA:  MOVLW  DC
06ADC:  MOVWF  xD7
06ADE:  MOVLB  0
06AE0:  CALL   371C
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
06AE4:  BCF    F92.5
06AE6:  BSF    F89.5
06AE8:  MOVLW  01
06AEA:  MOVLB  A
06AEC:  ADDWF  x1C,F
06AEE:  MOVLW  00
06AF0:  ADDWFC x1D,F
06AF2:  BRA    6A88
....................         } 
....................     } 
....................  
....................     return 0; 
06AF4:  MOVLW  00
06AF6:  MOVWF  01
06AF8:  MOVLB  0
06AFA:  GOTO   CCEE (RETURN)
.................... } 
....................  
.................... // Send data through xmodem protocol 
.................... uint8_t command_xmodem_send(uint8_t* data) 
*
091CE:  MOVLB  A
091D0:  CLRF   x07
091D2:  MOVFF  A06,A09
091D6:  MOVFF  A05,A08
091DA:  CLRF   x0A
.................... { 
....................     const uint8_t max_tries = 5; 
....................     uint8_t current_try = 0; 
....................     struct packet { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D0 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t destination_address; 
....................     }* packet = (struct packet*)data; 
....................     int8_t error = 0; 
....................     fprintf(PC, "Waiting for xmodem transfer..."); 
091DC:  MOVLW  CE
091DE:  MOVWF  FF6
091E0:  MOVLW  07
091E2:  MOVWF  FF7
091E4:  MOVLW  00
091E6:  MOVWF  FF8
091E8:  MOVLB  0
091EA:  CALL   1C7A
....................  
....................     uart_fn* destination_uart = NULL; 
091EE:  MOVLB  A
091F0:  CLRF   x0C
091F2:  CLRF   x0B
....................  
....................     while (current_try < max_tries) { 
091F4:  MOVF   x07,W
091F6:  SUBLW  04
091F8:  BTFSS  FD8.0
091FA:  BRA    9552
....................         switch (packet->destination) { 
091FC:  MOVLW  0B
091FE:  ADDWF  x08,W
09200:  MOVWF  FE9
09202:  MOVLW  00
09204:  ADDWFC x09,W
09206:  MOVWF  FEA
09208:  MOVF   FEF,W
0920A:  XORLW  00
0920C:  MOVLB  0
0920E:  BZ    921A
09210:  XORLW  01
09212:  BZ    9226
09214:  XORLW  03
09216:  BZ    9232
09218:  BRA    923E
....................         case 0: destination_uart = &uart_port_PC; break;   // For PC 
0921A:  MOVLW  07
0921C:  MOVLB  A
0921E:  MOVWF  x0C
09220:  MOVLW  DE
09222:  MOVWF  x0B
09224:  BRA    9248
....................         case 1: destination_uart = &uart_port_PCIB; break; // For PCIB 
09226:  MOVLW  08
09228:  MOVLB  A
0922A:  MOVWF  x0C
0922C:  MOVLW  17
0922E:  MOVWF  x0B
09230:  BRA    9248
....................         case 2: destination_uart = &uart_port_PCIB; break; // For Rpi 
09232:  MOVLW  08
09234:  MOVLB  A
09236:  MOVWF  x0C
09238:  MOVLW  17
0923A:  MOVWF  x0B
0923C:  BRA    9248
....................         default: destination_uart = &uart_port_PC; break; 
0923E:  MOVLW  07
09240:  MOVLB  A
09242:  MOVWF  x0C
09244:  MOVLW  DE
09246:  MOVWF  x0B
....................         } 
....................  
....................         if (packet->destination == 2) {                                                     // Rpi 
09248:  MOVLW  0B
0924A:  ADDWF  x08,W
0924C:  MOVWF  FE9
0924E:  MOVLW  00
09250:  ADDWFC x09,W
09252:  MOVWF  FEA
09254:  MOVF   FEF,W
09256:  SUBLW  02
09258:  BNZ   934C
....................             uint8_t message_pcib[MSG_LENGTH_PCIB] = { 0x0B, 0xCD };                         // Array with request for direct copy relay -> rpi = 0xCD 
0925A:  MOVLW  0B
0925C:  MOVWF  x0D
0925E:  MOVLW  CD
09260:  MOVWF  x0E
09262:  CLRF   x0F
09264:  CLRF   x10
09266:  CLRF   x11
09268:  CLRF   x12
0926A:  CLRF   x13
0926C:  CLRF   x14
0926E:  CLRF   x15
09270:  CLRF   x16
09272:  CLRF   x17
09274:  CLRF   x18
09276:  CLRF   x19
09278:  CLRF   x1A
0927A:  CLRF   x1B
0927C:  CLRF   x1C
0927E:  CLRF   x1D
09280:  CLRF   x1E
09282:  CLRF   x1F
09284:  CLRF   x20
09286:  CLRF   x21
09288:  CLRF   x22
0928A:  CLRF   x23
0928C:  CLRF   x24
0928E:  CLRF   x25
09290:  CLRF   x26
09292:  CLRF   x27
09294:  CLRF   x28
09296:  CLRF   x29
09298:  CLRF   x2A
0929A:  CLRF   x2B
0929C:  CLRF   x2C
0929E:  CLRF   x2D
092A0:  CLRF   x2E
092A2:  CLRF   x2F
092A4:  CLRF   x30
....................             checksum_obc(message_pcib, MSG_LENGTH_PCIB);                                    // Add checksum 
092A6:  MOVLW  0A
092A8:  MOVWF  x58
092AA:  MOVLW  0D
092AC:  MOVWF  x57
092AE:  MOVLW  24
092B0:  MOVWF  x59
092B2:  MOVLB  0
092B4:  CALL   712A
....................             uart_send_packet_repeat(&uart_port_PCIB, message_pcib, MSG_LENGTH_PCIB, 5, 10); // Send request 5 times, 100ms spaced 
092B8:  MOVLW  08
092BA:  MOVLB  A
092BC:  MOVWF  x58
092BE:  MOVLW  17
092C0:  MOVWF  x57
092C2:  MOVLW  0A
092C4:  MOVWF  x5A
092C6:  MOVLW  0D
092C8:  MOVWF  x59
092CA:  CLRF   x5E
092CC:  CLRF   x5D
092CE:  CLRF   x5C
092D0:  MOVLW  24
092D2:  MOVWF  x5B
092D4:  MOVLW  05
092D6:  MOVWF  x5F
092D8:  CLRF   x63
092DA:  CLRF   x62
092DC:  CLRF   x61
092DE:  MOVLW  0A
092E0:  MOVWF  x60
092E2:  MOVLB  0
092E4:  RCALL  8CAC
....................             delay_ms(1000); 
092E6:  MOVLW  04
092E8:  MOVLB  A
092EA:  MOVWF  x55
092EC:  MOVLW  FA
092EE:  MOVWF  xDB
092F0:  MOVLB  0
092F2:  CALL   36F2
092F6:  MOVLB  A
092F8:  DECFSZ x55,F
092FA:  BRA    92EC
....................             fprintf(PCIB, "\nrx,%05lu\n", packet->destination_address); 
092FC:  MOVLW  0C
092FE:  ADDWF  x08,W
09300:  MOVWF  FE9
09302:  MOVLW  00
09304:  ADDWFC x09,W
09306:  MOVWF  FEA
09308:  MOVFF  FEF,A55
0930C:  MOVFF  FEC,A56
09310:  MOVFF  FEC,A57
09314:  MOVFF  FEC,A58
09318:  MOVLW  EE
0931A:  MOVWF  FF6
0931C:  MOVLW  07
0931E:  MOVWF  FF7
09320:  MOVLW  00
09322:  MOVWF  FF8
09324:  MOVLW  04
09326:  MOVWF  x59
09328:  MOVLB  0
0932A:  BRA    8E68
0932C:  MOVLW  45
0932E:  MOVWF  FE9
09330:  MOVFF  A58,A5C
09334:  MOVFF  A57,A5B
09338:  MOVFF  A56,A5A
0933C:  MOVFF  A55,A59
09340:  BRA    8E9C
09342:  MOVLW  0A
09344:  BTFSS  F9E.4
09346:  BRA    9344
09348:  MOVWF  FAD
0934A:  MOVLB  A
....................         } 
....................  
....................         if (packet->destination == 1) { // PCIB 
0934C:  MOVLW  0B
0934E:  ADDWF  x08,W
09350:  MOVWF  FE9
09352:  MOVLW  00
09354:  ADDWFC x09,W
09356:  MOVWF  FEA
09358:  DECFSZ FEF,W
0935A:  BRA    93D4
....................             struct req { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint8_t source; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 9]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req; 
....................             req.origin = MSG_OBC; 
0935C:  MOVLW  0B
0935E:  MOVWF  x31
....................             req.command = 0xD1; // X-modem receive; 
09360:  MOVLW  D1
09362:  MOVWF  x32
....................             req.address = packet->destination_address; 
09364:  MOVLW  0C
09366:  ADDWF  x08,W
09368:  MOVWF  FE9
0936A:  MOVLW  00
0936C:  ADDWFC x09,W
0936E:  MOVWF  FEA
09370:  MOVFF  FEF,A33
09374:  MOVFF  FEC,A34
09378:  MOVFF  FEC,A35
0937C:  MOVFF  FEC,A36
....................             req.source = 1; // OBC 
09380:  MOVLW  01
09382:  MOVWF  x37
....................             checksum_obc((uint8_t*)&req, sizeof(req)); 
09384:  MOVLW  0A
09386:  MOVWF  x56
09388:  MOVLW  31
0938A:  MOVWF  x55
0938C:  MOVFF  A56,A58
09390:  MOVWF  x57
09392:  MOVLW  24
09394:  MOVWF  x59
09396:  MOVLB  0
09398:  CALL   712A
....................             uart_send_packet_repeat(&uart_port_PCIB, (uint8_t*)&req, sizeof(req), 5, 10); 
0939C:  MOVLW  0A
0939E:  MOVLB  A
093A0:  MOVWF  x56
093A2:  MOVLW  31
093A4:  MOVWF  x55
093A6:  MOVLW  08
093A8:  MOVWF  x58
093AA:  MOVLW  17
093AC:  MOVWF  x57
093AE:  MOVFF  A56,A5A
093B2:  MOVFF  A55,A59
093B6:  CLRF   x5E
093B8:  CLRF   x5D
093BA:  CLRF   x5C
093BC:  MOVLW  24
093BE:  MOVWF  x5B
093C0:  MOVLW  05
093C2:  MOVWF  x5F
093C4:  CLRF   x63
093C6:  CLRF   x62
093C8:  CLRF   x61
093CA:  MOVLW  0A
093CC:  MOVWF  x60
093CE:  MOVLB  0
093D0:  RCALL  8CAC
093D2:  MOVLB  A
....................         } 
....................  
....................         switch (packet->source) { 
093D4:  MOVLW  0A
093D6:  ADDWF  x08,W
093D8:  MOVWF  FE9
093DA:  MOVLW  00
093DC:  ADDWFC x09,W
093DE:  MOVWF  FEA
093E0:  MOVF   FEF,W
093E2:  XORLW  00
093E4:  MOVLB  0
093E6:  BZ    93F2
093E8:  XORLW  01
093EA:  BZ    9442
093EC:  XORLW  03
093EE:  BZ    948E
093F0:  BRA    94E2
....................         case 0: 
....................             get_com_shared_fm_access(); 
093F2:  CALL   593C
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, packet->source_address, packet->n_packets); 
093F6:  MOVLW  02
093F8:  MOVLB  A
093FA:  ADDWF  x08,W
093FC:  MOVWF  FE9
093FE:  MOVLW  00
09400:  ADDWFC x09,W
09402:  MOVWF  FEA
09404:  MOVFF  FEF,A5F
09408:  MOVFF  FEC,A60
0940C:  MOVFF  FEC,A61
09410:  MOVFF  FEC,A62
09414:  MOVLW  06
09416:  ADDWF  x08,W
09418:  MOVWF  FE9
0941A:  MOVLW  00
0941C:  ADDWFC x09,W
0941E:  MOVWF  FEA
09420:  MOVFF  FEF,A63
09424:  MOVFF  FEC,A64
09428:  MOVFF  A0C,A5C
0942C:  MOVFF  A0B,A5B
09430:  MOVLW  09
09432:  MOVWF  x5E
09434:  MOVLW  1B
09436:  MOVWF  x5D
09438:  MOVLB  0
0943A:  RCALL  907C
0943C:  MOVFF  01,A0A
....................             break; 
09440:  BRA    9530
....................         case 1: 
....................             error = xmodem_send(destination_uart, &spi_port_MAIN_FM, packet->source_address, packet->n_packets); 
09442:  MOVLW  02
09444:  MOVLB  A
09446:  ADDWF  x08,W
09448:  MOVWF  FE9
0944A:  MOVLW  00
0944C:  ADDWFC x09,W
0944E:  MOVWF  FEA
09450:  MOVFF  FEF,A5F
09454:  MOVFF  FEC,A60
09458:  MOVFF  FEC,A61
0945C:  MOVFF  FEC,A62
09460:  MOVLW  06
09462:  ADDWF  x08,W
09464:  MOVWF  FE9
09466:  MOVLW  00
09468:  ADDWFC x09,W
0946A:  MOVWF  FEA
0946C:  MOVFF  FEF,A63
09470:  MOVFF  FEC,A64
09474:  MOVFF  A0C,A5C
09478:  MOVFF  A0B,A5B
0947C:  MOVLW  09
0947E:  MOVWF  x5E
09480:  MOVLW  25
09482:  MOVWF  x5D
09484:  MOVLB  0
09486:  RCALL  907C
09488:  MOVFF  01,A0A
....................             break; 
0948C:  BRA    9530
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
0948E:  BCF    F92.5
09490:  BCF    F89.5
....................             error = xmodem_send(destination_uart, &spi_port_MISSION_FM, packet->source_address, packet->n_packets); 
09492:  MOVLW  02
09494:  MOVLB  A
09496:  ADDWF  x08,W
09498:  MOVWF  FE9
0949A:  MOVLW  00
0949C:  ADDWFC x09,W
0949E:  MOVWF  FEA
094A0:  MOVFF  FEF,A5F
094A4:  MOVFF  FEC,A60
094A8:  MOVFF  FEC,A61
094AC:  MOVFF  FEC,A62
094B0:  MOVLW  06
094B2:  ADDWF  x08,W
094B4:  MOVWF  FE9
094B6:  MOVLW  00
094B8:  ADDWFC x09,W
094BA:  MOVWF  FEA
094BC:  MOVFF  FEF,A63
094C0:  MOVFF  FEC,A64
094C4:  MOVFF  A0C,A5C
094C8:  MOVFF  A0B,A5B
094CC:  MOVLW  09
094CE:  MOVWF  x5E
094D0:  MOVLW  2F
094D2:  MOVWF  x5D
094D4:  MOVLB  0
094D6:  RCALL  907C
094D8:  MOVFF  01,A0A
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
094DC:  BCF    F92.5
094DE:  BSF    F89.5
....................             break; 
094E0:  BRA    9530
....................         default: 
....................             get_com_shared_fm_access(); 
094E2:  CALL   593C
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, packet->source_address, packet->n_packets); 
094E6:  MOVLW  02
094E8:  MOVLB  A
094EA:  ADDWF  x08,W
094EC:  MOVWF  FE9
094EE:  MOVLW  00
094F0:  ADDWFC x09,W
094F2:  MOVWF  FEA
094F4:  MOVFF  FEF,A5F
094F8:  MOVFF  FEC,A60
094FC:  MOVFF  FEC,A61
09500:  MOVFF  FEC,A62
09504:  MOVLW  06
09506:  ADDWF  x08,W
09508:  MOVWF  FE9
0950A:  MOVLW  00
0950C:  ADDWFC x09,W
0950E:  MOVWF  FEA
09510:  MOVFF  FEF,A63
09514:  MOVFF  FEC,A64
09518:  MOVFF  A0C,A5C
0951C:  MOVFF  A0B,A5B
09520:  MOVLW  09
09522:  MOVWF  x5E
09524:  MOVLW  1B
09526:  MOVWF  x5D
09528:  MOVLB  0
0952A:  RCALL  907C
0952C:  MOVFF  01,A0A
....................             break; 
....................         } 
....................         current_try++; 
09530:  MOVLB  A
09532:  INCF   x07,F
....................         delay_ms(1000); 
09534:  MOVLW  04
09536:  MOVWF  x55
09538:  MOVLW  FA
0953A:  MOVWF  xDB
0953C:  MOVLB  0
0953E:  CALL   36F2
09542:  MOVLB  A
09544:  DECFSZ x55,F
09546:  BRA    9538
....................         if (error != -1) 
09548:  MOVF   x0A,W
0954A:  SUBLW  FF
0954C:  BZ    9550
....................             break; 
0954E:  BRA    9552
09550:  BRA    91F4
....................     } 
....................     return error; 
09552:  MOVFF  A0A,01
09556:  MOVLB  0
09558:  GOTO   CF1C (RETURN)
.................... } 
....................  
.................... // Receive data through xmodem protocol 
.................... uint8_t command_xmodem_receive(uint8_t* data) 
*
09948:  MOVLB  A
0994A:  CLRF   x07
0994C:  MOVFF  A06,A09
09950:  MOVFF  A05,A08
09954:  CLRF   x0A
.................... { 
....................     const uint8_t max_tries = 5; 
....................     uint8_t current_try = 0; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     }* packet = (struct packet*)data; 
....................     int8_t total_packets = 0; 
....................     fprintf(PC, "Receiving xmodem data..."); 
09956:  MOVLW  FA
09958:  MOVWF  FF6
0995A:  MOVLW  07
0995C:  MOVWF  FF7
0995E:  MOVLW  00
09960:  MOVWF  FF8
09962:  MOVLB  0
09964:  CALL   1C7A
....................  
....................     uart_fn* source_uart = NULL; 
09968:  MOVLB  A
0996A:  CLRF   x0C
0996C:  CLRF   x0B
....................  
....................     switch (packet->source) { 
0996E:  MOVLW  06
09970:  ADDWF  x08,W
09972:  MOVWF  FE9
09974:  MOVLW  00
09976:  ADDWFC x09,W
09978:  MOVWF  FEA
0997A:  MOVF   FEF,W
0997C:  XORLW  00
0997E:  MOVLB  0
09980:  BZ    998C
09982:  XORLW  01
09984:  BZ    9998
09986:  XORLW  02
09988:  BZ    99A4
0998A:  BRA    99B0
....................     case 0: source_uart = &uart_port_PC; break; 
0998C:  MOVLW  07
0998E:  MOVLB  A
09990:  MOVWF  x0C
09992:  MOVLW  DE
09994:  MOVWF  x0B
09996:  BRA    99BA
....................     case 1: source_uart = &uart_port_PCIB; break; 
09998:  MOVLW  08
0999A:  MOVLB  A
0999C:  MOVWF  x0C
0999E:  MOVLW  17
099A0:  MOVWF  x0B
099A2:  BRA    99BA
....................     case 3: source_uart = &uart_port_ADCS; break; 
099A4:  MOVLW  08
099A6:  MOVLB  A
099A8:  MOVWF  x0C
099AA:  MOVLW  85
099AC:  MOVWF  x0B
099AE:  BRA    99BA
....................     default: source_uart = &uart_port_PC; break; 
099B0:  MOVLW  07
099B2:  MOVLB  A
099B4:  MOVWF  x0C
099B6:  MOVLW  DE
099B8:  MOVWF  x0B
....................     } 
....................  
....................     while (current_try < max_tries) { 
099BA:  MOVF   x07,W
099BC:  SUBLW  04
099BE:  BTFSS  FD8.0
099C0:  BRA    9BD8
....................         if (packet->source == 1) { // PCIB 
099C2:  MOVLW  06
099C4:  ADDWF  x08,W
099C6:  MOVWF  FE9
099C8:  MOVLW  00
099CA:  ADDWFC x09,W
099CC:  MOVWF  FEA
099CE:  DECFSZ FEF,W
099D0:  BRA    9A72
....................             struct req_pcib { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint32_t n_packets; 
....................                 uint8_t destination; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 13]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req_pcib; 
....................             req_pcib.origin = MSG_OBC; 
099D2:  MOVLW  0B
099D4:  MOVWF  x0D
....................             req_pcib.command = 0xD0; // X-modem send; 
099D6:  MOVLW  D0
099D8:  MOVWF  x0E
....................             req_pcib.address = packet->source_address; 
099DA:  MOVLW  08
099DC:  ADDWF  x08,W
099DE:  MOVWF  FE9
099E0:  MOVLW  00
099E2:  ADDWFC x09,W
099E4:  MOVWF  FEA
099E6:  MOVFF  FEF,A0F
099EA:  MOVFF  FEC,A10
099EE:  MOVFF  FEC,A11
099F2:  MOVFF  FEC,A12
....................             req_pcib.n_packets = packet->n_packets; 
099F6:  MOVLW  0C
099F8:  ADDWF  x08,W
099FA:  MOVWF  FE9
099FC:  MOVLW  00
099FE:  ADDWFC x09,W
09A00:  MOVWF  FEA
09A02:  MOVFF  FEF,A13
09A06:  MOVFF  FEC,A14
09A0A:  MOVFF  FEC,A15
09A0E:  MOVFF  FEC,A16
....................             req_pcib.destination = 1; // OBC 
09A12:  MOVLW  01
09A14:  MOVWF  x17
....................             checksum_obc((uint8_t*)&req_pcib, sizeof(req_pcib)); 
09A16:  MOVLW  0A
09A18:  MOVWF  x32
09A1A:  MOVLW  0D
09A1C:  MOVWF  x31
09A1E:  MOVFF  A32,A58
09A22:  MOVWF  x57
09A24:  MOVLW  24
09A26:  MOVWF  x59
09A28:  MOVLB  0
09A2A:  CALL   712A
....................             uart_send_packet_repeat(source_uart, (uint8_t*)&req_pcib, sizeof(req_pcib), 1, 10); 
09A2E:  MOVLW  0A
09A30:  MOVLB  A
09A32:  MOVWF  x32
09A34:  MOVLW  0D
09A36:  MOVWF  x31
09A38:  MOVFF  A0C,A58
09A3C:  MOVFF  A0B,A57
09A40:  MOVFF  A32,A5A
09A44:  MOVWF  x59
09A46:  CLRF   x5E
09A48:  CLRF   x5D
09A4A:  CLRF   x5C
09A4C:  MOVLW  24
09A4E:  MOVWF  x5B
09A50:  MOVLW  01
09A52:  MOVWF  x5F
09A54:  CLRF   x63
09A56:  CLRF   x62
09A58:  CLRF   x61
09A5A:  MOVLW  0A
09A5C:  MOVWF  x60
09A5E:  MOVLB  0
09A60:  CALL   8CAC
....................             delay_ms(100); 
09A64:  MOVLW  64
09A66:  MOVLB  A
09A68:  MOVWF  xDB
09A6A:  MOVLB  0
09A6C:  CALL   36F2
09A70:  MOVLB  A
....................         } 
....................         if (packet->source == 2 || packet->source == 3) { 
09A72:  MOVLW  06
09A74:  ADDWF  x08,W
09A76:  MOVWF  FE9
09A78:  MOVLW  00
09A7A:  ADDWFC x09,W
09A7C:  MOVWF  FEA
09A7E:  MOVF   FEF,W
09A80:  SUBLW  02
09A82:  BZ    9A96
09A84:  MOVLW  06
09A86:  ADDWF  x08,W
09A88:  MOVWF  FE9
09A8A:  MOVLW  00
09A8C:  ADDWFC x09,W
09A8E:  MOVWF  FEA
09A90:  MOVF   FEF,W
09A92:  SUBLW  03
09A94:  BNZ   9AAA
....................             delay_ms(5000); 
09A96:  MOVLW  14
09A98:  MOVWF  x31
09A9A:  MOVLW  FA
09A9C:  MOVWF  xDB
09A9E:  MOVLB  0
09AA0:  CALL   36F2
09AA4:  MOVLB  A
09AA6:  DECFSZ x31,F
09AA8:  BRA    9A9A
....................         } 
....................  
....................         switch (packet->destination) { 
09AAA:  MOVLW  07
09AAC:  ADDWF  x08,W
09AAE:  MOVWF  FE9
09AB0:  MOVLW  00
09AB2:  ADDWFC x09,W
09AB4:  MOVWF  FEA
09AB6:  MOVF   FEF,W
09AB8:  XORLW  00
09ABA:  MOVLB  0
09ABC:  BZ    9AC8
09ABE:  XORLW  01
09AC0:  BZ    9B04
09AC2:  XORLW  03
09AC4:  BZ    9B3C
09AC6:  BRA    9B7C
....................         case 0: 
....................             get_com_shared_fm_access(); 
09AC8:  CALL   593C
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, packet->destination_address); 
09ACC:  MOVLW  02
09ACE:  MOVLB  A
09AD0:  ADDWF  x08,W
09AD2:  MOVWF  FE9
09AD4:  MOVLW  00
09AD6:  ADDWFC x09,W
09AD8:  MOVWF  FEA
09ADA:  MOVFF  FEF,A39
09ADE:  MOVFF  FEC,A3A
09AE2:  MOVFF  FEC,A3B
09AE6:  MOVFF  FEC,A3C
09AEA:  MOVFF  A0C,A36
09AEE:  MOVFF  A0B,A35
09AF2:  MOVLW  09
09AF4:  MOVWF  x38
09AF6:  MOVLW  1B
09AF8:  MOVWF  x37
09AFA:  MOVLB  0
09AFC:  RCALL  9634
09AFE:  MOVFF  01,A0A
....................             break; 
09B02:  BRA    9BB6
....................         case 1: 
....................             total_packets = xmodem_receive(source_uart, &spi_port_MAIN_FM, packet->destination_address); 
09B04:  MOVLW  02
09B06:  MOVLB  A
09B08:  ADDWF  x08,W
09B0A:  MOVWF  FE9
09B0C:  MOVLW  00
09B0E:  ADDWFC x09,W
09B10:  MOVWF  FEA
09B12:  MOVFF  FEF,A39
09B16:  MOVFF  FEC,A3A
09B1A:  MOVFF  FEC,A3B
09B1E:  MOVFF  FEC,A3C
09B22:  MOVFF  A0C,A36
09B26:  MOVFF  A0B,A35
09B2A:  MOVLW  09
09B2C:  MOVWF  x38
09B2E:  MOVLW  25
09B30:  MOVWF  x37
09B32:  MOVLB  0
09B34:  RCALL  9634
09B36:  MOVFF  01,A0A
....................             break; 
09B3A:  BRA    9BB6
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
09B3C:  BCF    F92.5
09B3E:  BCF    F89.5
....................             total_packets = xmodem_receive(source_uart, &spi_port_MISSION_FM, packet->destination_address); 
09B40:  MOVLW  02
09B42:  MOVLB  A
09B44:  ADDWF  x08,W
09B46:  MOVWF  FE9
09B48:  MOVLW  00
09B4A:  ADDWFC x09,W
09B4C:  MOVWF  FEA
09B4E:  MOVFF  FEF,A39
09B52:  MOVFF  FEC,A3A
09B56:  MOVFF  FEC,A3B
09B5A:  MOVFF  FEC,A3C
09B5E:  MOVFF  A0C,A36
09B62:  MOVFF  A0B,A35
09B66:  MOVLW  09
09B68:  MOVWF  x38
09B6A:  MOVLW  2F
09B6C:  MOVWF  x37
09B6E:  MOVLB  0
09B70:  RCALL  9634
09B72:  MOVFF  01,A0A
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
09B76:  BCF    F92.5
09B78:  BSF    F89.5
....................             break; 
09B7A:  BRA    9BB6
....................         default: 
....................             get_com_shared_fm_access(); 
09B7C:  CALL   593C
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, packet->destination_address); 
09B80:  MOVLW  02
09B82:  MOVLB  A
09B84:  ADDWF  x08,W
09B86:  MOVWF  FE9
09B88:  MOVLW  00
09B8A:  ADDWFC x09,W
09B8C:  MOVWF  FEA
09B8E:  MOVFF  FEF,A39
09B92:  MOVFF  FEC,A3A
09B96:  MOVFF  FEC,A3B
09B9A:  MOVFF  FEC,A3C
09B9E:  MOVFF  A0C,A36
09BA2:  MOVFF  A0B,A35
09BA6:  MOVLW  09
09BA8:  MOVWF  x38
09BAA:  MOVLW  1B
09BAC:  MOVWF  x37
09BAE:  MOVLB  0
09BB0:  RCALL  9634
09BB2:  MOVFF  01,A0A
....................             break; 
....................         } 
....................         current_try++; 
09BB6:  MOVLB  A
09BB8:  INCF   x07,F
....................         delay_ms(1000); 
09BBA:  MOVLW  04
09BBC:  MOVWF  x31
09BBE:  MOVLW  FA
09BC0:  MOVWF  xDB
09BC2:  MOVLB  0
09BC4:  CALL   36F2
09BC8:  MOVLB  A
09BCA:  DECFSZ x31,F
09BCC:  BRA    9BBE
....................         if (total_packets != -1) 
09BCE:  MOVF   x0A,W
09BD0:  SUBLW  FF
09BD2:  BZ    9BD6
....................             break; 
09BD4:  BRA    9BD8
09BD6:  BRA    99BA
....................     } 
....................     return total_packets; 
09BD8:  MOVFF  A0A,01
09BDC:  MOVLB  0
09BDE:  GOTO   CF2E (RETURN)
.................... } 
....................  
.................... uint8_t command_clear_all_schedule_commands(uint8_t* data) 
.................... { 
....................     scheduled_command_clear_all(); 
*
0B3D8:  RCALL  B39C
....................     return 0; 
0B3DA:  MOVLW  00
0B3DC:  MOVWF  01
0B3DE:  GOTO   CFE2 (RETURN)
.................... } 
....................  
.................... uint8_t command_boot_flag_set(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
*
0B3EE:  CALL   593C
....................     uint8_t value = data[2]; 
0B3F2:  MOVLW  02
0B3F4:  MOVLB  A
0B3F6:  ADDWF  x05,W
0B3F8:  MOVWF  FE9
0B3FA:  MOVLW  00
0B3FC:  ADDWFC x06,W
0B3FE:  MOVWF  FEA
0B400:  MOVFF  FEF,A07
....................     boot_flags.deployment_flag = value; 
0B404:  MOVFF  A07,ED
....................     uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
0B408:  CLRF   x0B
0B40A:  MOVLW  ED
0B40C:  MOVFF  A0B,A09
0B410:  MOVWF  x08
....................     flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
0B412:  MOVLW  09
0B414:  MOVWF  x33
0B416:  MOVLW  1B
0B418:  MOVWF  x32
0B41A:  CLRF   x37
0B41C:  CLRF   x36
0B41E:  CLRF   x35
0B420:  CLRF   x34
0B422:  CLRF   x3B
0B424:  CLRF   x3A
0B426:  CLRF   x39
0B428:  MOVLW  01
0B42A:  MOVWF  x38
0B42C:  MOVLB  0
0B42E:  CALL   3968
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
0B432:  MOVLW  09
0B434:  MOVLB  A
0B436:  MOVWF  xD0
0B438:  MOVLW  1B
0B43A:  MOVWF  xCF
0B43C:  CLRF   xD4
0B43E:  CLRF   xD3
0B440:  CLRF   xD2
0B442:  CLRF   xD1
0B444:  MOVFF  A09,AD6
0B448:  MOVFF  A08,AD5
0B44C:  CLRF   xDA
0B44E:  CLRF   xD9
0B450:  CLRF   xD8
0B452:  MOVLW  01
0B454:  MOVWF  xD7
0B456:  MOVLB  0
0B458:  CALL   3C1A
....................     scheduled_command_clear_all(); 
0B45C:  RCALL  B39C
....................     return value; 
0B45E:  MOVLB  A
0B460:  MOVFF  A07,01
0B464:  MOVLB  0
0B466:  GOTO   D006 (RETURN)
.................... } 
....................  
.................... // Reset log command 
.................... uint8_t command_reset_log(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Main PIC reset detected."); 
*
0C510:  MOVLW  14
0C512:  MOVWF  FF6
0C514:  MOVLW  08
0C516:  MOVWF  FF7
0C518:  MOVLW  00
0C51A:  MOVWF  FF8
0C51C:  CALL   1C7A
....................     return boot_flags.deployment_flag; 
0C520:  MOVFF  ED,01
0C524:  GOTO   D060 (RETURN)
.................... } 
....................  
.................... // Telemetry keeping function 
.................... uint8_t command_save_telemetry(uint8_t* data) 
.................... { 
....................     uart_mux = 1; 
*
0B072:  MOVLW  01
0B074:  MOVLB  6
0B076:  MOVWF  x82
....................     if (!memory_busy) { 
0B078:  MOVLB  4
0B07A:  MOVF   xBF,F
0B07C:  BTFSS  FD8.2
0B07E:  BRA    B382
....................         // Write the obc timestamp to telemetry and relative collection times 
....................         telemetry.obc_time = current_time; 
0B080:  MOVFF  3C,CA
0B084:  MOVFF  3B,C9
0B088:  MOVFF  3A,C8
0B08C:  MOVFF  39,C7
....................         telemetry.reset_time = current_time - telemetry_time.reset_time > 255 ? 255 : current_time - telemetry_time.reset_time; 
0B090:  MOVLB  0
0B092:  MOVF   xCD,W
0B094:  SUBWF  39,W
0B096:  MOVLB  A
0B098:  MOVWF  x13
0B09A:  MOVLB  0
0B09C:  MOVF   xCE,W
0B09E:  SUBWFB 3A,W
0B0A0:  MOVLB  A
0B0A2:  MOVWF  x14
0B0A4:  MOVLB  0
0B0A6:  MOVF   xCF,W
0B0A8:  SUBWFB 3B,W
0B0AA:  MOVLB  A
0B0AC:  MOVWF  x15
0B0AE:  MOVLB  0
0B0B0:  MOVF   xD0,W
0B0B2:  SUBWFB 3C,W
0B0B4:  MOVLB  A
0B0B6:  MOVWF  x16
0B0B8:  BTFSC  FE8.7
0B0BA:  BRA    B0CE
0B0BC:  MOVF   x16,F
0B0BE:  BNZ   B0CA
0B0C0:  MOVF   x15,F
0B0C2:  BNZ   B0CA
0B0C4:  MOVF   x14,W
0B0C6:  SUBLW  00
0B0C8:  BC    B0CE
0B0CA:  MOVLW  FF
0B0CC:  BRA    B0EC
0B0CE:  MOVLB  0
0B0D0:  MOVF   xCD,W
0B0D2:  SUBWF  39,W
0B0D4:  MOVWF  00
0B0D6:  MOVF   xCE,W
0B0D8:  SUBWFB 3A,W
0B0DA:  MOVWF  01
0B0DC:  MOVF   xCF,W
0B0DE:  SUBWFB 3B,W
0B0E0:  MOVWF  02
0B0E2:  MOVF   xD0,W
0B0E4:  SUBWFB 3C,W
0B0E6:  MOVWF  03
0B0E8:  MOVF   00,W
0B0EA:  MOVLB  A
0B0EC:  MOVWF  41
....................         telemetry.fab_time = current_time - telemetry_time.fab_time > 255 ? 255 : current_time - telemetry_time.fab_time; 
0B0EE:  MOVLB  0
0B0F0:  MOVF   xD1,W
0B0F2:  SUBWF  39,W
0B0F4:  MOVLB  A
0B0F6:  MOVWF  x13
0B0F8:  MOVLB  0
0B0FA:  MOVF   xD2,W
0B0FC:  SUBWFB 3A,W
0B0FE:  MOVLB  A
0B100:  MOVWF  x14
0B102:  MOVLB  0
0B104:  MOVF   xD3,W
0B106:  SUBWFB 3B,W
0B108:  MOVLB  A
0B10A:  MOVWF  x15
0B10C:  MOVLB  0
0B10E:  MOVF   xD4,W
0B110:  SUBWFB 3C,W
0B112:  MOVLB  A
0B114:  MOVWF  x16
0B116:  BTFSC  FE8.7
0B118:  BRA    B12C
0B11A:  MOVF   x16,F
0B11C:  BNZ   B128
0B11E:  MOVF   x15,F
0B120:  BNZ   B128
0B122:  MOVF   x14,W
0B124:  SUBLW  00
0B126:  BC    B12C
0B128:  MOVLW  FF
0B12A:  BRA    B14A
0B12C:  MOVLB  0
0B12E:  MOVF   xD1,W
0B130:  SUBWF  39,W
0B132:  MOVWF  00
0B134:  MOVF   xD2,W
0B136:  SUBWFB 3A,W
0B138:  MOVWF  01
0B13A:  MOVF   xD3,W
0B13C:  SUBWFB 3B,W
0B13E:  MOVWF  02
0B140:  MOVF   xD4,W
0B142:  SUBWFB 3C,W
0B144:  MOVWF  03
0B146:  MOVF   00,W
0B148:  MOVLB  A
0B14A:  MOVWF  5A
....................         telemetry.pcib_time = current_time - telemetry_time.pcib_time > 255 ? 255 : current_time - telemetry_time.pcib_time; 
0B14C:  MOVLB  0
0B14E:  MOVF   xD5,W
0B150:  SUBWF  39,W
0B152:  MOVLB  A
0B154:  MOVWF  x13
0B156:  MOVLB  0
0B158:  MOVF   xD6,W
0B15A:  SUBWFB 3A,W
0B15C:  MOVLB  A
0B15E:  MOVWF  x14
0B160:  MOVLB  0
0B162:  MOVF   xD7,W
0B164:  SUBWFB 3B,W
0B166:  MOVLB  A
0B168:  MOVWF  x15
0B16A:  MOVLB  0
0B16C:  MOVF   xD8,W
0B16E:  SUBWFB 3C,W
0B170:  MOVLB  A
0B172:  MOVWF  x16
0B174:  BTFSC  FE8.7
0B176:  BRA    B18A
0B178:  MOVF   x16,F
0B17A:  BNZ   B186
0B17C:  MOVF   x15,F
0B17E:  BNZ   B186
0B180:  MOVF   x14,W
0B182:  SUBLW  00
0B184:  BC    B18A
0B186:  MOVLW  FF
0B188:  BRA    B1A6
0B18A:  MOVLB  0
0B18C:  MOVF   xD5,W
0B18E:  SUBWF  39,W
0B190:  MOVWF  00
0B192:  MOVF   xD6,W
0B194:  SUBWFB 3A,W
0B196:  MOVWF  01
0B198:  MOVF   xD7,W
0B19A:  SUBWFB 3B,W
0B19C:  MOVWF  02
0B19E:  MOVF   xD8,W
0B1A0:  SUBWFB 3C,W
0B1A2:  MOVWF  03
0B1A4:  MOVF   00,W
0B1A6:  MOVLB  0
0B1A8:  MOVWF  x91
....................         telemetry.adcs_time = current_time - telemetry_time.adcs_time > 255 ? 255 : current_time - telemetry_time.adcs_time; 
0B1AA:  MOVF   xD9,W
0B1AC:  SUBWF  39,W
0B1AE:  MOVLB  A
0B1B0:  MOVWF  x13
0B1B2:  MOVLB  0
0B1B4:  MOVF   xDA,W
0B1B6:  SUBWFB 3A,W
0B1B8:  MOVLB  A
0B1BA:  MOVWF  x14
0B1BC:  MOVLB  0
0B1BE:  MOVF   xDB,W
0B1C0:  SUBWFB 3B,W
0B1C2:  MOVLB  A
0B1C4:  MOVWF  x15
0B1C6:  MOVLB  0
0B1C8:  MOVF   xDC,W
0B1CA:  SUBWFB 3C,W
0B1CC:  MOVLB  A
0B1CE:  MOVWF  x16
0B1D0:  BTFSC  FE8.7
0B1D2:  BRA    B1E6
0B1D4:  MOVF   x16,F
0B1D6:  BNZ   B1E2
0B1D8:  MOVF   x15,F
0B1DA:  BNZ   B1E2
0B1DC:  MOVF   x14,W
0B1DE:  SUBLW  00
0B1E0:  BC    B1E6
0B1E2:  MOVLW  FF
0B1E4:  BRA    B202
0B1E6:  MOVLB  0
0B1E8:  MOVF   xD9,W
0B1EA:  SUBWF  39,W
0B1EC:  MOVWF  00
0B1EE:  MOVF   xDA,W
0B1F0:  SUBWFB 3A,W
0B1F2:  MOVWF  01
0B1F4:  MOVF   xDB,W
0B1F6:  SUBWFB 3B,W
0B1F8:  MOVWF  02
0B1FA:  MOVF   xDC,W
0B1FC:  SUBWFB 3C,W
0B1FE:  MOVWF  03
0B200:  MOVF   00,W
0B202:  MOVLB  0
0B204:  MOVWF  x9C
....................         telemetry.com_time = current_time - telemetry_time.com_time > 255 ? 255 : current_time - telemetry_time.com_time; 
0B206:  MOVF   xDD,W
0B208:  SUBWF  39,W
0B20A:  MOVLB  A
0B20C:  MOVWF  x13
0B20E:  MOVLB  0
0B210:  MOVF   xDE,W
0B212:  SUBWFB 3A,W
0B214:  MOVLB  A
0B216:  MOVWF  x14
0B218:  MOVLB  0
0B21A:  MOVF   xDF,W
0B21C:  SUBWFB 3B,W
0B21E:  MOVLB  A
0B220:  MOVWF  x15
0B222:  MOVLB  0
0B224:  MOVF   xE0,W
0B226:  SUBWFB 3C,W
0B228:  MOVLB  A
0B22A:  MOVWF  x16
0B22C:  BTFSC  FE8.7
0B22E:  BRA    B242
0B230:  MOVF   x16,F
0B232:  BNZ   B23E
0B234:  MOVF   x15,F
0B236:  BNZ   B23E
0B238:  MOVF   x14,W
0B23A:  SUBLW  00
0B23C:  BC    B242
0B23E:  MOVLW  FF
0B240:  BRA    B25E
0B242:  MOVLB  0
0B244:  MOVF   xDD,W
0B246:  SUBWF  39,W
0B248:  MOVWF  00
0B24A:  MOVF   xDE,W
0B24C:  SUBWFB 3A,W
0B24E:  MOVWF  01
0B250:  MOVF   xDF,W
0B252:  SUBWFB 3B,W
0B254:  MOVWF  02
0B256:  MOVF   xE0,W
0B258:  SUBWFB 3C,W
0B25A:  MOVWF  03
0B25C:  MOVF   00,W
0B25E:  MOVLB  0
0B260:  MOVWF  xC4
....................  
....................         // Save telemetry to flash 
....................         uint8_t* telemetry_data = (uint8_t*)&telemetry; 
0B262:  MOVLB  A
0B264:  CLRF   x14
0B266:  MOVLW  41
0B268:  MOVFF  A14,A08
0B26C:  MOVWF  x07
....................         flash_cycle_write(&spi_port_COM_FM, telemetry_data, &addr_flags.flash_telemetry); 
0B26E:  MOVLW  09
0B270:  MOVWF  x17
0B272:  MOVLW  1B
0B274:  MOVWF  x16
0B276:  MOVFF  A08,A19
0B27A:  MOVFF  A07,A18
0B27E:  MOVLW  01
0B280:  MOVWF  x1B
0B282:  MOVLW  12
0B284:  MOVWF  x1A
0B286:  MOVLB  0
0B288:  CALL   3D34
....................         fprintf(PC, "Saving telemetry data: "); 
0B28C:  MOVLW  2E
0B28E:  MOVWF  FF6
0B290:  MOVLW  08
0B292:  MOVWF  FF7
0B294:  MOVLW  00
0B296:  MOVWF  FF8
0B298:  CALL   1C7A
....................         fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_telemetry.current - sizeof(telemetry)); 
0B29C:  MOVLW  8C
0B29E:  MOVLB  1
0B2A0:  SUBWF  x1A,W
0B2A2:  MOVLB  A
0B2A4:  MOVWF  x13
0B2A6:  MOVLW  00
0B2A8:  MOVLB  1
0B2AA:  SUBWFB x1B,W
0B2AC:  MOVLB  A
0B2AE:  MOVWF  x14
0B2B0:  MOVLW  00
0B2B2:  MOVLB  1
0B2B4:  SUBWFB x1C,W
0B2B6:  MOVLB  A
0B2B8:  MOVWF  x15
0B2BA:  MOVLW  00
0B2BC:  MOVLB  1
0B2BE:  SUBWFB x1D,W
0B2C0:  MOVLB  A
0B2C2:  MOVWF  x16
0B2C4:  MOVLW  46
0B2C6:  MOVWF  FF6
0B2C8:  MOVLW  08
0B2CA:  MOVWF  FF7
0B2CC:  MOVLW  00
0B2CE:  MOVWF  FF8
0B2D0:  MOVLW  08
0B2D2:  MOVWF  x3B
0B2D4:  MOVLB  0
0B2D6:  CALL   3048
0B2DA:  MOVFF  A16,A58
0B2DE:  MOVLW  37
0B2E0:  MOVLB  A
0B2E2:  MOVWF  x59
0B2E4:  MOVLB  0
0B2E6:  CALL   3142
0B2EA:  MOVFF  A15,A58
0B2EE:  MOVLW  37
0B2F0:  MOVLB  A
0B2F2:  MOVWF  x59
0B2F4:  MOVLB  0
0B2F6:  CALL   3142
0B2FA:  MOVFF  A14,A58
0B2FE:  MOVLW  37
0B300:  MOVLB  A
0B302:  MOVWF  x59
0B304:  MOVLB  0
0B306:  CALL   3142
0B30A:  MOVFF  A13,A58
0B30E:  MOVLW  37
0B310:  MOVLB  A
0B312:  MOVWF  x59
0B314:  MOVLB  0
0B316:  CALL   3142
0B31A:  MOVLW  20
0B31C:  MOVLB  B
0B31E:  MOVWF  x1F
0B320:  MOVLB  0
0B322:  CALL   1C34
....................  
....................         build_cw();             // Prepare CW strings 
0B326:  GOTO   AB06
....................         initialize_telemetry(); // Reset for next iteration 
0B32A:  CALL   2982
....................  
....................         // Save satellite log to flash 
....................         log_flush(); 
0B32E:  BRA    AF30
....................  
....................         // Save addresses to flash 
....................         struct addr { 
....................             uint32_t flash_log_current; 
....................             uint32_t flash_telemetry_current; 
....................         } addr; 
....................  
....................         uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
0B330:  MOVLW  0A
0B332:  MOVLB  A
0B334:  MOVWF  x14
0B336:  MOVLW  09
0B338:  MOVFF  A14,A12
0B33C:  MOVWF  x11
....................  
....................         addr.flash_log_current = addr_flags.flash_log.current; 
0B33E:  MOVFF  110,A0C
0B342:  MOVFF  10F,A0B
0B346:  MOVFF  10E,A0A
0B34A:  MOVFF  10D,A09
....................         addr.flash_telemetry_current = addr_flags.flash_telemetry.current; 
0B34E:  MOVFF  11D,A10
0B352:  MOVFF  11C,A0F
0B356:  MOVFF  11B,A0E
0B35A:  MOVFF  11A,A0D
....................  
....................         flash_cycle_write(&spi_port_COM_FM, addr_flag_ptr, &addr_flags.flash_addr); 
0B35E:  MOVWF  x17
0B360:  MOVLW  1B
0B362:  MOVWF  x16
0B364:  MOVFF  A12,A19
0B368:  MOVFF  A11,A18
0B36C:  CLRF   x1B
0B36E:  MOVLW  F8
0B370:  MOVWF  x1A
0B372:  MOVLB  0
0B374:  CALL   3D34
....................         return 0; 
0B378:  MOVLW  00
0B37A:  MOVWF  01
0B37C:  BRA    B398
....................     } else { 
0B37E:  BRA    B398
0B380:  MOVLB  4
....................         fprintf(PC, "Skipping saving telemetry data."); 
0B382:  MOVLW  56
0B384:  MOVWF  FF6
0B386:  MOVLW  08
0B388:  MOVWF  FF7
0B38A:  MOVLW  00
0B38C:  MOVWF  FF8
0B38E:  MOVLB  0
0B390:  CALL   1C7A
....................         return 1; 
0B394:  MOVLW  01
0B396:  MOVWF  01
....................     } 
0B398:  GOTO   CFD0 (RETURN)
.................... } 
....................  
.................... // Change OCP's default state 
.................... uint8_t command_ocp_state(uint8_t* data) 
*
08AE0:  MOVFF  A06,A08
08AE4:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin;     // 0xC0 
....................         uint8_t command;    // 0xAE 
....................         uint8_t on_off;     // 0: off; 1: on 
....................         uint8_t ocp_number; // 0: adcs; 1: pcib 
....................     }* packet = (struct packet*)data; 
....................  
....................     enum { ocp_adcs = 0, 
....................         ocp_pcib = 1 }; 
....................  
....................     switch (packet->ocp_number) { 
08AE8:  MOVLW  03
08AEA:  MOVLB  A
08AEC:  ADDWF  x07,W
08AEE:  MOVWF  FE9
08AF0:  MOVLW  00
08AF2:  ADDWFC x08,W
08AF4:  MOVWF  FEA
08AF6:  MOVF   FEF,W
08AF8:  XORLW  00
08AFA:  MOVLB  0
08AFC:  BZ    8B04
08AFE:  XORLW  01
08B00:  BZ    8B38
08B02:  BRA    8B6A
....................     case ocp_adcs: 
....................         output_bit(OCP_EN_ADCS, packet->on_off); 
08B04:  MOVLW  02
08B06:  MOVLB  A
08B08:  ADDWF  x07,W
08B0A:  MOVWF  FE9
08B0C:  MOVLW  00
08B0E:  ADDWFC x08,W
08B10:  MOVWF  FEA
08B12:  MOVF   FEF,F
08B14:  BNZ   8B1A
08B16:  BCF    F8F.4
08B18:  BRA    8B1C
08B1A:  BSF    F8F.4
08B1C:  BCF    F98.4
....................         obc_flags.adcs_on_off = packet->on_off; 
08B1E:  MOVLW  02
08B20:  ADDWF  x07,W
08B22:  MOVWF  FE9
08B24:  MOVLW  00
08B26:  ADDWFC x08,W
08B28:  MOVWF  FEA
08B2A:  MOVFF  FEF,EF
....................         return obc_flags.adcs_on_off; 
08B2E:  MOVLB  0
08B30:  MOVFF  EF,01
08B34:  BRA    8B6E
....................         break; 
08B36:  BRA    8B6A
....................     case ocp_pcib: 
....................         output_bit(OCP_EN_PCIB, packet->on_off); 
08B38:  MOVLW  02
08B3A:  MOVLB  A
08B3C:  ADDWF  x07,W
08B3E:  MOVWF  FE9
08B40:  MOVLW  00
08B42:  ADDWFC x08,W
08B44:  MOVWF  FEA
08B46:  MOVF   FEF,F
08B48:  BNZ   8B4E
08B4A:  BCF    F8E.5
08B4C:  BRA    8B50
08B4E:  BSF    F8E.5
08B50:  BCF    F97.5
....................         obc_flags.pcib_on_off = packet->on_off; 
08B52:  MOVLW  02
08B54:  ADDWF  x07,W
08B56:  MOVWF  FE9
08B58:  MOVLW  00
08B5A:  ADDWFC x08,W
08B5C:  MOVWF  FEA
08B5E:  MOVFF  FEF,F0
....................         return obc_flags.pcib_on_off; 
08B62:  MOVLB  0
08B64:  MOVFF  F0,01
08B68:  BRA    8B6E
....................         break; 
....................     } 
....................  
....................     return -1; 
08B6A:  MOVLW  FF
08B6C:  MOVWF  01
08B6E:  GOTO   CEC2 (RETURN)
.................... } 
....................  
.................... // void boot_commands_clear_nth(uint8_t n) 
.................... uint8_t command_boot_cmd_clear_nth(uint8_t* data) 
*
06AFE:  MOVFF  A06,A08
06B02:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t n; 
....................     }* packet = (struct packet*)data; 
....................     boot_commands_clear_nth(packet->n); 
06B06:  MOVLW  02
06B08:  MOVLB  A
06B0A:  ADDWF  x07,W
06B0C:  MOVWF  FE9
06B0E:  MOVLW  00
06B10:  ADDWFC x08,W
06B12:  MOVWF  FEA
06B14:  MOVFF  FEF,A0A
06B18:  MOVLB  0
06B1A:  CALL   3C96
....................     boot_commands_write(); 
06B1E:  CALL   3CDE
....................     return 0; 
06B22:  MOVLW  00
06B24:  MOVWF  01
06B26:  GOTO   CD00 (RETURN)
.................... } 
....................  
.................... // void boot_commands_clear_all() 
.................... uint8_t command_boot_cmd_clear_all(uint8_t* data) 
.................... { 
....................     boot_commands_clear_all(); 
06B2A:  CALL   3CC2
....................     boot_commands_write(); 
06B2E:  CALL   3CDE
....................     return 0; 
06B32:  MOVLW  00
06B34:  MOVWF  01
06B36:  GOTO   CD12 (RETURN)
.................... } 
....................  
.................... // Add a boot command 
.................... uint8_t command_boot_cmd_add(uint8_t* data) 
*
06BC4:  MOVFF  A06,A08
06BC8:  MOVFF  A05,A07
.................... { 
....................     enum { length = MSG_LENGTH_COMM - 13 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t delay_from_boot; 
....................         uint8_t new_boot_cmd[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     boot_command bc; 
....................     bc.time = packet->delay_from_boot; 
06BCC:  MOVLW  02
06BCE:  MOVLB  A
06BD0:  ADDWF  x07,W
06BD2:  MOVWF  FE9
06BD4:  MOVLW  00
06BD6:  ADDWFC x08,W
06BD8:  MOVWF  FEA
06BDA:  MOVFF  FEF,A09
06BDE:  MOVFF  FEC,A0A
06BE2:  MOVFF  FEC,A0B
06BE6:  MOVFF  FEC,A0C
....................     memcpy(bc.command, packet->new_boot_cmd, length); 
06BEA:  MOVLW  06
06BEC:  ADDWF  x07,W
06BEE:  MOVWF  01
06BF0:  MOVLW  00
06BF2:  ADDWFC x08,W
06BF4:  MOVWF  03
06BF6:  MOVFF  01,A26
06BFA:  MOVWF  x27
06BFC:  MOVLW  0A
06BFE:  MOVWF  FEA
06C00:  MOVLW  0D
06C02:  MOVWF  FE9
06C04:  MOVFF  03,FE2
06C08:  MOVFF  01,FE1
06C0C:  MOVLW  0C
06C0E:  MOVWF  01
06C10:  MOVFF  FE6,FEE
06C14:  DECFSZ 01,F
06C16:  BRA    6C10
....................     boot_commands_add(bc); 
06C18:  MOVFF  A09,A26
06C1C:  MOVFF  A0A,A27
06C20:  MOVFF  A0B,A28
06C24:  MOVFF  A0C,A29
06C28:  MOVFF  A0D,A2A
06C2C:  MOVFF  A0E,A2B
06C30:  MOVFF  A0F,A2C
06C34:  MOVFF  A10,A2D
06C38:  MOVFF  A11,A2E
06C3C:  MOVFF  A12,A2F
06C40:  MOVFF  A13,A30
06C44:  MOVFF  A14,A31
06C48:  MOVFF  A15,A32
06C4C:  MOVFF  A16,A33
06C50:  MOVFF  A17,A34
06C54:  MOVFF  A18,A35
06C58:  MOVFF  A19,A36
06C5C:  MOVFF  A1A,A37
06C60:  MOVFF  A1B,A38
06C64:  MOVFF  A1C,A39
06C68:  MOVFF  A1D,A3A
06C6C:  MOVFF  A1E,A3B
06C70:  MOVFF  A1F,A3C
06C74:  MOVFF  A20,A3D
06C78:  MOVFF  A21,A3E
06C7C:  MOVFF  A22,A3F
06C80:  MOVFF  A23,A40
06C84:  MOVFF  A24,A41
06C88:  MOVFF  A25,A42
06C8C:  MOVLB  0
06C8E:  BRA    6B3A
....................     boot_commands_write(); 
06C90:  CALL   3CDE
....................  
....................     return 0; 
06C94:  MOVLW  00
06C96:  MOVWF  01
06C98:  GOTO   CD24 (RETURN)
.................... } 
....................  
.................... // ============ Reset Commands ============ 
....................  
.................... // Reset pic telemetry data 
.................... uint8_t command_reset_telemetry(uint8_t* data) 
.................... { 
....................     response_rx = 1; // Received a reply 
*
0BEEA:  MOVLW  01
0BEEC:  MOVLB  6
0BEEE:  MOVWF  x83
....................     struct packet { 
....................         uint8_t message[MSG_LENGTH_RST - 10]; 
....................         uint8_t padding[9]; // empty part 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
0BEF0:  MOVFF  A06,A08
0BEF4:  MOVFF  A05,A07
....................  
....................     fprintf(PC, "RESET: "); 
0BEF8:  MOVLW  76
0BEFA:  MOVWF  FF6
0BEFC:  MOVLW  08
0BEFE:  MOVWF  FF7
0BF00:  MOVLW  00
0BF02:  MOVWF  FF8
0BF04:  MOVLB  0
0BF06:  CALL   1C7A
....................     uart_print_pc_hex(data, MSG_LENGTH_RST); 
0BF0A:  MOVFF  A06,A54
0BF0E:  MOVFF  A05,A53
0BF12:  MOVLW  24
0BF14:  MOVLB  A
0BF16:  MOVWF  x55
0BF18:  MOVLB  0
0BF1A:  CALL   4EF0
....................  
....................     if (rst_clock_update) { 
0BF1E:  MOVLB  6
0BF20:  MOVF   x88,F
0BF22:  BTFSC  FD8.2
0BF24:  BRA    C3AE
....................         rst_clock_updated = 1; 
0BF26:  MOVLW  01
0BF28:  MOVWF  x89
....................         rst_clock_update = 0; 
0BF2A:  CLRF   x88
....................         struct_tm rst_time; 
....................         rst_time.tm_year = (unsigned long)packet->message[2] + 100; 
0BF2C:  MOVLW  02
0BF2E:  MOVLB  A
0BF30:  ADDWF  x07,W
0BF32:  MOVWF  FE9
0BF34:  MOVLW  00
0BF36:  ADDWFC x08,W
0BF38:  MOVWF  FEA
0BF3A:  MOVF   FEF,W
0BF3C:  CLRF   x1D
0BF3E:  MOVWF  x1C
0BF40:  MOVLW  64
0BF42:  ADDWF  x1C,W
0BF44:  MOVWF  x0E
0BF46:  MOVLW  00
0BF48:  ADDWFC x1D,W
0BF4A:  MOVWF  x0F
....................         rst_time.tm_mon = (unsigned long)packet->message[3] - 1; 
0BF4C:  MOVLW  03
0BF4E:  ADDWF  x07,W
0BF50:  MOVWF  FE9
0BF52:  MOVLW  00
0BF54:  ADDWFC x08,W
0BF56:  MOVWF  FEA
0BF58:  MOVF   FEF,W
0BF5A:  MOVWF  x1C
0BF5C:  MOVLW  01
0BF5E:  SUBWF  x1C,W
0BF60:  MOVWF  x0D
....................         rst_time.tm_mday = (unsigned long)packet->message[4]; 
0BF62:  MOVLW  04
0BF64:  ADDWF  x07,W
0BF66:  MOVWF  FE9
0BF68:  MOVLW  00
0BF6A:  ADDWFC x08,W
0BF6C:  MOVWF  FEA
0BF6E:  MOVFF  FEF,A0C
....................         rst_time.tm_hour = (unsigned long)packet->message[5]; 
0BF72:  MOVLW  05
0BF74:  ADDWF  x07,W
0BF76:  MOVWF  FE9
0BF78:  MOVLW  00
0BF7A:  ADDWFC x08,W
0BF7C:  MOVWF  FEA
0BF7E:  MOVFF  FEF,A0B
....................         rst_time.tm_min = (unsigned long)packet->message[6]; 
0BF82:  MOVLW  06
0BF84:  ADDWF  x07,W
0BF86:  MOVWF  FE9
0BF88:  MOVLW  00
0BF8A:  ADDWFC x08,W
0BF8C:  MOVWF  FEA
0BF8E:  MOVFF  FEF,A0A
....................         rst_time.tm_sec = (unsigned long)packet->message[7] + 1; 
0BF92:  MOVLW  07
0BF94:  ADDWF  x07,W
0BF96:  MOVWF  FE9
0BF98:  MOVLW  00
0BF9A:  ADDWFC x08,W
0BF9C:  MOVWF  FEA
0BF9E:  MOVF   FEF,W
0BFA0:  MOVWF  x1C
0BFA2:  MOVLW  01
0BFA4:  ADDWF  x1C,W
0BFA6:  MOVWF  x09
....................         SetTime(&rst_time); 
0BFA8:  MOVLW  0A
0BFAA:  MOVWF  x1D
0BFAC:  MOVLW  09
0BFAE:  MOVWF  x1C
0BFB0:  MOVLB  0
0BFB2:  BRA    BCFC
....................         time_t new_time = mktime(&rst_time); 
0BFB4:  MOVLW  0A
0BFB6:  MOVLB  A
0BFB8:  MOVWF  x2E
0BFBA:  MOVLW  09
0BFBC:  MOVWF  x2D
0BFBE:  MOVLB  0
0BFC0:  CALL   1F56
0BFC4:  MOVFF  03,A16
0BFC8:  MOVFF  02,A15
0BFCC:  MOVFF  01,A14
0BFD0:  MOVFF  00,A13
....................         // mai_400_update_clock(new_time); 
....................         current_time = new_time; 
0BFD4:  MOVFF  A16,3C
0BFD8:  MOVFF  A15,3B
0BFDC:  MOVFF  A14,3A
0BFE0:  MOVFF  A13,39
....................         previous_time = new_time; 
0BFE4:  MOVFF  A16,40
0BFE8:  MOVFF  A15,3F
0BFEC:  MOVFF  A14,3E
0BFF0:  MOVFF  A13,3D
....................         reset_time = new_time; 
0BFF4:  MOVFF  A16,687
0BFF8:  MOVFF  A15,686
0BFFC:  MOVFF  A14,685
0C000:  MOVFF  A13,684
....................         // Read stored commands from memory 
....................         get_com_shared_fm_access(); 
0C004:  CALL   593C
....................         uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
0C008:  MOVLW  01
0C00A:  MOVLB  A
0C00C:  MOVWF  x1D
0C00E:  MOVLW  1F
0C010:  MOVFF  A1D,A18
0C014:  MOVWF  x17
....................         flash_transfer_data_to_ram( 
....................             &spi_port_COM_FM, 
....................             SCHEDULED_CMD_ADDRESS, 
....................             cmd_ptr, 
....................             sizeof(scheduled_commands)); 
0C016:  MOVLW  09
0C018:  MOVLB  B
0C01A:  MOVWF  x01
0C01C:  MOVLW  1B
0C01E:  MOVWF  x00
0C020:  CLRF   x05
0C022:  CLRF   x04
0C024:  MOVLW  30
0C026:  MOVWF  x03
0C028:  CLRF   x02
0C02A:  MOVFF  A18,B07
0C02E:  MOVFF  A17,B06
0C032:  CLRF   x0B
0C034:  CLRF   x0A
0C036:  MOVLW  03
0C038:  MOVWF  x09
0C03A:  MOVLW  A0
0C03C:  MOVWF  x08
0C03E:  MOVLB  0
0C040:  CALL   2E46
....................         // Remove scheduled commads that are scheduled to run in the past 
....................         for(uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
0C044:  MOVLB  A
0C046:  CLRF   x19
0C048:  MOVF   x19,W
0C04A:  SUBLW  1F
0C04C:  BTFSS  FD8.0
0C04E:  BRA    C1D0
....................             if(scheduled_commands[i].time < current_time + 1800L) { 
0C050:  CLRF   x5B
0C052:  MOVFF  A19,A5A
0C056:  CLRF   x5D
0C058:  MOVLW  1D
0C05A:  MOVWF  x5C
0C05C:  MOVLB  0
0C05E:  CALL   244C
0C062:  MOVFF  02,A1D
0C066:  MOVFF  01,A1C
0C06A:  MOVLW  1F
0C06C:  MOVLB  A
0C06E:  ADDWF  01,W
0C070:  MOVWF  FE9
0C072:  MOVLW  01
0C074:  ADDWFC 02,W
0C076:  MOVWF  FEA
0C078:  MOVFF  FEF,A1E
0C07C:  MOVFF  FEC,A1F
0C080:  MOVFF  FEC,A20
0C084:  MOVFF  FEC,A21
0C088:  MOVLW  08
0C08A:  ADDWF  39,W
0C08C:  MOVWF  00
0C08E:  MOVLW  07
0C090:  ADDWFC 3A,W
0C092:  MOVWF  01
0C094:  MOVLW  00
0C096:  ADDWFC 3B,W
0C098:  MOVWF  02
0C09A:  MOVLW  00
0C09C:  ADDWFC 3C,W
0C09E:  MOVWF  03
0C0A0:  BTFSS  x21.7
0C0A2:  BRA    C0AA
0C0A4:  BTFSS  03.7
0C0A6:  BRA    C0D2
0C0A8:  BRA    C0AE
0C0AA:  BTFSC  03.7
0C0AC:  BRA    C1CC
0C0AE:  MOVF   x21,W
0C0B0:  SUBWF  03,W
0C0B2:  BTFSS  FD8.0
0C0B4:  BRA    C1CC
0C0B6:  BNZ   C0D2
0C0B8:  MOVF   x20,W
0C0BA:  SUBWF  02,W
0C0BC:  BTFSS  FD8.0
0C0BE:  BRA    C1CC
0C0C0:  BNZ   C0D2
0C0C2:  MOVF   x1F,W
0C0C4:  SUBWF  01,W
0C0C6:  BTFSS  FD8.0
0C0C8:  BRA    C1CC
0C0CA:  BNZ   C0D2
0C0CC:  MOVF   00,W
0C0CE:  SUBWF  x1E,W
0C0D0:  BC    C1CC
....................                 scheduled_commands[i].time = TIME_T_MAX; 
0C0D2:  CLRF   x5B
0C0D4:  MOVFF  A19,A5A
0C0D8:  CLRF   x5D
0C0DA:  MOVLW  1D
0C0DC:  MOVWF  x5C
0C0DE:  MOVLB  0
0C0E0:  CALL   244C
0C0E4:  MOVLW  1F
0C0E6:  MOVLB  A
0C0E8:  ADDWF  01,W
0C0EA:  MOVWF  FE9
0C0EC:  MOVLW  01
0C0EE:  ADDWFC 02,W
0C0F0:  MOVWF  FEA
0C0F2:  SETF   FEF
0C0F4:  SETF   FEC
0C0F6:  SETF   FEC
0C0F8:  MOVLW  7F
0C0FA:  MOVWF  FEC
....................                 fprintf(PC, "\r\nWarning: a scheduled command (%02X %02X) in flash memory was scheduled to run in a past date/time and was marked as complete.\r\n", scheduled_commands[i].command[0], scheduled_commands[i].command[1]); 
0C0FC:  CLRF   x5B
0C0FE:  MOVFF  A19,A5A
0C102:  CLRF   x5D
0C104:  MOVLW  1D
0C106:  MOVWF  x5C
0C108:  MOVLB  0
0C10A:  CALL   244C
0C10E:  MOVFF  02,A1D
0C112:  MOVFF  01,A1C
0C116:  MOVLW  04
0C118:  MOVLB  A
0C11A:  ADDWF  x1C,F
0C11C:  MOVLW  00
0C11E:  ADDWFC x1D,F
0C120:  MOVLW  1F
0C122:  ADDWF  x1C,W
0C124:  MOVWF  FE9
0C126:  MOVLW  01
0C128:  ADDWFC x1D,W
0C12A:  MOVWF  FEA
0C12C:  MOVFF  FEF,A1E
0C130:  CLRF   x5B
0C132:  MOVFF  A19,A5A
0C136:  CLRF   x5D
0C138:  MOVLW  1D
0C13A:  MOVWF  x5C
0C13C:  MOVLB  0
0C13E:  CALL   244C
0C142:  MOVFF  02,A20
0C146:  MOVFF  01,A1F
0C14A:  MOVLW  04
0C14C:  MOVLB  A
0C14E:  ADDWF  x1F,F
0C150:  MOVLW  00
0C152:  ADDWFC x20,F
0C154:  MOVLW  01
0C156:  ADDWF  x1F,W
0C158:  MOVWF  01
0C15A:  MOVLW  00
0C15C:  ADDWFC x20,W
0C15E:  MOVWF  03
0C160:  MOVF   01,W
0C162:  ADDLW  1F
0C164:  MOVWF  FE9
0C166:  MOVLW  01
0C168:  ADDWFC 03,W
0C16A:  MOVWF  FEA
0C16C:  MOVFF  FEF,A1F
0C170:  MOVLW  7E
0C172:  MOVWF  FF6
0C174:  MOVLW  08
0C176:  MOVWF  FF7
0C178:  MOVLW  00
0C17A:  MOVWF  FF8
0C17C:  MOVLW  20
0C17E:  MOVWF  x3B
0C180:  MOVLB  0
0C182:  CALL   3048
0C186:  MOVFF  A1E,A58
0C18A:  MOVLW  37
0C18C:  MOVLB  A
0C18E:  MOVWF  x59
0C190:  MOVLB  0
0C192:  CALL   3142
0C196:  MOVLW  20
0C198:  MOVLB  B
0C19A:  MOVWF  x1F
0C19C:  MOVLB  0
0C19E:  CALL   1C34
0C1A2:  MOVFF  A1F,A58
0C1A6:  MOVLW  37
0C1A8:  MOVLB  A
0C1AA:  MOVWF  x59
0C1AC:  MOVLB  0
0C1AE:  CALL   3142
0C1B2:  MOVLW  A7
0C1B4:  MOVWF  FF6
0C1B6:  MOVLW  08
0C1B8:  MOVWF  FF7
0C1BA:  MOVLW  00
0C1BC:  MOVWF  FF8
0C1BE:  MOVLW  58
0C1C0:  MOVLB  A
0C1C2:  MOVWF  x3B
0C1C4:  MOVLB  0
0C1C6:  CALL   3048
0C1CA:  MOVLB  A
....................             } 
0C1CC:  INCF   x19,F
0C1CE:  BRA    C048
....................         } 
....................         // Read and schedule boot commands 
....................         boot_commands_schedule(); 
0C1D0:  MOVLB  0
0C1D2:  BRA    BDDA
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
0C1D4:  MOVLW  02
0C1D6:  MOVLB  A
0C1D8:  MOVWF  x1C
0C1DA:  MOVFF  ED,A1D
0C1DE:  MOVFF  11D,A21
0C1E2:  MOVFF  11C,A20
0C1E6:  MOVFF  11B,A1F
0C1EA:  MOVFF  11A,A1E
0C1EE:  CLRF   x25
0C1F0:  MOVLW  11
0C1F2:  MOVWF  x24
0C1F4:  CLRF   x23
0C1F6:  CLRF   x22
0C1F8:  CLRF   x29
0C1FA:  CLRF   x28
0C1FC:  CLRF   x27
0C1FE:  MOVLW  8C
0C200:  MOVWF  x26
0C202:  MOVLW  01
0C204:  MOVWF  x2A
0C206:  MOVWF  x2C
0C208:  MOVLW  12
0C20A:  MOVWF  x2B
0C20C:  MOVLB  0
0C20E:  CALL   3214
....................  
....................         struct_tm* local_time = localtime(&current_time); 
0C212:  MOVLB  A
0C214:  CLRF   x4D
0C216:  MOVLW  39
0C218:  MOVWF  x4C
0C21A:  MOVLB  0
0C21C:  CALL   246E
0C220:  MOVFF  02,A1B
0C224:  MOVFF  01,A1A
....................         fprintf(PC, " New time: %04ld/%02d/%02d %02d:%02d:%02d (0x%08lX)", 
....................             local_time->tm_year + 1900, 
....................             (uint8_t)local_time->tm_mon + 1, 
....................             local_time->tm_mday, 
....................             local_time->tm_hour, 
....................             local_time->tm_min, 
....................             local_time->tm_sec, 
....................             current_time); 
0C228:  MOVLW  05
0C22A:  MOVLB  A
0C22C:  ADDWF  x1A,W
0C22E:  MOVWF  FE9
0C230:  MOVLW  00
0C232:  ADDWFC x1B,W
0C234:  MOVWF  FEA
0C236:  MOVFF  FEC,A1D
0C23A:  MOVF   FED,F
0C23C:  MOVFF  FEF,A1C
0C240:  MOVLW  6C
0C242:  ADDWF  x1C,F
0C244:  MOVLW  07
0C246:  ADDWFC x1D,F
0C248:  MOVLW  04
0C24A:  ADDWF  x1A,W
0C24C:  MOVWF  FE9
0C24E:  MOVLW  00
0C250:  ADDWFC x1B,W
0C252:  MOVWF  FEA
0C254:  MOVLW  01
0C256:  ADDWF  FEF,W
0C258:  MOVWF  x1E
0C25A:  MOVLW  03
0C25C:  ADDWF  x1A,W
0C25E:  MOVWF  FE9
0C260:  MOVLW  00
0C262:  ADDWFC x1B,W
0C264:  MOVWF  FEA
0C266:  MOVFF  FEF,A1F
0C26A:  MOVLW  02
0C26C:  ADDWF  x1A,W
0C26E:  MOVWF  FE9
0C270:  MOVLW  00
0C272:  ADDWFC x1B,W
0C274:  MOVWF  FEA
0C276:  MOVFF  FEF,A20
0C27A:  MOVLW  01
0C27C:  ADDWF  x1A,W
0C27E:  MOVWF  FE9
0C280:  MOVLW  00
0C282:  ADDWFC x1B,W
0C284:  MOVWF  FEA
0C286:  MOVFF  FEF,A21
0C28A:  MOVFF  A1A,FE9
0C28E:  MOVFF  A1B,FEA
0C292:  MOVFF  FEF,A22
0C296:  MOVLW  00
0C298:  MOVWF  FF6
0C29A:  MOVLW  09
0C29C:  MOVWF  FF7
0C29E:  MOVLW  00
0C2A0:  MOVWF  FF8
0C2A2:  MOVLW  0B
0C2A4:  MOVWF  x3B
0C2A6:  MOVLB  0
0C2A8:  CALL   3048
0C2AC:  MOVLW  0A
0C2AE:  MOVWF  FE9
0C2B0:  MOVFF  A1D,A24
0C2B4:  MOVFF  A1C,A23
0C2B8:  CALL   4D28
0C2BC:  MOVLW  2F
0C2BE:  MOVLB  B
0C2C0:  MOVWF  x1F
0C2C2:  MOVLB  0
0C2C4:  CALL   1C34
0C2C8:  MOVFF  A1E,A23
0C2CC:  MOVLW  01
0C2CE:  MOVLB  A
0C2D0:  MOVWF  x24
0C2D2:  MOVLB  0
0C2D4:  CALL   4E28
0C2D8:  MOVLW  2F
0C2DA:  MOVLB  B
0C2DC:  MOVWF  x1F
0C2DE:  MOVLB  0
0C2E0:  CALL   1C34
0C2E4:  MOVFF  A1F,A23
0C2E8:  MOVLW  01
0C2EA:  MOVLB  A
0C2EC:  MOVWF  x24
0C2EE:  MOVLB  0
0C2F0:  CALL   4E28
0C2F4:  MOVLW  20
0C2F6:  MOVLB  B
0C2F8:  MOVWF  x1F
0C2FA:  MOVLB  0
0C2FC:  CALL   1C34
0C300:  MOVFF  A20,A23
0C304:  MOVLW  01
0C306:  MOVLB  A
0C308:  MOVWF  x24
0C30A:  MOVLB  0
0C30C:  CALL   4E28
0C310:  MOVLW  3A
0C312:  MOVLB  B
0C314:  MOVWF  x1F
0C316:  MOVLB  0
0C318:  CALL   1C34
0C31C:  MOVFF  A21,A23
0C320:  MOVLW  01
0C322:  MOVLB  A
0C324:  MOVWF  x24
0C326:  MOVLB  0
0C328:  CALL   4E28
0C32C:  MOVLW  3A
0C32E:  MOVLB  B
0C330:  MOVWF  x1F
0C332:  MOVLB  0
0C334:  CALL   1C34
0C338:  MOVFF  A22,A23
0C33C:  MOVLW  01
0C33E:  MOVLB  A
0C340:  MOVWF  x24
0C342:  MOVLB  0
0C344:  CALL   4E28
0C348:  MOVLW  29
0C34A:  MOVWF  FF6
0C34C:  MOVLW  09
0C34E:  MOVWF  FF7
0C350:  MOVLW  00
0C352:  MOVWF  FF8
0C354:  MOVLW  04
0C356:  MOVLB  A
0C358:  MOVWF  x3B
0C35A:  MOVLB  0
0C35C:  CALL   3048
0C360:  MOVFF  3C,A58
0C364:  MOVLW  37
0C366:  MOVLB  A
0C368:  MOVWF  x59
0C36A:  MOVLB  0
0C36C:  CALL   3142
0C370:  MOVFF  3B,A58
0C374:  MOVLW  37
0C376:  MOVLB  A
0C378:  MOVWF  x59
0C37A:  MOVLB  0
0C37C:  CALL   3142
0C380:  MOVFF  3A,A58
0C384:  MOVLW  37
0C386:  MOVLB  A
0C388:  MOVWF  x59
0C38A:  MOVLB  0
0C38C:  CALL   3142
0C390:  MOVFF  39,A58
0C394:  MOVLW  37
0C396:  MOVLB  A
0C398:  MOVWF  x59
0C39A:  MOVLB  0
0C39C:  CALL   3142
0C3A0:  MOVLW  29
0C3A2:  MOVLB  B
0C3A4:  MOVWF  x1F
0C3A6:  MOVLB  0
0C3A8:  CALL   1C34
0C3AC:  MOVLB  6
....................     } 
....................  
....................     telemetry_time.reset_time = current_time; 
0C3AE:  MOVFF  3C,D0
0C3B2:  MOVFF  3B,CF
0C3B6:  MOVFF  3A,CE
0C3BA:  MOVFF  39,CD
....................     memcpy(telemetry.reset_message, packet->message + 2, sizeof(telemetry.reset_message)); 
0C3BE:  MOVLB  A
0C3C0:  MOVFF  A08,03
0C3C4:  MOVFF  A07,A1C
0C3C8:  MOVFF  A08,A1D
0C3CC:  MOVLW  02
0C3CE:  ADDWF  x1C,F
0C3D0:  MOVLW  00
0C3D2:  ADDWFC x1D,F
0C3D4:  CLRF   FEA
0C3D6:  MOVLW  42
0C3D8:  MOVWF  FE9
0C3DA:  MOVFF  A1D,FE2
0C3DE:  MOVFF  A1C,FE1
0C3E2:  MOVLW  18
0C3E4:  MOVWF  01
0C3E6:  MOVFF  FE6,FEE
0C3EA:  DECFSZ 01,F
0C3EC:  BRA    C3E6
....................     return rst_clock_updated; 
0C3EE:  MOVLB  6
0C3F0:  MOVF   x89,W
0C3F2:  MOVWF  01
0C3F4:  MOVLB  0
0C3F6:  GOTO   D02A (RETURN)
.................... } 
....................  
.................... // Warn that 24-hour reset is about to happen 
.................... uint8_t command_reset_warning(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................  
....................     // uint8_t adcs_cmd[] = { 0x22 }; 
....................     // mai_400_command(adcs_cmd, sizeof(adcs_cmd)); 
....................  
....................     save_state(data[1]); // data[1] is the current command id 
0C3FA:  MOVLW  01
0C3FC:  MOVLB  A
0C3FE:  ADDWF  x05,W
0C400:  MOVWF  FE9
0C402:  MOVLW  00
0C404:  ADDWFC x06,W
0C406:  MOVWF  FEA
0C408:  MOVFF  FEF,A0E
0C40C:  MOVLB  0
0C40E:  CALL   74CE
....................  
....................     // Reply: 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
0C412:  MOVLB  A
0C414:  CLRF   x07
0C416:  MOVF   x07,W
0C418:  SUBLW  23
0C41A:  BNC   C430
....................         fputc(cmd[i], RST); 
0C41C:  CLRF   03
0C41E:  MOVF   x07,W
0C420:  MOVLB  0
0C422:  CALL   01CC
0C426:  CALL   2A84
0C42A:  MOVLB  A
0C42C:  INCF   x07,F
0C42E:  BRA    C416
....................     } 
....................     uart_clean(RST); 
0C430:  MOVLW  08
0C432:  MOVLB  B
0C434:  MOVWF  x3A
0C436:  MOVLW  E2
0C438:  MOVWF  x39
....................  
....................     fprintf(PC, "Waiting for 24h reset...\r\n"); 
*
0C4A0:  MOVLW  34
0C4A2:  MOVWF  FF6
0C4A4:  MOVLW  09
0C4A6:  MOVWF  FF7
0C4A8:  MOVLW  00
0C4AA:  MOVWF  FF8
0C4AC:  MOVLB  0
0C4AE:  CALL   1C7A
....................     delay_ms(60000); 
0C4B2:  MOVLW  F0
0C4B4:  MOVLB  A
0C4B6:  MOVWF  x08
0C4B8:  MOVLW  FA
0C4BA:  MOVWF  xDB
0C4BC:  MOVLB  0
0C4BE:  CALL   36F2
0C4C2:  MOVLB  A
0C4C4:  DECFSZ x08,F
0C4C6:  BRA    C4B8
....................     delay_ms(60000); 
0C4C8:  MOVLW  F0
0C4CA:  MOVWF  x08
0C4CC:  MOVLW  FA
0C4CE:  MOVWF  xDB
0C4D0:  MOVLB  0
0C4D2:  CALL   36F2
0C4D6:  MOVLB  A
0C4D8:  DECFSZ x08,F
0C4DA:  BRA    C4CC
....................     fprintf(PC, "No 24h reset happened, doing soft reset instead.\r\n"); 
0C4DC:  MOVLW  50
0C4DE:  MOVWF  FF6
0C4E0:  MOVLW  09
0C4E2:  MOVWF  FF7
0C4E4:  MOVLW  00
0C4E6:  MOVWF  FF8
0C4E8:  MOVLB  0
0C4EA:  CALL   1C7A
....................     reset_cpu(); 
0C4EE:  RESET
....................  
....................     return 0; 
0C4F0:  MOVLW  00
0C4F2:  MOVWF  01
0C4F4:  GOTO   D03C (RETURN)
.................... } 
....................  
.................... // Reset pic acknowledge of time change 
.................... uint8_t command_time_change_ack(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Reset PIC time change ACK."); 
0C4F8:  MOVLW  84
0C4FA:  MOVWF  FF6
0C4FC:  MOVLW  09
0C4FE:  MOVWF  FF7
0C500:  MOVLW  00
0C502:  MOVWF  FF8
0C504:  CALL   1C7A
....................     return 0; 
0C508:  MOVLW  00
0C50A:  MOVWF  01
0C50C:  GOTO   D04E (RETURN)
.................... } 
....................  
.................... // Passes a command from ground-station to reset pic 
.................... uint8_t command_send_data_to_reset(uint8_t* data) 
*
0A89A:  MOVFF  A06,A09
0A89E:  MOVFF  A05,A08
.................... { 
....................     uint8_t i; 
....................     struct packet { 
....................         uint8_t command;     // C0: comm pic message 
....................         uint8_t reset_cmd;   // F5: reset message 
....................         uint8_t data[8];     // data to be passed to reset pic 
....................         uint8_t silent_mode; // if equals to 1, do not print debug message 
....................     }* packet = (struct packet*)data; 
....................     uint8_t cmd[36] = { 0 }; 
0A8A2:  MOVLB  A
0A8A4:  CLRF   x0A
0A8A6:  CLRF   x0B
0A8A8:  CLRF   x0C
0A8AA:  CLRF   x0D
0A8AC:  CLRF   x0E
0A8AE:  CLRF   x0F
0A8B0:  CLRF   x10
0A8B2:  CLRF   x11
0A8B4:  CLRF   x12
0A8B6:  CLRF   x13
0A8B8:  CLRF   x14
0A8BA:  CLRF   x15
0A8BC:  CLRF   x16
0A8BE:  CLRF   x17
0A8C0:  CLRF   x18
0A8C2:  CLRF   x19
0A8C4:  CLRF   x1A
0A8C6:  CLRF   x1B
0A8C8:  CLRF   x1C
0A8CA:  CLRF   x1D
0A8CC:  CLRF   x1E
0A8CE:  CLRF   x1F
0A8D0:  CLRF   x20
0A8D2:  CLRF   x21
0A8D4:  CLRF   x22
0A8D6:  CLRF   x23
0A8D8:  CLRF   x24
0A8DA:  CLRF   x25
0A8DC:  CLRF   x26
0A8DE:  CLRF   x27
0A8E0:  CLRF   x28
0A8E2:  CLRF   x29
0A8E4:  CLRF   x2A
0A8E6:  CLRF   x2B
0A8E8:  CLRF   x2C
0A8EA:  CLRF   x2D
....................     cmd[0] = 0xB0; 
0A8EC:  MOVLW  B0
0A8EE:  MOVWF  x0A
....................     for (i = 0; i < 8; i++) { 
0A8F0:  CLRF   x07
0A8F2:  MOVF   x07,W
0A8F4:  SUBLW  07
0A8F6:  BNC   A928
....................         cmd[i + 1] = packet->data[i]; 
0A8F8:  MOVLW  01
0A8FA:  ADDWF  x07,W
0A8FC:  CLRF   03
0A8FE:  ADDLW  0A
0A900:  MOVWF  01
0A902:  MOVLW  0A
0A904:  ADDWFC 03,F
0A906:  MOVLW  02
0A908:  ADDWF  x07,W
0A90A:  ADDWF  x08,W
0A90C:  MOVWF  FE9
0A90E:  MOVLW  00
0A910:  ADDWFC x09,W
0A912:  MOVWF  FEA
0A914:  MOVFF  FEF,A30
0A918:  MOVFF  03,FEA
0A91C:  MOVFF  01,FE9
0A920:  MOVFF  A30,FEF
0A924:  INCF   x07,F
0A926:  BRA    A8F2
....................     } 
....................     cmd[35] = 0xB1; 
0A928:  MOVLW  B1
0A92A:  MOVWF  x2D
....................     for (i = 0; i < sizeof(cmd); i++) { 
0A92C:  CLRF   x07
0A92E:  MOVF   x07,W
0A930:  SUBLW  23
0A932:  BNC   A954
....................         fputc(cmd[i], RST); 
0A934:  CLRF   03
0A936:  MOVF   x07,W
0A938:  ADDLW  0A
0A93A:  MOVWF  FE9
0A93C:  MOVLW  0A
0A93E:  ADDWFC 03,W
0A940:  MOVWF  FEA
0A942:  MOVFF  FEF,A2E
0A946:  MOVF   x2E,W
0A948:  MOVLB  0
0A94A:  CALL   2A84
0A94E:  MOVLB  A
0A950:  INCF   x07,F
0A952:  BRA    A92E
....................     } 
....................     if (packet->silent_mode != 1) 
0A954:  MOVLW  0A
0A956:  ADDWF  x08,W
0A958:  MOVWF  FE9
0A95A:  MOVLW  00
0A95C:  ADDWFC x09,W
0A95E:  MOVWF  FEA
0A960:  DECFSZ FEF,W
0A962:  BRA    A966
0A964:  BRA    A978
....................         uart_print_pc_hex(cmd, sizeof(cmd)); 
0A966:  MOVLW  0A
0A968:  MOVWF  x54
0A96A:  MOVWF  x53
0A96C:  MOVLW  24
0A96E:  MOVWF  x55
0A970:  MOVLB  0
0A972:  CALL   4EF0
0A976:  MOVLB  A
....................     return 0; 
0A978:  MOVLW  00
0A97A:  MOVWF  01
0A97C:  MOVLB  0
0A97E:  GOTO   CF9A (RETURN)
.................... } 
....................  
.................... // ============ EPS Commands ============ 
....................  
.................... uint8_t command_eps_telemetry(uint8_t* data) 
.................... { 
....................     enum { cmd_len = 7 }; 
....................     response_rx = 1; // Received a reply 
*
0B7BA:  MOVLW  01
0B7BC:  MOVLB  6
0B7BE:  MOVWF  x83
....................     fprintf(PC, "EPS: "); 
0B7C0:  MOVLW  A0
0B7C2:  MOVWF  FF6
0B7C4:  MOVLW  09
0B7C6:  MOVWF  FF7
0B7C8:  MOVLW  00
0B7CA:  MOVWF  FF8
0B7CC:  MOVLB  0
0B7CE:  CALL   1C7A
....................  
....................     uint16_t voltage_hex = make16(data[46], data[47]); 
....................     uint16_t current_hex = make16(data[50], data[51]); 
....................     uint16_t temperature_hex = make16(data[52], data[53]); 
....................  
....................     float voltage = voltage_hex * 3.3 * 3 / 4096; 
....................     float current = (3835. * current_hex * 3.3 / 4096) - 6396.3; 
....................     float temperature = 75 - temperature_hex * 3.256 * 30 / 4096; 
0B7D2:  MOVLW  2E
0B7D4:  MOVLB  A
0B7D6:  ADDWF  x05,W
0B7D8:  MOVWF  FE9
0B7DA:  MOVLW  00
0B7DC:  ADDWFC x06,W
0B7DE:  MOVWF  FEA
0B7E0:  MOVFF  FEF,A08
0B7E4:  MOVLW  2F
0B7E6:  ADDWF  x05,W
0B7E8:  MOVWF  FE9
0B7EA:  MOVLW  00
0B7EC:  ADDWFC x06,W
0B7EE:  MOVWF  FEA
0B7F0:  MOVFF  FEF,A07
0B7F4:  MOVLW  32
0B7F6:  ADDWF  x05,W
0B7F8:  MOVWF  FE9
0B7FA:  MOVLW  00
0B7FC:  ADDWFC x06,W
0B7FE:  MOVWF  FEA
0B800:  MOVFF  FEF,A0A
0B804:  MOVLW  33
0B806:  ADDWF  x05,W
0B808:  MOVWF  FE9
0B80A:  MOVLW  00
0B80C:  ADDWFC x06,W
0B80E:  MOVWF  FEA
0B810:  MOVFF  FEF,A09
0B814:  MOVLW  34
0B816:  ADDWF  x05,W
0B818:  MOVWF  FE9
0B81A:  MOVLW  00
0B81C:  ADDWFC x06,W
0B81E:  MOVWF  FEA
0B820:  MOVFF  FEF,A0C
0B824:  MOVLW  35
0B826:  ADDWF  x05,W
0B828:  MOVWF  FE9
0B82A:  MOVLW  00
0B82C:  ADDWFC x06,W
0B82E:  MOVWF  FEA
0B830:  MOVFF  FEF,A0B
0B834:  MOVFF  A08,A31
0B838:  MOVFF  A07,A30
0B83C:  MOVLB  0
0B83E:  RCALL  B46A
0B840:  MOVFF  03,A34
0B844:  MOVFF  02,A33
0B848:  MOVFF  01,A32
0B84C:  MOVFF  00,A31
0B850:  MOVLW  33
0B852:  MOVLB  A
0B854:  MOVWF  x38
0B856:  MOVWF  x37
0B858:  MOVLW  53
0B85A:  MOVWF  x36
0B85C:  MOVLW  80
0B85E:  MOVWF  x35
0B860:  MOVLB  0
0B862:  CALL   83EC
0B866:  MOVFF  03,A2D
0B86A:  MOVFF  02,A2C
0B86E:  MOVFF  01,A2B
0B872:  MOVFF  00,A2A
0B876:  MOVFF  03,A34
0B87A:  MOVFF  02,A33
0B87E:  MOVFF  01,A32
0B882:  MOVFF  00,A31
0B886:  MOVLB  A
0B888:  CLRF   x38
0B88A:  CLRF   x37
0B88C:  MOVLW  40
0B88E:  MOVWF  x36
0B890:  MOVLW  80
0B892:  MOVWF  x35
0B894:  MOVLB  0
0B896:  CALL   83EC
0B89A:  MOVFF  03,A2D
0B89E:  MOVFF  02,A2C
0B8A2:  MOVFF  01,A2B
0B8A6:  MOVFF  00,A2A
0B8AA:  MOVFF  03,A33
0B8AE:  MOVFF  02,A32
0B8B2:  MOVFF  01,A31
0B8B6:  MOVFF  00,A30
0B8BA:  MOVLB  A
0B8BC:  CLRF   x37
0B8BE:  CLRF   x36
0B8C0:  CLRF   x35
0B8C2:  MOVLW  8B
0B8C4:  MOVWF  x34
0B8C6:  MOVLB  0
0B8C8:  RCALL  B4A0
0B8CA:  MOVFF  03,A10
0B8CE:  MOVFF  02,A0F
0B8D2:  MOVFF  01,A0E
0B8D6:  MOVFF  00,A0D
0B8DA:  MOVFF  A0A,A31
0B8DE:  MOVFF  A09,A30
0B8E2:  RCALL  B46A
0B8E4:  MOVLB  A
0B8E6:  CLRF   x34
0B8E8:  MOVLW  B0
0B8EA:  MOVWF  x33
0B8EC:  MOVLW  6F
0B8EE:  MOVWF  x32
0B8F0:  MOVLW  8A
0B8F2:  MOVWF  x31
0B8F4:  MOVFF  03,A38
0B8F8:  MOVFF  02,A37
0B8FC:  MOVFF  01,A36
0B900:  MOVFF  00,A35
0B904:  MOVLB  0
0B906:  CALL   83EC
0B90A:  MOVFF  03,A2D
0B90E:  MOVFF  02,A2C
0B912:  MOVFF  01,A2B
0B916:  MOVFF  00,A2A
0B91A:  MOVFF  03,A34
0B91E:  MOVFF  02,A33
0B922:  MOVFF  01,A32
0B926:  MOVFF  00,A31
0B92A:  MOVLW  33
0B92C:  MOVLB  A
0B92E:  MOVWF  x38
0B930:  MOVWF  x37
0B932:  MOVLW  53
0B934:  MOVWF  x36
0B936:  MOVLW  80
0B938:  MOVWF  x35
0B93A:  MOVLB  0
0B93C:  CALL   83EC
0B940:  MOVFF  03,A2D
0B944:  MOVFF  02,A2C
0B948:  MOVFF  01,A2B
0B94C:  MOVFF  00,A2A
0B950:  MOVFF  03,A33
0B954:  MOVFF  02,A32
0B958:  MOVFF  01,A31
0B95C:  MOVFF  00,A30
0B960:  MOVLB  A
0B962:  CLRF   x37
0B964:  CLRF   x36
0B966:  CLRF   x35
0B968:  MOVLW  8B
0B96A:  MOVWF  x34
0B96C:  MOVLB  0
0B96E:  RCALL  B4A0
0B970:  MOVFF  03,A2D
0B974:  MOVFF  02,A2C
0B978:  MOVFF  01,A2B
0B97C:  MOVFF  00,A2A
0B980:  MOVFF  FEA,A2F
0B984:  MOVFF  FE9,A2E
0B988:  BSF    FD8.1
0B98A:  MOVFF  03,A33
0B98E:  MOVFF  02,A32
0B992:  MOVFF  01,A31
0B996:  MOVFF  00,A30
0B99A:  MOVLW  66
0B99C:  MOVLB  A
0B99E:  MOVWF  x37
0B9A0:  MOVLW  E2
0B9A2:  MOVWF  x36
0B9A4:  MOVLW  47
0B9A6:  MOVWF  x35
0B9A8:  MOVLW  8B
0B9AA:  MOVWF  x34
0B9AC:  MOVLB  0
0B9AE:  CALL   84E2
0B9B2:  MOVFF  A2F,FEA
0B9B6:  MOVFF  A2E,FE9
0B9BA:  MOVFF  03,A14
0B9BE:  MOVFF  02,A13
0B9C2:  MOVFF  01,A12
0B9C6:  MOVFF  00,A11
0B9CA:  MOVFF  A0C,A31
0B9CE:  MOVFF  A0B,A30
0B9D2:  RCALL  B46A
0B9D4:  MOVFF  03,A34
0B9D8:  MOVFF  02,A33
0B9DC:  MOVFF  01,A32
0B9E0:  MOVFF  00,A31
0B9E4:  MOVLW  4E
0B9E6:  MOVLB  A
0B9E8:  MOVWF  x38
0B9EA:  MOVLW  62
0B9EC:  MOVWF  x37
0B9EE:  MOVLW  50
0B9F0:  MOVWF  x36
0B9F2:  MOVLW  80
0B9F4:  MOVWF  x35
0B9F6:  MOVLB  0
0B9F8:  CALL   83EC
0B9FC:  MOVFF  03,A2D
0BA00:  MOVFF  02,A2C
0BA04:  MOVFF  01,A2B
0BA08:  MOVFF  00,A2A
0BA0C:  MOVFF  03,A34
0BA10:  MOVFF  02,A33
0BA14:  MOVFF  01,A32
0BA18:  MOVFF  00,A31
0BA1C:  MOVLB  A
0BA1E:  CLRF   x38
0BA20:  CLRF   x37
0BA22:  MOVLW  70
0BA24:  MOVWF  x36
0BA26:  MOVLW  83
0BA28:  MOVWF  x35
0BA2A:  MOVLB  0
0BA2C:  CALL   83EC
0BA30:  MOVFF  03,A2D
0BA34:  MOVFF  02,A2C
0BA38:  MOVFF  01,A2B
0BA3C:  MOVFF  00,A2A
0BA40:  MOVFF  03,A33
0BA44:  MOVFF  02,A32
0BA48:  MOVFF  01,A31
0BA4C:  MOVFF  00,A30
0BA50:  MOVLB  A
0BA52:  CLRF   x37
0BA54:  CLRF   x36
0BA56:  CLRF   x35
0BA58:  MOVLW  8B
0BA5A:  MOVWF  x34
0BA5C:  MOVLB  0
0BA5E:  RCALL  B4A0
0BA60:  MOVFF  FEA,A2B
0BA64:  MOVFF  FE9,A2A
0BA68:  BSF    FD8.1
0BA6A:  MOVLB  A
0BA6C:  CLRF   x33
0BA6E:  CLRF   x32
0BA70:  MOVLW  16
0BA72:  MOVWF  x31
0BA74:  MOVLW  85
0BA76:  MOVWF  x30
0BA78:  MOVFF  03,A37
0BA7C:  MOVFF  02,A36
0BA80:  MOVFF  01,A35
0BA84:  MOVFF  00,A34
0BA88:  MOVLB  0
0BA8A:  CALL   84E2
0BA8E:  MOVFF  A2B,FEA
0BA92:  MOVFF  A2A,FE9
0BA96:  MOVFF  03,A18
0BA9A:  MOVFF  02,A17
0BA9E:  MOVFF  01,A16
0BAA2:  MOVFF  00,A15
....................     fprintf(PC, "V=%f, C=%f, T=%f | ", voltage, current, temperature); 
0BAA6:  MOVLW  56
0BAA8:  MOVLB  B
0BAAA:  MOVWF  x1F
0BAAC:  MOVLB  0
0BAAE:  CALL   1C34
0BAB2:  MOVLW  3D
0BAB4:  MOVLB  B
0BAB6:  MOVWF  x1F
0BAB8:  MOVLB  0
0BABA:  CALL   1C34
0BABE:  MOVLW  89
0BAC0:  MOVWF  FE9
0BAC2:  MOVFF  A10,A27
0BAC6:  MOVFF  A0F,A26
0BACA:  MOVFF  A0E,A25
0BACE:  MOVFF  A0D,A24
0BAD2:  MOVLW  02
0BAD4:  MOVLB  A
0BAD6:  MOVWF  x28
0BAD8:  MOVLB  0
0BADA:  RCALL  B5FE
0BADC:  MOVLW  AA
0BADE:  MOVWF  FF6
0BAE0:  MOVLW  09
0BAE2:  MOVWF  FF7
0BAE4:  MOVLW  00
0BAE6:  MOVWF  FF8
0BAE8:  MOVLW  04
0BAEA:  MOVLB  A
0BAEC:  MOVWF  x3B
0BAEE:  MOVLB  0
0BAF0:  CALL   3048
0BAF4:  MOVLW  89
0BAF6:  MOVWF  FE9
0BAF8:  MOVFF  A14,A27
0BAFC:  MOVFF  A13,A26
0BB00:  MOVFF  A12,A25
0BB04:  MOVFF  A11,A24
0BB08:  MOVLW  02
0BB0A:  MOVLB  A
0BB0C:  MOVWF  x28
0BB0E:  MOVLB  0
0BB10:  RCALL  B5FE
0BB12:  MOVLW  B0
0BB14:  MOVWF  FF6
0BB16:  MOVLW  09
0BB18:  MOVWF  FF7
0BB1A:  MOVLW  00
0BB1C:  MOVWF  FF8
0BB1E:  MOVLW  04
0BB20:  MOVLB  A
0BB22:  MOVWF  x3B
0BB24:  MOVLB  0
0BB26:  CALL   3048
0BB2A:  MOVLW  89
0BB2C:  MOVWF  FE9
0BB2E:  MOVFF  A18,A27
0BB32:  MOVFF  A17,A26
0BB36:  MOVFF  A16,A25
0BB3A:  MOVFF  A15,A24
0BB3E:  MOVLW  02
0BB40:  MOVLB  A
0BB42:  MOVWF  x28
0BB44:  MOVLB  0
0BB46:  RCALL  B5FE
0BB48:  MOVLW  B6
0BB4A:  MOVWF  FF6
0BB4C:  MOVLW  09
0BB4E:  MOVWF  FF7
0BB50:  MOVLW  00
0BB52:  MOVWF  FF8
0BB54:  MOVLW  03
0BB56:  MOVLB  A
0BB58:  MOVWF  x3B
0BB5A:  MOVLB  0
0BB5C:  CALL   3048
....................  
....................     uint16_t heater_ref_temperature = make16(data[56], data[57]); 
....................     uint16_t heater_ref_voltage = make16(data[58], data[59]); 
0BB60:  MOVLW  38
0BB62:  MOVLB  A
0BB64:  ADDWF  x05,W
0BB66:  MOVWF  FE9
0BB68:  MOVLW  00
0BB6A:  ADDWFC x06,W
0BB6C:  MOVWF  FEA
0BB6E:  MOVFF  FEF,A1A
0BB72:  MOVLW  39
0BB74:  ADDWF  x05,W
0BB76:  MOVWF  FE9
0BB78:  MOVLW  00
0BB7A:  ADDWFC x06,W
0BB7C:  MOVWF  FEA
0BB7E:  MOVFF  FEF,A19
0BB82:  MOVLW  3A
0BB84:  ADDWF  x05,W
0BB86:  MOVWF  FE9
0BB88:  MOVLW  00
0BB8A:  ADDWFC x06,W
0BB8C:  MOVWF  FEA
0BB8E:  MOVFF  FEF,A1C
0BB92:  MOVLW  3B
0BB94:  ADDWF  x05,W
0BB96:  MOVWF  FE9
0BB98:  MOVLW  00
0BB9A:  ADDWFC x06,W
0BB9C:  MOVWF  FEA
0BB9E:  MOVFF  FEF,A1B
....................  
....................     if ((heater_ref_temperature != obc_flags.heater_ref_temperature) || (heater_ref_voltage != obc_flags.heater_ref_voltage)) { 
0BBA2:  MOVLB  0
0BBA4:  MOVF   xF4,W
0BBA6:  MOVLB  A
0BBA8:  SUBWF  x19,W
0BBAA:  BNZ   BBCA
0BBAC:  MOVLB  0
0BBAE:  MOVF   xF5,W
0BBB0:  MOVLB  A
0BBB2:  SUBWF  x1A,W
0BBB4:  BNZ   BBCA
0BBB6:  MOVLB  0
0BBB8:  MOVF   xF6,W
0BBBA:  MOVLB  A
0BBBC:  SUBWF  x1B,W
0BBBE:  BNZ   BBCA
0BBC0:  MOVLB  0
0BBC2:  MOVF   xF7,W
0BBC4:  MOVLB  A
0BBC6:  SUBWF  x1C,W
0BBC8:  BZ    BCA8
....................         // E0 66 TH TL VH VL 
....................         fprintf(PC, " New T=0x%04lX, V=0x%04lX | ", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
0BBCA:  MOVLW  BA
0BBCC:  MOVWF  FF6
0BBCE:  MOVLW  09
0BBD0:  MOVWF  FF7
0BBD2:  MOVLW  00
0BBD4:  MOVWF  FF8
0BBD6:  MOVLW  09
0BBD8:  MOVWF  x3B
0BBDA:  MOVLB  0
0BBDC:  CALL   3048
0BBE0:  MOVFF  F5,A58
0BBE4:  MOVLW  37
0BBE6:  MOVLB  A
0BBE8:  MOVWF  x59
0BBEA:  MOVLB  0
0BBEC:  CALL   3142
0BBF0:  MOVFF  F4,A58
0BBF4:  MOVLW  37
0BBF6:  MOVLB  A
0BBF8:  MOVWF  x59
0BBFA:  MOVLB  0
0BBFC:  CALL   3142
0BC00:  MOVLW  C8
0BC02:  MOVWF  FF6
0BC04:  MOVLW  09
0BC06:  MOVWF  FF7
0BC08:  MOVLW  00
0BC0A:  MOVWF  FF8
0BC0C:  MOVLW  06
0BC0E:  MOVLB  A
0BC10:  MOVWF  x3B
0BC12:  MOVLB  0
0BC14:  CALL   3048
0BC18:  MOVFF  F7,A58
0BC1C:  MOVLW  37
0BC1E:  MOVLB  A
0BC20:  MOVWF  x59
0BC22:  MOVLB  0
0BC24:  CALL   3142
0BC28:  MOVFF  F6,A58
0BC2C:  MOVLW  37
0BC2E:  MOVLB  A
0BC30:  MOVWF  x59
0BC32:  MOVLB  0
0BC34:  CALL   3142
0BC38:  MOVLW  D3
0BC3A:  MOVWF  FF6
0BC3C:  MOVLW  09
0BC3E:  MOVWF  FF7
0BC40:  MOVLW  00
0BC42:  MOVWF  FF8
0BC44:  MOVLW  03
0BC46:  MOVLB  A
0BC48:  MOVWF  x3B
0BC4A:  MOVLB  0
0BC4C:  CALL   3048
....................         uint8_t cmd_temp[cmd_len]; 
....................         cmd_temp[0] = 0xC0;                                      // COM_MSG 
0BC50:  MOVLW  C0
0BC52:  MOVLB  A
0BC54:  MOVWF  x1D
....................         cmd_temp[1] = 0x6C;                                      // OBC_CMD 
0BC56:  MOVLW  6C
0BC58:  MOVWF  x1E
....................         cmd_temp[2] = 0x66;                                      // EPS_CMD 
0BC5A:  MOVLW  66
0BC5C:  MOVWF  x1F
....................         cmd_temp[3] = (obc_flags.heater_ref_temperature >> 8);   // TEMP_HIGH 
0BC5E:  MOVFF  F5,A20
....................         cmd_temp[4] = (obc_flags.heater_ref_temperature & 0xFF); // TEMP_LOW 
0BC62:  MOVFF  F4,A21
0BC66:  MOVLB  A
....................         cmd_temp[5] = (obc_flags.heater_ref_voltage >> 8);       // V_HIGH 
0BC68:  MOVFF  F7,A22
....................         cmd_temp[6] = (obc_flags.heater_ref_voltage & 0xFF);     // V_LOW 
0BC6C:  MOVFF  F6,A23
0BC70:  MOVLB  A
....................         vschedule(current_time + 5, cmd_temp); 
0BC72:  MOVLW  05
0BC74:  ADDWF  39,W
0BC76:  MOVWF  x24
0BC78:  MOVLW  00
0BC7A:  ADDWFC 3A,W
0BC7C:  MOVWF  x25
0BC7E:  MOVLW  00
0BC80:  ADDWFC 3B,W
0BC82:  MOVWF  x26
0BC84:  MOVLW  00
0BC86:  ADDWFC 3C,W
0BC88:  MOVWF  x27
0BC8A:  MOVWF  x2E
0BC8C:  MOVFF  A26,A2D
0BC90:  MOVFF  A25,A2C
0BC94:  MOVFF  A24,A2B
0BC98:  MOVLW  0A
0BC9A:  MOVWF  x30
0BC9C:  MOVLW  1D
0BC9E:  MOVWF  x2F
0BCA0:  MOVLB  0
0BCA2:  CALL   4600
0BCA6:  MOVLB  A
....................     } 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_FAB); 
0BCA8:  MOVFF  A06,A54
0BCAC:  MOVFF  A05,A53
0BCB0:  MOVLW  3C
0BCB2:  MOVWF  x55
0BCB4:  MOVLB  0
0BCB6:  CALL   4EF0
....................     telemetry_time.fab_time = current_time; 
0BCBA:  MOVFF  3C,D4
0BCBE:  MOVFF  3B,D3
0BCC2:  MOVFF  3A,D2
0BCC6:  MOVFF  39,D1
....................     memcpy(telemetry.fab_message, data + 2, sizeof(telemetry.fab_message)); 
0BCCA:  MOVLW  02
0BCCC:  MOVLB  A
0BCCE:  ADDWF  x05,W
0BCD0:  MOVWF  x24
0BCD2:  MOVLW  00
0BCD4:  ADDWFC x06,W
0BCD6:  MOVWF  x25
0BCD8:  CLRF   FEA
0BCDA:  MOVLW  5B
0BCDC:  MOVWF  FE9
0BCDE:  MOVFF  A25,FE2
0BCE2:  MOVFF  A24,FE1
0BCE6:  MOVLW  36
0BCE8:  MOVWF  01
0BCEA:  MOVFF  FE6,FEE
0BCEE:  DECFSZ 01,F
0BCF0:  BRA    BCEA
....................     return 0; 
0BCF2:  MOVLW  00
0BCF4:  MOVWF  01
0BCF6:  MOVLB  0
0BCF8:  GOTO   D018 (RETURN)
.................... } 
....................  
.................... // Passes a command from ground-station to eps pic 
.................... uint8_t command_send_data_to_eps(uint8_t* data) 
*
078D4:  MOVFF  A06,A09
078D8:  MOVFF  A05,A08
.................... { 
....................     uint8_t i; 
....................     enum { data_size = 5 }; 
....................     struct packet { 
....................         uint8_t command;         // C0: com pic message 
....................         uint8_t eps_cmd;         // 6C: eps message 
....................         uint8_t data[data_size]; // data to be passed to reset pic 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t cmd[data_size + 1] = { 0 }; 
078DC:  MOVLB  A
078DE:  CLRF   x0A
078E0:  CLRF   x0B
078E2:  CLRF   x0C
078E4:  CLRF   x0D
078E6:  CLRF   x0E
078E8:  CLRF   x0F
....................     cmd[0] = 0xE0; 
078EA:  MOVLW  E0
078EC:  MOVWF  x0A
....................     for (i = 0; i < data_size; i++) { 
078EE:  CLRF   x07
078F0:  MOVF   x07,W
078F2:  SUBLW  04
078F4:  BNC   7926
....................         cmd[i + 1] = packet->data[i]; 
078F6:  MOVLW  01
078F8:  ADDWF  x07,W
078FA:  CLRF   03
078FC:  ADDLW  0A
078FE:  MOVWF  01
07900:  MOVLW  0A
07902:  ADDWFC 03,F
07904:  MOVLW  02
07906:  ADDWF  x07,W
07908:  ADDWF  x08,W
0790A:  MOVWF  FE9
0790C:  MOVLW  00
0790E:  ADDWFC x09,W
07910:  MOVWF  FEA
07912:  MOVFF  FEF,A12
07916:  MOVFF  03,FEA
0791A:  MOVFF  01,FE9
0791E:  MOVFF  A12,FEF
07922:  INCF   x07,F
07924:  BRA    78F0
....................     } 
....................     for (i = 0; i < sizeof(cmd); i++) { 
07926:  CLRF   x07
07928:  MOVF   x07,W
0792A:  SUBLW  05
0792C:  BNC   794E
....................         fputc(cmd[i], FAB); 
0792E:  CLRF   03
07930:  MOVF   x07,W
07932:  ADDLW  0A
07934:  MOVWF  FE9
07936:  MOVLW  0A
07938:  ADDWFC 03,W
0793A:  MOVWF  FEA
0793C:  MOVFF  FEF,A10
07940:  MOVF   x10,W
07942:  MOVLB  0
07944:  CALL   2A6E
07948:  MOVLB  A
0794A:  INCF   x07,F
0794C:  BRA    7928
....................     } 
....................  
....................     fprintf(PC, "EPS cmd: "); 
0794E:  MOVLW  D8
07950:  MOVWF  FF6
07952:  MOVLW  09
07954:  MOVWF  FF7
07956:  MOVLW  00
07958:  MOVWF  FF8
0795A:  MOVLB  0
0795C:  CALL   1C7A
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
07960:  MOVLW  0A
07962:  MOVLB  A
07964:  MOVWF  x54
07966:  MOVWF  x53
07968:  MOVLW  06
0796A:  MOVWF  x55
0796C:  MOVLB  0
0796E:  CALL   4EF0
....................  
....................     return 0; 
07972:  MOVLW  00
07974:  MOVWF  01
07976:  GOTO   CDB4 (RETURN)
.................... } 
....................  
.................... uint8_t command_eps_set_heater_ref(uint8_t* data) 
0797A:  MOVFF  A06,A08
0797E:  MOVFF  A05,A07
.................... { 
....................     struct packet { 
....................         uint8_t command;   // C0: com pic message 
....................         uint8_t eps_cmd;   // 6D: heater ref settings 
....................         uint16_t temp_ref; // temperature reference 
....................         uint16_t v_ref;    // voltage reference 
....................     }* packet = (struct packet*)data; 
....................  
....................     obc_flags.heater_ref_temperature = packet->temp_ref; 
07982:  MOVLW  02
07984:  MOVLB  A
07986:  ADDWF  x07,W
07988:  MOVWF  FE9
0798A:  MOVLW  00
0798C:  ADDWFC x08,W
0798E:  MOVWF  FEA
07990:  MOVFF  FEC,F5
07994:  MOVF   FED,F
07996:  MOVFF  FEF,F4
....................     obc_flags.heater_ref_voltage = packet->v_ref; 
0799A:  MOVLW  04
0799C:  ADDWF  x07,W
0799E:  MOVWF  FE9
079A0:  MOVLW  00
079A2:  ADDWFC x08,W
079A4:  MOVWF  FEA
079A6:  MOVFF  FEC,F7
079AA:  MOVF   FED,F
079AC:  MOVFF  FEF,F6
....................     save_state(packet->eps_cmd); 
079B0:  MOVLW  01
079B2:  ADDWF  x07,W
079B4:  MOVWF  FE9
079B6:  MOVLW  00
079B8:  ADDWFC x08,W
079BA:  MOVWF  FEA
079BC:  MOVFF  FEF,A0E
079C0:  MOVLB  0
079C2:  RCALL  74CE
....................  
....................     fprintf(PC, "New T=0x%04lX, V=0x%04lX", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
079C4:  MOVLW  E2
079C6:  MOVWF  FF6
079C8:  MOVLW  09
079CA:  MOVWF  FF7
079CC:  MOVLW  00
079CE:  MOVWF  FF8
079D0:  MOVLW  08
079D2:  MOVLB  A
079D4:  MOVWF  x3B
079D6:  MOVLB  0
079D8:  CALL   3048
079DC:  MOVFF  F5,A58
079E0:  MOVLW  37
079E2:  MOVLB  A
079E4:  MOVWF  x59
079E6:  MOVLB  0
079E8:  CALL   3142
079EC:  MOVFF  F4,A58
079F0:  MOVLW  37
079F2:  MOVLB  A
079F4:  MOVWF  x59
079F6:  MOVLB  0
079F8:  CALL   3142
079FC:  MOVLW  EF
079FE:  MOVWF  FF6
07A00:  MOVLW  09
07A02:  MOVWF  FF7
07A04:  MOVLW  00
07A06:  MOVWF  FF8
07A08:  MOVLW  06
07A0A:  MOVLB  A
07A0C:  MOVWF  x3B
07A0E:  MOVLB  0
07A10:  CALL   3048
07A14:  MOVFF  F7,A58
07A18:  MOVLW  37
07A1A:  MOVLB  A
07A1C:  MOVWF  x59
07A1E:  MOVLB  0
07A20:  CALL   3142
07A24:  MOVFF  F6,A58
07A28:  MOVLW  37
07A2A:  MOVLB  A
07A2C:  MOVWF  x59
07A2E:  MOVLB  0
07A30:  CALL   3142
....................  
....................     return 0; 
07A34:  MOVLW  00
07A36:  MOVWF  01
07A38:  GOTO   CDC6 (RETURN)
.................... } 
....................  
.................... uint8_t command_obc_kill_on(uint8_t* data) 
*
07822:  MOVLB  A
07824:  CLRF   x07
.................... { 
....................     uint8_t kill_sw_status = 0; 
....................     if (data[2] == 0x55 && data[4] == 0x55 && data[6] == 0x55 && data[8] == 0x55 && data[3] == 0xAA && data[5] == 0xAA && data[7] == 0xAA && data[9] == 0xAA) { 
07826:  MOVLW  02
07828:  ADDWF  x05,W
0782A:  MOVWF  FE9
0782C:  MOVLW  00
0782E:  ADDWFC x06,W
07830:  MOVWF  FEA
07832:  MOVF   FEF,W
07834:  SUBLW  55
07836:  BNZ   78BE
07838:  MOVLW  04
0783A:  ADDWF  x05,W
0783C:  MOVWF  FE9
0783E:  MOVLW  00
07840:  ADDWFC x06,W
07842:  MOVWF  FEA
07844:  MOVF   FEF,W
07846:  SUBLW  55
07848:  BNZ   78BE
0784A:  MOVLW  06
0784C:  ADDWF  x05,W
0784E:  MOVWF  FE9
07850:  MOVLW  00
07852:  ADDWFC x06,W
07854:  MOVWF  FEA
07856:  MOVF   FEF,W
07858:  SUBLW  55
0785A:  BNZ   78BE
0785C:  MOVLW  08
0785E:  ADDWF  x05,W
07860:  MOVWF  FE9
07862:  MOVLW  00
07864:  ADDWFC x06,W
07866:  MOVWF  FEA
07868:  MOVF   FEF,W
0786A:  SUBLW  55
0786C:  BNZ   78BE
0786E:  MOVLW  03
07870:  ADDWF  x05,W
07872:  MOVWF  FE9
07874:  MOVLW  00
07876:  ADDWFC x06,W
07878:  MOVWF  FEA
0787A:  MOVF   FEF,W
0787C:  SUBLW  AA
0787E:  BNZ   78BE
07880:  MOVLW  05
07882:  ADDWF  x05,W
07884:  MOVWF  FE9
07886:  MOVLW  00
07888:  ADDWFC x06,W
0788A:  MOVWF  FEA
0788C:  MOVF   FEF,W
0788E:  SUBLW  AA
07890:  BNZ   78BE
07892:  MOVLW  07
07894:  ADDWF  x05,W
07896:  MOVWF  FE9
07898:  MOVLW  00
0789A:  ADDWFC x06,W
0789C:  MOVWF  FEA
0789E:  MOVF   FEF,W
078A0:  SUBLW  AA
078A2:  BNZ   78BE
078A4:  MOVLW  09
078A6:  ADDWF  x05,W
078A8:  MOVWF  FE9
078AA:  MOVLW  00
078AC:  ADDWFC x06,W
078AE:  MOVWF  FEA
078B0:  MOVF   FEF,W
078B2:  SUBLW  AA
078B4:  BNZ   78BE
....................         kill_sw_status = 1; 
078B6:  MOVLW  01
078B8:  MOVWF  x07
....................         output_high(PIN_A4); 
078BA:  BCF    F92.4
078BC:  BSF    F89.4
....................     } 
....................     return kill_sw_status; 
078BE:  MOVFF  A07,01
078C2:  MOVLB  0
078C4:  GOTO   CD90 (RETURN)
.................... } 
....................  
.................... uint8_t command_obc_kill_off(uint8_t* data) 
.................... { 
....................     output_low(PIN_A4); 
078C8:  BCF    F92.4
078CA:  BCF    F89.4
....................     return 0; 
078CC:  MOVLW  00
078CE:  MOVWF  01
078D0:  GOTO   CDA2 (RETURN)
.................... } 
....................  
.................... uint8_t command_raw_pcib(uint8_t* data) 
*
08D08:  MOVFF  A06,A08
08D0C:  MOVFF  A05,A07
.................... { 
....................     enum { cmd_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t pcib_command[cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t pcib_cmd[MSG_LENGTH_PCIB] = { 0 }; 
08D10:  MOVLB  A
08D12:  CLRF   x09
08D14:  CLRF   x0A
08D16:  CLRF   x0B
08D18:  CLRF   x0C
08D1A:  CLRF   x0D
08D1C:  CLRF   x0E
08D1E:  CLRF   x0F
08D20:  CLRF   x10
08D22:  CLRF   x11
08D24:  CLRF   x12
08D26:  CLRF   x13
08D28:  CLRF   x14
08D2A:  CLRF   x15
08D2C:  CLRF   x16
08D2E:  CLRF   x17
08D30:  CLRF   x18
08D32:  CLRF   x19
08D34:  CLRF   x1A
08D36:  CLRF   x1B
08D38:  CLRF   x1C
08D3A:  CLRF   x1D
08D3C:  CLRF   x1E
08D3E:  CLRF   x1F
08D40:  CLRF   x20
08D42:  CLRF   x21
08D44:  CLRF   x22
08D46:  CLRF   x23
08D48:  CLRF   x24
08D4A:  CLRF   x25
08D4C:  CLRF   x26
08D4E:  CLRF   x27
08D50:  CLRF   x28
08D52:  CLRF   x29
08D54:  CLRF   x2A
08D56:  CLRF   x2B
08D58:  CLRF   x2C
....................     pcib_cmd[0] = 0x0B; 
08D5A:  MOVLW  0B
08D5C:  MOVWF  x09
....................     memcpy(pcib_cmd + 1, packet->pcib_command, cmd_size); 
08D5E:  MOVLW  02
08D60:  ADDWF  x07,W
08D62:  MOVWF  01
08D64:  MOVLW  00
08D66:  ADDWFC x08,W
08D68:  MOVWF  03
08D6A:  MOVFF  01,A2D
08D6E:  MOVWF  x2E
08D70:  MOVLW  0A
08D72:  MOVWF  FEA
08D74:  MOVWF  FE9
08D76:  MOVFF  03,FE2
08D7A:  MOVFF  01,FE1
08D7E:  MOVLW  08
08D80:  MOVWF  01
08D82:  MOVFF  FE6,FEE
08D86:  DECFSZ 01,F
08D88:  BRA    8D82
....................     checksum_obc(pcib_cmd, MSG_LENGTH_PCIB); 
08D8A:  MOVLW  0A
08D8C:  MOVWF  x58
08D8E:  MOVLW  09
08D90:  MOVWF  x57
08D92:  MOVLW  24
08D94:  MOVWF  x59
08D96:  MOVLB  0
08D98:  CALL   712A
....................     uart_send_packet_repeat(&uart_port_PCIB, pcib_cmd, MSG_LENGTH_PCIB, 5, 10); 
08D9C:  MOVLW  08
08D9E:  MOVLB  A
08DA0:  MOVWF  x58
08DA2:  MOVLW  17
08DA4:  MOVWF  x57
08DA6:  MOVLW  0A
08DA8:  MOVWF  x5A
08DAA:  MOVLW  09
08DAC:  MOVWF  x59
08DAE:  CLRF   x5E
08DB0:  CLRF   x5D
08DB2:  CLRF   x5C
08DB4:  MOVLW  24
08DB6:  MOVWF  x5B
08DB8:  MOVLW  05
08DBA:  MOVWF  x5F
08DBC:  CLRF   x63
08DBE:  CLRF   x62
08DC0:  CLRF   x61
08DC2:  MOVLW  0A
08DC4:  MOVWF  x60
08DC6:  MOVLB  0
08DC8:  RCALL  8CAC
....................     return packet->pcib_command[0]; 
08DCA:  MOVLW  02
08DCC:  MOVLB  A
08DCE:  ADDWF  x07,W
08DD0:  MOVWF  FE9
08DD2:  MOVLW  00
08DD4:  ADDWFC x08,W
08DD6:  MOVWF  FEA
08DD8:  MOVFF  FEF,01
08DDC:  MOVLB  0
08DDE:  GOTO   CEE6 (RETURN)
.................... } 
....................  
.................... // Used to stop the simulation 
.................... uint8_t command_debug(uint8_t* data) 
.................... { 
.................... #ifdef PC_SIM 
....................     fprintf(PC, "Exiting simulation"); 
....................     continue_program = 0; 
.................... #else 
....................     for (uint32_t i = 0; i < 65536; i++) { 
*
09FA2:  MOVLB  A
09FA4:  CLRF   x0A
09FA6:  CLRF   x09
09FA8:  CLRF   x08
09FAA:  CLRF   x07
09FAC:  MOVF   x0A,F
09FAE:  BNZ   A06E
09FB0:  MOVF   x09,W
09FB2:  SUBLW  00
09FB4:  BNC   A06E
....................         fprintf(PC, "%02X:%02X:%d\r\n", (uint8_t)(i >> 8), (uint8_t)(i & 0xFF), (int8_t)gyro_to_cw((uint8_t)(i >> 8), (uint8_t)(i & 0xFF))); 
09FB6:  MOVFF  A09,01
09FBA:  MOVFF  A0A,02
09FBE:  CLRF   03
09FC0:  MOVFF  A08,A0C
09FC4:  CLRF   01
09FC6:  CLRF   02
09FC8:  CLRF   03
09FCA:  MOVFF  A07,A0D
09FCE:  MOVFF  A09,01
09FD2:  MOVFF  A0A,02
09FD6:  CLRF   03
09FD8:  MOVFF  A08,A0F
09FDC:  MOVFF  A07,00
09FE0:  CLRF   01
09FE2:  CLRF   02
09FE4:  CLRF   03
09FE6:  MOVFF  A07,A10
09FEA:  MOVFF  A08,A1A
09FEE:  MOVFF  A07,A1B
09FF2:  MOVLB  0
09FF4:  RCALL  9E5E
09FF6:  MOVFF  01,A0F
09FFA:  MOVFF  A0C,A58
09FFE:  MOVLW  37
0A000:  MOVLB  A
0A002:  MOVWF  x59
0A004:  MOVLB  0
0A006:  CALL   3142
0A00A:  MOVLW  3A
0A00C:  MOVLB  B
0A00E:  MOVWF  x1F
0A010:  MOVLB  0
0A012:  CALL   1C34
0A016:  MOVFF  A0D,A58
0A01A:  MOVLW  37
0A01C:  MOVLB  A
0A01E:  MOVWF  x59
0A020:  MOVLB  0
0A022:  CALL   3142
0A026:  MOVLW  3A
0A028:  MOVLB  B
0A02A:  MOVWF  x1F
0A02C:  MOVLB  0
0A02E:  CALL   1C34
0A032:  MOVFF  A0F,A25
0A036:  MOVLW  18
0A038:  MOVLB  A
0A03A:  MOVWF  x26
0A03C:  MOVLB  0
0A03E:  CALL   4960
0A042:  MOVLW  0D
0A044:  MOVLB  B
0A046:  MOVWF  x1F
0A048:  MOVLB  0
0A04A:  CALL   1C34
0A04E:  MOVLW  0A
0A050:  MOVLB  B
0A052:  MOVWF  x1F
0A054:  MOVLB  0
0A056:  CALL   1C34
0A05A:  MOVLW  01
0A05C:  MOVLB  A
0A05E:  ADDWF  x07,F
0A060:  BTFSC  FD8.0
0A062:  INCF   x08,F
0A064:  BTFSC  FD8.2
0A066:  INCF   x09,F
0A068:  BTFSC  FD8.2
0A06A:  INCF   x0A,F
0A06C:  BRA    9FAC
....................     } 
.................... #endif // !PC_SIM 
....................     return 0; 
0A06E:  MOVLW  00
0A070:  MOVWF  01
0A072:  MOVLB  0
0A074:  GOTO   CF52 (RETURN)
.................... } 
....................  
.................... // ===================================================== 
....................  
.................... // Function that executes a command, by looking up on the table of available commands. 
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled) 
*
0C582:  MOVLB  9
0C584:  CLRF   xF7
.................... { 
....................     uint8_t error = 0; 
....................  
....................     if (origin == data[0] || origin == MSG_WILDCARD) { 
0C586:  MOVFF  9F3,FE9
0C58A:  MOVFF  9F4,FEA
0C58E:  MOVF   FEF,W
0C590:  SUBWF  xF5,W
0C592:  BZ    C59A
0C594:  INCFSZ xF5,W
0C596:  GOTO   D17C
....................  
....................         // COM reply 
....................         if (data[0] == 0xC0) { 
0C59A:  MOVFF  9F3,FE9
0C59E:  MOVFF  9F4,FEA
0C5A2:  MOVF   FEF,W
0C5A4:  SUBLW  C0
0C5A6:  BNZ   C624
....................             if (data[1] == 0x42) { 
0C5A8:  MOVLW  01
0C5AA:  ADDWF  xF3,W
0C5AC:  MOVWF  FE9
0C5AE:  MOVLW  00
0C5B0:  ADDWFC xF4,W
0C5B2:  MOVWF  FEA
0C5B4:  MOVF   FEF,W
0C5B6:  SUBLW  42
0C5B8:  BNZ   C624
....................                 if (data[4] != 0x00) { // 0x00 is a request for memory dump 
0C5BA:  MOVLW  04
0C5BC:  ADDWF  xF3,W
0C5BE:  MOVWF  FE9
0C5C0:  MOVLW  00
0C5C2:  ADDWFC xF4,W
0C5C4:  MOVWF  FEA
0C5C6:  MOVF   FEF,F
0C5C8:  BZ    C5EC
....................                     send_com_ack(data + 2); 
0C5CA:  MOVLW  02
0C5CC:  ADDWF  xF3,W
0C5CE:  MOVLB  A
0C5D0:  MOVWF  x05
0C5D2:  MOVLW  00
0C5D4:  MOVLB  9
0C5D6:  ADDWFC xF4,W
0C5D8:  MOVLB  A
0C5DA:  MOVWF  x06
0C5DC:  MOVWF  x1C
0C5DE:  MOVFF  A05,A1B
0C5E2:  MOVLB  0
0C5E4:  CALL   4C36
....................                 } else { 
0C5E8:  BRA    C622
0C5EA:  MOVLB  9
.................... #ifndef PC_SIM 
....................                     uint32_t* ptr = *(uint32_t*)&data[5]; 
0C5EC:  MOVLW  05
0C5EE:  ADDWF  xF3,W
0C5F0:  MOVWF  01
0C5F2:  MOVLW  00
0C5F4:  ADDWFC xF4,W
0C5F6:  MOVFF  01,FE9
0C5FA:  MOVWF  FEA
0C5FC:  MOVFF  FEF,9F8
0C600:  MOVFF  FEC,9F9
....................                     send_com_ack(ptr + &current_time); 
0C604:  MOVLW  39
0C606:  ADDWF  xF8,W
0C608:  MOVLB  A
0C60A:  MOVWF  x05
0C60C:  MOVLW  00
0C60E:  MOVLB  9
0C610:  ADDWFC xF9,W
0C612:  MOVLB  A
0C614:  MOVWF  x06
0C616:  MOVWF  x1C
0C618:  MOVFF  A05,A1B
0C61C:  MOVLB  0
0C61E:  CALL   4C36
0C622:  MOVLB  9
.................... #endif 
....................                 } 
....................             } 
....................         } 
....................  
....................         // Satellite log 
....................         log_entry log; 
....................         log.origin = data[0]; 
0C624:  MOVFF  9F3,FE9
0C628:  MOVFF  9F4,FEA
0C62C:  MOVFF  FEF,9FE
....................         log.command = data[1]; 
0C630:  MOVLW  01
0C632:  ADDWF  xF3,W
0C634:  MOVWF  FE9
0C636:  MOVLW  00
0C638:  ADDWFC xF4,W
0C63A:  MOVWF  FEA
0C63C:  MOVFF  FEF,9FF
....................  
....................         struct_tm* local_time = localtime(&current_time); 
0C640:  MOVLB  A
0C642:  CLRF   x4D
0C644:  MOVLW  39
0C646:  MOVWF  x4C
0C648:  MOVLB  0
0C64A:  CALL   246E
0C64E:  MOVFF  02,A02
0C652:  MOVFF  01,A01
....................  
....................         // Execute command 
....................         if (log_enabled) 
0C656:  MOVLB  9
0C658:  MOVF   xF6,F
0C65A:  BTFSC  FD8.2
0C65C:  BRA    C818
....................             fprintf(PC, "%04ld/%02d/%02d %02d:%02d:%02d | %02d | %02X %02X | ", local_time->tm_year + 1900, 
....................                 (uint8_t)local_time->tm_mon + 1, 
....................                 local_time->tm_mday, 
....................                 local_time->tm_hour, 
....................                 local_time->tm_min, 
....................                 local_time->tm_sec, 
....................                 scheduled_command_count(), 
....................                 data[0], 
....................                 data[1]); 
0C65E:  MOVLW  05
0C660:  MOVLB  A
0C662:  ADDWF  x01,W
0C664:  MOVWF  FE9
0C666:  MOVLW  00
0C668:  ADDWFC x02,W
0C66A:  MOVWF  FEA
0C66C:  MOVFF  FEC,A06
0C670:  MOVF   FED,F
0C672:  MOVFF  FEF,A05
0C676:  MOVLW  6C
0C678:  ADDWF  x05,F
0C67A:  MOVLW  07
0C67C:  ADDWFC x06,F
0C67E:  MOVLW  04
0C680:  ADDWF  x01,W
0C682:  MOVWF  FE9
0C684:  MOVLW  00
0C686:  ADDWFC x02,W
0C688:  MOVWF  FEA
0C68A:  MOVLW  01
0C68C:  ADDWF  FEF,W
0C68E:  MOVWF  x07
0C690:  MOVLW  03
0C692:  ADDWF  x01,W
0C694:  MOVWF  FE9
0C696:  MOVLW  00
0C698:  ADDWFC x02,W
0C69A:  MOVWF  FEA
0C69C:  MOVFF  FEF,A08
0C6A0:  MOVLW  02
0C6A2:  ADDWF  x01,W
0C6A4:  MOVWF  FE9
0C6A6:  MOVLW  00
0C6A8:  ADDWFC x02,W
0C6AA:  MOVWF  FEA
0C6AC:  MOVFF  FEF,A09
0C6B0:  MOVLW  01
0C6B2:  ADDWF  x01,W
0C6B4:  MOVWF  FE9
0C6B6:  MOVLW  00
0C6B8:  ADDWFC x02,W
0C6BA:  MOVWF  FEA
0C6BC:  MOVFF  FEF,A0A
0C6C0:  MOVFF  A01,FE9
0C6C4:  MOVFF  A02,FEA
0C6C8:  MOVFF  FEF,A0B
0C6CC:  MOVLB  0
0C6CE:  CALL   4CC4
0C6D2:  MOVFF  01,A0C
0C6D6:  MOVLB  9
0C6D8:  MOVFF  9F3,FE9
0C6DC:  MOVFF  9F4,FEA
0C6E0:  MOVFF  FEF,A0D
0C6E4:  MOVLW  01
0C6E6:  ADDWF  xF3,W
0C6E8:  MOVWF  FE9
0C6EA:  MOVLW  00
0C6EC:  ADDWFC xF4,W
0C6EE:  MOVWF  FEA
0C6F0:  MOVFF  FEF,A0E
0C6F4:  MOVLW  0A
0C6F6:  MOVWF  FE9
0C6F8:  MOVFF  A06,A24
0C6FC:  MOVFF  A05,A23
0C700:  MOVLB  0
0C702:  CALL   4D28
0C706:  MOVLW  2F
0C708:  MOVLB  B
0C70A:  MOVWF  x1F
0C70C:  MOVLB  0
0C70E:  CALL   1C34
0C712:  MOVFF  A07,A23
0C716:  MOVLW  01
0C718:  MOVLB  A
0C71A:  MOVWF  x24
0C71C:  MOVLB  0
0C71E:  CALL   4E28
0C722:  MOVLW  2F
0C724:  MOVLB  B
0C726:  MOVWF  x1F
0C728:  MOVLB  0
0C72A:  CALL   1C34
0C72E:  MOVFF  A08,A23
0C732:  MOVLW  01
0C734:  MOVLB  A
0C736:  MOVWF  x24
0C738:  MOVLB  0
0C73A:  CALL   4E28
0C73E:  MOVLW  20
0C740:  MOVLB  B
0C742:  MOVWF  x1F
0C744:  MOVLB  0
0C746:  CALL   1C34
0C74A:  MOVFF  A09,A23
0C74E:  MOVLW  01
0C750:  MOVLB  A
0C752:  MOVWF  x24
0C754:  MOVLB  0
0C756:  CALL   4E28
0C75A:  MOVLW  3A
0C75C:  MOVLB  B
0C75E:  MOVWF  x1F
0C760:  MOVLB  0
0C762:  CALL   1C34
0C766:  MOVFF  A0A,A23
0C76A:  MOVLW  01
0C76C:  MOVLB  A
0C76E:  MOVWF  x24
0C770:  MOVLB  0
0C772:  CALL   4E28
0C776:  MOVLW  3A
0C778:  MOVLB  B
0C77A:  MOVWF  x1F
0C77C:  MOVLB  0
0C77E:  CALL   1C34
0C782:  MOVFF  A0B,A23
0C786:  MOVLW  01
0C788:  MOVLB  A
0C78A:  MOVWF  x24
0C78C:  MOVLB  0
0C78E:  CALL   4E28
0C792:  MOVLW  1A
0C794:  MOVWF  FF6
0C796:  MOVLW  0A
0C798:  MOVWF  FF7
0C79A:  MOVLW  00
0C79C:  MOVWF  FF8
0C79E:  MOVLW  03
0C7A0:  MOVLB  A
0C7A2:  MOVWF  x3B
0C7A4:  MOVLB  0
0C7A6:  CALL   3048
0C7AA:  MOVFF  A0C,A23
0C7AE:  MOVLW  01
0C7B0:  MOVLB  A
0C7B2:  MOVWF  x24
0C7B4:  MOVLB  0
0C7B6:  CALL   4E28
0C7BA:  MOVLW  21
0C7BC:  MOVWF  FF6
0C7BE:  MOVLW  0A
0C7C0:  MOVWF  FF7
0C7C2:  MOVLW  00
0C7C4:  MOVWF  FF8
0C7C6:  MOVLW  03
0C7C8:  MOVLB  A
0C7CA:  MOVWF  x3B
0C7CC:  MOVLB  0
0C7CE:  CALL   3048
0C7D2:  MOVFF  A0D,A58
0C7D6:  MOVLW  37
0C7D8:  MOVLB  A
0C7DA:  MOVWF  x59
0C7DC:  MOVLB  0
0C7DE:  CALL   3142
0C7E2:  MOVLW  20
0C7E4:  MOVLB  B
0C7E6:  MOVWF  x1F
0C7E8:  MOVLB  0
0C7EA:  CALL   1C34
0C7EE:  MOVFF  A0E,A58
0C7F2:  MOVLW  37
0C7F4:  MOVLB  A
0C7F6:  MOVWF  x59
0C7F8:  MOVLB  0
0C7FA:  CALL   3142
0C7FE:  MOVLW  2D
0C800:  MOVWF  FF6
0C802:  MOVLW  0A
0C804:  MOVWF  FF7
0C806:  MOVLW  00
0C808:  MOVWF  FF8
0C80A:  MOVLW  03
0C80C:  MOVLB  A
0C80E:  MOVWF  x3B
0C810:  MOVLB  0
0C812:  CALL   3048
0C816:  MOVLB  9
....................  
....................         uint16_t command = make16(data[0], data[1]); 
0C818:  MOVFF  9F3,FE9
0C81C:  MOVFF  9F4,FEA
0C820:  MOVFF  FEF,A04
0C824:  MOVLW  01
0C826:  ADDWF  xF3,W
0C828:  MOVWF  FE9
0C82A:  MOVLW  00
0C82C:  ADDWFC xF4,W
0C82E:  MOVWF  FEA
0C830:  MOVFF  FEF,A03
....................  
....................         // The table of available commands. 
....................         switch (command) { 
0C834:  MOVLB  A
0C836:  MOVF   x03,W
0C838:  MOVWF  00
0C83A:  MOVF   x04,W
0C83C:  MOVWF  03
0C83E:  MOVLW  AB
0C840:  SUBWF  03,W
0C842:  BNZ   C850
0C844:  MOVLW  AA
0C846:  SUBWF  00,W
0C848:  MOVLB  0
0C84A:  BTFSC  FD8.2
0C84C:  BRA    CC52
0C84E:  MOVLB  A
0C850:  MOVLW  AD
0C852:  SUBWF  03,W
0C854:  BNZ   C862
0C856:  MOVLW  90
0C858:  SUBWF  00,W
0C85A:  MOVLB  0
0C85C:  BTFSC  FD8.2
0C85E:  BRA    CC64
0C860:  MOVLB  A
0C862:  MOVLW  AD
0C864:  SUBWF  03,W
0C866:  BNZ   C874
0C868:  MOVLW  DA
0C86A:  SUBWF  00,W
0C86C:  MOVLB  0
0C86E:  BTFSC  FD8.2
0C870:  BRA    CC76
0C872:  MOVLB  A
0C874:  MOVLW  C0
0C876:  SUBWF  03,W
0C878:  BNZ   C884
0C87A:  MOVF   00,F
0C87C:  MOVLB  0
0C87E:  BTFSC  FD8.2
0C880:  BRA    CC88
0C882:  MOVLB  A
0C884:  MOVLW  C0
0C886:  SUBWF  03,W
0C888:  BNZ   C896
0C88A:  MOVLW  01
0C88C:  SUBWF  00,W
0C88E:  MOVLB  0
0C890:  BTFSC  FD8.2
0C892:  BRA    CC9A
0C894:  MOVLB  A
0C896:  MOVLW  C0
0C898:  SUBWF  03,W
0C89A:  BNZ   C8A8
0C89C:  MOVLW  0A
0C89E:  SUBWF  00,W
0C8A0:  MOVLB  0
0C8A2:  BTFSC  FD8.2
0C8A4:  BRA    CCAC
0C8A6:  MOVLB  A
0C8A8:  MOVLW  C0
0C8AA:  SUBWF  03,W
0C8AC:  BNZ   C8BA
0C8AE:  MOVLW  0B
0C8B0:  SUBWF  00,W
0C8B2:  MOVLB  0
0C8B4:  BTFSC  FD8.2
0C8B6:  BRA    CCBE
0C8B8:  MOVLB  A
0C8BA:  MOVLW  C0
0C8BC:  SUBWF  03,W
0C8BE:  BNZ   C8CC
0C8C0:  MOVLW  0C
0C8C2:  SUBWF  00,W
0C8C4:  MOVLB  0
0C8C6:  BTFSC  FD8.2
0C8C8:  BRA    CCD0
0C8CA:  MOVLB  A
0C8CC:  MOVLW  C0
0C8CE:  SUBWF  03,W
0C8D0:  BNZ   C8DE
0C8D2:  MOVLW  0D
0C8D4:  SUBWF  00,W
0C8D6:  MOVLB  0
0C8D8:  BTFSC  FD8.2
0C8DA:  BRA    CCE2
0C8DC:  MOVLB  A
0C8DE:  MOVLW  C0
0C8E0:  SUBWF  03,W
0C8E2:  BNZ   C8F0
0C8E4:  MOVLW  25
0C8E6:  SUBWF  00,W
0C8E8:  MOVLB  0
0C8EA:  BTFSC  FD8.2
0C8EC:  BRA    CCF4
0C8EE:  MOVLB  A
0C8F0:  MOVLW  C0
0C8F2:  SUBWF  03,W
0C8F4:  BNZ   C902
0C8F6:  MOVLW  26
0C8F8:  SUBWF  00,W
0C8FA:  MOVLB  0
0C8FC:  BTFSC  FD8.2
0C8FE:  BRA    CD06
0C900:  MOVLB  A
0C902:  MOVLW  C0
0C904:  SUBWF  03,W
0C906:  BNZ   C914
0C908:  MOVLW  28
0C90A:  SUBWF  00,W
0C90C:  MOVLB  0
0C90E:  BTFSC  FD8.2
0C910:  BRA    CD18
0C912:  MOVLB  A
0C914:  MOVLW  C0
0C916:  SUBWF  03,W
0C918:  BNZ   C926
0C91A:  MOVLW  42
0C91C:  SUBWF  00,W
0C91E:  MOVLB  0
0C920:  BTFSC  FD8.2
0C922:  BRA    CD2A
0C924:  MOVLB  A
0C926:  MOVLW  C0
0C928:  SUBWF  03,W
0C92A:  BNZ   C938
0C92C:  MOVLW  50
0C92E:  SUBWF  00,W
0C930:  MOVLB  0
0C932:  BTFSC  FD8.2
0C934:  BRA    CD3C
0C936:  MOVLB  A
0C938:  MOVLW  C0
0C93A:  SUBWF  03,W
0C93C:  BNZ   C94A
0C93E:  MOVLW  55
0C940:  SUBWF  00,W
0C942:  MOVLB  0
0C944:  BTFSC  FD8.2
0C946:  BRA    CD4E
0C948:  MOVLB  A
0C94A:  MOVLW  C0
0C94C:  SUBWF  03,W
0C94E:  BNZ   C95C
0C950:  MOVLW  58
0C952:  SUBWF  00,W
0C954:  MOVLB  0
0C956:  BTFSC  FD8.2
0C958:  BRA    CD60
0C95A:  MOVLB  A
0C95C:  MOVLW  C0
0C95E:  SUBWF  03,W
0C960:  BNZ   C96E
0C962:  MOVLW  59
0C964:  SUBWF  00,W
0C966:  MOVLB  0
0C968:  BTFSC  FD8.2
0C96A:  BRA    CD72
0C96C:  MOVLB  A
0C96E:  MOVLW  C0
0C970:  SUBWF  03,W
0C972:  BNZ   C980
0C974:  MOVLW  60
0C976:  SUBWF  00,W
0C978:  MOVLB  0
0C97A:  BTFSC  FD8.2
0C97C:  BRA    CD84
0C97E:  MOVLB  A
0C980:  MOVLW  C0
0C982:  SUBWF  03,W
0C984:  BNZ   C992
0C986:  MOVLW  61
0C988:  SUBWF  00,W
0C98A:  MOVLB  0
0C98C:  BTFSC  FD8.2
0C98E:  BRA    CD96
0C990:  MOVLB  A
0C992:  MOVLW  C0
0C994:  SUBWF  03,W
0C996:  BNZ   C9A4
0C998:  MOVLW  6C
0C99A:  SUBWF  00,W
0C99C:  MOVLB  0
0C99E:  BTFSC  FD8.2
0C9A0:  BRA    CDA8
0C9A2:  MOVLB  A
0C9A4:  MOVLW  C0
0C9A6:  SUBWF  03,W
0C9A8:  BNZ   C9B6
0C9AA:  MOVLW  6D
0C9AC:  SUBWF  00,W
0C9AE:  MOVLB  0
0C9B0:  BTFSC  FD8.2
0C9B2:  BRA    CDBA
0C9B4:  MOVLB  A
0C9B6:  MOVLW  C0
0C9B8:  SUBWF  03,W
0C9BA:  BNZ   C9C8
0C9BC:  MOVLW  70
0C9BE:  SUBWF  00,W
0C9C0:  MOVLB  0
0C9C2:  BTFSC  FD8.2
0C9C4:  BRA    CDCC
0C9C6:  MOVLB  A
0C9C8:  MOVLW  C0
0C9CA:  SUBWF  03,W
0C9CC:  BNZ   C9DA
0C9CE:  MOVLW  71
0C9D0:  SUBWF  00,W
0C9D2:  MOVLB  0
0C9D4:  BTFSC  FD8.2
0C9D6:  BRA    CDDE
0C9D8:  MOVLB  A
0C9DA:  MOVLW  C0
0C9DC:  SUBWF  03,W
0C9DE:  BNZ   C9EC
0C9E0:  MOVLW  72
0C9E2:  SUBWF  00,W
0C9E4:  MOVLB  0
0C9E6:  BTFSC  FD8.2
0C9E8:  BRA    CDF0
0C9EA:  MOVLB  A
0C9EC:  MOVLW  C0
0C9EE:  SUBWF  03,W
0C9F0:  BNZ   C9FE
0C9F2:  MOVLW  90
0C9F4:  SUBWF  00,W
0C9F6:  MOVLB  0
0C9F8:  BTFSC  FD8.2
0C9FA:  BRA    CE02
0C9FC:  MOVLB  A
0C9FE:  MOVLW  C0
0CA00:  SUBWF  03,W
0CA02:  BNZ   CA10
0CA04:  MOVLW  91
0CA06:  SUBWF  00,W
0CA08:  MOVLB  0
0CA0A:  BTFSC  FD8.2
0CA0C:  BRA    CE14
0CA0E:  MOVLB  A
0CA10:  MOVLW  C0
0CA12:  SUBWF  03,W
0CA14:  BNZ   CA22
0CA16:  MOVLW  92
0CA18:  SUBWF  00,W
0CA1A:  MOVLB  0
0CA1C:  BTFSC  FD8.2
0CA1E:  BRA    CE26
0CA20:  MOVLB  A
0CA22:  MOVLW  C0
0CA24:  SUBWF  03,W
0CA26:  BNZ   CA34
0CA28:  MOVLW  93
0CA2A:  SUBWF  00,W
0CA2C:  MOVLB  0
0CA2E:  BTFSC  FD8.2
0CA30:  BRA    CE38
0CA32:  MOVLB  A
0CA34:  MOVLW  C0
0CA36:  SUBWF  03,W
0CA38:  BNZ   CA46
0CA3A:  MOVLW  A1
0CA3C:  SUBWF  00,W
0CA3E:  MOVLB  0
0CA40:  BTFSC  FD8.2
0CA42:  BRA    CE4A
0CA44:  MOVLB  A
0CA46:  MOVLW  C0
0CA48:  SUBWF  03,W
0CA4A:  BNZ   CA58
0CA4C:  MOVLW  A2
0CA4E:  SUBWF  00,W
0CA50:  MOVLB  0
0CA52:  BTFSC  FD8.2
0CA54:  BRA    CE5C
0CA56:  MOVLB  A
0CA58:  MOVLW  C0
0CA5A:  SUBWF  03,W
0CA5C:  BNZ   CA6A
0CA5E:  MOVLW  A6
0CA60:  SUBWF  00,W
0CA62:  MOVLB  0
0CA64:  BTFSC  FD8.2
0CA66:  BRA    CE6E
0CA68:  MOVLB  A
0CA6A:  MOVLW  C0
0CA6C:  SUBWF  03,W
0CA6E:  BNZ   CA7C
0CA70:  MOVLW  A8
0CA72:  SUBWF  00,W
0CA74:  MOVLB  0
0CA76:  BTFSC  FD8.2
0CA78:  BRA    CE80
0CA7A:  MOVLB  A
0CA7C:  MOVLW  C0
0CA7E:  SUBWF  03,W
0CA80:  BNZ   CA8E
0CA82:  MOVLW  A9
0CA84:  SUBWF  00,W
0CA86:  MOVLB  0
0CA88:  BTFSC  FD8.2
0CA8A:  BRA    CE92
0CA8C:  MOVLB  A
0CA8E:  MOVLW  C0
0CA90:  SUBWF  03,W
0CA92:  BNZ   CAA0
0CA94:  MOVLW  AD
0CA96:  SUBWF  00,W
0CA98:  MOVLB  0
0CA9A:  BTFSC  FD8.2
0CA9C:  BRA    CEA4
0CA9E:  MOVLB  A
0CAA0:  MOVLW  C0
0CAA2:  SUBWF  03,W
0CAA4:  BNZ   CAB2
0CAA6:  MOVLW  AE
0CAA8:  SUBWF  00,W
0CAAA:  MOVLB  0
0CAAC:  BTFSC  FD8.2
0CAAE:  BRA    CEB6
0CAB0:  MOVLB  A
0CAB2:  MOVLW  C0
0CAB4:  SUBWF  03,W
0CAB6:  BNZ   CAC4
0CAB8:  MOVLW  AF
0CABA:  SUBWF  00,W
0CABC:  MOVLB  0
0CABE:  BTFSC  FD8.2
0CAC0:  BRA    CEC8
0CAC2:  MOVLB  A
0CAC4:  MOVLW  C0
0CAC6:  SUBWF  03,W
0CAC8:  BNZ   CAD6
0CACA:  MOVLW  CC
0CACC:  SUBWF  00,W
0CACE:  MOVLB  0
0CAD0:  BTFSC  FD8.2
0CAD2:  BRA    CEDA
0CAD4:  MOVLB  A
0CAD6:  MOVLW  C0
0CAD8:  SUBWF  03,W
0CADA:  BNZ   CAE8
0CADC:  MOVLW  CD
0CADE:  SUBWF  00,W
0CAE0:  MOVLB  0
0CAE2:  BTFSC  FD8.2
0CAE4:  BRA    CEEC
0CAE6:  MOVLB  A
0CAE8:  MOVLW  C0
0CAEA:  SUBWF  03,W
0CAEC:  BNZ   CAFA
0CAEE:  MOVLW  C5
0CAF0:  SUBWF  00,W
0CAF2:  MOVLB  0
0CAF4:  BTFSC  FD8.2
0CAF6:  BRA    CEFE
0CAF8:  MOVLB  A
0CAFA:  MOVLW  C0
0CAFC:  SUBWF  03,W
0CAFE:  BNZ   CB0C
0CB00:  MOVLW  D0
0CB02:  SUBWF  00,W
0CB04:  MOVLB  0
0CB06:  BTFSC  FD8.2
0CB08:  BRA    CF10
0CB0A:  MOVLB  A
0CB0C:  MOVLW  C0
0CB0E:  SUBWF  03,W
0CB10:  BNZ   CB1E
0CB12:  MOVLW  D1
0CB14:  SUBWF  00,W
0CB16:  MOVLB  0
0CB18:  BTFSC  FD8.2
0CB1A:  BRA    CF22
0CB1C:  MOVLB  A
0CB1E:  MOVLW  C0
0CB20:  SUBWF  03,W
0CB22:  BNZ   CB30
0CB24:  MOVLW  DA
0CB26:  SUBWF  00,W
0CB28:  MOVLB  0
0CB2A:  BTFSC  FD8.2
0CB2C:  BRA    CF34
0CB2E:  MOVLB  A
0CB30:  MOVLW  C0
0CB32:  SUBWF  03,W
0CB34:  BNZ   CB42
0CB36:  MOVLW  DB
0CB38:  SUBWF  00,W
0CB3A:  MOVLB  0
0CB3C:  BTFSC  FD8.2
0CB3E:  BRA    CF46
0CB40:  MOVLB  A
0CB42:  MOVLW  C0
0CB44:  SUBWF  03,W
0CB46:  BNZ   CB54
0CB48:  MOVLW  DD
0CB4A:  SUBWF  00,W
0CB4C:  MOVLB  0
0CB4E:  BTFSC  FD8.2
0CB50:  BRA    CF58
0CB52:  MOVLB  A
0CB54:  MOVLW  C0
0CB56:  SUBWF  03,W
0CB58:  BNZ   CB66
0CB5A:  MOVLW  DF
0CB5C:  SUBWF  00,W
0CB5E:  MOVLB  0
0CB60:  BTFSC  FD8.2
0CB62:  BRA    CF6A
0CB64:  MOVLB  A
0CB66:  MOVLW  C0
0CB68:  SUBWF  03,W
0CB6A:  BNZ   CB78
0CB6C:  MOVLW  E4
0CB6E:  SUBWF  00,W
0CB70:  MOVLB  0
0CB72:  BTFSC  FD8.2
0CB74:  BRA    CF7C
0CB76:  MOVLB  A
0CB78:  MOVLW  C0
0CB7A:  SUBWF  03,W
0CB7C:  BNZ   CB8A
0CB7E:  MOVLW  F5
0CB80:  SUBWF  00,W
0CB82:  MOVLB  0
0CB84:  BTFSC  FD8.2
0CB86:  BRA    CF8E
0CB88:  MOVLB  A
0CB8A:  MOVLW  C0
0CB8C:  SUBWF  03,W
0CB8E:  BNZ   CB9C
0CB90:  MOVLW  F6
0CB92:  SUBWF  00,W
0CB94:  MOVLB  0
0CB96:  BTFSC  FD8.2
0CB98:  BRA    CFA0
0CB9A:  MOVLB  A
0CB9C:  MOVLW  C0
0CB9E:  SUBWF  03,W
0CBA0:  BNZ   CBAE
0CBA2:  MOVLW  F7
0CBA4:  SUBWF  00,W
0CBA6:  MOVLB  0
0CBA8:  BTFSC  FD8.2
0CBAA:  BRA    CFB2
0CBAC:  MOVLB  A
0CBAE:  MOVLW  C0
0CBB0:  SUBWF  03,W
0CBB2:  BNZ   CBC0
0CBB4:  MOVLW  F8
0CBB6:  SUBWF  00,W
0CBB8:  MOVLB  0
0CBBA:  BTFSC  FD8.2
0CBBC:  BRA    CFC4
0CBBE:  MOVLB  A
0CBC0:  MOVLW  C0
0CBC2:  SUBWF  03,W
0CBC4:  BNZ   CBD2
0CBC6:  MOVLW  F9
0CBC8:  SUBWF  00,W
0CBCA:  MOVLB  0
0CBCC:  BTFSC  FD8.2
0CBCE:  BRA    CFD6
0CBD0:  MOVLB  A
0CBD2:  MOVLW  C0
0CBD4:  SUBWF  03,W
0CBD6:  BNZ   CBE4
0CBD8:  MOVLW  FC
0CBDA:  SUBWF  00,W
0CBDC:  MOVLB  0
0CBDE:  BTFSC  FD8.2
0CBE0:  BRA    CFE8
0CBE2:  MOVLB  A
0CBE4:  MOVLW  C0
0CBE6:  SUBWF  03,W
0CBE8:  BNZ   CBF6
0CBEA:  MOVLW  FE
0CBEC:  SUBWF  00,W
0CBEE:  MOVLB  0
0CBF0:  BTFSC  FD8.2
0CBF2:  BRA    CFFA
0CBF4:  MOVLB  A
0CBF6:  MOVLW  E0
0CBF8:  SUBWF  03,W
0CBFA:  BNZ   CC08
0CBFC:  MOVLW  33
0CBFE:  SUBWF  00,W
0CC00:  MOVLB  0
0CC02:  BTFSC  FD8.2
0CC04:  BRA    D00C
0CC06:  MOVLB  A
0CC08:  MOVLW  B0
0CC0A:  SUBWF  03,W
0CC0C:  BNZ   CC1A
0CC0E:  MOVLW  A0
0CC10:  SUBWF  00,W
0CC12:  MOVLB  0
0CC14:  BTFSC  FD8.2
0CC16:  BRA    D01E
0CC18:  MOVLB  A
0CC1A:  MOVLW  B0
0CC1C:  SUBWF  03,W
0CC1E:  BNZ   CC2C
0CC20:  MOVLW  A2
0CC22:  SUBWF  00,W
0CC24:  MOVLB  0
0CC26:  BTFSC  FD8.2
0CC28:  BRA    D030
0CC2A:  MOVLB  A
0CC2C:  MOVLW  B0
0CC2E:  SUBWF  03,W
0CC30:  BNZ   CC3E
0CC32:  MOVLW  70
0CC34:  SUBWF  00,W
0CC36:  MOVLB  0
0CC38:  BTFSC  FD8.2
0CC3A:  BRA    D042
0CC3C:  MOVLB  A
0CC3E:  MOVLW  DB
0CC40:  SUBWF  03,W
0CC42:  BNZ   CC50
0CC44:  MOVLW  FF
0CC46:  SUBWF  00,W
0CC48:  MOVLB  0
0CC4A:  BTFSC  FD8.2
0CC4C:  BRA    D054
0CC4E:  MOVLB  A
0CC50:  BRA    D066
....................         case 0xABAA: error = command_pcib_telemetry(data); break; 
0CC52:  MOVFF  9F4,A06
0CC56:  MOVFF  9F3,A05
0CC5A:  GOTO   4F46
0CC5E:  MOVFF  01,9F7
0CC62:  BRA    D078
....................         case 0xAD90: error = command_adcs_telemetry(data); break; 
0CC64:  MOVFF  9F4,A06
0CC68:  MOVFF  9F3,A05
0CC6C:  GOTO   4FB0
0CC70:  MOVFF  01,9F7
0CC74:  BRA    D078
....................         case 0xADDA: error = command_adcs_gps_time(data); break; 
0CC76:  MOVFF  9F4,A06
0CC7A:  MOVFF  9F3,A05
0CC7E:  GOTO   51C2
0CC82:  MOVFF  01,9F7
0CC86:  BRA    D078
....................         case 0xC000: error = command_print_memory_address(data); break; 
0CC88:  MOVFF  9F4,A06
0CC8C:  MOVFF  9F3,A05
0CC90:  GOTO   5408
0CC94:  MOVFF  01,9F7
0CC98:  BRA    D078
....................         case 0xC001: error = command_set_clock(data); break; 
0CC9A:  MOVFF  9F4,A06
0CC9E:  MOVFF  9F3,A05
0CCA2:  GOTO   54E2
0CCA6:  MOVFF  01,9F7
0CCAA:  BRA    D078
....................         case 0xC00A: error = command_copy_memory_page(data); break; 
0CCAC:  MOVFF  9F4,A06
0CCB0:  MOVFF  9F3,A05
0CCB4:  GOTO   59FE
0CCB8:  MOVFF  01,9F7
0CCBC:  BRA    D078
....................         case 0xC00B: error = command_copy_memory_sector(data); break; 
0CCBE:  MOVFF  9F4,A06
0CCC2:  MOVFF  9F3,A05
0CCC6:  GOTO   60B6
0CCCA:  MOVFF  01,9F7
0CCCE:  BRA    D078
....................         case 0xC00C: error = command_erase_memory_page(data); break; 
0CCD0:  MOVFF  9F4,A06
0CCD4:  MOVFF  9F3,A05
0CCD8:  GOTO   672A
0CCDC:  MOVFF  01,9F7
0CCE0:  BRA    D078
....................         case 0xC00D: error = command_erase_memory_sector(data); break; 
0CCE2:  MOVFF  9F4,A06
0CCE6:  MOVFF  9F3,A05
0CCEA:  GOTO   6934
0CCEE:  MOVFF  01,9F7
0CCF2:  BRA    D078
....................         // - 0xC010: reserved for COM 
....................         // - 0xC011: reserved for COM 
....................         // - 0xC013: reserved for COM 
....................         // - 0xC014: reserved for COM 
....................         // - 0xC015: reserved for COM 
....................         // - 0xC016: reserved for COM 
....................         // - 0xC017: reserved for COM 
....................         // - 0xC020: reserved for COM 
....................         // - 0xC021: reserved for COM 
....................         // - 0xC022: reserved for COM 
....................         // - 0xC023: reserved for COM 
....................         // - 0xC024: reserved for COM 
....................         case 0xC025: error = command_boot_cmd_clear_nth(data); break; 
0CCF4:  MOVFF  9F4,A06
0CCF8:  MOVFF  9F3,A05
0CCFC:  GOTO   6AFE
0CD00:  MOVFF  01,9F7
0CD04:  BRA    D078
....................         case 0xC026: error = command_boot_cmd_clear_all(data); break; 
0CD06:  MOVFF  9F4,A06
0CD0A:  MOVFF  9F3,A05
0CD0E:  GOTO   6B2A
0CD12:  MOVFF  01,9F7
0CD16:  BRA    D078
....................         // - 0xC027: reserved for COM 
....................         case 0xC028: error = command_boot_cmd_add(data); break; 
0CD18:  MOVFF  9F4,A06
0CD1C:  MOVFF  9F3,A05
0CD20:  GOTO   6BC4
0CD24:  MOVFF  01,9F7
0CD28:  BRA    D078
....................         // - 0xC030: reserved for COM 
....................         // - 0xC035: reserved for COM 
....................         // - 0xC040: reserved for COM 
....................         // - 0xC041: reserved for COM 
....................         case 0xC042: error = command_uhf_message(data); break; 
0CD2A:  MOVFF  9F4,A06
0CD2E:  MOVFF  9F3,A05
0CD32:  GOTO   6EAE
0CD36:  MOVFF  01,9F7
0CD3A:  BRA    D078
....................         // - 0xC044: reserved for COM 
....................         case 0xC050: error = command_com_cw(data); break; 
0CD3C:  MOVFF  9F4,A06
0CD40:  MOVFF  9F3,A05
0CD44:  GOTO   73C2
0CD48:  MOVFF  01,9F7
0CD4C:  BRA    D078
....................         case 0xC055: error = command_save_state(data); break; 
0CD4E:  MOVFF  9F4,A06
0CD52:  MOVFF  9F3,A05
0CD56:  GOTO   76A2
0CD5A:  MOVFF  01,9F7
0CD5E:  BRA    D078
....................         case 0xC058: error = command_com_access_change(data); break; 
0CD60:  MOVFF  9F4,A06
0CD64:  MOVFF  9F3,A05
0CD68:  GOTO   76C4
0CD6C:  MOVFF  01,9F7
0CD70:  BRA    D078
....................         case 0xC059: error = command_com_access_request(data); break; 
0CD72:  MOVFF  9F4,A06
0CD76:  MOVFF  9F3,A05
0CD7A:  GOTO   770C
0CD7E:  MOVFF  01,9F7
0CD82:  BRA    D078
....................         case 0xC060: error = command_obc_kill_on(data); break; 
0CD84:  MOVFF  9F4,A06
0CD88:  MOVFF  9F3,A05
0CD8C:  GOTO   7822
0CD90:  MOVFF  01,9F7
0CD94:  BRA    D078
....................         case 0xC061: error = command_obc_kill_off(data); break; 
0CD96:  MOVFF  9F4,A06
0CD9A:  MOVFF  9F3,A05
0CD9E:  GOTO   78C8
0CDA2:  MOVFF  01,9F7
0CDA6:  BRA    D078
....................         case 0xC06C: error = command_send_data_to_eps(data); break; 
0CDA8:  MOVFF  9F4,A06
0CDAC:  MOVFF  9F3,A05
0CDB0:  GOTO   78D4
0CDB4:  MOVFF  01,9F7
0CDB8:  BRA    D078
....................         case 0xC06D: error = command_eps_set_heater_ref(data); break; 
0CDBA:  MOVFF  9F4,A06
0CDBE:  MOVFF  9F3,A05
0CDC2:  GOTO   797A
0CDC6:  MOVFF  01,9F7
0CDCA:  BRA    D078
....................         case 0xC070: error = command_stm32_raw_8_16(data); break; 
0CDCC:  MOVFF  9F4,A06
0CDD0:  MOVFF  9F3,A05
0CDD4:  GOTO   7A3C
0CDD8:  MOVFF  01,9F7
0CDDC:  BRA    D078
....................         case 0xC071: error = command_stm32_raw_uhf32(data); break; 
0CDDE:  MOVFF  9F4,A06
0CDE2:  MOVFF  9F3,A05
0CDE6:  CALL   7AC8
0CDEA:  MOVFF  01,9F7
0CDEE:  BRA    D078
....................         case 0xC072: error = command_stm32_raw_uhf32(data); break; 
0CDF0:  MOVFF  9F4,A06
0CDF4:  MOVFF  9F3,A05
0CDF8:  CALL   7AC8
0CDFC:  MOVFF  01,9F7
0CE00:  BRA    D078
....................         case 0xC090: error = command_request_reset(data); break; 
0CE02:  MOVFF  9F4,A06
0CE06:  MOVFF  9F3,A05
0CE0A:  GOTO   7BA0
0CE0E:  MOVFF  01,9F7
0CE12:  BRA    D078
....................         case 0xC091: error = command_request_eps(data); break; 
0CE14:  MOVFF  9F4,A06
0CE18:  MOVFF  9F3,A05
0CE1C:  GOTO   7C3E
0CE20:  MOVFF  01,9F7
0CE24:  BRA    D078
....................         case 0xC092: error = command_request_pcib(data); break; 
0CE26:  MOVFF  9F4,A06
0CE2A:  MOVFF  9F3,A05
0CE2E:  GOTO   7D12
0CE32:  MOVFF  01,9F7
0CE36:  BRA    D078
....................         case 0xC093: error = command_request_adcs(data); break; 
0CE38:  MOVFF  9F4,A06
0CE3C:  MOVFF  9F3,A05
0CE40:  GOTO   7D9C
0CE44:  MOVFF  01,9F7
0CE48:  BRA    D078
....................         case 0xC0A1: error = command_stm32_raw_uhf32_tle(data); break; 
0CE4A:  MOVFF  9F4,A06
0CE4E:  MOVFF  9F3,A05
0CE52:  CALL   7ECE
0CE56:  MOVFF  01,9F7
0CE5A:  BRA    D078
....................         case 0xC0A2: error = command_stm32_raw_uhf32_tle(data); break; 
0CE5C:  MOVFF  9F4,A06
0CE60:  MOVFF  9F3,A05
0CE64:  CALL   7ECE
0CE68:  MOVFF  01,9F7
0CE6C:  BRA    D078
....................         case 0xC0A6: error = command_adcs_default_mode(data); break; 
0CE6E:  MOVFF  9F4,A06
0CE72:  MOVFF  9F3,A05
0CE76:  GOTO   7FA8
0CE7A:  MOVFF  01,9F7
0CE7E:  BRA    D078
....................         case 0xC0A8: error = command_adcs_gps_copy(data); break; 
0CE80:  MOVFF  9F4,A06
0CE84:  MOVFF  9F3,A05
0CE88:  GOTO   80F2
0CE8C:  MOVFF  01,9F7
0CE90:  BRA    D078
....................         case 0xC0A9: error = command_adcs_hs_copy(data); break; 
0CE92:  MOVFF  9F4,A06
0CE96:  MOVFF  9F3,A05
0CE9A:  GOTO   879C
0CE9E:  MOVFF  01,9F7
0CEA2:  BRA    D078
....................         case 0xC0AD: error = command_adcs_mode(data); break; 
0CEA4:  MOVFF  9F4,A06
0CEA8:  MOVFF  9F3,A05
0CEAC:  GOTO   8A72
0CEB0:  MOVFF  01,9F7
0CEB4:  BRA    D078
....................         case 0xC0AE: error = command_ocp_state(data); break; 
0CEB6:  MOVFF  9F4,A06
0CEBA:  MOVFF  9F3,A05
0CEBE:  GOTO   8AE0
0CEC2:  MOVFF  01,9F7
0CEC6:  BRA    D078
....................         case 0xC0AF: error = command_adcs_raw(data); break; 
0CEC8:  MOVFF  9F4,A06
0CECC:  MOVFF  9F3,A05
0CED0:  GOTO   8B72
0CED4:  MOVFF  01,9F7
0CED8:  BRA    D078
....................         case 0xC0CC: error = command_raw_pcib(data); break; 
0CEDA:  MOVFF  9F4,A06
0CEDE:  MOVFF  9F3,A05
0CEE2:  GOTO   8D08
0CEE6:  MOVFF  01,9F7
0CEEA:  BRA    D078
....................         case 0xC0CD: error = command_change_cw_mode_flags(data); break; 
0CEEC:  MOVFF  9F4,A06
0CEF0:  MOVFF  9F3,A05
0CEF4:  GOTO   8DE2
0CEF8:  MOVFF  01,9F7
0CEFC:  BRA    D078
....................         case 0xC0C5: error = command_clear_state(data); break; 
0CEFE:  MOVFF  9F4,A06
0CF02:  MOVFF  9F3,A05
0CF06:  GOTO   8E16
0CF0A:  MOVFF  01,9F7
0CF0E:  BRA    D078
....................         case 0xC0D0: error = command_xmodem_send(data); break; 
0CF10:  MOVFF  9F4,A06
0CF14:  MOVFF  9F3,A05
0CF18:  GOTO   91CE
0CF1C:  MOVFF  01,9F7
0CF20:  BRA    D078
....................         case 0xC0D1: error = command_xmodem_receive(data); break; 
0CF22:  MOVFF  9F4,A06
0CF26:  MOVFF  9F3,A05
0CF2A:  GOTO   9948
0CF2E:  MOVFF  01,9F7
0CF32:  BRA    D078
....................         case 0xC0DA: error = command_deploy_antenna(data); break; 
0CF34:  MOVFF  9F4,A06
0CF38:  MOVFF  9F3,A05
0CF3C:  GOTO   9BE2
0CF40:  MOVFF  01,9F7
0CF44:  BRA    D078
....................         case 0xC0DB: error = command_debug(data); break; 
0CF46:  MOVFF  9F4,A06
0CF4A:  MOVFF  9F3,A05
0CF4E:  GOTO   9FA2
0CF52:  MOVFF  01,9F7
0CF56:  BRA    D078
....................         case 0xC0DD: error = command_dump_memory(data); break; 
0CF58:  MOVFF  9F4,A06
0CF5C:  MOVFF  9F3,A05
0CF60:  GOTO   A17C
0CF64:  MOVFF  01,9F7
0CF68:  BRA    D078
....................         case 0xC0DF: error = command_get_tris(data); break; 
0CF6A:  MOVFF  9F4,A06
0CF6E:  MOVFF  9F3,A05
0CF72:  CALL   A45E
0CF76:  MOVFF  01,9F7
0CF7A:  BRA    D078
....................         case 0xC0E4: error = command_copy_adcs_data_to_uhf(data); break; 
0CF7C:  MOVFF  9F4,A06
0CF80:  MOVFF  9F3,A05
0CF84:  GOTO   A554
0CF88:  MOVFF  01,9F7
0CF8C:  BRA    D078
....................         case 0xC0F5: error = command_send_data_to_reset(data); break; 
0CF8E:  MOVFF  9F4,A06
0CF92:  MOVFF  9F3,A05
0CF96:  GOTO   A89A
0CF9A:  MOVFF  01,9F7
0CF9E:  BRA    D078
....................         case 0xC0F6: error = command_schedule_anything(data); break; 
0CFA0:  MOVFF  9F4,A06
0CFA4:  MOVFF  9F3,A05
0CFA8:  GOTO   A982
0CFAC:  MOVFF  01,9F7
0CFB0:  BRA    D078
....................         case 0xC0F7: error = command_schedule_mode(data); break; 
0CFB2:  MOVFF  9F4,A06
0CFB6:  MOVFF  9F3,A05
0CFBA:  GOTO   A9CE
0CFBE:  MOVFF  01,9F7
0CFC2:  BRA    D078
....................         case 0xC0F8: error = command_save_telemetry(data); break; 
0CFC4:  MOVFF  9F4,A06
0CFC8:  MOVFF  9F3,A05
0CFCC:  GOTO   B072
0CFD0:  MOVFF  01,9F7
0CFD4:  BRA    D078
....................         case 0xC0F9: error = command_clear_all_schedule_commands(data); break; 
0CFD6:  MOVFF  9F4,A06
0CFDA:  MOVFF  9F3,A05
0CFDE:  GOTO   B3D8
0CFE2:  MOVFF  01,9F7
0CFE6:  BRA    D078
....................         // - 0xC0FA: reserved for COM 
....................         // - 0xC0FB: reserved for COM 
....................         case 0xC0FC: error = command_print_flags(data); break; 
0CFE8:  MOVFF  9F4,A06
0CFEC:  MOVFF  9F3,A05
0CFF0:  GOTO   B3E2
0CFF4:  MOVFF  01,9F7
0CFF8:  BRA    D078
....................         case 0xC0FE: error = command_boot_flag_set(data); break; 
0CFFA:  MOVFF  9F4,A06
0CFFE:  MOVFF  9F3,A05
0D002:  GOTO   B3EE
0D006:  MOVFF  01,9F7
0D00A:  BRA    D078
....................         case 0xE033: error = command_eps_telemetry(data); break; 
0D00C:  MOVFF  9F4,A06
0D010:  MOVFF  9F3,A05
0D014:  GOTO   B7BA
0D018:  MOVFF  01,9F7
0D01C:  BRA    D078
....................         case 0xB0A0: error = command_reset_telemetry(data); break; 
0D01E:  MOVFF  9F4,A06
0D022:  MOVFF  9F3,A05
0D026:  GOTO   BEEA
0D02A:  MOVFF  01,9F7
0D02E:  BRA    D078
....................         case 0xB0A2: error = command_reset_warning(data); break; 
0D030:  MOVFF  9F4,A06
0D034:  MOVFF  9F3,A05
0D038:  GOTO   C3FA
0D03C:  MOVFF  01,9F7
0D040:  BRA    D078
....................         case 0xB070: error = command_time_change_ack(data); break; 
0D042:  MOVFF  9F4,A06
0D046:  MOVFF  9F3,A05
0D04A:  GOTO   C4F8
0D04E:  MOVFF  01,9F7
0D052:  BRA    D078
....................         case 0xDBFF: error = command_reset_log(data); break; 
0D054:  MOVFF  9F4,A06
0D058:  MOVFF  9F3,A05
0D05C:  GOTO   C510
0D060:  MOVFF  01,9F7
0D064:  BRA    D078
....................         default: error = command_get_tris(data); break; 
0D066:  MOVFF  9F4,A06
0D06A:  MOVFF  9F3,A05
0D06E:  MOVLB  0
0D070:  CALL   A45E
0D074:  MOVFF  01,9F7
....................         } 
....................  
....................         if (log_enabled) { 
0D078:  MOVLB  9
0D07A:  MOVF   xF6,F
0D07C:  BZ    D0B4
....................             fprintf(PC, " (Ret: %02X)", error); 
0D07E:  MOVLW  32
0D080:  MOVWF  FF6
0D082:  MOVLW  0A
0D084:  MOVWF  FF7
0D086:  MOVLW  00
0D088:  MOVWF  FF8
0D08A:  MOVLW  07
0D08C:  MOVLB  A
0D08E:  MOVWF  x3B
0D090:  MOVLB  0
0D092:  CALL   3048
0D096:  MOVFF  9F7,A58
0D09A:  MOVLW  37
0D09C:  MOVLB  A
0D09E:  MOVWF  x59
0D0A0:  MOVLB  0
0D0A2:  CALL   3142
0D0A6:  MOVLW  29
0D0A8:  MOVLB  B
0D0AA:  MOVWF  x1F
0D0AC:  MOVLB  0
0D0AE:  CALL   1C34
0D0B2:  MOVLB  9
....................         } 
....................  
....................         // Satellite log 
....................         log.time = current_time; 
0D0B4:  MOVFF  3C,9FD
0D0B8:  MOVFF  3B,9FC
0D0BC:  MOVFF  3A,9FB
0D0C0:  MOVFF  39,9FA
....................         log.return_value = error; 
0D0C4:  MOVFF  9F7,A00
....................  
....................         if (log_enabled && command != 0xB0A0 && command != 0xE033 && command != 0xABAA && command != 0xAD90 && command != 0xC050 && command != 0xC0F8) 
0D0C8:  MOVF   xF6,F
0D0CA:  BZ    D15E
0D0CC:  MOVLB  A
0D0CE:  MOVF   x03,W
0D0D0:  SUBLW  A0
0D0D2:  BNZ   D0E0
0D0D4:  MOVF   x04,W
0D0D6:  SUBLW  B0
0D0D8:  BTFSS  FD8.2
0D0DA:  BRA    D0E0
0D0DC:  MOVLB  9
0D0DE:  BRA    D15E
0D0E0:  MOVF   x03,W
0D0E2:  SUBLW  33
0D0E4:  BNZ   D0F2
0D0E6:  MOVF   x04,W
0D0E8:  SUBLW  E0
0D0EA:  BTFSS  FD8.2
0D0EC:  BRA    D0F2
0D0EE:  MOVLB  9
0D0F0:  BRA    D15E
0D0F2:  MOVF   x03,W
0D0F4:  SUBLW  AA
0D0F6:  BNZ   D104
0D0F8:  MOVF   x04,W
0D0FA:  SUBLW  AB
0D0FC:  BTFSS  FD8.2
0D0FE:  BRA    D104
0D100:  MOVLB  9
0D102:  BRA    D15E
0D104:  MOVF   x03,W
0D106:  SUBLW  90
0D108:  BNZ   D116
0D10A:  MOVF   x04,W
0D10C:  SUBLW  AD
0D10E:  BTFSS  FD8.2
0D110:  BRA    D116
0D112:  MOVLB  9
0D114:  BRA    D15E
0D116:  MOVF   x03,W
0D118:  SUBLW  50
0D11A:  BNZ   D128
0D11C:  MOVF   x04,W
0D11E:  SUBLW  C0
0D120:  BTFSS  FD8.2
0D122:  BRA    D128
0D124:  MOVLB  9
0D126:  BRA    D15E
0D128:  MOVF   x03,W
0D12A:  SUBLW  F8
0D12C:  BNZ   D13A
0D12E:  MOVF   x04,W
0D130:  SUBLW  C0
0D132:  BTFSS  FD8.2
0D134:  BRA    D13A
0D136:  MOVLB  9
0D138:  BRA    D15E
....................             log_add(log); 
0D13A:  MOVFF  9FA,A05
0D13E:  MOVFF  9FB,A06
0D142:  MOVFF  9FC,A07
0D146:  MOVFF  9FD,A08
0D14A:  MOVFF  9FE,A09
0D14E:  MOVFF  9FF,A0A
0D152:  MOVFF  A00,A0B
0D156:  MOVLB  0
0D158:  GOTO   C528
0D15C:  MOVLB  9
....................  
....................         if (log_enabled) 
0D15E:  MOVF   xF6,F
0D160:  BZ    D17C
....................             fprintf(PC, "\r\n"); 
0D162:  MOVLW  0D
0D164:  MOVLB  B
0D166:  MOVWF  x1F
0D168:  MOVLB  0
0D16A:  CALL   1C34
0D16E:  MOVLW  0A
0D170:  MOVLB  B
0D172:  MOVWF  x1F
0D174:  MOVLB  0
0D176:  CALL   1C34
0D17A:  MOVLB  9
....................     } 
0D17C:  MOVLB  0
0D17E:  RETURN 0
.................... } 
....................  
.................... #endif /* INTERPRETER_H */ 
....................  
....................  
.................... void initialize_memory() 
*
03F44:  MOVLB  9
03F46:  CLRF   xD4
03F48:  MOVLW  ED
03F4A:  MOVFF  9D4,9C6
03F4E:  MOVWF  xC5
03F50:  CLRF   xD6
03F52:  MOVLW  EE
03F54:  MOVFF  9D6,9C8
03F58:  MOVWF  xC7
.................... { 
....................     uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
....................  
....................     boot_flags.deployment_flag = 0; 
03F5A:  MOVLB  0
03F5C:  CLRF   xED
....................     flash_initialize_flash_ctrl(FLASH_ADDR_START, FLASH_ADDR_END, FLASH_ADDR_START, FLASH_ADDR_DELTA, &addr_flags.flash_addr); 
03F5E:  MOVLB  A
03F60:  CLRF   x3C
03F62:  CLRF   x3B
03F64:  MOVLW  20
03F66:  MOVWF  x3A
03F68:  CLRF   x39
03F6A:  CLRF   x40
03F6C:  CLRF   x3F
03F6E:  MOVLW  30
03F70:  MOVWF  x3E
03F72:  CLRF   x3D
03F74:  CLRF   x44
03F76:  CLRF   x43
03F78:  MOVLW  20
03F7A:  MOVWF  x42
03F7C:  CLRF   x41
03F7E:  CLRF   x48
03F80:  CLRF   x47
03F82:  CLRF   x46
03F84:  MOVLW  08
03F86:  MOVWF  x45
03F88:  CLRF   x4A
03F8A:  MOVLW  F8
03F8C:  MOVWF  x49
03F8E:  MOVLB  0
03F90:  CALL   2F64
....................     flash_initialize_flash_ctrl(FLASH_LOG_START, FLASH_LOG_END, FLASH_LOG_START, FLASH_LOG_DELTA, &addr_flags.flash_log); 
03F94:  MOVLB  A
03F96:  CLRF   x3C
03F98:  MOVLW  01
03F9A:  MOVWF  x3B
03F9C:  CLRF   x3A
03F9E:  CLRF   x39
03FA0:  CLRF   x40
03FA2:  MOVLW  11
03FA4:  MOVWF  x3F
03FA6:  CLRF   x3E
03FA8:  CLRF   x3D
03FAA:  CLRF   x44
03FAC:  MOVLW  01
03FAE:  MOVWF  x43
03FB0:  CLRF   x42
03FB2:  CLRF   x41
03FB4:  CLRF   x48
03FB6:  CLRF   x47
03FB8:  CLRF   x46
03FBA:  MOVLW  07
03FBC:  MOVWF  x45
03FBE:  MOVLW  01
03FC0:  MOVWF  x4A
03FC2:  MOVLW  05
03FC4:  MOVWF  x49
03FC6:  MOVLB  0
03FC8:  CALL   2F64
....................     // flash_initialize_flash_ctrl(FLASH_TELEMETRY_START, FLASH_TELEMETRY_END, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, &addr_flags.flash_telemetry); 
....................     flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, 0xFFFFFFFF, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, false, &addr_flags.flash_telemetry); 
03FCC:  MOVLW  02
03FCE:  MOVLB  A
03FD0:  MOVWF  x1C
03FD2:  MOVFF  ED,A1D
03FD6:  SETF   x21
03FD8:  SETF   x20
03FDA:  SETF   x1F
03FDC:  SETF   x1E
03FDE:  CLRF   x25
03FE0:  MOVLW  11
03FE2:  MOVWF  x24
03FE4:  CLRF   x23
03FE6:  CLRF   x22
03FE8:  CLRF   x29
03FEA:  CLRF   x28
03FEC:  CLRF   x27
03FEE:  MOVLW  8C
03FF0:  MOVWF  x26
03FF2:  CLRF   x2A
03FF4:  MOVLW  01
03FF6:  MOVWF  x2C
03FF8:  MOVLW  12
03FFA:  MOVWF  x2B
03FFC:  MOVLB  0
03FFE:  CALL   3214
....................  
....................     // Save boot flags 
....................     flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
04002:  MOVLW  09
04004:  MOVLB  A
04006:  MOVWF  x33
04008:  MOVLW  1B
0400A:  MOVWF  x32
0400C:  CLRF   x37
0400E:  CLRF   x36
04010:  CLRF   x35
04012:  CLRF   x34
04014:  CLRF   x3B
04016:  CLRF   x3A
04018:  CLRF   x39
0401A:  MOVLW  01
0401C:  MOVWF  x38
0401E:  MOVLB  0
04020:  RCALL  3968
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
04022:  MOVLW  09
04024:  MOVLB  A
04026:  MOVWF  xD0
04028:  MOVLW  1B
0402A:  MOVWF  xCF
0402C:  CLRF   xD4
0402E:  CLRF   xD3
04030:  CLRF   xD2
04032:  CLRF   xD1
04034:  MOVFF  9C6,AD6
04038:  MOVFF  9C5,AD5
0403C:  CLRF   xDA
0403E:  CLRF   xD9
04040:  CLRF   xD8
04042:  MOVLW  01
04044:  MOVWF  xD7
04046:  MOVLB  0
04048:  RCALL  3C1A
....................  
....................     // Save OBC flags 
....................     flash_erase_pages(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, OBC_FLAGS_ADDRESS + sizeof(obc_flags)); 
0404A:  MOVLW  09
0404C:  MOVLB  A
0404E:  MOVWF  x33
04050:  MOVLW  1B
04052:  MOVWF  x32
04054:  CLRF   x37
04056:  CLRF   x36
04058:  MOVLW  10
0405A:  MOVWF  x35
0405C:  CLRF   x34
0405E:  CLRF   x3B
04060:  CLRF   x3A
04062:  MOVWF  x39
04064:  MOVLW  0A
04066:  MOVWF  x38
04068:  MOVLB  0
0406A:  RCALL  3968
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, obc_flag_ptr, sizeof(obc_flags)); 
0406C:  MOVLW  09
0406E:  MOVLB  A
04070:  MOVWF  xD0
04072:  MOVLW  1B
04074:  MOVWF  xCF
04076:  CLRF   xD4
04078:  CLRF   xD3
0407A:  MOVLW  10
0407C:  MOVWF  xD2
0407E:  CLRF   xD1
04080:  MOVFF  9C8,AD6
04084:  MOVFF  9C7,AD5
04088:  CLRF   xDA
0408A:  CLRF   xD9
0408C:  CLRF   xD8
0408E:  MOVLW  0A
04090:  MOVWF  xD7
04092:  MOVLB  0
04094:  RCALL  3C1A
....................  
....................     // Initialize boot commands 
....................     boot_commands_clear_all(); 
04096:  RCALL  3CC2
....................     boot_commands_write(); 
04098:  RCALL  3CDE
....................  
....................     // Save addresses 
....................     struct addr { 
....................         uint32_t flash_log_current; 
....................         uint32_t flash_telemetry_current; 
....................     } addr; 
....................  
....................     uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
0409A:  MOVLW  09
0409C:  MOVLB  9
0409E:  MOVWF  xD4
040A0:  MOVLW  C9
040A2:  MOVFF  9D4,9D2
040A6:  MOVWF  xD1
....................     addr.flash_log_current = addr_flags.flash_log.current; 
040A8:  MOVFF  110,9CC
040AC:  MOVFF  10F,9CB
040B0:  MOVFF  10E,9CA
040B4:  MOVFF  10D,9C9
....................     addr.flash_telemetry_current = addr_flags.flash_telemetry.current; 
040B8:  MOVFF  11D,9D0
040BC:  MOVFF  11C,9CF
040C0:  MOVFF  11B,9CE
040C4:  MOVFF  11A,9CD
....................     flash_erase_pages(&spi_port_COM_FM, ADDR_FLAGS_ADDRESS, ADDR_FLAGS_ADDRESS + sizeof(addr)); 
040C8:  MOVLW  09
040CA:  MOVLB  A
040CC:  MOVWF  x33
040CE:  MOVLW  1B
040D0:  MOVWF  x32
040D2:  CLRF   x37
040D4:  CLRF   x36
040D6:  MOVLW  20
040D8:  MOVWF  x35
040DA:  CLRF   x34
040DC:  CLRF   x3B
040DE:  CLRF   x3A
040E0:  MOVWF  x39
040E2:  MOVLW  08
040E4:  MOVWF  x38
040E6:  MOVLB  0
040E8:  RCALL  3968
....................     flash_cycle_write(&spi_port_COM_FM, addr_flag_ptr, &addr_flags.flash_addr); 
040EA:  MOVLW  09
040EC:  MOVLB  A
040EE:  MOVWF  x17
040F0:  MOVLW  1B
040F2:  MOVWF  x16
040F4:  MOVFF  9D2,A19
040F8:  MOVFF  9D1,A18
040FC:  CLRF   x1B
040FE:  MOVLW  F8
04100:  MOVWF  x1A
04102:  MOVLB  0
04104:  RCALL  3D34
04106:  GOTO   493A (RETURN)
.................... } 
....................  
.................... void retrieve_memory() 
*
043F4:  MOVLB  9
043F6:  CLRF   xD6
043F8:  MOVLW  EE
043FA:  MOVFF  9D6,9C6
043FE:  MOVWF  xC5
.................... { 
....................     // Load OBC flags 
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
....................     flash_transfer_data_to_ram( 
....................         &spi_port_COM_FM, 
....................         OBC_FLAGS_ADDRESS, 
....................         obc_flag_ptr, 
....................         sizeof(obc_flags)); 
04400:  MOVLW  09
04402:  MOVLB  B
04404:  MOVWF  x01
04406:  MOVLW  1B
04408:  MOVWF  x00
0440A:  CLRF   x05
0440C:  CLRF   x04
0440E:  MOVLW  10
04410:  MOVWF  x03
04412:  CLRF   x02
04414:  MOVFF  9C6,B07
04418:  MOVFF  9C5,B06
0441C:  CLRF   x0B
0441E:  CLRF   x0A
04420:  CLRF   x09
04422:  MOVLW  0A
04424:  MOVWF  x08
04426:  MOVLB  0
04428:  CALL   2E46
....................  
....................     // Load addresses of addresses 
....................     flash_initialize_flash_ctrl(FLASH_ADDR_START, FLASH_ADDR_END, FLASH_ADDR_START, FLASH_ADDR_DELTA, &addr_flags.flash_addr); 
0442C:  MOVLB  A
0442E:  CLRF   x3C
04430:  CLRF   x3B
04432:  MOVLW  20
04434:  MOVWF  x3A
04436:  CLRF   x39
04438:  CLRF   x40
0443A:  CLRF   x3F
0443C:  MOVLW  30
0443E:  MOVWF  x3E
04440:  CLRF   x3D
04442:  CLRF   x44
04444:  CLRF   x43
04446:  MOVLW  20
04448:  MOVWF  x42
0444A:  CLRF   x41
0444C:  CLRF   x48
0444E:  CLRF   x47
04450:  CLRF   x46
04452:  MOVLW  08
04454:  MOVWF  x45
04456:  CLRF   x4A
04458:  MOVLW  F8
0445A:  MOVWF  x49
0445C:  MOVLB  0
0445E:  CALL   2F64
....................     flash_recover_last_addr(&spi_port_COM_FM, &addr_flags.flash_addr); 
04462:  MOVLW  09
04464:  MOVLB  9
04466:  MOVWF  xD6
04468:  MOVLW  1B
0446A:  MOVWF  xD5
0446C:  CLRF   xD8
0446E:  MOVLW  F8
04470:  MOVWF  xD7
04472:  MOVLB  0
04474:  BRA    410A
....................     unsigned long long address_address; 
....................     if (addr_flags.flash_addr.current >= addr_flags.flash_addr.start + addr_flags.flash_addr.delta) { 
04476:  MOVLB  1
04478:  MOVF   x04,W
0447A:  MOVLB  0
0447C:  ADDWF  xF8,W
0447E:  MOVWF  00
04480:  MOVLW  00
04482:  ADDWFC xF9,W
04484:  MOVWF  01
04486:  MOVLW  00
04488:  ADDWFC xFA,W
0448A:  MOVWF  02
0448C:  MOVLW  00
0448E:  ADDWFC xFB,W
04490:  MOVWF  03
04492:  MOVLB  1
04494:  SUBWF  x03,W
04496:  BNC   44DA
04498:  BNZ   44B0
0449A:  MOVF   02,W
0449C:  SUBWF  x02,W
0449E:  BNC   44DA
044A0:  BNZ   44B0
044A2:  MOVF   01,W
044A4:  SUBWF  x01,W
044A6:  BNC   44DA
044A8:  BNZ   44B0
044AA:  MOVF   00,W
044AC:  SUBWF  x00,W
044AE:  BNC   44DA
....................         address_address = addr_flags.flash_addr.current - addr_flags.flash_addr.delta; 
044B0:  MOVF   x04,W
044B2:  SUBWF  x00,W
044B4:  MOVLB  9
044B6:  MOVWF  xC7
044B8:  MOVLW  00
044BA:  MOVLB  1
044BC:  SUBWFB x01,W
044BE:  MOVLB  9
044C0:  MOVWF  xC8
044C2:  MOVLW  00
044C4:  MOVLB  1
044C6:  SUBWFB x02,W
044C8:  MOVLB  9
044CA:  MOVWF  xC9
044CC:  MOVLW  00
044CE:  MOVLB  1
044D0:  SUBWFB x03,W
044D2:  MOVLB  9
044D4:  MOVWF  xCA
....................     } else { 
044D6:  BRA    4502
044D8:  MOVLB  1
....................         address_address = addr_flags.flash_addr.end - addr_flags.flash_addr.delta; 
044DA:  MOVF   x04,W
044DC:  MOVLB  0
044DE:  SUBWF  xFC,W
044E0:  MOVLB  9
044E2:  MOVWF  xC7
044E4:  MOVLW  00
044E6:  MOVLB  0
044E8:  SUBWFB xFD,W
044EA:  MOVLB  9
044EC:  MOVWF  xC8
044EE:  MOVLW  00
044F0:  MOVLB  0
044F2:  SUBWFB xFE,W
044F4:  MOVLB  9
044F6:  MOVWF  xC9
044F8:  MOVLW  00
044FA:  MOVLB  0
044FC:  SUBWFB xFF,W
044FE:  MOVLB  9
04500:  MOVWF  xCA
....................     } 
....................  
....................     // Load addresses 
....................     struct addr { 
....................         uint32_t flash_log_current; 
....................         uint32_t flash_telemetry_current; 
....................     } addr; 
....................     uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
04502:  MOVLW  09
04504:  MOVWF  xD6
04506:  MOVLW  CB
04508:  MOVFF  9D6,9D4
0450C:  MOVWF  xD3
....................     flash_transfer_data_to_ram( 
....................         &spi_port_COM_FM, 
....................         address_address, 
....................         addr_flag_ptr, 
....................         sizeof(addr)); 
0450E:  MOVLW  09
04510:  MOVLB  B
04512:  MOVWF  x01
04514:  MOVLW  1B
04516:  MOVWF  x00
04518:  MOVFF  9CA,B05
0451C:  MOVFF  9C9,B04
04520:  MOVFF  9C8,B03
04524:  MOVFF  9C7,B02
04528:  MOVFF  9D4,B07
0452C:  MOVFF  9D3,B06
04530:  CLRF   x0B
04532:  CLRF   x0A
04534:  CLRF   x09
04536:  MOVLW  08
04538:  MOVWF  x08
0453A:  MOVLB  0
0453C:  CALL   2E46
....................     flash_initialize_flash_ctrl(FLASH_LOG_START, FLASH_LOG_END, addr.flash_log_current, FLASH_LOG_DELTA, &addr_flags.flash_log); 
04540:  MOVLB  A
04542:  CLRF   x3C
04544:  MOVLW  01
04546:  MOVWF  x3B
04548:  CLRF   x3A
0454A:  CLRF   x39
0454C:  CLRF   x40
0454E:  MOVLW  11
04550:  MOVWF  x3F
04552:  CLRF   x3E
04554:  CLRF   x3D
04556:  MOVFF  9CE,A44
0455A:  MOVFF  9CD,A43
0455E:  MOVFF  9CC,A42
04562:  MOVFF  9CB,A41
04566:  CLRF   x48
04568:  CLRF   x47
0456A:  CLRF   x46
0456C:  MOVLW  07
0456E:  MOVWF  x45
04570:  MOVLW  01
04572:  MOVWF  x4A
04574:  MOVLW  05
04576:  MOVWF  x49
04578:  MOVLB  0
0457A:  CALL   2F64
....................     // flash_initialize_flash_ctrl(FLASH_TELEMETRY_START, FLASH_TELEMETRY_END, addr.flash_telemetry_current, FLASH_TELEMETRY_DELTA, &addr_flags.flash_telemetry); 
....................     flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr.flash_telemetry_current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, false, &addr_flags.flash_telemetry); 
0457E:  MOVLW  02
04580:  MOVLB  A
04582:  MOVWF  x1C
04584:  MOVFF  ED,A1D
04588:  MOVFF  9D2,A21
0458C:  MOVFF  9D1,A20
04590:  MOVFF  9D0,A1F
04594:  MOVFF  9CF,A1E
04598:  CLRF   x25
0459A:  MOVLW  11
0459C:  MOVWF  x24
0459E:  CLRF   x23
045A0:  CLRF   x22
045A2:  CLRF   x29
045A4:  CLRF   x28
045A6:  CLRF   x27
045A8:  MOVLW  8C
045AA:  MOVWF  x26
045AC:  CLRF   x2A
045AE:  MOVLW  01
045B0:  MOVWF  x2C
045B2:  MOVLW  12
045B4:  MOVWF  x2B
045B6:  MOVLB  0
045B8:  CALL   3214
....................     boot_commands_read(); 
045BC:  BRA    43B8
045BE:  GOTO   494E (RETURN)
.................... } 
....................  
.................... void initial_deployment_setup() 
*
046D8:  MOVLW  01
046DA:  MOVLB  9
046DC:  MOVWF  xCC
046DE:  MOVLW  1F
046E0:  MOVFF  9CC,9C6
046E4:  MOVWF  xC5
.................... { 
....................     uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
....................     // Antenna deployment schedule 
....................     scheduler_initialize(); 
046E6:  MOVLB  0
046E8:  RCALL  45C2
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, cmd_ptr, sizeof(scheduled_commands)); 
046EA:  MOVLW  09
046EC:  MOVLB  A
046EE:  MOVWF  xD0
046F0:  MOVLW  1B
046F2:  MOVWF  xCF
046F4:  CLRF   xD4
046F6:  CLRF   xD3
046F8:  MOVLW  30
046FA:  MOVWF  xD2
046FC:  CLRF   xD1
046FE:  MOVFF  9C6,AD6
04702:  MOVFF  9C5,AD5
04706:  CLRF   xDA
04708:  CLRF   xD9
0470A:  MOVLW  03
0470C:  MOVWF  xD8
0470E:  MOVLW  A0
04710:  MOVWF  xD7
04712:  MOVLB  0
04714:  CALL   3C1A
....................  
....................     current_time = T0 + (time_t)boot_flags.deployment_flag * 24L * 60L * 60L; // Set clock to as early as possible (Jan 1st 2000, 00:00:00), increasing every day by the deployment flag; 
04718:  MOVLB  9
0471A:  CLRF   xCE
0471C:  CLRF   xCD
0471E:  CLRF   xCC
04720:  MOVFF  ED,9CB
04724:  MOVFF  9CE,A5A
04728:  MOVFF  9CD,A59
0472C:  MOVFF  9CC,A58
04730:  MOVFF  ED,A57
04734:  MOVLB  A
04736:  CLRF   x5E
04738:  CLRF   x5D
0473A:  CLRF   x5C
0473C:  MOVLW  18
0473E:  MOVWF  x5B
04740:  MOVLB  0
04742:  CALL   1CB4
04746:  MOVFF  03,9CE
0474A:  MOVFF  02,9CD
0474E:  MOVFF  01,9CC
04752:  MOVFF  00,9CB
04756:  MOVFF  03,A5A
0475A:  MOVFF  02,A59
0475E:  MOVFF  01,A58
04762:  MOVFF  00,A57
04766:  MOVLB  A
04768:  CLRF   x5E
0476A:  CLRF   x5D
0476C:  CLRF   x5C
0476E:  MOVLW  3C
04770:  MOVWF  x5B
04772:  MOVLB  0
04774:  CALL   1CB4
04778:  MOVFF  03,9CE
0477C:  MOVFF  02,9CD
04780:  MOVFF  01,9CC
04784:  MOVFF  00,9CB
04788:  MOVFF  03,A5A
0478C:  MOVFF  02,A59
04790:  MOVFF  01,A58
04794:  MOVFF  00,A57
04798:  MOVLB  A
0479A:  CLRF   x5E
0479C:  CLRF   x5D
0479E:  CLRF   x5C
047A0:  MOVLW  3C
047A2:  MOVWF  x5B
047A4:  MOVLB  0
047A6:  CALL   1CB4
047AA:  MOVLW  80
047AC:  ADDWF  00,W
047AE:  MOVWF  39
047B0:  MOVLW  43
047B2:  ADDWFC 01,W
047B4:  MOVWF  3A
047B6:  MOVLW  6D
047B8:  ADDWFC 02,W
047BA:  MOVWF  3B
047BC:  MOVLW  38
047BE:  ADDWFC 03,W
047C0:  MOVWF  3C
....................     SetTimeSec(current_time); 
047C2:  MOVFF  3C,A1F
047C6:  MOVFF  3B,A1E
047CA:  MOVFF  3A,A1D
047CE:  MOVFF  39,A1C
047D2:  CALL   2886
....................     previous_time = current_time; 
047D6:  MOVFF  3C,40
047DA:  MOVFF  3B,3F
047DE:  MOVFF  3A,3E
047E2:  MOVFF  39,3D
....................  
....................     struct antenna_deployment_command { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t duration; 
....................     } cmd; 
....................  
....................     uint8_t factor = boot_flags.deployment_flag > 3 ? 3 : boot_flags.deployment_flag; 
047E6:  MOVF   xED,W
047E8:  SUBLW  03
047EA:  BC    47F0
047EC:  MOVLW  03
047EE:  BRA    47F2
047F0:  MOVF   xED,W
047F2:  MOVLB  9
047F4:  MOVWF  xCA
....................  
....................     cmd.origin = MSG_COMM; 
047F6:  MOVLW  C0
047F8:  MOVWF  xC7
....................     cmd.command = 0xDA; 
047FA:  MOVLW  DA
047FC:  MOVWF  xC8
....................     cmd.duration = 30 + 10 * factor; 
047FE:  MOVF   xCA,W
04800:  MULLW  0A
04802:  MOVF   FF3,W
04804:  ADDLW  1E
04806:  MOVWF  xC9
....................  
....................     vschedule(T_ANTENNA + (time_t)boot_flags.deployment_flag * 24L * 60L * 60L, (uint8_t*)&cmd); // Antenna deploy command (Jan 1st 2000, 00:30:30), 30s. 
04808:  CLRF   xCE
0480A:  CLRF   xCD
0480C:  CLRF   xCC
0480E:  MOVFF  ED,9CB
04812:  MOVFF  9CE,A5A
04816:  MOVFF  9CD,A59
0481A:  MOVFF  9CC,A58
0481E:  MOVFF  ED,A57
04822:  MOVLB  A
04824:  CLRF   x5E
04826:  CLRF   x5D
04828:  CLRF   x5C
0482A:  MOVLW  18
0482C:  MOVWF  x5B
0482E:  MOVLB  0
04830:  CALL   1CB4
04834:  MOVFF  03,9CE
04838:  MOVFF  02,9CD
0483C:  MOVFF  01,9CC
04840:  MOVFF  00,9CB
04844:  MOVFF  03,A5A
04848:  MOVFF  02,A59
0484C:  MOVFF  01,A58
04850:  MOVFF  00,A57
04854:  MOVLB  A
04856:  CLRF   x5E
04858:  CLRF   x5D
0485A:  CLRF   x5C
0485C:  MOVLW  3C
0485E:  MOVWF  x5B
04860:  MOVLB  0
04862:  CALL   1CB4
04866:  MOVFF  03,9CE
0486A:  MOVFF  02,9CD
0486E:  MOVFF  01,9CC
04872:  MOVFF  00,9CB
04876:  MOVFF  03,A5A
0487A:  MOVFF  02,A59
0487E:  MOVFF  01,A58
04882:  MOVFF  00,A57
04886:  MOVLB  A
04888:  CLRF   x5E
0488A:  CLRF   x5D
0488C:  CLRF   x5C
0488E:  MOVLW  3C
04890:  MOVWF  x5B
04892:  MOVLB  0
04894:  CALL   1CB4
04898:  MOVLW  A6
0489A:  ADDWF  00,W
0489C:  MOVLB  9
0489E:  MOVWF  xCB
048A0:  MOVLW  4A
048A2:  ADDWFC 01,W
048A4:  MOVWF  xCC
048A6:  MOVLW  6D
048A8:  ADDWFC 02,W
048AA:  MOVWF  xCD
048AC:  MOVLW  38
048AE:  ADDWFC 03,W
048B0:  MOVWF  xCE
048B2:  MOVLW  09
048B4:  MOVWF  xD0
048B6:  MOVLW  C7
048B8:  MOVWF  xCF
048BA:  MOVFF  9CE,A2E
048BE:  MOVFF  9CD,A2D
048C2:  MOVFF  9CC,A2C
048C6:  MOVFF  9CB,A2B
048CA:  MOVFF  9D0,A30
048CE:  MOVFF  FE8,A2F
048D2:  MOVLB  0
048D4:  RCALL  4600
048D6:  GOTO   4956 (RETURN)
.................... } 
....................  
.................... void nominal_setup() 
.................... { 
....................     // Normal boot. 
....................     rst_clock_update = 1;   // Update clock with reset pic 
048DA:  MOVLW  01
048DC:  MOVLB  6
048DE:  MOVWF  x88
....................     scheduler_initialize(); // Needed if not loading from FM 
048E0:  MOVLB  0
048E2:  RCALL  45C2
048E4:  GOTO   495A (RETURN)
....................     // scheduled commands are loaded after reset time sync instead of here 
.................... } 
....................  
.................... void adcs_setup() 
.................... { 
....................     // // Get ADCS memory addresses 
....................     // uint32_t adcs_ptr = get_adcs_pointer(); 
....................     // output_low(MUX_SEL_MSN_SHARED_FM); 
....................     // flash_transfer_data_to_ram( 
....................     //     MISSION_FM, 
....................     //     adcs_ptr, 
....................     //     obc_flags.adcs_addr, 
....................     //     sizeof(obc_flags.adcs_addr)); 
....................     // output_high(MUX_SEL_MSN_SHARED_FM); 
....................     adcs_mode = obc_flags.adcs_initial_value; 
048E8:  MOVFF  F2,68A
048EC:  GOTO   495C (RETURN)
.................... } 
....................  
.................... void memory_setup() 
.................... { 
....................     // Read boot flags from flash memory 
....................     flash_transfer_data_to_ram( 
....................         &spi_port_COM_FM, 
....................         BOOT_FLAGS_ADDRESS, 
....................         (uint8_t*)&boot_flags, 
....................         sizeof(boot_flags)); 
048F0:  MOVLB  9
048F2:  CLRF   xC6
048F4:  MOVLW  ED
048F6:  MOVWF  xC5
048F8:  MOVLW  09
048FA:  MOVLB  B
048FC:  MOVWF  x01
048FE:  MOVLW  1B
04900:  MOVWF  x00
04902:  CLRF   x05
04904:  CLRF   x04
04906:  CLRF   x03
04908:  CLRF   x02
0490A:  MOVFF  9C6,B07
0490E:  MOVFF  9C5,B06
04912:  CLRF   x0B
04914:  CLRF   x0A
04916:  CLRF   x09
04918:  MOVLW  01
0491A:  MOVWF  x08
0491C:  MOVLB  0
0491E:  CALL   2E46
....................  
....................     if (boot_flags.deployment_flag == 0xFF) { // The memory has no data 
04922:  INCFSZ xED,W
04924:  BRA    493C
....................         fprintf(PC, "Initializing flash memory...\r\n"); 
04926:  MOVLW  40
04928:  MOVWF  FF6
0492A:  MOVLW  0A
0492C:  MOVWF  FF7
0492E:  MOVLW  00
04930:  MOVWF  FF8
04932:  CALL   1C7A
....................         initialize_memory(); 
04936:  GOTO   3F44
....................     } else { 
0493A:  BRA    494E
....................         fprintf(PC, "Retrieving addresses from flash memory...\r\n"); 
0493C:  MOVLW  60
0493E:  MOVWF  FF6
04940:  MOVLW  0A
04942:  MOVWF  FF7
04944:  MOVLW  00
04946:  MOVWF  FF8
04948:  CALL   1C7A
....................         retrieve_memory(); 
0494C:  BRA    43F4
....................     } 
....................  
....................     if (boot_flags.deployment_flag < 5) { // Less than 5 deployment tries 
0494E:  MOVF   xED,W
04950:  SUBLW  04
04952:  BNC   4958
....................         initial_deployment_setup(); 
04954:  BRA    46D8
....................     } else { 
04956:  BRA    495A
....................         nominal_setup(); 
04958:  BRA    48DA
....................     } 
....................     adcs_setup(); 
0495A:  BRA    48E8
0495C:  GOTO   EBBC (RETURN)
.................... } 
....................  
.................... #endif // !MEMORY_SETUP_H 
....................  
.................... #include "flash_memory.h" 
.................... #ifndef FLASH_MEMORY_H 
.................... #define FLASH_MEMORY_H 
....................  
.................... #include "definitions.h" 
....................  
.................... // Driver for the MT25QL01GBBB flash memory 
....................  
.................... // A limitation of CCS compiler is that port names can not be passed as parameters to functions. 
.................... // Therefore, C macros and function pointers were used to achieve generic procedures. 
.................... // All functions start with the function_ prefix to separate from other names used in the program. 
....................  
.................... // Pin definitions should start with CS_PIN_ and end with the correspondent spi port name. 
.................... // This ensures that the define macros below will know the corresponding pins. 
.................... #define CS_PIN_MAIN_FM PIN_E2    // MAIN_FM 
.................... #define CS_PIN_COM_FM PIN_B3     // COM_FM 
.................... #define CS_PIN_MISSION_FM PIN_A2 // MISSION_FM 
....................  
.................... // These are constant values used for the flash memory operation. 
.................... #define READ_ID 0x9F 
.................... #define READ_STATUS_REG 0x05 
.................... #define READ_DATA_BYTES 0x13 
.................... #define ENABLE_WRITE 0x06 
.................... #define WRITE_PAGE 0x12 
.................... #define ERASE_SECTOR 0xDC    // 64 KB 
.................... #define ERASE_SUBSECTOR 0x5C // 32 KB 
.................... #define ERASE_PAGE 0x21      // 04 KB 
.................... #define DIE_ERASE 0xC4 
....................  
.................... // Memory size (available addresses) 
.................... #define MEMORY_N_SECTORS 2048 
.................... #define MEMORY_SIZE 128 * 1024 * 1024 
.................... #define MEMORY_SECTOR_SIZE (64 * 1024) 
.................... #define MEMORY_SUBSECTOR_SIZE (32 * 1024) 
.................... #define MEMORY_PAGE_SIZE (4 * 1024) 
....................  
.................... typedef void (*spi_send_fn)(uint8_t data); 
.................... typedef uint8_t (*spi_receive_fn)(); 
....................  
.................... typedef struct spi_fn { 
....................     spi_send_fn* spi_send; 
....................     spi_receive_fn* spi_receive; 
....................     uint16_t cs_pin; 
.................... } spi_fn; 
....................  
.................... #define spi_declaration(spi_port)                 \ 
....................     inline void spi_send_##spi_port(uint8_t data) \ 
....................     {                                             \ 
....................         spi_xfer(spi_port, data);                 \ 
....................     }                                             \ 
....................     inline uint8_t spi_receive_##spi_port()       \ 
....................     {                                             \ 
....................         return spi_xfer(spi_port);                \ 
....................     }                                             \ 
....................     spi_fn spi_port_##spi_port = { &spi_send_##spi_port, &spi_receive_##spi_port, CS_PIN_##spi_port } 
....................  
.................... spi_declaration(COM_FM);     // Will create a spi_port_COM_FM structure with function pointers 
.................... spi_declaration(MAIN_FM);    // Will create a spi_port_MAIN_FM structure with function pointers 
.................... spi_declaration(MISSION_FM); // Will create a spi_port_MISSION_FM structure with function pointers 
....................  
.................... // Write a byte (data) to an address (page_address) on a given flash memory (spi_port). 
.................... void flash_write(spi_fn* spi_functions, uint32_t page_address, uint8_t data) 
.................... { 
....................     /* Byte extraction */ 
....................     uint8_t* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(WRITE_PAGE); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     spi_functions->spi_send(data); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_us(20); 
.................... } 
....................  
.................... // Read a byte (data) from an address (page_address) on a given flash memory (spi_port). 
.................... uint8_t flash_read(spi_fn* spi_functions, uint32_t page_address) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (uint8_t*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(READ_DATA_BYTES); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     uint8_t data = spi_functions->spi_receive(); 
....................     output_high(spi_functions->cs_pin); 
....................     return data; 
.................... } 
....................  
.................... // Erase a sector (64KB), subsector (32KB) or page (4KB) starting in a given address (page address). 
.................... // Any address within the subsector is valid for entry. 
.................... // erase_command can be ERASE_SECTOR, ERASE_SUBSECTOR or ERASE_PAGE 
.................... void flash_erase(spi_fn* spi_functions, uint32_t page_address, uint8_t erase_command) 
.................... { 
....................     /* Byte extraction */ 
....................     unsigned int8* address = (unsigned int8*)&page_address; 
....................     /* address[0] : 0x 00 00 00 _ _ */ 
....................     /* address[1] : 0x 00 00 _ _ 00 */ 
....................     /* address[2] : 0x 00 _ _ 00 00 */ 
....................     /* address[3] : 0x _ _ 00 00 00 */ 
....................     output_low(spi_functions->cs_pin); 
....................     spi_functions->spi_send(ENABLE_WRITE); 
....................     output_high(spi_functions->cs_pin); 
....................     output_low(spi_functions->cs_pin); 
....................     delay_us(2); 
....................     spi_functions->spi_send(erase_command); 
....................     spi_functions->spi_send(address[3]); 
....................     spi_functions->spi_send(address[2]); 
....................     spi_functions->spi_send(address[1]); 
....................     spi_functions->spi_send(address[0]); 
....................     delay_us(2); 
....................     output_high(spi_functions->cs_pin); 
....................     delay_ms(750); 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_H 
....................  
.................... #include "flash_memory_fn.h" 
.................... #ifndef FLASH_MEMORY_FN_H 
.................... #define FLASH_MEMORY_FN_H 
....................  
.................... #include "definitions.h" 
.................... #include "flash_memory.h" 
....................  
.................... // Erase all sectors from a given flash memory (spi_port). 
.................... void flash_erase_all_sectors(spi_fn* spi_functions) 
.................... { 
....................     uint32_t address = 0; 
....................     for (uint16_t i = 0; i < MEMORY_N_SECTORS; i++) { 
....................         flash_erase(spi_functions, address, ERASE_SECTOR); 
....................         address = address + MEMORY_SECTOR_SIZE; 
....................     } 
.................... } 
....................  
.................... // Transfer data from the flash memory (spi_port) to an uart device (uart_port), starting from a given 
.................... // address (page_address) and with a given total lenth (nbytes). 
.................... void flash_transfer_data_to_uart(spi_fn* from_spi_functions, uart_fn* to_uart_port, uint32_t page_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data = flash_read(from_spi_functions, page_address); 
....................         to_uart_port->put_char(data); 
....................         page_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data from one flash memory (from_spi_port) to another (to_spi_port), with different to and from page 
.................... // addresses and configurable length (nbytes). The same flash memory can be used as source and destination. 
.................... void flash_transfer_data_to_flash(spi_fn* from_spi_functions, uint32_t from_address, spi_fn* to_spi_functions, uint32_t to_address, uint32_t nbytes) 
.................... { 
....................     uint8_t data; 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data = flash_read(from_spi_functions, from_address); 
....................         flash_write(to_spi_functions, to_address, data); 
....................         from_address++; 
....................         to_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data from ram to flash memory (to_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_from_ram(spi_fn* to_spi_functions, uint32_t to_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         flash_write(to_spi_functions, to_address, data[i]); 
....................         to_address++; 
....................     } 
.................... } 
....................  
.................... // Transfer data to ram from flash memory (from_spi_port) with configurable length (nbytes). 
.................... void flash_transfer_data_to_ram(spi_fn* to_spi_functions, uint32_t from_address, uint8_t* data, uint32_t nbytes) 
.................... { 
....................     for (uint32_t i = 0; i < nbytes; i++) { 
....................         data[i] = flash_read(to_spi_functions, from_address); 
....................         from_address++; 
....................     } 
.................... } 
....................  
.................... // Erase memory pages around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to page allignment. 
....................  
.................... void flash_erase_pages(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_PAGE_SIZE) { 
....................         flash_erase(to_spi_functions, i, ERASE_PAGE); 
....................     } 
.................... } 
....................  
.................... // Erase memory sectors around the desired addresses in memory spi_port. 
.................... // Bytes might be erased before start_address and after end_address due to sector allignment. 
.................... void flash_erase_sectors(spi_fn* to_spi_functions, uint32_t start_address, uint32_t end_address) 
.................... { 
....................     for (uint32_t i = start_address; i < end_address; i += MEMORY_SECTOR_SIZE) { 
....................         flash_erase(to_spi_functions, i, ERASE_SECTOR); 
....................     } 
.................... } 
....................  
.................... void flash_dump(spi_fn* spi_functions, uint32_t start, uint32_t end) 
.................... { 
....................     uint8_t data; 
....................     uint16_t empty_blocks = 0; 
....................     for (uint32_t i = start; i < end; i++) { 
....................         if (i % (TERMINAL_COLS / 2) == 0) 
....................             fprintf(PC, "\r\n"); 
....................         data = flash_read(spi_functions, i); 
....................         fprintf(PC, "%02X", data); 
....................         if (data == 0xFF) { 
....................             empty_blocks++; 
....................         } else { 
....................             empty_blocks = 0; 
....................         } 
....................         if (empty_blocks >= EMPTY_BLOCKS_LIMIT) { 
....................             break; 
....................         } 
....................     } 
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) 
.................... void flash_initialize_flash_ctrl(uint32_t start, 
....................     uint32_t end, 
....................     uint32_t current, 
....................     uint32_t packet_size, 
....................     flash_ctrl* fmem) 
.................... { 
....................     fmem->start = start; 
....................     fmem->end = end - (end - start) % packet_size; 
....................     fmem->current = current; 
....................     fmem->delta = packet_size; 
.................... } 
....................  
.................... // Initialize the flash control structure (stores address for flash memory operation) based on existing address information from flash 
.................... void flash_initialize_flash_ctrl_from_memory_date_based( 
....................     uint8_t sectors_per_day, 
....................     int8_t deployment_counter, 
....................     uint32_t candidate_address, 
....................     uint32_t first_address, 
....................     uint32_t telemetry_size, 
....................     uint8_t update_date, 
....................     flash_ctrl* fmem) 
.................... { 
....................      
....................     if(deployment_counter < 0) 
....................         deployment_counter = 0; 
....................  
....................     uint32_t addr_start; 
....................     uint16_t day_of_the_year; 
....................  
....................     if(deployment_counter < 5){ 
....................         day_of_the_year = deployment_counter; 
....................         addr_start = first_address + (uint32_t)deployment_counter * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     } 
....................     else{ 
....................         if(update_date){ 
....................             struct_tm* local_time = localtime(&current_time); 
....................             day_of_the_year = local_time->tm_yday; // struct_tm::tm_yday is the day of the year (from 0-365) 
....................         } else{ 
....................             day_of_the_year = (candidate_address - first_address) / ((uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE); 
....................         } 
....................         if (day_of_the_year > 366) 
....................             day_of_the_year = 0; 
....................         addr_start = first_address + (uint32_t)day_of_the_year * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     } 
....................     uint32_t addr_end = addr_start + (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     if(candidate_address >= addr_start && candidate_address < addr_end){ 
....................         flash_initialize_flash_ctrl(addr_start, addr_end, candidate_address, telemetry_size, fmem); 
....................     } else { 
....................         flash_initialize_flash_ctrl(addr_start, addr_end, addr_start, telemetry_size, fmem); 
....................     } 
....................     fprintf(PC, "\r\nDay of the year = %lu\r\n", day_of_the_year + 1); 
....................     fprintf(PC, "Candidate telemetry address = 0x%8lX\r\n", candidate_address); 
....................     fprintf(PC, "Initial telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.start); 
....................     fprintf(PC, "Current telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.current); 
....................     fprintf(PC, "Telemetry size = %u\r\n", addr_flags.flash_telemetry.delta); 
....................     fprintf(PC, "Last telemetry address = 0x%8lX\r\n", addr_flags.flash_telemetry.end); 
.................... } 
....................  
.................... // Writes data according to a flash control structure (fctrl) to a flash memory in spi_port 
.................... void flash_cycle_write(spi_fn* spi_functions, uint8_t* data, flash_ctrl* fctrl) 
.................... { 
....................     if (fctrl->current < fctrl->start || fctrl->current >= fctrl->end) 
....................         fctrl->current = fctrl->start; 
....................     uint32_t remaining_addressess = (MEMORY_PAGE_SIZE - (fctrl->current % MEMORY_PAGE_SIZE)) % MEMORY_PAGE_SIZE; 
....................     if (remaining_addressess < fctrl->delta) { 
....................         flash_erase(spi_functions, fctrl->current + remaining_addressess, ERASE_PAGE); 
....................     } 
....................     for (int i = 0; i < fctrl->delta; i++) { 
....................         flash_write(spi_functions, fctrl->current, data[i]); 
....................         fctrl->current++; 
....................     } 
.................... } 
....................  
.................... // Recover last available address from a flash control structure (fctrl) 
.................... void flash_recover_last_addr(spi_fn* spi_functions, flash_ctrl* fctrl) 
.................... { 
....................     uint8_t data; 
....................     for (fctrl->current = fctrl->end - fctrl->delta; fctrl->current >= fctrl->start; fctrl->current -= fctrl->delta) { 
....................         for (uint8_t i = 0; i < fctrl->delta; i++) { 
....................             data = flash_read(spi_functions, fctrl->current + i); 
....................             if (data != 0xFF) { 
....................                 fctrl->current += fctrl->delta; 
....................                 goto loop_end; 
....................             } 
....................         } 
....................     } 
.................... loop_end: 
....................     if (fctrl->current >= fctrl->end) 
....................         fctrl->current = fctrl->start; 
.................... } 
....................  
.................... #endif // !FLASH_MEMORY_FN_H 
....................  
.................... #include "crc16.h" 
.................... #ifndef CRC16_H 
.................... #define CRC16_H 
....................  
.................... #include <stdint.h> 
....................  
.................... // CRC calculation function 
.................... uint16_t mk_crc(uint8_t* data, uint8_t size) 
.................... { 
....................     uint32_t crcreg = 0xffff; 
....................     uint32_t calc = 0x8408; 
....................     for (uint32_t k = 0; k < size; k++) { 
....................         uint8_t cal_data = data[k]; 
....................         for (uint32_t i = 0; i < 8; i++) { 
....................             uint8_t w = (crcreg ^ cal_data) & 0x0001; 
....................             crcreg = crcreg >> 1; 
....................             if (w == 1) { 
....................                 crcreg = crcreg ^ calc; 
....................             } 
....................             cal_data = cal_data >> 1; 
....................         } 
....................     } 
....................     crcreg = crcreg ^ 0xffff; 
....................     return crcreg; 
.................... } 
....................  
.................... #endif /* CRC16_H */ 
....................  
.................... #include "scheduler.h" 
.................... #ifndef SCHEDULER_H 
.................... #define SCHEDULER_H 
....................  
.................... #include <string.h> 
.................... #include "definitions.h" 
....................  
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled); 
....................  
.................... void scheduler_initialize() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... int scheduled_command_add(time_t time, uint8_t* command) 
.................... { 
....................     scheduled_command cmd; 
....................     cmd.time = time; 
....................     memcpy(cmd.command, command, BUFF_LENGTH); 
....................  
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&scheduled_commands[i], &cmd, sizeof(scheduled_command)); 
....................             return 0; 
....................         } 
....................     } 
....................  
....................     return -1; // Error signaling 
.................... } 
....................  
.................... int scheduled_command_count() 
.................... { 
....................     int count = 0; 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].time != TIME_T_MAX) { 
....................             count++; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
.................... void scheduled_command_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         scheduled_commands[i].time = TIME_T_MAX; 
....................     } 
.................... } 
....................  
.................... void scheduled_command_clear_specified_command(uint8_t source, uint8_t command) 
.................... { 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].command[0] == source && scheduled_commands[i].command[1] == command) { 
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
....................         } 
....................     } 
.................... } 
....................  
.................... void scheduled_command_check() 
.................... { 
....................     // time_t current_time = time(0); 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (current_time >= scheduled_commands[i].time) { 
....................             command_execute(scheduled_commands[i].command, MSG_COMM, 1); // scheduled commands can only be COMM commands 
....................             scheduled_commands[i].time = TIME_T_MAX;                     // Disable the command from executing again (== reschedule it at infinity). 
....................             i = 0; // Check the whole table again for changes 
....................         } 
....................     } 
.................... } 
....................  
.................... #ifndef PC_SIM 
.................... #define ZERO (0, 0) 
.................... #else 
.................... #define ZERO (0) 
.................... #endif 
....................  
.................... // Schedule a constant 
.................... #define schedule(time, ...)               \ 
....................     do {                                  \ 
....................         uint8_t cmd[] = __VA_ARGS__;      \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Schedule a variable 
.................... #define vschedule(time, cmd)              \ 
....................     do {                                  \ 
....................         scheduled_command_add(time, cmd); \ 
....................     } while ZERO 
....................  
.................... // Execute a command immediately 
.................... #define execute(log, ...)                        \ 
....................     do {                                         \ 
....................         uint8_t cmd[] = __VA_ARGS__;             \ 
....................         command_execute(cmd, MSG_WILDCARD, log); \ 
....................     } while ZERO 
....................  
.................... #define periodic_command_clear_rx_flag(period, delta) \ 
....................     do {                                              \ 
....................         if ((current_time % period == delta)) {       \ 
....................             response_rx = 0;                          \ 
....................         }                                             \ 
....................     } while ZERO 
....................  
.................... #define periodic_command(period, delta, log, ...) \ 
....................     do {                                          \ 
....................         if ((current_time % period == delta)) {   \ 
....................             if (!response_rx)                     \ 
....................                 execute(log, __VA_ARGS__);        \ 
....................         }                                         \ 
....................     } while ZERO 
....................  
.................... #endif /* SCHEDULER_H */ 
....................  
.................... #include "log_control.h" 
.................... #ifndef LOG_CONTROL_H 
.................... #define LOG_CONTROL_H 
....................  
.................... #include <string.h> 
.................... #include "definitions.h" 
.................... #include "flash_memory.h" 
....................  
.................... // Adds a log entry to buffer in RAM 
.................... void log_add(log_entry e) 
.................... { 
....................     if (log_index < MAX_LOGS_IN_RAM) { 
....................         memcpy(&log_buffer[log_index], &e, sizeof(log_entry)); 
....................         log_index++; 
....................     } 
.................... } 
....................  
.................... // Clears buffer in RAM 
.................... void log_clear() 
.................... { 
....................     log_index = 0; 
.................... } 
....................  
.................... // Flushes RAM buffer to flash memory 
.................... void log_flush() 
.................... { 
....................     for(uint8_t i=0; i<log_index; i++){ 
....................         uint8_t *ptr = (uint8_t*)&log_buffer[i]; 
....................         flash_cycle_write(&spi_port_COM_FM, ptr, &addr_flags.flash_log); 
....................     } 
....................     fprintf(PC, "Log: 0x%08lX => 0x%08lX", addr_flags.flash_log.current - log_index*sizeof(log_entry), addr_flags.flash_log.current); 
....................     log_index = 0; 
.................... } 
....................  
.................... #endif /* LOG_CONTROL_H */ 
....................  
.................... #include "boot_command.h" 
.................... #ifndef BOOT_COMMAND_H 
.................... #define BOOT_COMMAND_H 
....................  
.................... #include "definitions.h" 
.................... #include "flash_memory.h" 
.................... #include "flash_memory_fn.h" 
.................... #include "scheduler.h" 
....................  
.................... void boot_commands_write() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_erase_pages(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, BOOT_COMMANDS_ADDR + sizeof(boot_commands)); 
....................     flash_transfer_data_from_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_read() 
.................... { 
....................     uint8_t* bc_ptr = (uint8_t*)boot_commands; 
....................     flash_transfer_data_to_ram(&spi_port_MAIN_FM, BOOT_COMMANDS_ADDR, bc_ptr, sizeof(boot_commands)); 
.................... } 
....................  
.................... void boot_commands_clear_nth(uint8_t n) 
.................... { 
....................     if (n < BOOT_COMMANDS_MAX) 
....................         boot_commands[n].time = TIME_T_MAX; 
.................... } 
....................  
.................... void boot_commands_clear_all() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         boot_commands_clear_nth(i); 
....................     } 
.................... } 
....................  
.................... uint8_t boot_commands_add(boot_command bc) 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if (boot_commands[i].time == TIME_T_MAX) { 
....................             memcpy(&boot_commands[i], &bc, sizeof(boot_command)); 
....................             return i; 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... void boot_commands_schedule() 
.................... { 
....................     for (uint8_t i = 0; i < BOOT_COMMANDS_MAX; i++) { 
....................         if(boot_commands[i].time > 0 && boot_commands[i].time < TIME_T_MAX) 
....................             vschedule(current_time + boot_commands[i].time, boot_commands[i].command); 
....................     } 
.................... } 
....................  
.................... #endif /* BOOT_COMMAND_H */ 
....................  
.................... #include "xmodem.h" 
.................... #ifndef XMODEM_H 
.................... #define XMODEM_H 
....................  
.................... // Based on: 
.................... // https://web.mit.edu/6.115/www/amulet/xmodem.htm 
.................... // https://pythonhosted.org/xmodem/xmodem.html#data-flow-example-including-error-recovery 
....................  
.................... #include "definitions.h" 
.................... #include "flash_memory.h" 
.................... #include "libuart_fn.h" 
....................  
.................... #define XMODEM_SOH 0x01                   // Start of Header 
.................... #define XMODEM_EOT 0x04                   // End of Transmission 
.................... #define XMODEM_ACK 0x06                   // Acknowledge 
.................... #define XMODEM_NAK 0x15                   // Not Acknowledge 
.................... #define XMODEM_DLENGTH 128                // Data length 
.................... #define XMODEM_PLENGTH XMODEM_DLENGTH + 4 // Packet length 
....................  
.................... typedef struct xmodem_packet { 
....................     uint8_t header; 
....................     uint8_t packet_no; 
....................     uint8_t packet_no_; 
....................     uint8_t packet_data[XMODEM_DLENGTH]; 
....................     uint8_t checksum; 
.................... } xmodem_packet; 
....................  
.................... uint8_t xmodem_calc_chksum(uint8_t* ptr, uint8_t count) 
.................... { 
....................     uint8_t result = 0; 
....................     for (uint8_t* i = ptr; i < ptr + count; i++) { 
....................         result += *i; 
....................     } 
....................     return result; 
.................... } 
....................  
.................... void xmodem_create_packet(spi_fn* spi_port, uint32_t fm_address, uint32_t packet_no, uint8_t* packet_data) 
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)packet_data; 
....................     packet->header = XMODEM_SOH; 
....................     packet->packet_no = packet_no & 0xFF; 
....................     packet->packet_no_ = 0xFF - packet->packet_no; 
....................     flash_transfer_data_to_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
....................     packet->checksum = xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH); 
.................... } 
....................  
.................... int8_t xmodem_send(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address, uint16_t n_packets) 
.................... { 
....................     const uint32_t timeout = 5000000; 
....................     uint16_t current_packet = 1; 
....................     uint8_t packet[XMODEM_PLENGTH]; 
....................     for (uint32_t t = 0; t < timeout; t++) { 
....................         if (uart_stream->bytes_available()) { 
....................             uint8_t command = uart_stream->get_char(); 
....................             t = 0; 
....................             switch (command) { 
....................             case XMODEM_ACK: 
....................                 current_packet++; 
....................                 fm_address += XMODEM_DLENGTH; 
....................                 if (current_packet > n_packets) { 
....................                     uart_stream->put_char(XMODEM_EOT); 
....................                     return 0; 
....................                 } 
....................             case XMODEM_NAK: 
....................                 xmodem_create_packet(spi_port, fm_address, current_packet, packet); 
....................                 uart_send_packet(uart_stream, packet, XMODEM_PLENGTH); 
....................                 break; 
....................             default: 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... uint8_t xmodem_validate(uint8_t* buffer, uint16_t packet_no) 
.................... { 
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uint8_t correct_header = (packet->header == XMODEM_SOH); 
....................     uint8_t correct_no = (packet->packet_no == (packet_no & 0xFF)); 
....................     uint8_t correct_no_ = (packet->packet_no_ == 0xFF - (packet_no & 0xFF)); 
....................     uint8_t correct_checksum = (packet->checksum == xmodem_calc_chksum(packet->packet_data, XMODEM_DLENGTH)); 
....................     return correct_header && correct_no && correct_no_ && correct_checksum; 
.................... } 
....................  
.................... int16_t xmodem_receive(uart_fn* uart_stream, spi_fn* spi_port, uint32_t fm_address) 
.................... { 
....................     const uint32_t uart_timeout = 1000000; 
....................     uint16_t max_nak = 2; 
....................     uint16_t packet_no = 1; 
....................     uint16_t nak_count = 0; 
....................     uint8_t buffer[XMODEM_PLENGTH] = { 0 }; 
....................     xmodem_packet* packet = (xmodem_packet*)buffer; 
....................     uart_stream->put_char(XMODEM_NAK); // Request 1st packet 
....................     while (nak_count < max_nak) { 
....................         uart_download_packet(uart_stream, buffer, XMODEM_PLENGTH, uart_timeout); 
....................         if (buffer[0] == XMODEM_EOT) { 
....................             uart_stream->put_char(XMODEM_ACK); 
....................             return packet_no; 
....................         } 
....................         if (xmodem_validate(buffer, packet_no)) { 
....................             // uart_send_packet(uart_stream, packet->packet_data, XMODEM_DLENGTH); // for debug 
....................             uint32_t remaining_addressess = (MEMORY_SECTOR_SIZE - (fm_address % MEMORY_SECTOR_SIZE)) % MEMORY_SECTOR_SIZE; 
....................             if (remaining_addressess < XMODEM_DLENGTH) { 
....................                 flash_erase(spi_port, fm_address + remaining_addressess, ERASE_SECTOR); 
....................             } 
....................             flash_transfer_data_from_ram(spi_port, fm_address, packet->packet_data, XMODEM_DLENGTH); 
....................             packet_no++; 
....................             fm_address += XMODEM_DLENGTH; 
....................             nak_count = 0; 
....................             max_nak = 64; // Increase max number of nak once communication is established 
....................             uart_stream->put_char(XMODEM_ACK); 
....................         } else { 
....................             uart_stream->put_char(XMODEM_NAK); 
....................             nak_count++; 
....................         } 
....................     } 
....................     return -1; 
.................... } 
....................  
.................... #endif /* XMODEM_H */ 
....................  
.................... #include "interpreter.h" 
.................... #ifndef INTERPRETER_H 
.................... #define INTERPRETER_H 
....................  
.................... #include "definitions.h" 
.................... #include "scheduler.h" 
.................... #include "crc16.h" 
.................... #include "libuart_fn.h" 
.................... #include "flash_memory.h" 
.................... #include "xmodem.h" 
.................... #include "log_control.h" 
.................... #include "boot_command.h" 
....................  
.................... // Interpreter: The procedures here are concerned with interpreting 
.................... // received commands and executing the appropriate commands. 
....................  
.................... // Definition of commands. Should follow the prototype: "uint8_t command_name(uint8_t *data)" 
.................... // Return value = 0 indicates that the command was successful 
.................... // Return value > 0 indicates that there was an error 
....................  
.................... // ============ Helper functions ============ 
....................  
.................... void get_com_shared_fm_access() 
.................... { 
....................     if (memory_busy) { 
....................         scheduled_command_clear_specified_command(0xC0, 0x58); // Disable scheduled command to regain access to memory in the future 
....................         output_low(MUX_SEL_COM_SHARED_FM);                     // Regain access to memory now 
....................         memory_busy = 0;                                       // Now memory is free 
....................     } 
.................... } 
....................  
.................... // Helper function to calculate OBC checksum 
.................... void checksum_obc(uint8_t* data, uint8_t size) 
.................... { 
....................     uint8_t checksum = 0; 
....................     for (uint8_t i = 1; i < size - 2; i++) { 
....................         checksum ^= data[i]; 
....................     } 
....................     data[size - 2] = checksum; 
....................     data[size - 1] = data[0] + 1; // Footer 
.................... } 
....................  
.................... // Helper function to check if uplink is valid 
.................... uint8_t uplink_valid(uint8_t* buffer) 
.................... { 
....................     const uint8_t cmd_length = 22;        // Extended packet length 
....................     const uint8_t cmd_legacy_length = 14; // Legacy packet length 
....................  
....................     struct packet { 
....................         uint8_t packet_format_id; 
....................         uint8_t satellite_id; 
....................         uint8_t cmd_format_id; 
....................     }* packet = (struct packet*)buffer; 
....................  
....................     uint16_t cr, pk;                                                                 // these are the crc check variables 
....................     if (packet->packet_format_id == 0x42 && packet->satellite_id == SPACECRAFT_ID) { // This packet is meant for CURTIS 
....................         if (packet->cmd_format_id == 0xCC) {                                         // Extended KITSUNE format (22 bytes) 
....................             cr = mk_crc(buffer, cmd_length - 2); 
....................             pk = make16(buffer[cmd_length - 1], buffer[cmd_length - 2]); 
....................         } else { // Herritage BIRDS format (14 bytes) 
....................             cr = mk_crc(buffer, cmd_legacy_length - 2); 
....................             pk = make16(buffer[cmd_legacy_length - 1], buffer[cmd_legacy_length - 2]); 
....................         } 
....................         if (cr == pk) { // CRC is good to go 
....................             return 1;   // Packet is valid 
....................         } 
....................     } 
....................     return 0; // Packet is invalid 
.................... } 
....................  
.................... // Helper function to send an acknowledge back to COM 
.................... void send_com_ack(uint8_t* data) 
.................... { 
....................     uint8_t cmd[24] = { 0 }; 
....................     cmd[0] = 0x0B; 
....................     cmd[1] = 0xAA; 
....................     cmd[2] = 0xCC; 
....................     memcpy(cmd + 3, data, 8); 
....................     cmd[12] = 0x66; 
....................     cmd[23] = 0x0C; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], COMM); 
....................     } 
.................... } 
....................  
.................... // Helper function to change reset time 
.................... void reset_pic_update_clock(time_t time) 
.................... { 
....................     struct_tm* tstr = localtime(&time); 
....................     struct rst_msg { 
....................         uint8_t rst_command; 
....................         uint8_t year; 
....................         uint8_t month; 
....................         uint8_t day; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................     } msg; 
....................  
....................     msg.rst_command = 0x70; 
....................     msg.year = tstr->tm_year - 100; 
....................     msg.month = tstr->tm_mon + 1; 
....................     msg.day = tstr->tm_mday; 
....................     msg.hour = tstr->tm_hour; 
....................     msg.minute = tstr->tm_min; 
....................     msg.second = tstr->tm_sec; 
....................  
....................     uint8_t i; 
....................     uint8_t cmd[36] = { 0 }; 
....................     cmd[0] = 0xB0; 
....................     uint8_t* ptr = (uint8_t*)&msg; 
....................     for (i = 0; i < sizeof(msg); i++) { 
....................         cmd[i + 1] = ptr[i]; 
....................     } 
....................     cmd[35] = 0xB1; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
.................... } 
....................  
.................... // Helper function to print binary data 
.................... void print_binary16(uint16_t data) 
.................... { 
....................     const uint8_t size = 16; 
....................     for (uint8_t i = 1; i <= size; i++) { 
....................         fprintf(PC, "%Lu", ((data >> (size - i)) & 1)); 
....................     } 
....................     fputc('\r', PC); 
....................     fputc('\n', PC); 
.................... } 
....................  
.................... // Helper funtion to initialize the telemetry array. 
.................... void initialize_telemetry() 
.................... { 
....................     memset(&telemetry_time, 0, sizeof(telemetry_time)); 
....................     memset(&telemetry, 0, sizeof(telemetry)); 
....................     telemetry.master_footer[0] = 0xB0; 
....................     telemetry.master_footer[1] = 0x0B; 
.................... } 
....................  
.................... // Convert gyro data 16 -> 8 bits (-128 to 127 with LSB = 1deg/s, with overflow protection) 
.................... int8_t gyro_to_cw(uint8_t msb, uint8_t lsb) 
.................... { 
....................     int8_t gyro_cw; 
....................     float gyro = ((int16_t)make16(msb, lsb)) * 8.75e-3; 
....................     if (gyro > 127.) { 
....................         gyro_cw = 127; 
....................     } else if (gyro < -128.) { 
....................         gyro_cw = -128; 
....................     } else { 
....................         if (gyro > 0.) { 
....................             gyro_cw = (int8_t)(gyro + 0.5); 
....................         } else { 
....................             gyro_cw = (int8_t)(gyro - 0.5); 
....................         } 
....................     } 
....................     return gyro_cw; 
.................... } 
....................  
.................... // Helper funtion to initialize the cw beacon array. 
.................... void build_cw() 
.................... { 
....................     uint8_t sc = scheduled_command_count(); 
....................     uint8_t adcs_mode = telemetry.adcs_message[0]; 
....................     time_t time_after_reset = (current_time - reset_time) / 3600; 
....................     uint8_t time_after_reset_ = time_after_reset > 24 ? 0x1F : time_after_reset; 
....................  
....................     memset(&cw, 0, sizeof(cw)); // Erase old data. 
....................  
....................     // Page 0 
....................     cw[0][0] = (telemetry.reset_message[6] << 4) | (telemetry.reset_message[7] >> 4);      // Battery voltage 
....................     cw[0][1] = (telemetry.fab_message[48] << 4) | (telemetry.fab_message[49] >> 4);        // Battery current, 12 -> 8 bit 
....................     cw[0][2] = (telemetry.fab_message[50] << 4) | (telemetry.fab_message[51] >> 4);        // Battery temperature, 12 -> 8 bit 
....................     cw[0][3] = (telemetry.fab_message[10] << 4) | (telemetry.fab_message[11] >> 4);        // CPLD temperature 
....................     cw[0][4] = (make16(telemetry.fab_message[28], telemetry.fab_message[29]) > 0x229) << 7 // +X sun / no sun 
....................         | (make16(telemetry.fab_message[30], telemetry.fab_message[31]) > 0x223) << 6      // -X sun / no sun 
....................         | (make16(telemetry.fab_message[26], telemetry.fab_message[27]) > 0x2E8) << 5      // +Y sun / no sun 
....................         | (make16(telemetry.fab_message[32], telemetry.fab_message[33]) > 0x03E) << 4      // -Y sun / no sun 
....................         | (make16(telemetry.fab_message[36], telemetry.fab_message[37]) > 0x081) << 3      // +Z sun / no sun 
....................         | (make16(telemetry.fab_message[34], telemetry.fab_message[35]) > 0x065) << 2      // -Z sun / no sun 
....................         | (boot_flags.deployment_flag >= 5) << 1                                           // OBC mode 
....................         | ((time_after_reset_ >> 4) & 0x1);                                                // Time after reset bit 5 
....................     cw[0][5] = (time_after_reset_ & 0x0F) << 4                                             // Time after reset bits 0-4 
....................         | (telemetry.fab_message[52] & 0x1) << 3                                           // Battery heater on/off 
....................         | (telemetry.fab_message[53] & 0x1) << 2                                           // Kill switch Main PIC 
....................         | ((telemetry.fab_message[53] & 0x10) >> 4) << 1                                   // Kill switch EPS PIC 
....................         | 0x0;                                                                             // Format identifier 
....................  
....................     // Page 1 
....................     cw[1][0] = gyro_to_cw(telemetry.adcs_message[1], telemetry.adcs_message[2]); // Gyro X axis (deg/s), 16 -> 8 bits (-128 to 127 with LSB = 1deg/s) 
....................     cw[1][1] = gyro_to_cw(telemetry.adcs_message[3], telemetry.adcs_message[4]); // Gyro Y axis (deg/s), 16 -> 8 bits (-128 to 127 with LSB = 1deg/s) 
....................     cw[1][2] = gyro_to_cw(telemetry.adcs_message[5], telemetry.adcs_message[6]); // Gyro Z axis (deg/s), 16 -> 8 bits (-128 to 127 with LSB = 1deg/s) 
....................     cw[1][3] = ((telemetry.adcs_message[37] >> 2) & 0x1) << 7                    // Magnetometer X axis sign bit 
....................         | ((telemetry.adcs_message[37] >> 1) & 0x1) << 6                         // Magnetometer Y axis sign bit 
....................         | (telemetry.adcs_message[37] & 0x1) << 5                                // Magnetometer Z axis sign bit 
....................         | (adcs_mode < 8 ? adcs_mode : 7) << 2                                   // ADCS mode 
....................         | ((sc < 4 ? sc : 3) & 0x03);                                            // No. of scheduled commands 
....................  
....................     cw[1][4] = ((telemetry_time.reset_time > 0) 
....................                    + (telemetry_time.fab_time > 0) 
....................                    + (telemetry_time.pcib_time > 0) 
....................                    + (telemetry_time.adcs_time > 0)) 
....................             << 5 // Number of subsystems communicating with OBC 
....................         | 0;     // 5 bits free for assignment here 
....................  
....................     cw[1][5] = 0 // 7 bits free for assignment here 
....................         | 0x1;   // Format identifier 
....................  
....................     fprintf(PC, "CW: 0x"); 
....................     uart_print_pc_hex_short(cw[0], sizeof(cw[0])); 
....................     fprintf(PC, " 0x"); 
....................     uart_print_pc_hex_short(cw[1], sizeof(cw[1])); 
....................     fputc(' ', PC); 
.................... } 
....................  
.................... // Helper function to save state to flash 
.................... void save_state(uint8_t current_command) 
.................... { 
....................     get_com_shared_fm_access(); 
....................  
....................     // Save state of obc_flags: 
....................     flash_erase_pages(&spi_port_COM_FM, OBC_FLAGS_ADDRESS, OBC_FLAGS_ADDRESS + sizeof(obc_flags)); 
....................     uint8_t* obc_flag_ptr = (uint8_t*)&obc_flags; 
....................     flash_transfer_data_from_ram( 
....................         &spi_port_COM_FM, 
....................         OBC_FLAGS_ADDRESS, 
....................         obc_flag_ptr, 
....................         sizeof(obc_flags)); 
....................  
....................     // Disable the current command before saving 
....................     for (uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................         if (scheduled_commands[i].command[0] == MSG_COMM && scheduled_commands[i].command[1] == current_command && scheduled_commands[i].time <= current_time) { 
....................             scheduled_commands[i].time = TIME_T_MAX; // Disable the command from executing again (== reschedule it at infinity). 
....................         } 
....................     } 
....................  
....................     // Save state of scheduled commands: 
....................     flash_erase_pages(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, SCHEDULED_CMD_ADDRESS + sizeof(scheduled_commands)); 
....................     uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, SCHEDULED_CMD_ADDRESS, cmd_ptr, sizeof(scheduled_commands)); 
.................... } 
....................  
.................... // ============ Commands for Telemetry request ============ 
....................  
.................... // Request for reset telemetry 
.................... uint8_t command_request_reset(uint8_t* data) 
.................... { 
....................     uart_clean(RST); 
....................     uart_mux = 1; 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // Request for eps telemetry 
.................... uint8_t command_request_eps(uint8_t* data) 
.................... { 
....................     uart_clean(FAB); 
....................     uart_mux = 1; 
....................  
....................     uint8_t i; 
....................     enum { cmd_size = 6 }; 
....................  
....................     uint8_t cmd[cmd_size] = { 0 }; 
....................  
....................     cmd[0] = 0xE0; 
....................     cmd[1] = 0x61; 
....................     *(uint32_t*)&cmd[2] = current_time; 
....................  
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], FAB); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Request for pcib (ADB) telemetry 
.................... uint8_t command_request_pcib(uint8_t* data) 
.................... { 
....................     struct request { 
....................         uint8_t origin; 
....................         uint8_t cmd; 
....................         time_t obc_time; 
....................         uint8_t data[MSG_LENGTH_PCIB - 8]; 
....................         uint8_t checksum; 
....................         uint8_t footer; 
....................     } request; 
....................  
....................     uint8_t* cmd = (uint8_t*)&request; 
....................     memset(cmd, 0, sizeof(request)); 
....................  
....................     request.origin = 0x0B; 
....................     request.cmd = 0xAA; 
....................     request.obc_time = current_time; 
....................  
....................     uart_mux = 1; 
....................     checksum_obc(cmd, sizeof(request)); 
....................     for (uint8_t i = 0; i < sizeof(request); i++) { 
....................         fputc(cmd[i], PCIB); 
....................     } 
....................     return 0; 
.................... } 
....................  
.................... // request for adcs telemetry 
.................... uint8_t command_request_adcs(uint8_t* data) 
.................... { 
....................     uart_clean(ADCS); 
....................     uart_mux = 0; 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B }; 
....................     adcs_command[1] = 0xAB; 
....................     *(time_t*)&adcs_command[2] = current_time; 
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
....................         fputc(adcs_command[i], ADCS); 
....................     } 
....................     // fprintf(PC, "ADCS REQ: "); 
....................     // uart_print_pc_hex(adcs_command, MSG_LENGTH_ADCS); 
....................     // fprintf(PC, "\r\n"); 
....................     return 0; 
.................... } 
....................  
.................... // ============ ADCS Commands ============ 
....................  
.................... enum { // updated on 2023/05/01 
....................     adcs_mode_tumbling = 0, 
....................     adcs_mode_detumbling = 1, 
....................     adcs_mode_detumble_sun_tracking_auto = 2, 
....................     adcs_mode_sun_tracking = 3, 
....................     adcs_mode_nadir_sband = 4, 
....................     adcs_mode_nadir_camera = 5, 
....................     adcs_mode_target = 6, 
....................     adcs_mode_sun_tracking_quat = 7, 
....................     adcs_mode_target_camera = 8, 
....................     adcs_mode_horizon_camera = 9, 
....................     adcs_mode_nadir_sband_pz = 10, 
....................     adcs_mode_nadir_camera_pz = 11 
.................... }; 
....................  
.................... // Helper function to send STM32 commands (up to 32-bytes) 
.................... void stm32_raw_command(uint8_t* data, uint8_t length, uint8_t tle) 
.................... { 
....................     uint8_t adcs_command[MSG_LENGTH_ADCS] = { 0x0B, 0x06 }; 
....................     if (tle) { 
....................         adcs_command[1] = 0x07; 
....................     } 
....................     memcpy(adcs_command + 2, data, length); 
....................     checksum_obc(adcs_command, sizeof(adcs_command)); 
....................     for (uint8_t i = 0; i < sizeof(adcs_command); i++) { 
....................         fputc(adcs_command[i], ADCS); 
....................     } 
....................     fprintf(PC, "STM RAW CMD: "); 
....................     uart_print_pc_hex(adcs_command, sizeof(adcs_command)); 
.................... } 
....................  
.................... // Change ADCS mode internally and externally 
.................... uint8_t command_adcs_mode(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; // when true, change mode permanently 
....................     }* packet = (struct packet*)data; 
....................     uint8_t adcs_command[3] = { 0x01 }; 
....................     adcs_mode = packet->mode; 
....................     adcs_command[1] = packet->mode; 
....................     adcs_command[2] = packet->permanent; 
....................     stm32_raw_command(adcs_command, sizeof(adcs_command), 0); 
....................     return packet->mode; 
.................... } 
....................  
.................... // Change ADCS default mode 
.................... uint8_t command_adcs_default_mode(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t new_mode; 
....................     }* packet = (struct packet*)data; 
....................  
....................     // Change stored vale in OBC 
....................     obc_flags.adcs_initial_value = packet->new_mode; 
....................     adcs_mode = obc_flags.adcs_initial_value; 
....................     save_state(packet->command); 
....................  
....................     // Change stored value in ADCS 
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................     adcs_mode_st.origin = MSG_COMM; 
....................     adcs_mode_st.command = 0xAD; 
....................     adcs_mode_st.mode = packet->new_mode; 
....................     adcs_mode_st.permanent = true; 
....................     vschedule(current_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
....................  
....................     return adcs_mode; 
.................... } 
....................  
.................... // Schedule ADCS mode (without coordinates) 
.................... uint8_t command_schedule_mode(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_mode; 
....................         time_t mode_scheduled_time; 
....................         uint16_t total_duration; 
....................     }* packet = (struct packet*)data; 
....................  
....................     if (packet->mode_scheduled_time == 0) { // debug case 
....................         packet->mode_scheduled_time = current_time; 
....................     } 
....................  
....................     struct adcs_mode_st { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t mode; 
....................         uint8_t permanent; 
....................     } adcs_mode_st; 
....................  
....................     adcs_mode_st.origin = MSG_COMM; 
....................     adcs_mode_st.command = 0xAD; 
....................     adcs_mode_st.mode = packet->adcs_mode; 
....................     adcs_mode_st.permanent = false; 
....................     vschedule(packet->mode_scheduled_time, (uint8_t*)&adcs_mode_st); // ADCS change to selected mode 
....................  
....................     adcs_mode_st.mode = obc_flags.adcs_initial_value; 
....................     vschedule(packet->mode_scheduled_time + packet->total_duration, (uint8_t*)&adcs_mode_st); // ADCS back to default mode 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Print the satellite flags to the debug line 
.................... uint8_t command_print_flags(uint8_t* data) 
.................... { 
....................     print_flags(); 
....................     return 0; 
.................... } 
....................  
.................... // Send a raw command to ADCS 
.................... uint8_t command_adcs_raw(uint8_t* data) 
.................... { 
....................     enum { adcs_cmd_size = 7 }; 
....................  
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t adcs_command[adcs_cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t msg[MSG_LENGTH_ADCS] = { 0 }; 
....................     msg[0] = 0x0B; 
....................     memcpy(msg + 1, packet->adcs_command, adcs_cmd_size); 
....................     msg[MSG_LENGTH_ADCS - 1] = 0x0C; 
....................  
....................     uart_print_pc_hex(msg, sizeof(msg)); 
....................  
....................     for (uint8_t i = 0; i < sizeof(msg); i++) { 
....................         fputc(msg[i], ADCS); 
....................     } 
....................  
....................     uart_mux = 0; 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_stm32_raw_8_16(uint8_t* data) 
.................... { 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
....................     memcpy(stm32_command_uhf, packet->part, length); 
....................     stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
....................     memset(stm32_command_uhf, 0, STM32_SIZE); 
....................  
....................     fprintf(PC, "STM32 command (8/16)"); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32(uint8_t* data) 
.................... { 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
....................  
....................     if (part == 1) { 
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, 0); 
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_stm32_raw_uhf32_tle(uint8_t* data) 
.................... { 
....................     enum { length = 16 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t part[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t part = ((packet->command & 0x0F) - 1); 
....................  
....................     memcpy(stm32_command_uhf + length * part, packet->part, length); 
....................  
....................     fprintf(PC, "STM32 command (32) part %d. ", part + 1); 
....................  
....................     if (part == 1) { 
....................         stm32_raw_command(stm32_command_uhf, STM32_SIZE, true); 
....................         memset(stm32_command_uhf, 0, STM32_SIZE); 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Receive ADCS telemetry 
.................... uint8_t command_adcs_telemetry(uint8_t* data) 
.................... { 
....................     response_rx = 1; // Received a reply 
....................     uart_mux = 1; 
....................  
....................     fprintf(PC, "ADCS: "); 
....................     fprintf(PC, "Mode=%X | ", data[2]); 
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
....................  
....................     telemetry_time.adcs_time = current_time; 
....................     memcpy(telemetry.adcs_message, data + 2, sizeof(telemetry.adcs_message)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Receive GPS time from ADCS 
.................... uint8_t command_adcs_gps_time(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t hour; 
....................         uint8_t minute; 
....................         uint8_t second; 
....................         uint8_t day; 
....................         uint8_t month; 
....................         uint8_t year; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t valid_time = 0; 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_ADCS); 
....................  
....................     if (packet->year == 0x00 || packet->year >= 38) { 
....................         valid_time = 2; 
....................     } else if (obc_flags.gps_time_sync_state == 1 && boot_flags.deployment_flag >= 5) { 
....................         valid_time = 1; 
....................         struct_tm gps_time; 
....................         gps_time.tm_year = packet->year + 100; 
....................         gps_time.tm_mon = packet->month - 1; 
....................         gps_time.tm_mday = packet->day; 
....................         gps_time.tm_hour = packet->hour; 
....................         gps_time.tm_min = packet->minute; 
....................         gps_time.tm_sec = packet->second + obc_flags.leap_seconds; 
....................  
....................         time_t unix_time = mktime(&gps_time); 
....................  
....................         SetTimeSec(unix_time + 1); 
....................         current_time = time(0); 
....................         reset_pic_update_clock(current_time); 
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
....................         fprintf(PC, "\r\nNew time: %04ld/%02d/%02d %02d:%02d:%02d", gps_time.tm_year + 1900, 
....................             (char)gps_time.tm_mon + 1, 
....................             gps_time.tm_mday, 
....................             gps_time.tm_hour, 
....................             gps_time.tm_min, 
....................             gps_time.tm_sec); 
....................     } 
....................     return valid_time; 
.................... } 
....................  
.................... // ADCS copy high sampling data 
.................... uint8_t command_adcs_hs_copy(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t slots_30m; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t source_address = (1831UL + 6.23 * (uint32_t)packet->slots_30m) * MEMORY_SECTOR_SIZE; 
....................     uint32_t destination_address = FLASH_ADCS_HS_START; 
....................     const uint32_t n_packets = 6.23 * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "\r\n"); 
....................     fprintf(PC, "Copy ADCS HS data to Main PIC\r\n"); 
....................     fprintf(PC, "Source address      = 0x%8lX\r\n", source_address); 
....................     fprintf(PC, "Destination address = 0x%8lX\r\n", destination_address); 
....................     fprintf(PC, "Size                = %lu\r\n", n_packets); 
....................  
....................     struct xmodem_command { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D1 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     } xmodem_command; 
....................     xmodem_command.origin = 0xC0; 
....................     xmodem_command.command = 0xD1; 
....................     xmodem_command.destination_address = destination_address; 
....................     xmodem_command.source = 3;      // ADCS 
....................     xmodem_command.destination = 0; // 0: COM Shared FM 
....................     xmodem_command.source_address = source_address; 
....................     xmodem_command.n_packets = n_packets; 
....................  
....................     uart_print_pc_hex((uint8_t*)&xmodem_command, sizeof(xmodem_command)); 
....................     vschedule(current_time + 1, (uint8_t*)&xmodem_command); 
....................     return 0; 
.................... } 
....................  
.................... // ADCS copy GPS data 
.................... uint8_t command_adcs_gps_copy(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t slots_1h; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint32_t source_address = (1987UL + 5UL * (uint32_t)packet->slots_1h) * MEMORY_SECTOR_SIZE; 
....................     uint32_t destination_address = FLASH_ADCS_GPS_START; 
....................     const uint32_t n_packets = 5UL * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "\r\n"); 
....................     fprintf(PC, "Copy GPS data to Main PIC\r\n"); 
....................     fprintf(PC, "1h slots            = %d\r\n", packet->slots_1h); 
....................     fprintf(PC, "Source address      = 0x%8lX\r\n", source_address); 
....................     fprintf(PC, "Destination address = 0x%8lX\r\n", destination_address); 
....................     fprintf(PC, "Size                = %lu\r\n", n_packets); 
....................  
....................     struct xmodem_command { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D1 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     } xmodem_command; 
....................     xmodem_command.origin = 0xC0; 
....................     xmodem_command.command = 0xD1; 
....................     xmodem_command.destination_address = destination_address; 
....................     xmodem_command.source = 3;      // ADCS 
....................     xmodem_command.destination = 0; // 0: COM Shared FM 
....................     xmodem_command.source_address = source_address; 
....................     xmodem_command.n_packets = n_packets; 
....................  
....................     uart_print_pc_hex((uint8_t*)&xmodem_command, sizeof(xmodem_command)); 
....................     vschedule(current_time + 1, (uint8_t*)&xmodem_command); 
....................     return 0; 
.................... } 
....................  
.................... // Copy ADCS data to COM shared FM 
.................... uint8_t command_copy_adcs_data_to_uhf(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t day_of_the_year; 
....................         uint8_t slot; 
....................     }* packet = (struct packet*)data; 
....................  
....................     const uint8_t sectors_per_day = 5; 
....................     uint32_t source_address = (1UL + (uint32_t)packet->day_of_the_year * (uint32_t)sectors_per_day) * MEMORY_SECTOR_SIZE; 
....................     uint32_t destination_address = FLASH_ADCS_TELEMETRY_START + (uint32_t)packet->slot * (uint32_t)sectors_per_day * MEMORY_SECTOR_SIZE; 
....................     uint32_t n_packets = 5UL * MEMORY_SECTOR_SIZE / XMODEM_DLENGTH; 
....................  
....................     fprintf(PC, "\r\n"); 
....................     fprintf(PC, "Copy ADCS data to Main PIC\r\n"); 
....................     fprintf(PC, "Day of the year     = %lu\r\n", packet->day_of_the_year + 1); 
....................     fprintf(PC, "Source address      = 0x%8lX\r\n", source_address); 
....................     fprintf(PC, "Destination address = 0x%8lX\r\n", destination_address); 
....................     fprintf(PC, "Size                = %lu\r\n", n_packets); 
....................  
....................     struct xmodem_command { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D1 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     } xmodem_command; 
....................     xmodem_command.origin = 0xC0; 
....................     xmodem_command.command = 0xD1; 
....................     xmodem_command.destination_address = destination_address; 
....................     xmodem_command.source = 3;      // ADCS 
....................     xmodem_command.destination = 0; // 0: COM Shared FM 
....................     xmodem_command.source_address = source_address; 
....................     xmodem_command.n_packets = n_packets; 
....................  
....................     uart_print_pc_hex((uint8_t*)&xmodem_command, sizeof(xmodem_command)); 
....................     vschedule(current_time + 1, (uint8_t*)&xmodem_command); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // ============ COM Commands ============ 
....................  
.................... // Message from UHF 
.................... uint8_t command_uhf_message(uint8_t* data) 
.................... { 
....................     enum { length = 22 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t gs_message[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     static uint8_t last_upload[length] = { 0 }; // Stores the last uploaded command 
....................     static time_t last_upload_t = 0; 
....................  
....................     fprintf(PC, "Uplink: "); 
....................     uart_print_pc_hex(packet->gs_message, length); 
....................     uint8_t valid = uplink_valid(packet->gs_message); 
....................     uint8_t different = memcmp(last_upload, packet->gs_message, length) || (last_upload_t <= (current_time - 4 * 60)); // Commands are different within 4 min window 
....................     memcpy(last_upload, packet->gs_message, length); 
....................     last_upload_t = current_time; 
....................     if (valid && different) { 
....................         fprintf(PC, " Valid uplink"); 
....................         uint8_t cmd[BUFF_LENGTH] = { MSG_COMM }; 
....................         uint8_t copy_size = packet->gs_message[2] != 0xCC ? 9 : length; // Don't pass CRC onwards for short commands 
....................         memcpy(cmd + 1, packet->gs_message + 3, copy_size); 
....................         vschedule(current_time, cmd); 
....................     } else { 
....................         fprintf(PC, " Invalid (%d) or identical (%d) uplink.", valid, different); 
....................     } 
....................     return !(valid && different); 
.................... } 
....................  
.................... // Change CW mode flags 
.................... uint8_t command_change_cw_mode_flags(uint8_t* data) 
.................... { 
....................     obc_flags.cw_mode = data[2]; // data[2] is the new flag status 
....................     save_state(data[1]);         // data[1] is the current command ID 
....................     return obc_flags.cw_mode; 
.................... } 
....................  
.................... // Ask ADCS if satellite is over Japan 
.................... uint8_t over_japan_check() 
.................... { 
....................     uint8_t command[] = { 0xFC }; 
....................     stm32_raw_command(command, sizeof(command), false); // Send request to ADCS 
....................  
....................     uint8_t response[2] = { 0 }; 
....................     uart_download_packet(&uart_port_ADCS, response, sizeof(response), 100000); // Try to get a response 
....................  
....................     if (response[1] == 0xA5) { 
....................         return ((int8_t)response[0] > 0); // Elevation > 0 degrees 
....................     } else { 
....................         return false; 
....................     } 
.................... } 
....................  
.................... // Decides if it is OK to send CW or not based on flags and ADCS 
.................... uint8_t ok_to_send_cw() 
.................... { 
....................     switch (obc_flags.cw_mode) { 
....................     case 0: return false; 
....................     case 1: return over_japan_check(); 
....................     case 2: return true; 
....................     default: return false; 
....................     } 
.................... } 
....................  
.................... // COM CW request 
.................... uint8_t command_com_cw(uint8_t* data) 
.................... { 
....................     enum { com_to_main_size = 25 }; 
....................  
....................     static uint8_t current_cw = 0; 
....................     telemetry.com_rssi = *(uint16_t*)&data[2]; 
....................     telemetry_time.com_time = current_time; 
....................  
....................     // Generate CW reply 
....................     uint8_t cmd[24] = { 0 }; 
....................     cmd[0] = 0x0B; 
....................     cmd[1] = 0x50; 
....................     memcpy(cmd + 2, cw[current_cw], sizeof(cw[0])); 
....................     cmd[sizeof(cw[0]) + 2] = ok_to_send_cw(); 
....................     cmd[23] = 0x0C; 
....................     for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], COMM); 
....................     } 
....................     current_cw++; 
....................     if (current_cw >= sizeof(cw) / sizeof(cw[0])) 
....................         current_cw = 0; 
....................     fprintf(PC, "COM: "); 
....................     uart_print_pc_hex(data, com_to_main_size); 
....................     return 0; 
.................... } 
....................  
.................... // COM Access request 
.................... uint8_t command_com_access_request(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x59 
....................         uint8_t time;    // in minutes 
....................     }* packet = (struct packet*)data; 
....................  
....................     time_t disable_time = current_time + (60 * (time_t)packet->time); 
....................     scheduled_command_clear_specified_command(0xC0, 0x58); 
....................     schedule(current_time, { 0xC0, 0x58, 0x01 }); 
....................     schedule(disable_time, { 0xC0, 0x58, 0x00 }); 
....................  
....................     uint8_t reply[8] = { 0 }; 
....................     send_com_ack(reply); 
....................  
....................     return packet->time; 
.................... } 
....................  
.................... // Change COM access 
.................... uint8_t command_com_access_change(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;  // 0xC0 
....................         uint8_t command; // 0x58 
....................         uint8_t state;   // 0: OBC side; 1: COM side 
....................     }* packet = (struct packet*)data; 
....................  
....................     output_bit(MUX_SEL_COM_SHARED_FM, packet->state); 
....................     memory_busy = packet->state; 
....................  
....................     return packet->state; 
.................... } 
....................  
.................... // ============ OBC/PCIB Commands ============ 
....................  
.................... // Schedule any command 
.................... uint8_t command_schedule_anything(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t schedule_time; 
....................         uint8_t schedule_command[12]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     vschedule(packet->schedule_time, packet->schedule_command); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_pcib_telemetry(uint8_t* data) 
.................... { 
....................     fprintf(PC, "RELAY: "); 
....................     response_rx = 1; // Received a reply 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_PCIB); 
....................  
....................     telemetry_time.pcib_time = current_time; 
....................     memcpy(telemetry.pcib_message, data + 2, sizeof(telemetry.pcib_message)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Set the clock to a given value (UNIX time, seconds after Jan 1st 1970) 
.................... uint8_t command_set_clock(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t current_time; 
....................         int8_t leap_seconds; 
....................         uint8_t gps_time_sync_state; 
....................     }* packet = (struct packet*)data; 
....................     obc_flags.leap_seconds = packet->leap_seconds; 
....................     obc_flags.gps_time_sync_state = packet->gps_time_sync_state; 
....................  
....................     uint8_t time_updated = 0; 
....................  
....................     if (packet->current_time < T0) { 
....................         time_updated = 1; 
....................         SetTimeSec(T0); // Set clock to as early as possible (Jan 1st 2000, 00:00:00); 
....................         // mai_400_update_clock(T0); 
....................         reset_pic_update_clock(T0); 
....................     } else { 
....................         SetTimeSec(packet->current_time + obc_flags.leap_seconds); 
....................         reset_pic_update_clock(packet->current_time + obc_flags.leap_seconds); 
....................     } 
....................     current_time = time(0); 
....................  
....................     // Change memory location based on the new date 
....................     flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
....................  
....................     struct_tm* local_time = localtime(&current_time); 
....................  
....................     fprintf(PC, "New time: %04ld/%02d/%02d %02d:%02d:%02d(0x%08lX) ", 
....................         local_time->tm_year + 1900, 
....................         (uint8_t)local_time->tm_mon + 1, 
....................         local_time->tm_mday, 
....................         local_time->tm_hour, 
....................         local_time->tm_min, 
....................         local_time->tm_sec, 
....................         current_time); 
....................  
....................     fprintf(PC, "Leap: %d GPS sync: 0x%02X", obc_flags.leap_seconds, obc_flags.gps_time_sync_state); 
....................     return time_updated; 
.................... } 
....................  
.................... // Display the TRIS status to debug port 
.................... uint8_t command_get_tris(uint8_t* data) 
.................... { 
....................     fprintf(PC, "\n         fedcba9876543210\r\n"); 
....................     fprintf(PC, "tris_a = "); 
....................     print_binary16(get_tris_a()); 
....................     fprintf(PC, "tris_b = "); 
....................     print_binary16(get_tris_b()); 
....................     fprintf(PC, "tris_c = "); 
....................     print_binary16(get_tris_c()); 
....................     fprintf(PC, "tris_d = "); 
....................     print_binary16(get_tris_d()); 
....................     fprintf(PC, "tris_e = "); 
....................     print_binary16(get_tris_e()); 
....................     fprintf(PC, "tris_f = "); 
....................     print_binary16(get_tris_f()); 
....................     fprintf(PC, "tris_g = "); 
....................     print_binary16(get_tris_g()); 
....................     return 0xEE; 
.................... } 
....................  
.................... // Prints a memory address relative to satellite time (if ptr = 0x0000, prints satellite time). 
.................... uint8_t command_print_memory_address(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t ptr; 
....................     }* packet = (struct packet*)data; 
.................... #ifndef PC_SIM 
....................     uint32_t* addr = (uint32_t*)packet->ptr + &current_time; 
....................     fprintf(PC, "*%04lX = %08lX", addr, *addr); 
.................... #endif 
....................     return 0; 
.................... } 
....................  
.................... // Sends the antenna deployment command to relay pic 
.................... uint8_t command_deploy_antenna(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t time_s; 
....................     }* packet = (struct packet*)data; 
....................  
....................     const uint8_t n_tries = 5; // Number of times it try to send PCIB the request 
....................  
....................     if (current_time >= T_ANTENNA) { // Never try to deploy ahead of 31m mark 
....................         // Increment deployment flag and save state 
....................         boot_flags.deployment_flag++; 
....................         get_com_shared_fm_access(); 
....................         uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
....................         flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
....................         flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
....................  
....................         uint8_t time = 30; // in seconds 
....................         if (packet->time_s) { 
....................             time = packet->time_s; 
....................         } 
....................         uint8_t cmd[36] = { 0x0B, 0xDA }; 
....................         cmd[2] = time; 
....................         checksum_obc(cmd, sizeof(cmd)); 
....................         for (uint8_t j = 0; j < n_tries; j++) { 
....................             for (uint8_t i = 0; i < sizeof(cmd); i++) { 
....................                 fputc(cmd[i], PCIB); 
....................             } 
....................             delay_ms(100); 
....................         } 
....................         return 0; 
....................     } else { 
....................         return 1; 
....................     } 
.................... } 
....................  
.................... // Clear completely the main memory. 
.................... uint8_t command_clear_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
....................     flash_erase(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, ERASE_SECTOR); 
....................     fprintf(PC, "Waiting 10s for reset...\r\n"); 
....................     delay_ms(10000); 
....................     reset_cpu(); 
....................     return 0; 
.................... } 
....................  
.................... // Save state to memory. 
.................... uint8_t command_save_state(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
....................     save_state(data[1]); // data[1] is the current command id 
....................     return 0; 
.................... } 
....................  
.................... // Dump state. 
.................... uint8_t command_dump_memory(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t start; 
....................         uint32_t size; 
....................         uint8_t source; 
....................     }* packet = (struct packet*)data; 
....................     fprintf(PC, "\r\nHex dump start"); 
....................     switch (packet->source) { 
....................     case 0: 
....................         get_com_shared_fm_access(); 
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
....................         break; 
....................     case 1: 
....................         flash_dump(&spi_port_MAIN_FM, packet->start, packet->start + packet->size); 
....................         break; 
....................     case 2: 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_dump(&spi_port_MISSION_FM, packet->start, packet->start + packet->size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................         break; 
....................     default: 
....................         get_com_shared_fm_access(); 
....................         flash_dump(&spi_port_COM_FM, packet->start, packet->start + packet->size); 
....................         break; 
....................     } 
....................     fprintf(PC, "\r\nHex dump end\r\n"); 
....................     return packet->source; 
.................... } 
....................  
.................... // Copy data between flash memories 
.................... uint8_t command_copy_memory_sector(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t source_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t origin = packet->origin_port; 
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address_ = (uint32_t)packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t from_address_ = (uint32_t)packet->source_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_sectors * MEMORY_SECTOR_SIZE; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX", origin, dest, to_address_, from_address_, size); 
....................  
....................     get_com_shared_fm_access(); 
....................  
....................     // Erase the pages before copying 
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             flash_erase(&spi_port_COM_FM, to_address_ + i, ERASE_SECTOR); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address_ + i, ERASE_SECTOR); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address_ + i, ERASE_SECTOR); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     if (origin == 0x00 && dest == 0x00) { 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x00 && dest == 0x01) { 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x00 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x01 && dest == 0x00) { 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x01 && dest == 0x01) { 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x01 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x00) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x01) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else { 
....................         return 1; 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Copy data between flash memories 
.................... uint8_t command_copy_memory_page(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t source_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................         uint8_t origin_port;      // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t origin = packet->origin_port; 
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address_ = (uint32_t)packet->destination_page * MEMORY_PAGE_SIZE; 
....................     uint32_t from_address_ = (uint32_t)packet->source_page * MEMORY_PAGE_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_pages * MEMORY_PAGE_SIZE; 
....................  
....................     fprintf(PC, "memcpy orig=%d,dest=%d,to_addr=%lX,from_addr=%lX,size=%lX", origin, dest, to_address_, from_address_, size); 
....................  
....................     get_com_shared_fm_access(); 
....................  
....................     // Erase the pages before copying 
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             flash_erase(&spi_port_COM_FM, to_address_ + i, ERASE_PAGE); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address_ + i, ERASE_PAGE); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address_ + i, ERASE_PAGE); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     if (origin == 0x00 && dest == 0x00) { 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x00 && dest == 0x01) { 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x00 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_COM_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x01 && dest == 0x00) { 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x01 && dest == 0x01) { 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
....................  
....................     } else if (origin == 0x01 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MAIN_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x00) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_COM_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x01) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MAIN_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else if (origin == 0x02 && dest == 0x02) { 
....................         output_low(MUX_SEL_MSN_SHARED_FM); 
....................         flash_transfer_data_to_flash(&spi_port_MISSION_FM, from_address_, &spi_port_MISSION_FM, to_address_, size); 
....................         output_high(MUX_SEL_MSN_SHARED_FM); 
....................  
....................     } else { 
....................         return 1; 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_page(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_page; 
....................         uint16_t n_pages; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_page * MEMORY_PAGE_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_pages * MEMORY_PAGE_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
....................  
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_PAGE); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_PAGE); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_PAGE_SIZE) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_PAGE); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Erase data from flash memory 
.................... uint8_t command_erase_memory_sector(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint16_t destination_sector; 
....................         uint16_t n_sectors; 
....................         uint8_t destination_port; // 0:COM, 1:MAIN, 2:MISSION 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t dest = packet->destination_port; 
....................  
....................     uint32_t to_address = (uint32_t)packet->destination_sector * MEMORY_SECTOR_SIZE; 
....................     uint32_t size = (uint32_t)packet->n_sectors * MEMORY_SECTOR_SIZE; 
....................  
....................     get_com_shared_fm_access(); 
....................  
....................     if (dest == 0x00) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             flash_erase(&spi_port_COM_FM, to_address + i, ERASE_SECTOR); 
....................         } 
....................     } else if (dest == 0x01) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             flash_erase(&spi_port_MAIN_FM, to_address + i, ERASE_SECTOR); 
....................         } 
....................     } else if (dest == 0x02) { 
....................         for (uint32_t i = 0; i < size; i += MEMORY_SECTOR_SIZE) { 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             flash_erase(&spi_port_MISSION_FM, to_address + i, ERASE_SECTOR); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................         } 
....................     } 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Send data through xmodem protocol 
.................... uint8_t command_xmodem_send(uint8_t* data) 
.................... { 
....................     const uint8_t max_tries = 5; 
....................     uint8_t current_try = 0; 
....................     struct packet { 
....................         uint8_t origin;  // C0 
....................         uint8_t command; // D0 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t destination_address; 
....................     }* packet = (struct packet*)data; 
....................     int8_t error = 0; 
....................     fprintf(PC, "Waiting for xmodem transfer..."); 
....................  
....................     uart_fn* destination_uart = NULL; 
....................  
....................     while (current_try < max_tries) { 
....................         switch (packet->destination) { 
....................         case 0: destination_uart = &uart_port_PC; break;   // For PC 
....................         case 1: destination_uart = &uart_port_PCIB; break; // For PCIB 
....................         case 2: destination_uart = &uart_port_PCIB; break; // For Rpi 
....................         default: destination_uart = &uart_port_PC; break; 
....................         } 
....................  
....................         if (packet->destination == 2) {                                                     // Rpi 
....................             uint8_t message_pcib[MSG_LENGTH_PCIB] = { 0x0B, 0xCD };                         // Array with request for direct copy relay -> rpi = 0xCD 
....................             checksum_obc(message_pcib, MSG_LENGTH_PCIB);                                    // Add checksum 
....................             uart_send_packet_repeat(&uart_port_PCIB, message_pcib, MSG_LENGTH_PCIB, 5, 10); // Send request 5 times, 100ms spaced 
....................             delay_ms(1000); 
....................             fprintf(PCIB, "\nrx,%05lu\n", packet->destination_address); 
....................         } 
....................  
....................         if (packet->destination == 1) { // PCIB 
....................             struct req { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint8_t source; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 9]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req; 
....................             req.origin = MSG_OBC; 
....................             req.command = 0xD1; // X-modem receive; 
....................             req.address = packet->destination_address; 
....................             req.source = 1; // OBC 
....................             checksum_obc((uint8_t*)&req, sizeof(req)); 
....................             uart_send_packet_repeat(&uart_port_PCIB, (uint8_t*)&req, sizeof(req), 5, 10); 
....................         } 
....................  
....................         switch (packet->source) { 
....................         case 0: 
....................             get_com_shared_fm_access(); 
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, packet->source_address, packet->n_packets); 
....................             break; 
....................         case 1: 
....................             error = xmodem_send(destination_uart, &spi_port_MAIN_FM, packet->source_address, packet->n_packets); 
....................             break; 
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             error = xmodem_send(destination_uart, &spi_port_MISSION_FM, packet->source_address, packet->n_packets); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................             break; 
....................         default: 
....................             get_com_shared_fm_access(); 
....................             error = xmodem_send(destination_uart, &spi_port_COM_FM, packet->source_address, packet->n_packets); 
....................             break; 
....................         } 
....................         current_try++; 
....................         delay_ms(1000); 
....................         if (error != -1) 
....................             break; 
....................     } 
....................     return error; 
.................... } 
....................  
.................... // Receive data through xmodem protocol 
.................... uint8_t command_xmodem_receive(uint8_t* data) 
.................... { 
....................     const uint8_t max_tries = 5; 
....................     uint8_t current_try = 0; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint32_t destination_address; 
....................         uint8_t source; 
....................         uint8_t destination; 
....................         uint32_t source_address; 
....................         uint32_t n_packets; 
....................     }* packet = (struct packet*)data; 
....................     int8_t total_packets = 0; 
....................     fprintf(PC, "Receiving xmodem data..."); 
....................  
....................     uart_fn* source_uart = NULL; 
....................  
....................     switch (packet->source) { 
....................     case 0: source_uart = &uart_port_PC; break; 
....................     case 1: source_uart = &uart_port_PCIB; break; 
....................     case 3: source_uart = &uart_port_ADCS; break; 
....................     default: source_uart = &uart_port_PC; break; 
....................     } 
....................  
....................     while (current_try < max_tries) { 
....................         if (packet->source == 1) { // PCIB 
....................             struct req_pcib { 
....................                 uint8_t origin; 
....................                 uint8_t command; 
....................                 uint32_t address; 
....................                 uint32_t n_packets; 
....................                 uint8_t destination; 
....................                 uint8_t padding[MSG_LENGTH_PCIB - 13]; 
....................                 uint8_t checksum; 
....................                 uint8_t footer; 
....................             } req_pcib; 
....................             req_pcib.origin = MSG_OBC; 
....................             req_pcib.command = 0xD0; // X-modem send; 
....................             req_pcib.address = packet->source_address; 
....................             req_pcib.n_packets = packet->n_packets; 
....................             req_pcib.destination = 1; // OBC 
....................             checksum_obc((uint8_t*)&req_pcib, sizeof(req_pcib)); 
....................             uart_send_packet_repeat(source_uart, (uint8_t*)&req_pcib, sizeof(req_pcib), 1, 10); 
....................             delay_ms(100); 
....................         } 
....................         if (packet->source == 2 || packet->source == 3) { 
....................             delay_ms(5000); 
....................         } 
....................  
....................         switch (packet->destination) { 
....................         case 0: 
....................             get_com_shared_fm_access(); 
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, packet->destination_address); 
....................             break; 
....................         case 1: 
....................             total_packets = xmodem_receive(source_uart, &spi_port_MAIN_FM, packet->destination_address); 
....................             break; 
....................         case 2: 
....................             output_low(MUX_SEL_MSN_SHARED_FM); 
....................             total_packets = xmodem_receive(source_uart, &spi_port_MISSION_FM, packet->destination_address); 
....................             output_high(MUX_SEL_MSN_SHARED_FM); 
....................             break; 
....................         default: 
....................             get_com_shared_fm_access(); 
....................             total_packets = xmodem_receive(source_uart, &spi_port_COM_FM, packet->destination_address); 
....................             break; 
....................         } 
....................         current_try++; 
....................         delay_ms(1000); 
....................         if (total_packets != -1) 
....................             break; 
....................     } 
....................     return total_packets; 
.................... } 
....................  
.................... uint8_t command_clear_all_schedule_commands(uint8_t* data) 
.................... { 
....................     scheduled_command_clear_all(); 
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_boot_flag_set(uint8_t* data) 
.................... { 
....................     get_com_shared_fm_access(); 
....................     uint8_t value = data[2]; 
....................     boot_flags.deployment_flag = value; 
....................     uint8_t* boot_flag_ptr = (uint8_t*)&boot_flags; 
....................     flash_erase_pages(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, BOOT_FLAGS_ADDRESS + sizeof(boot_flags)); 
....................     flash_transfer_data_from_ram(&spi_port_COM_FM, BOOT_FLAGS_ADDRESS, boot_flag_ptr, sizeof(boot_flags)); 
....................     scheduled_command_clear_all(); 
....................     return value; 
.................... } 
....................  
.................... // Reset log command 
.................... uint8_t command_reset_log(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Main PIC reset detected."); 
....................     return boot_flags.deployment_flag; 
.................... } 
....................  
.................... // Telemetry keeping function 
.................... uint8_t command_save_telemetry(uint8_t* data) 
.................... { 
....................     uart_mux = 1; 
....................     if (!memory_busy) { 
....................         // Write the obc timestamp to telemetry and relative collection times 
....................         telemetry.obc_time = current_time; 
....................         telemetry.reset_time = current_time - telemetry_time.reset_time > 255 ? 255 : current_time - telemetry_time.reset_time; 
....................         telemetry.fab_time = current_time - telemetry_time.fab_time > 255 ? 255 : current_time - telemetry_time.fab_time; 
....................         telemetry.pcib_time = current_time - telemetry_time.pcib_time > 255 ? 255 : current_time - telemetry_time.pcib_time; 
....................         telemetry.adcs_time = current_time - telemetry_time.adcs_time > 255 ? 255 : current_time - telemetry_time.adcs_time; 
....................         telemetry.com_time = current_time - telemetry_time.com_time > 255 ? 255 : current_time - telemetry_time.com_time; 
....................  
....................         // Save telemetry to flash 
....................         uint8_t* telemetry_data = (uint8_t*)&telemetry; 
....................         flash_cycle_write(&spi_port_COM_FM, telemetry_data, &addr_flags.flash_telemetry); 
....................         fprintf(PC, "Saving telemetry data: "); 
....................         fprintf(PC, "Addr: 0x%08lX ", addr_flags.flash_telemetry.current - sizeof(telemetry)); 
....................  
....................         build_cw();             // Prepare CW strings 
....................         initialize_telemetry(); // Reset for next iteration 
....................  
....................         // Save satellite log to flash 
....................         log_flush(); 
....................  
....................         // Save addresses to flash 
....................         struct addr { 
....................             uint32_t flash_log_current; 
....................             uint32_t flash_telemetry_current; 
....................         } addr; 
....................  
....................         uint8_t* addr_flag_ptr = (uint8_t*)&addr; 
....................  
....................         addr.flash_log_current = addr_flags.flash_log.current; 
....................         addr.flash_telemetry_current = addr_flags.flash_telemetry.current; 
....................  
....................         flash_cycle_write(&spi_port_COM_FM, addr_flag_ptr, &addr_flags.flash_addr); 
....................         return 0; 
....................     } else { 
....................         fprintf(PC, "Skipping saving telemetry data."); 
....................         return 1; 
....................     } 
.................... } 
....................  
.................... // Change OCP's default state 
.................... uint8_t command_ocp_state(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin;     // 0xC0 
....................         uint8_t command;    // 0xAE 
....................         uint8_t on_off;     // 0: off; 1: on 
....................         uint8_t ocp_number; // 0: adcs; 1: pcib 
....................     }* packet = (struct packet*)data; 
....................  
....................     enum { ocp_adcs = 0, 
....................         ocp_pcib = 1 }; 
....................  
....................     switch (packet->ocp_number) { 
....................     case ocp_adcs: 
....................         output_bit(OCP_EN_ADCS, packet->on_off); 
....................         obc_flags.adcs_on_off = packet->on_off; 
....................         return obc_flags.adcs_on_off; 
....................         break; 
....................     case ocp_pcib: 
....................         output_bit(OCP_EN_PCIB, packet->on_off); 
....................         obc_flags.pcib_on_off = packet->on_off; 
....................         return obc_flags.pcib_on_off; 
....................         break; 
....................     } 
....................  
....................     return -1; 
.................... } 
....................  
.................... // void boot_commands_clear_nth(uint8_t n) 
.................... uint8_t command_boot_cmd_clear_nth(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t n; 
....................     }* packet = (struct packet*)data; 
....................     boot_commands_clear_nth(packet->n); 
....................     boot_commands_write(); 
....................     return 0; 
.................... } 
....................  
.................... // void boot_commands_clear_all() 
.................... uint8_t command_boot_cmd_clear_all(uint8_t* data) 
.................... { 
....................     boot_commands_clear_all(); 
....................     boot_commands_write(); 
....................     return 0; 
.................... } 
....................  
.................... // Add a boot command 
.................... uint8_t command_boot_cmd_add(uint8_t* data) 
.................... { 
....................     enum { length = MSG_LENGTH_COMM - 13 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         time_t delay_from_boot; 
....................         uint8_t new_boot_cmd[length]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     boot_command bc; 
....................     bc.time = packet->delay_from_boot; 
....................     memcpy(bc.command, packet->new_boot_cmd, length); 
....................     boot_commands_add(bc); 
....................     boot_commands_write(); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // ============ Reset Commands ============ 
....................  
.................... // Reset pic telemetry data 
.................... uint8_t command_reset_telemetry(uint8_t* data) 
.................... { 
....................     response_rx = 1; // Received a reply 
....................     struct packet { 
....................         uint8_t message[MSG_LENGTH_RST - 10]; 
....................         uint8_t padding[9]; // empty part 
....................         uint8_t footer; 
....................     }* packet = (struct packet*)data; 
....................  
....................     fprintf(PC, "RESET: "); 
....................     uart_print_pc_hex(data, MSG_LENGTH_RST); 
....................  
....................     if (rst_clock_update) { 
....................         rst_clock_updated = 1; 
....................         rst_clock_update = 0; 
....................         struct_tm rst_time; 
....................         rst_time.tm_year = (unsigned long)packet->message[2] + 100; 
....................         rst_time.tm_mon = (unsigned long)packet->message[3] - 1; 
....................         rst_time.tm_mday = (unsigned long)packet->message[4]; 
....................         rst_time.tm_hour = (unsigned long)packet->message[5]; 
....................         rst_time.tm_min = (unsigned long)packet->message[6]; 
....................         rst_time.tm_sec = (unsigned long)packet->message[7] + 1; 
....................         SetTime(&rst_time); 
....................         time_t new_time = mktime(&rst_time); 
....................         // mai_400_update_clock(new_time); 
....................         current_time = new_time; 
....................         previous_time = new_time; 
....................         reset_time = new_time; 
....................         // Read stored commands from memory 
....................         get_com_shared_fm_access(); 
....................         uint8_t* cmd_ptr = (uint8_t*)scheduled_commands; 
....................         flash_transfer_data_to_ram( 
....................             &spi_port_COM_FM, 
....................             SCHEDULED_CMD_ADDRESS, 
....................             cmd_ptr, 
....................             sizeof(scheduled_commands)); 
....................         // Remove scheduled commads that are scheduled to run in the past 
....................         for(uint8_t i = 0; i < SCHEDULED_COMMANDS_MAX; i++) { 
....................             if(scheduled_commands[i].time < current_time + 1800L) { 
....................                 scheduled_commands[i].time = TIME_T_MAX; 
....................                 fprintf(PC, "\r\nWarning: a scheduled command (%02X %02X) in flash memory was scheduled to run in a past date/time and was marked as complete.\r\n", scheduled_commands[i].command[0], scheduled_commands[i].command[1]); 
....................             } 
....................         } 
....................         // Read and schedule boot commands 
....................         boot_commands_schedule(); 
....................         // Change memory location based on the new date 
....................         flash_initialize_flash_ctrl_from_memory_date_based(FLASH_TELEMETRY_SECTORS_PER_DAY, boot_flags.deployment_flag, addr_flags.flash_telemetry.current, FLASH_TELEMETRY_START, FLASH_TELEMETRY_DELTA, true, &addr_flags.flash_telemetry); 
....................  
....................         struct_tm* local_time = localtime(&current_time); 
....................         fprintf(PC, " New time: %04ld/%02d/%02d %02d:%02d:%02d (0x%08lX)", 
....................             local_time->tm_year + 1900, 
....................             (uint8_t)local_time->tm_mon + 1, 
....................             local_time->tm_mday, 
....................             local_time->tm_hour, 
....................             local_time->tm_min, 
....................             local_time->tm_sec, 
....................             current_time); 
....................     } 
....................  
....................     telemetry_time.reset_time = current_time; 
....................     memcpy(telemetry.reset_message, packet->message + 2, sizeof(telemetry.reset_message)); 
....................     return rst_clock_updated; 
.................... } 
....................  
.................... // Warn that 24-hour reset is about to happen 
.................... uint8_t command_reset_warning(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................  
....................     // uint8_t adcs_cmd[] = { 0x22 }; 
....................     // mai_400_command(adcs_cmd, sizeof(adcs_cmd)); 
....................  
....................     save_state(data[1]); // data[1] is the current command id 
....................  
....................     // Reply: 
....................     const uint8_t cmd[36] = { 
....................         0xB0, 0xA2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
....................         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB1 
....................     }; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     uart_clean(RST); 
....................  
....................     fprintf(PC, "Waiting for 24h reset...\r\n"); 
....................     delay_ms(60000); 
....................     delay_ms(60000); 
....................     fprintf(PC, "No 24h reset happened, doing soft reset instead.\r\n"); 
....................     reset_cpu(); 
....................  
....................     return 0; 
.................... } 
....................  
.................... // Reset pic acknowledge of time change 
.................... uint8_t command_time_change_ack(uint8_t* data) 
.................... { 
....................     fprintf(PC, "Reset PIC time change ACK."); 
....................     return 0; 
.................... } 
....................  
.................... // Passes a command from ground-station to reset pic 
.................... uint8_t command_send_data_to_reset(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................     struct packet { 
....................         uint8_t command;     // C0: comm pic message 
....................         uint8_t reset_cmd;   // F5: reset message 
....................         uint8_t data[8];     // data to be passed to reset pic 
....................         uint8_t silent_mode; // if equals to 1, do not print debug message 
....................     }* packet = (struct packet*)data; 
....................     uint8_t cmd[36] = { 0 }; 
....................     cmd[0] = 0xB0; 
....................     for (i = 0; i < 8; i++) { 
....................         cmd[i + 1] = packet->data[i]; 
....................     } 
....................     cmd[35] = 0xB1; 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], RST); 
....................     } 
....................     if (packet->silent_mode != 1) 
....................         uart_print_pc_hex(cmd, sizeof(cmd)); 
....................     return 0; 
.................... } 
....................  
.................... // ============ EPS Commands ============ 
....................  
.................... uint8_t command_eps_telemetry(uint8_t* data) 
.................... { 
....................     enum { cmd_len = 7 }; 
....................     response_rx = 1; // Received a reply 
....................     fprintf(PC, "EPS: "); 
....................  
....................     uint16_t voltage_hex = make16(data[46], data[47]); 
....................     uint16_t current_hex = make16(data[50], data[51]); 
....................     uint16_t temperature_hex = make16(data[52], data[53]); 
....................  
....................     float voltage = voltage_hex * 3.3 * 3 / 4096; 
....................     float current = (3835. * current_hex * 3.3 / 4096) - 6396.3; 
....................     float temperature = 75 - temperature_hex * 3.256 * 30 / 4096; 
....................     fprintf(PC, "V=%f, C=%f, T=%f | ", voltage, current, temperature); 
....................  
....................     uint16_t heater_ref_temperature = make16(data[56], data[57]); 
....................     uint16_t heater_ref_voltage = make16(data[58], data[59]); 
....................  
....................     if ((heater_ref_temperature != obc_flags.heater_ref_temperature) || (heater_ref_voltage != obc_flags.heater_ref_voltage)) { 
....................         // E0 66 TH TL VH VL 
....................         fprintf(PC, " New T=0x%04lX, V=0x%04lX | ", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
....................         uint8_t cmd_temp[cmd_len]; 
....................         cmd_temp[0] = 0xC0;                                      // COM_MSG 
....................         cmd_temp[1] = 0x6C;                                      // OBC_CMD 
....................         cmd_temp[2] = 0x66;                                      // EPS_CMD 
....................         cmd_temp[3] = (obc_flags.heater_ref_temperature >> 8);   // TEMP_HIGH 
....................         cmd_temp[4] = (obc_flags.heater_ref_temperature & 0xFF); // TEMP_LOW 
....................         cmd_temp[5] = (obc_flags.heater_ref_voltage >> 8);       // V_HIGH 
....................         cmd_temp[6] = (obc_flags.heater_ref_voltage & 0xFF);     // V_LOW 
....................         vschedule(current_time + 5, cmd_temp); 
....................     } 
....................  
....................     uart_print_pc_hex(data, MSG_LENGTH_FAB); 
....................     telemetry_time.fab_time = current_time; 
....................     memcpy(telemetry.fab_message, data + 2, sizeof(telemetry.fab_message)); 
....................     return 0; 
.................... } 
....................  
.................... // Passes a command from ground-station to eps pic 
.................... uint8_t command_send_data_to_eps(uint8_t* data) 
.................... { 
....................     uint8_t i; 
....................     enum { data_size = 5 }; 
....................     struct packet { 
....................         uint8_t command;         // C0: com pic message 
....................         uint8_t eps_cmd;         // 6C: eps message 
....................         uint8_t data[data_size]; // data to be passed to reset pic 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t cmd[data_size + 1] = { 0 }; 
....................     cmd[0] = 0xE0; 
....................     for (i = 0; i < data_size; i++) { 
....................         cmd[i + 1] = packet->data[i]; 
....................     } 
....................     for (i = 0; i < sizeof(cmd); i++) { 
....................         fputc(cmd[i], FAB); 
....................     } 
....................  
....................     fprintf(PC, "EPS cmd: "); 
....................     uart_print_pc_hex(cmd, sizeof(cmd)); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_eps_set_heater_ref(uint8_t* data) 
.................... { 
....................     struct packet { 
....................         uint8_t command;   // C0: com pic message 
....................         uint8_t eps_cmd;   // 6D: heater ref settings 
....................         uint16_t temp_ref; // temperature reference 
....................         uint16_t v_ref;    // voltage reference 
....................     }* packet = (struct packet*)data; 
....................  
....................     obc_flags.heater_ref_temperature = packet->temp_ref; 
....................     obc_flags.heater_ref_voltage = packet->v_ref; 
....................     save_state(packet->eps_cmd); 
....................  
....................     fprintf(PC, "New T=0x%04lX, V=0x%04lX", obc_flags.heater_ref_temperature, obc_flags.heater_ref_voltage); 
....................  
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_obc_kill_on(uint8_t* data) 
.................... { 
....................     uint8_t kill_sw_status = 0; 
....................     if (data[2] == 0x55 && data[4] == 0x55 && data[6] == 0x55 && data[8] == 0x55 && data[3] == 0xAA && data[5] == 0xAA && data[7] == 0xAA && data[9] == 0xAA) { 
....................         kill_sw_status = 1; 
....................         output_high(PIN_A4); 
....................     } 
....................     return kill_sw_status; 
.................... } 
....................  
.................... uint8_t command_obc_kill_off(uint8_t* data) 
.................... { 
....................     output_low(PIN_A4); 
....................     return 0; 
.................... } 
....................  
.................... uint8_t command_raw_pcib(uint8_t* data) 
.................... { 
....................     enum { cmd_size = 8 }; 
....................     struct packet { 
....................         uint8_t origin; 
....................         uint8_t command; 
....................         uint8_t pcib_command[cmd_size]; 
....................     }* packet = (struct packet*)data; 
....................  
....................     uint8_t pcib_cmd[MSG_LENGTH_PCIB] = { 0 }; 
....................     pcib_cmd[0] = 0x0B; 
....................     memcpy(pcib_cmd + 1, packet->pcib_command, cmd_size); 
....................     checksum_obc(pcib_cmd, MSG_LENGTH_PCIB); 
....................     uart_send_packet_repeat(&uart_port_PCIB, pcib_cmd, MSG_LENGTH_PCIB, 5, 10); 
....................     return packet->pcib_command[0]; 
.................... } 
....................  
.................... // Used to stop the simulation 
.................... uint8_t command_debug(uint8_t* data) 
.................... { 
.................... #ifdef PC_SIM 
....................     fprintf(PC, "Exiting simulation"); 
....................     continue_program = 0; 
.................... #else 
....................     for (uint32_t i = 0; i < 65536; i++) { 
....................         fprintf(PC, "%02X:%02X:%d\r\n", (uint8_t)(i >> 8), (uint8_t)(i & 0xFF), (int8_t)gyro_to_cw((uint8_t)(i >> 8), (uint8_t)(i & 0xFF))); 
....................     } 
.................... #endif // !PC_SIM 
....................     return 0; 
.................... } 
....................  
.................... // ===================================================== 
....................  
.................... // Function that executes a command, by looking up on the table of available commands. 
.................... void command_execute(uint8_t* data, uint8_t origin, uint8_t log_enabled) 
.................... { 
....................     uint8_t error = 0; 
....................  
....................     if (origin == data[0] || origin == MSG_WILDCARD) { 
....................  
....................         // COM reply 
....................         if (data[0] == 0xC0) { 
....................             if (data[1] == 0x42) { 
....................                 if (data[4] != 0x00) { // 0x00 is a request for memory dump 
....................                     send_com_ack(data + 2); 
....................                 } else { 
.................... #ifndef PC_SIM 
....................                     uint32_t* ptr = *(uint32_t*)&data[5]; 
....................                     send_com_ack(ptr + &current_time); 
.................... #endif 
....................                 } 
....................             } 
....................         } 
....................  
....................         // Satellite log 
....................         log_entry log; 
....................         log.origin = data[0]; 
....................         log.command = data[1]; 
....................  
....................         struct_tm* local_time = localtime(&current_time); 
....................  
....................         // Execute command 
....................         if (log_enabled) 
....................             fprintf(PC, "%04ld/%02d/%02d %02d:%02d:%02d | %02d | %02X %02X | ", local_time->tm_year + 1900, 
....................                 (uint8_t)local_time->tm_mon + 1, 
....................                 local_time->tm_mday, 
....................                 local_time->tm_hour, 
....................                 local_time->tm_min, 
....................                 local_time->tm_sec, 
....................                 scheduled_command_count(), 
....................                 data[0], 
....................                 data[1]); 
....................  
....................         uint16_t command = make16(data[0], data[1]); 
....................  
....................         // The table of available commands. 
....................         switch (command) { 
....................         case 0xABAA: error = command_pcib_telemetry(data); break; 
....................         case 0xAD90: error = command_adcs_telemetry(data); break; 
....................         case 0xADDA: error = command_adcs_gps_time(data); break; 
....................         case 0xC000: error = command_print_memory_address(data); break; 
....................         case 0xC001: error = command_set_clock(data); break; 
....................         case 0xC00A: error = command_copy_memory_page(data); break; 
....................         case 0xC00B: error = command_copy_memory_sector(data); break; 
....................         case 0xC00C: error = command_erase_memory_page(data); break; 
....................         case 0xC00D: error = command_erase_memory_sector(data); break; 
....................         // - 0xC010: reserved for COM 
....................         // - 0xC011: reserved for COM 
....................         // - 0xC013: reserved for COM 
....................         // - 0xC014: reserved for COM 
....................         // - 0xC015: reserved for COM 
....................         // - 0xC016: reserved for COM 
....................         // - 0xC017: reserved for COM 
....................         // - 0xC020: reserved for COM 
....................         // - 0xC021: reserved for COM 
....................         // - 0xC022: reserved for COM 
....................         // - 0xC023: reserved for COM 
....................         // - 0xC024: reserved for COM 
....................         case 0xC025: error = command_boot_cmd_clear_nth(data); break; 
....................         case 0xC026: error = command_boot_cmd_clear_all(data); break; 
....................         // - 0xC027: reserved for COM 
....................         case 0xC028: error = command_boot_cmd_add(data); break; 
....................         // - 0xC030: reserved for COM 
....................         // - 0xC035: reserved for COM 
....................         // - 0xC040: reserved for COM 
....................         // - 0xC041: reserved for COM 
....................         case 0xC042: error = command_uhf_message(data); break; 
....................         // - 0xC044: reserved for COM 
....................         case 0xC050: error = command_com_cw(data); break; 
....................         case 0xC055: error = command_save_state(data); break; 
....................         case 0xC058: error = command_com_access_change(data); break; 
....................         case 0xC059: error = command_com_access_request(data); break; 
....................         case 0xC060: error = command_obc_kill_on(data); break; 
....................         case 0xC061: error = command_obc_kill_off(data); break; 
....................         case 0xC06C: error = command_send_data_to_eps(data); break; 
....................         case 0xC06D: error = command_eps_set_heater_ref(data); break; 
....................         case 0xC070: error = command_stm32_raw_8_16(data); break; 
....................         case 0xC071: error = command_stm32_raw_uhf32(data); break; 
....................         case 0xC072: error = command_stm32_raw_uhf32(data); break; 
....................         case 0xC090: error = command_request_reset(data); break; 
....................         case 0xC091: error = command_request_eps(data); break; 
....................         case 0xC092: error = command_request_pcib(data); break; 
....................         case 0xC093: error = command_request_adcs(data); break; 
....................         case 0xC0A1: error = command_stm32_raw_uhf32_tle(data); break; 
....................         case 0xC0A2: error = command_stm32_raw_uhf32_tle(data); break; 
....................         case 0xC0A6: error = command_adcs_default_mode(data); break; 
....................         case 0xC0A8: error = command_adcs_gps_copy(data); break; 
....................         case 0xC0A9: error = command_adcs_hs_copy(data); break; 
....................         case 0xC0AD: error = command_adcs_mode(data); break; 
....................         case 0xC0AE: error = command_ocp_state(data); break; 
....................         case 0xC0AF: error = command_adcs_raw(data); break; 
....................         case 0xC0CC: error = command_raw_pcib(data); break; 
....................         case 0xC0CD: error = command_change_cw_mode_flags(data); break; 
....................         case 0xC0C5: error = command_clear_state(data); break; 
....................         case 0xC0D0: error = command_xmodem_send(data); break; 
....................         case 0xC0D1: error = command_xmodem_receive(data); break; 
....................         case 0xC0DA: error = command_deploy_antenna(data); break; 
....................         case 0xC0DB: error = command_debug(data); break; 
....................         case 0xC0DD: error = command_dump_memory(data); break; 
....................         case 0xC0DF: error = command_get_tris(data); break; 
....................         case 0xC0E4: error = command_copy_adcs_data_to_uhf(data); break; 
....................         case 0xC0F5: error = command_send_data_to_reset(data); break; 
....................         case 0xC0F6: error = command_schedule_anything(data); break; 
....................         case 0xC0F7: error = command_schedule_mode(data); break; 
....................         case 0xC0F8: error = command_save_telemetry(data); break; 
....................         case 0xC0F9: error = command_clear_all_schedule_commands(data); break; 
....................         // - 0xC0FA: reserved for COM 
....................         // - 0xC0FB: reserved for COM 
....................         case 0xC0FC: error = command_print_flags(data); break; 
....................         case 0xC0FE: error = command_boot_flag_set(data); break; 
....................         case 0xE033: error = command_eps_telemetry(data); break; 
....................         case 0xB0A0: error = command_reset_telemetry(data); break; 
....................         case 0xB0A2: error = command_reset_warning(data); break; 
....................         case 0xB070: error = command_time_change_ack(data); break; 
....................         case 0xDBFF: error = command_reset_log(data); break; 
....................         default: error = command_get_tris(data); break; 
....................         } 
....................  
....................         if (log_enabled) { 
....................             fprintf(PC, " (Ret: %02X)", error); 
....................         } 
....................  
....................         // Satellite log 
....................         log.time = current_time; 
....................         log.return_value = error; 
....................  
....................         if (log_enabled && command != 0xB0A0 && command != 0xE033 && command != 0xABAA && command != 0xAD90 && command != 0xC050 && command != 0xC0F8) 
....................             log_add(log); 
....................  
....................         if (log_enabled) 
....................             fprintf(PC, "\r\n"); 
....................     } 
.................... } 
....................  
.................... #endif /* INTERPRETER_H */ 
....................  
....................  
.................... #INT_RDA // PCIB 
.................... void interrupt_rda() 
.................... { 
....................     uart_update(PCIB, message_PCIB); // Receive data 
*
00AA2:  RCALL  0A8C
00AA4:  MOVFF  01,B24
00AA8:  MOVLW  07
00AAA:  MOVLB  B
00AAC:  MOVWF  x35
00AAE:  MOVLW  EA
00AB0:  MOVWF  x34
00AB2:  MOVFF  7A5,B37
00AB6:  MOVFF  7A4,B36
00ABA:  MOVFF  B24,B38
.................... } 
....................  
*
00E50:  BCF    F9E.5
00E52:  MOVLB  0
00E54:  GOTO   009C
.................... #INT_RDA2 HIGH // COM 
.................... void interrupt_rda2() 
.................... { 
....................     uart_update(COMM, message_COMM); // Receive data 
*
00E72:  RCALL  0E58
00E74:  MOVFF  01,B33
00E78:  MOVLW  08
00E7A:  MOVLB  B
00E7C:  MOVWF  x35
00E7E:  MOVLW  23
00E80:  MOVWF  x34
00E82:  MOVFF  7A3,B37
00E86:  MOVFF  7A2,B36
00E8A:  MOVFF  B33,B38
....................     if (uart_ready(COMM)) {          // If ready, execute imediately 
*
01220:  MOVLB  8
01222:  MOVF   x2A,W
01224:  SUBLW  02
01226:  BNZ   122E
....................         set_timer0(1); 
01228:  CLRF   FD7
0122A:  MOVLW  01
0122C:  MOVWF  FD6
....................     } 
.................... } 
....................  
0122E:  BCF    FA4.5
01230:  MOVLB  0
01232:  GOTO   0148
.................... #INT_RDA3 // FAB 
.................... void interrupt_rda3() 
.................... { 
....................     uart_update(FAB, message_FAB); // Receive data 
*
01250:  RCALL  1236
01252:  MOVFF  01,B24
01256:  MOVLW  08
01258:  MOVLB  B
0125A:  MOVWF  x35
0125C:  MOVLW  91
0125E:  MOVWF  x34
01260:  MOVFF  7A9,B37
01264:  MOVFF  7A8,B36
01268:  MOVFF  B24,B38
.................... } 
....................  
*
015FE:  BCF    FA6.5
01600:  MOVLB  0
01602:  GOTO   009C
.................... #INT_RDA4 // RST 
.................... void interrupt_rda4() 
.................... { 
....................     uart_update(RST, message_RST); // Receive data 
*
01620:  RCALL  1606
01622:  MOVFF  01,B24
01626:  MOVLW  08
01628:  MOVLB  B
0162A:  MOVWF  x35
0162C:  MOVLW  E2
0162E:  MOVWF  x34
01630:  MOVFF  7A7,B37
01634:  MOVFF  7A6,B36
01638:  MOVFF  B24,B38
.................... } 
....................  
*
019CE:  BCF    FA6.7
019D0:  MOVLB  0
019D2:  GOTO   009C
.................... #INT_TIMER0 
.................... void interrupt_timer0() 
.................... { 
....................     clock_update = 1; 
019D6:  MOVLW  01
019D8:  MOVLB  6
019DA:  MOVWF  x81
019DC:  BCF    FF2.2
019DE:  MOVLB  0
019E0:  GOTO   009C
.................... } 
....................  
.................... void schedule_new_commands() 
.................... { 
....................     static uint8_t buffer[MAX_LENGTH]; 
....................     if (uart_ready(COMM)) { 
*
0D180:  MOVLB  8
0D182:  MOVF   x2A,W
0D184:  SUBLW  02
0D186:  BNZ   D22E
....................         memcpy(buffer, uart_message(COMM), MSG_LENGTH_COMM); 
0D188:  MOVLW  09
0D18A:  MOVWF  FEA
0D18C:  MOVLW  54
0D18E:  MOVWF  FE9
0D190:  MOVFF  824,FE2
0D194:  MOVFF  823,FE1
0D198:  MOVLW  19
0D19A:  MOVWF  01
0D19C:  MOVFF  FE6,FEE
0D1A0:  DECFSZ 01,F
0D1A2:  BRA    D19C
....................         command_execute(buffer, MSG_COMM, 1); 
0D1A4:  MOVLW  09
0D1A6:  MOVLB  9
0D1A8:  MOVWF  xF4
0D1AA:  MOVLW  54
0D1AC:  MOVWF  xF3
0D1AE:  MOVLW  C0
0D1B0:  MOVWF  xF5
0D1B2:  MOVLW  01
0D1B4:  MOVWF  xF6
0D1B6:  MOVLB  0
0D1B8:  CALL   C582
....................         uart_clean(COMM); 
0D1BC:  MOVLW  08
0D1BE:  MOVLB  B
0D1C0:  MOVWF  x3A
0D1C2:  MOVLW  23
0D1C4:  MOVWF  x39
....................     } 
....................     if (uart_ready(PCIB)) { 
*
0D22E:  MOVLB  7
0D230:  MOVF   xF1,W
0D232:  SUBLW  02
0D234:  BNZ   D2DC
....................         memcpy(buffer, uart_message(PCIB), MSG_LENGTH_PCIB); 
0D236:  MOVLW  09
0D238:  MOVWF  FEA
0D23A:  MOVLW  54
0D23C:  MOVWF  FE9
0D23E:  MOVFF  7EB,FE2
0D242:  MOVFF  7EA,FE1
0D246:  MOVLW  24
0D248:  MOVWF  01
0D24A:  MOVFF  FE6,FEE
0D24E:  DECFSZ 01,F
0D250:  BRA    D24A
....................         command_execute(buffer, MSG_PCIB, 1); 
0D252:  MOVLW  09
0D254:  MOVLB  9
0D256:  MOVWF  xF4
0D258:  MOVLW  54
0D25A:  MOVWF  xF3
0D25C:  MOVLW  AB
0D25E:  MOVWF  xF5
0D260:  MOVLW  01
0D262:  MOVWF  xF6
0D264:  MOVLB  0
0D266:  CALL   C582
....................         uart_clean(PCIB); 
0D26A:  MOVLW  07
0D26C:  MOVLB  B
0D26E:  MOVWF  x3A
0D270:  MOVLW  EA
0D272:  MOVWF  x39
....................     } 
....................     if (uart_ready(ADCS)) { 
*
0D2DC:  MOVLB  8
0D2DE:  MOVF   x58,W
0D2E0:  SUBLW  02
0D2E2:  BNZ   D38A
....................         memcpy(buffer, uart_message(ADCS), MSG_LENGTH_ADCS); 
0D2E4:  MOVLW  09
0D2E6:  MOVWF  FEA
0D2E8:  MOVLW  54
0D2EA:  MOVWF  FE9
0D2EC:  MOVFF  852,FE2
0D2F0:  MOVFF  851,FE1
0D2F4:  MOVLW  2B
0D2F6:  MOVWF  01
0D2F8:  MOVFF  FE6,FEE
0D2FC:  DECFSZ 01,F
0D2FE:  BRA    D2F8
....................         command_execute(buffer, MSG_ADCS, 1); 
0D300:  MOVLW  09
0D302:  MOVLB  9
0D304:  MOVWF  xF4
0D306:  MOVLW  54
0D308:  MOVWF  xF3
0D30A:  MOVLW  AD
0D30C:  MOVWF  xF5
0D30E:  MOVLW  01
0D310:  MOVWF  xF6
0D312:  MOVLB  0
0D314:  CALL   C582
....................         uart_clean(ADCS); 
0D318:  MOVLW  08
0D31A:  MOVLB  B
0D31C:  MOVWF  x3A
0D31E:  MOVLW  51
0D320:  MOVWF  x39
....................     } 
....................     if (uart_ready(FAB)) { 
*
0D38A:  MOVF   x98,W
0D38C:  SUBLW  02
0D38E:  BNZ   D436
....................         memcpy(buffer, uart_message(FAB), MSG_LENGTH_FAB); 
0D390:  MOVLW  09
0D392:  MOVWF  FEA
0D394:  MOVLW  54
0D396:  MOVWF  FE9
0D398:  MOVFF  892,FE2
0D39C:  MOVFF  891,FE1
0D3A0:  MOVLW  3C
0D3A2:  MOVWF  01
0D3A4:  MOVFF  FE6,FEE
0D3A8:  DECFSZ 01,F
0D3AA:  BRA    D3A4
....................         command_execute(buffer, MSG_FAB, 1); 
0D3AC:  MOVLW  09
0D3AE:  MOVLB  9
0D3B0:  MOVWF  xF4
0D3B2:  MOVLW  54
0D3B4:  MOVWF  xF3
0D3B6:  MOVLW  E0
0D3B8:  MOVWF  xF5
0D3BA:  MOVLW  01
0D3BC:  MOVWF  xF6
0D3BE:  MOVLB  0
0D3C0:  CALL   C582
....................         uart_clean(FAB); 
0D3C4:  MOVLW  08
0D3C6:  MOVLB  B
0D3C8:  MOVWF  x3A
0D3CA:  MOVLW  91
0D3CC:  MOVWF  x39
....................     } 
....................     if (uart_ready(RST)) { 
*
0D436:  MOVF   xE9,W
0D438:  SUBLW  02
0D43A:  BNZ   D4E2
....................         memcpy(buffer, uart_message(RST), MSG_LENGTH_RST); 
0D43C:  MOVLW  09
0D43E:  MOVWF  FEA
0D440:  MOVLW  54
0D442:  MOVWF  FE9
0D444:  MOVFF  8E3,FE2
0D448:  MOVFF  8E2,FE1
0D44C:  MOVLW  24
0D44E:  MOVWF  01
0D450:  MOVFF  FE6,FEE
0D454:  DECFSZ 01,F
0D456:  BRA    D450
....................         command_execute(buffer, MSG_RST, 1); 
0D458:  MOVLW  09
0D45A:  MOVLB  9
0D45C:  MOVWF  xF4
0D45E:  MOVLW  54
0D460:  MOVWF  xF3
0D462:  MOVLW  B0
0D464:  MOVWF  xF5
0D466:  MOVLW  01
0D468:  MOVWF  xF6
0D46A:  MOVLB  0
0D46C:  CALL   C582
....................         uart_clean(RST); 
0D470:  MOVLW  08
0D472:  MOVLB  B
0D474:  MOVWF  x3A
0D476:  MOVLW  E2
0D478:  MOVWF  x39
....................     } 
....................     if (uart_ready(PC)) { 
*
0D4E2:  MOVLB  7
0D4E4:  MOVF   xC3,W
0D4E6:  SUBLW  02
0D4E8:  BNZ   D58E
....................         memcpy(buffer, uart_message(PC), MSG_LENGTH_PC); 
0D4EA:  MOVLW  09
0D4EC:  MOVWF  FEA
0D4EE:  MOVLW  54
0D4F0:  MOVWF  FE9
0D4F2:  MOVFF  7BD,FE2
0D4F6:  MOVFF  7BC,FE1
0D4FA:  MOVLW  19
0D4FC:  MOVWF  01
0D4FE:  MOVFF  FE6,FEE
0D502:  DECFSZ 01,F
0D504:  BRA    D4FE
....................         command_execute(buffer, MSG_WILDCARD, 1); 
0D506:  MOVLW  09
0D508:  MOVLB  9
0D50A:  MOVWF  xF4
0D50C:  MOVLW  54
0D50E:  MOVWF  xF3
0D510:  SETF   xF5
0D512:  MOVLW  01
0D514:  MOVWF  xF6
0D516:  MOVLB  0
0D518:  CALL   C582
....................         uart_clean(PC); 
0D51C:  MOVLW  07
0D51E:  MOVLB  B
0D520:  MOVWF  x3A
0D522:  MOVLW  BC
0D524:  MOVWF  x39
....................     } 
*
0D58E:  MOVLB  0
0D590:  GOTO   E1F4 (RETURN)
.................... } 
....................  
.................... void periodic_requests_commands() 
.................... { 
....................     const uint8_t period = 100; 
....................     periodic_command_clear_rx_flag(period, 0);           // Reset 
*
0D68C:  BSF    FD8.1
0D68E:  MOVLW  09
0D690:  MOVWF  FEA
0D692:  MOVLW  F3
0D694:  MOVWF  FE9
0D696:  MOVFF  3C,A5E
0D69A:  MOVFF  3B,A5D
0D69E:  MOVFF  3A,A5C
0D6A2:  MOVFF  39,A5B
0D6A6:  MOVLB  A
0D6A8:  CLRF   x62
0D6AA:  CLRF   x61
0D6AC:  CLRF   x60
0D6AE:  MOVLW  64
0D6B0:  MOVWF  x5F
0D6B2:  MOVLB  0
0D6B4:  CALL   1E6C
0D6B8:  MOVFF  9F6,9FA
0D6BC:  MOVFF  9F5,9F9
0D6C0:  MOVFF  9F4,9F8
0D6C4:  MOVFF  9F3,9F7
0D6C8:  MOVLB  9
0D6CA:  MOVF   xF7,F
0D6CC:  BNZ   D6E0
0D6CE:  MOVF   xF8,F
0D6D0:  BNZ   D6E0
0D6D2:  MOVF   xF9,F
0D6D4:  BNZ   D6E0
0D6D6:  MOVF   xFA,F
0D6D8:  BNZ   D6E0
0D6DA:  MOVLB  6
0D6DC:  CLRF   x83
0D6DE:  MOVLB  9
....................     periodic_command(period, 0, 0, { MSG_COMM, 0x90 });  // Reset 
0D6E0:  BSF    FD8.1
0D6E2:  MOVLW  09
0D6E4:  MOVWF  FEA
0D6E6:  MOVLW  F3
0D6E8:  MOVWF  FE9
0D6EA:  MOVFF  3C,A5E
0D6EE:  MOVFF  3B,A5D
0D6F2:  MOVFF  3A,A5C
0D6F6:  MOVFF  39,A5B
0D6FA:  MOVLB  A
0D6FC:  CLRF   x62
0D6FE:  CLRF   x61
0D700:  CLRF   x60
0D702:  MOVLW  64
0D704:  MOVWF  x5F
0D706:  MOVLB  0
0D708:  CALL   1E6C
0D70C:  MOVFF  9F6,9FA
0D710:  MOVFF  9F5,9F9
0D714:  MOVFF  9F4,9F8
0D718:  MOVFF  9F3,9F7
0D71C:  MOVLB  9
0D71E:  MOVF   xF7,F
0D720:  BNZ   D752
0D722:  MOVF   xF8,F
0D724:  BNZ   D752
0D726:  MOVF   xF9,F
0D728:  BNZ   D752
0D72A:  MOVF   xFA,F
0D72C:  BNZ   D752
0D72E:  MOVLB  6
0D730:  MOVF   x83,F
0D732:  BNZ   D750
0D734:  MOVLW  C0
0D736:  MOVLB  9
0D738:  MOVWF  xC9
0D73A:  MOVLW  90
0D73C:  MOVWF  xCA
0D73E:  MOVLW  09
0D740:  MOVWF  xF4
0D742:  MOVLW  C9
0D744:  MOVWF  xF3
0D746:  SETF   xF5
0D748:  CLRF   xF6
0D74A:  MOVLB  0
0D74C:  CALL   C582
0D750:  MOVLB  9
....................     periodic_command(period, 4, 0, { MSG_COMM, 0x90 });  // Reset 
0D752:  BSF    FD8.1
0D754:  MOVLW  09
0D756:  MOVWF  FEA
0D758:  MOVLW  F3
0D75A:  MOVWF  FE9
0D75C:  MOVFF  3C,A5E
0D760:  MOVFF  3B,A5D
0D764:  MOVFF  3A,A5C
0D768:  MOVFF  39,A5B
0D76C:  MOVLB  A
0D76E:  CLRF   x62
0D770:  CLRF   x61
0D772:  CLRF   x60
0D774:  MOVLW  64
0D776:  MOVWF  x5F
0D778:  MOVLB  0
0D77A:  CALL   1E6C
0D77E:  MOVFF  9F6,9FA
0D782:  MOVFF  9F5,9F9
0D786:  MOVFF  9F4,9F8
0D78A:  MOVFF  9F3,9F7
0D78E:  MOVLB  9
0D790:  MOVF   xF3,W
0D792:  SUBLW  04
0D794:  BNZ   D7C6
0D796:  MOVF   xF8,F
0D798:  BNZ   D7C6
0D79A:  MOVF   xF9,F
0D79C:  BNZ   D7C6
0D79E:  MOVF   xFA,F
0D7A0:  BNZ   D7C6
0D7A2:  MOVLB  6
0D7A4:  MOVF   x83,F
0D7A6:  BNZ   D7C4
0D7A8:  MOVLW  C0
0D7AA:  MOVLB  9
0D7AC:  MOVWF  xCB
0D7AE:  MOVLW  90
0D7B0:  MOVWF  xCC
0D7B2:  MOVLW  09
0D7B4:  MOVWF  xF4
0D7B6:  MOVLW  CB
0D7B8:  MOVWF  xF3
0D7BA:  SETF   xF5
0D7BC:  CLRF   xF6
0D7BE:  MOVLB  0
0D7C0:  CALL   C582
0D7C4:  MOVLB  9
....................     periodic_command(period, 8, 0, { MSG_COMM, 0x90 });  // Reset 
0D7C6:  BSF    FD8.1
0D7C8:  MOVLW  09
0D7CA:  MOVWF  FEA
0D7CC:  MOVLW  F3
0D7CE:  MOVWF  FE9
0D7D0:  MOVFF  3C,A5E
0D7D4:  MOVFF  3B,A5D
0D7D8:  MOVFF  3A,A5C
0D7DC:  MOVFF  39,A5B
0D7E0:  MOVLB  A
0D7E2:  CLRF   x62
0D7E4:  CLRF   x61
0D7E6:  CLRF   x60
0D7E8:  MOVLW  64
0D7EA:  MOVWF  x5F
0D7EC:  MOVLB  0
0D7EE:  CALL   1E6C
0D7F2:  MOVFF  9F6,9FA
0D7F6:  MOVFF  9F5,9F9
0D7FA:  MOVFF  9F4,9F8
0D7FE:  MOVFF  9F3,9F7
0D802:  MOVLB  9
0D804:  MOVF   xF3,W
0D806:  SUBLW  08
0D808:  BNZ   D83A
0D80A:  MOVF   xF8,F
0D80C:  BNZ   D83A
0D80E:  MOVF   xF9,F
0D810:  BNZ   D83A
0D812:  MOVF   xFA,F
0D814:  BNZ   D83A
0D816:  MOVLB  6
0D818:  MOVF   x83,F
0D81A:  BNZ   D838
0D81C:  MOVLW  C0
0D81E:  MOVLB  9
0D820:  MOVWF  xCD
0D822:  MOVLW  90
0D824:  MOVWF  xCE
0D826:  MOVLW  09
0D828:  MOVWF  xF4
0D82A:  MOVLW  CD
0D82C:  MOVWF  xF3
0D82E:  SETF   xF5
0D830:  CLRF   xF6
0D832:  MOVLB  0
0D834:  CALL   C582
0D838:  MOVLB  9
....................     periodic_command(period, 12, 0, { MSG_COMM, 0x90 }); // Reset 
0D83A:  BSF    FD8.1
0D83C:  MOVLW  09
0D83E:  MOVWF  FEA
0D840:  MOVLW  F3
0D842:  MOVWF  FE9
0D844:  MOVFF  3C,A5E
0D848:  MOVFF  3B,A5D
0D84C:  MOVFF  3A,A5C
0D850:  MOVFF  39,A5B
0D854:  MOVLB  A
0D856:  CLRF   x62
0D858:  CLRF   x61
0D85A:  CLRF   x60
0D85C:  MOVLW  64
0D85E:  MOVWF  x5F
0D860:  MOVLB  0
0D862:  CALL   1E6C
0D866:  MOVFF  9F6,9FA
0D86A:  MOVFF  9F5,9F9
0D86E:  MOVFF  9F4,9F8
0D872:  MOVFF  9F3,9F7
0D876:  MOVLB  9
0D878:  MOVF   xF3,W
0D87A:  SUBLW  0C
0D87C:  BNZ   D8AE
0D87E:  MOVF   xF8,F
0D880:  BNZ   D8AE
0D882:  MOVF   xF9,F
0D884:  BNZ   D8AE
0D886:  MOVF   xFA,F
0D888:  BNZ   D8AE
0D88A:  MOVLB  6
0D88C:  MOVF   x83,F
0D88E:  BNZ   D8AC
0D890:  MOVLW  C0
0D892:  MOVLB  9
0D894:  MOVWF  xCF
0D896:  MOVLW  90
0D898:  MOVWF  xD0
0D89A:  MOVLW  09
0D89C:  MOVWF  xF4
0D89E:  MOVLW  CF
0D8A0:  MOVWF  xF3
0D8A2:  SETF   xF5
0D8A4:  CLRF   xF6
0D8A6:  MOVLB  0
0D8A8:  CALL   C582
0D8AC:  MOVLB  9
....................     periodic_command(period, 16, 0, { MSG_COMM, 0x90 }); // Reset 
0D8AE:  BSF    FD8.1
0D8B0:  MOVLW  09
0D8B2:  MOVWF  FEA
0D8B4:  MOVLW  F3
0D8B6:  MOVWF  FE9
0D8B8:  MOVFF  3C,A5E
0D8BC:  MOVFF  3B,A5D
0D8C0:  MOVFF  3A,A5C
0D8C4:  MOVFF  39,A5B
0D8C8:  MOVLB  A
0D8CA:  CLRF   x62
0D8CC:  CLRF   x61
0D8CE:  CLRF   x60
0D8D0:  MOVLW  64
0D8D2:  MOVWF  x5F
0D8D4:  MOVLB  0
0D8D6:  CALL   1E6C
0D8DA:  MOVFF  9F6,9FA
0D8DE:  MOVFF  9F5,9F9
0D8E2:  MOVFF  9F4,9F8
0D8E6:  MOVFF  9F3,9F7
0D8EA:  MOVLB  9
0D8EC:  MOVF   xF3,W
0D8EE:  SUBLW  10
0D8F0:  BNZ   D922
0D8F2:  MOVF   xF8,F
0D8F4:  BNZ   D922
0D8F6:  MOVF   xF9,F
0D8F8:  BNZ   D922
0D8FA:  MOVF   xFA,F
0D8FC:  BNZ   D922
0D8FE:  MOVLB  6
0D900:  MOVF   x83,F
0D902:  BNZ   D920
0D904:  MOVLW  C0
0D906:  MOVLB  9
0D908:  MOVWF  xD1
0D90A:  MOVLW  90
0D90C:  MOVWF  xD2
0D90E:  MOVLW  09
0D910:  MOVWF  xF4
0D912:  MOVLW  D1
0D914:  MOVWF  xF3
0D916:  SETF   xF5
0D918:  CLRF   xF6
0D91A:  MOVLB  0
0D91C:  CALL   C582
0D920:  MOVLB  9
....................     periodic_command_clear_rx_flag(period, 20);          // EPS 
0D922:  BSF    FD8.1
0D924:  MOVLW  09
0D926:  MOVWF  FEA
0D928:  MOVLW  F3
0D92A:  MOVWF  FE9
0D92C:  MOVFF  3C,A5E
0D930:  MOVFF  3B,A5D
0D934:  MOVFF  3A,A5C
0D938:  MOVFF  39,A5B
0D93C:  MOVLB  A
0D93E:  CLRF   x62
0D940:  CLRF   x61
0D942:  CLRF   x60
0D944:  MOVLW  64
0D946:  MOVWF  x5F
0D948:  MOVLB  0
0D94A:  CALL   1E6C
0D94E:  MOVFF  9F6,9FA
0D952:  MOVFF  9F5,9F9
0D956:  MOVFF  9F4,9F8
0D95A:  MOVFF  9F3,9F7
0D95E:  MOVLB  9
0D960:  MOVF   xF3,W
0D962:  SUBLW  14
0D964:  BNZ   D978
0D966:  MOVF   xF8,F
0D968:  BNZ   D978
0D96A:  MOVF   xF9,F
0D96C:  BNZ   D978
0D96E:  MOVF   xFA,F
0D970:  BNZ   D978
0D972:  MOVLB  6
0D974:  CLRF   x83
0D976:  MOVLB  9
....................     periodic_command(period, 20, 0, { MSG_COMM, 0x91 }); // EPS 
0D978:  BSF    FD8.1
0D97A:  MOVLW  09
0D97C:  MOVWF  FEA
0D97E:  MOVLW  F3
0D980:  MOVWF  FE9
0D982:  MOVFF  3C,A5E
0D986:  MOVFF  3B,A5D
0D98A:  MOVFF  3A,A5C
0D98E:  MOVFF  39,A5B
0D992:  MOVLB  A
0D994:  CLRF   x62
0D996:  CLRF   x61
0D998:  CLRF   x60
0D99A:  MOVLW  64
0D99C:  MOVWF  x5F
0D99E:  MOVLB  0
0D9A0:  CALL   1E6C
0D9A4:  MOVFF  9F6,9FA
0D9A8:  MOVFF  9F5,9F9
0D9AC:  MOVFF  9F4,9F8
0D9B0:  MOVFF  9F3,9F7
0D9B4:  MOVLB  9
0D9B6:  MOVF   xF3,W
0D9B8:  SUBLW  14
0D9BA:  BNZ   D9EC
0D9BC:  MOVF   xF8,F
0D9BE:  BNZ   D9EC
0D9C0:  MOVF   xF9,F
0D9C2:  BNZ   D9EC
0D9C4:  MOVF   xFA,F
0D9C6:  BNZ   D9EC
0D9C8:  MOVLB  6
0D9CA:  MOVF   x83,F
0D9CC:  BNZ   D9EA
0D9CE:  MOVLW  C0
0D9D0:  MOVLB  9
0D9D2:  MOVWF  xD3
0D9D4:  MOVLW  91
0D9D6:  MOVWF  xD4
0D9D8:  MOVLW  09
0D9DA:  MOVWF  xF4
0D9DC:  MOVLW  D3
0D9DE:  MOVWF  xF3
0D9E0:  SETF   xF5
0D9E2:  CLRF   xF6
0D9E4:  MOVLB  0
0D9E6:  CALL   C582
0D9EA:  MOVLB  9
....................     periodic_command(period, 24, 0, { MSG_COMM, 0x91 }); // EPS 
0D9EC:  BSF    FD8.1
0D9EE:  MOVLW  09
0D9F0:  MOVWF  FEA
0D9F2:  MOVLW  F3
0D9F4:  MOVWF  FE9
0D9F6:  MOVFF  3C,A5E
0D9FA:  MOVFF  3B,A5D
0D9FE:  MOVFF  3A,A5C
0DA02:  MOVFF  39,A5B
0DA06:  MOVLB  A
0DA08:  CLRF   x62
0DA0A:  CLRF   x61
0DA0C:  CLRF   x60
0DA0E:  MOVLW  64
0DA10:  MOVWF  x5F
0DA12:  MOVLB  0
0DA14:  CALL   1E6C
0DA18:  MOVFF  9F6,9FA
0DA1C:  MOVFF  9F5,9F9
0DA20:  MOVFF  9F4,9F8
0DA24:  MOVFF  9F3,9F7
0DA28:  MOVLB  9
0DA2A:  MOVF   xF3,W
0DA2C:  SUBLW  18
0DA2E:  BNZ   DA60
0DA30:  MOVF   xF8,F
0DA32:  BNZ   DA60
0DA34:  MOVF   xF9,F
0DA36:  BNZ   DA60
0DA38:  MOVF   xFA,F
0DA3A:  BNZ   DA60
0DA3C:  MOVLB  6
0DA3E:  MOVF   x83,F
0DA40:  BNZ   DA5E
0DA42:  MOVLW  C0
0DA44:  MOVLB  9
0DA46:  MOVWF  xD5
0DA48:  MOVLW  91
0DA4A:  MOVWF  xD6
0DA4C:  MOVLW  09
0DA4E:  MOVWF  xF4
0DA50:  MOVLW  D5
0DA52:  MOVWF  xF3
0DA54:  SETF   xF5
0DA56:  CLRF   xF6
0DA58:  MOVLB  0
0DA5A:  CALL   C582
0DA5E:  MOVLB  9
....................     periodic_command(period, 28, 0, { MSG_COMM, 0x91 }); // EPS 
0DA60:  BSF    FD8.1
0DA62:  MOVLW  09
0DA64:  MOVWF  FEA
0DA66:  MOVLW  F3
0DA68:  MOVWF  FE9
0DA6A:  MOVFF  3C,A5E
0DA6E:  MOVFF  3B,A5D
0DA72:  MOVFF  3A,A5C
0DA76:  MOVFF  39,A5B
0DA7A:  MOVLB  A
0DA7C:  CLRF   x62
0DA7E:  CLRF   x61
0DA80:  CLRF   x60
0DA82:  MOVLW  64
0DA84:  MOVWF  x5F
0DA86:  MOVLB  0
0DA88:  CALL   1E6C
0DA8C:  MOVFF  9F6,9FA
0DA90:  MOVFF  9F5,9F9
0DA94:  MOVFF  9F4,9F8
0DA98:  MOVFF  9F3,9F7
0DA9C:  MOVLB  9
0DA9E:  MOVF   xF3,W
0DAA0:  SUBLW  1C
0DAA2:  BNZ   DAD4
0DAA4:  MOVF   xF8,F
0DAA6:  BNZ   DAD4
0DAA8:  MOVF   xF9,F
0DAAA:  BNZ   DAD4
0DAAC:  MOVF   xFA,F
0DAAE:  BNZ   DAD4
0DAB0:  MOVLB  6
0DAB2:  MOVF   x83,F
0DAB4:  BNZ   DAD2
0DAB6:  MOVLW  C0
0DAB8:  MOVLB  9
0DABA:  MOVWF  xD7
0DABC:  MOVLW  91
0DABE:  MOVWF  xD8
0DAC0:  MOVLW  09
0DAC2:  MOVWF  xF4
0DAC4:  MOVLW  D7
0DAC6:  MOVWF  xF3
0DAC8:  SETF   xF5
0DACA:  CLRF   xF6
0DACC:  MOVLB  0
0DACE:  CALL   C582
0DAD2:  MOVLB  9
....................     periodic_command(period, 32, 0, { MSG_COMM, 0x91 }); // EPS 
0DAD4:  BSF    FD8.1
0DAD6:  MOVLW  09
0DAD8:  MOVWF  FEA
0DADA:  MOVLW  F3
0DADC:  MOVWF  FE9
0DADE:  MOVFF  3C,A5E
0DAE2:  MOVFF  3B,A5D
0DAE6:  MOVFF  3A,A5C
0DAEA:  MOVFF  39,A5B
0DAEE:  MOVLB  A
0DAF0:  CLRF   x62
0DAF2:  CLRF   x61
0DAF4:  CLRF   x60
0DAF6:  MOVLW  64
0DAF8:  MOVWF  x5F
0DAFA:  MOVLB  0
0DAFC:  CALL   1E6C
0DB00:  MOVFF  9F6,9FA
0DB04:  MOVFF  9F5,9F9
0DB08:  MOVFF  9F4,9F8
0DB0C:  MOVFF  9F3,9F7
0DB10:  MOVLB  9
0DB12:  MOVF   xF3,W
0DB14:  SUBLW  20
0DB16:  BNZ   DB48
0DB18:  MOVF   xF8,F
0DB1A:  BNZ   DB48
0DB1C:  MOVF   xF9,F
0DB1E:  BNZ   DB48
0DB20:  MOVF   xFA,F
0DB22:  BNZ   DB48
0DB24:  MOVLB  6
0DB26:  MOVF   x83,F
0DB28:  BNZ   DB46
0DB2A:  MOVLW  C0
0DB2C:  MOVLB  9
0DB2E:  MOVWF  xD9
0DB30:  MOVLW  91
0DB32:  MOVWF  xDA
0DB34:  MOVLW  09
0DB36:  MOVWF  xF4
0DB38:  MOVLW  D9
0DB3A:  MOVWF  xF3
0DB3C:  SETF   xF5
0DB3E:  CLRF   xF6
0DB40:  MOVLB  0
0DB42:  CALL   C582
0DB46:  MOVLB  9
....................     periodic_command(period, 36, 0, { MSG_COMM, 0x91 }); // EPS 
0DB48:  BSF    FD8.1
0DB4A:  MOVLW  09
0DB4C:  MOVWF  FEA
0DB4E:  MOVLW  F3
0DB50:  MOVWF  FE9
0DB52:  MOVFF  3C,A5E
0DB56:  MOVFF  3B,A5D
0DB5A:  MOVFF  3A,A5C
0DB5E:  MOVFF  39,A5B
0DB62:  MOVLB  A
0DB64:  CLRF   x62
0DB66:  CLRF   x61
0DB68:  CLRF   x60
0DB6A:  MOVLW  64
0DB6C:  MOVWF  x5F
0DB6E:  MOVLB  0
0DB70:  CALL   1E6C
0DB74:  MOVFF  9F6,9FA
0DB78:  MOVFF  9F5,9F9
0DB7C:  MOVFF  9F4,9F8
0DB80:  MOVFF  9F3,9F7
0DB84:  MOVLB  9
0DB86:  MOVF   xF3,W
0DB88:  SUBLW  24
0DB8A:  BNZ   DBBC
0DB8C:  MOVF   xF8,F
0DB8E:  BNZ   DBBC
0DB90:  MOVF   xF9,F
0DB92:  BNZ   DBBC
0DB94:  MOVF   xFA,F
0DB96:  BNZ   DBBC
0DB98:  MOVLB  6
0DB9A:  MOVF   x83,F
0DB9C:  BNZ   DBBA
0DB9E:  MOVLW  C0
0DBA0:  MOVLB  9
0DBA2:  MOVWF  xDB
0DBA4:  MOVLW  91
0DBA6:  MOVWF  xDC
0DBA8:  MOVLW  09
0DBAA:  MOVWF  xF4
0DBAC:  MOVLW  DB
0DBAE:  MOVWF  xF3
0DBB0:  SETF   xF5
0DBB2:  CLRF   xF6
0DBB4:  MOVLB  0
0DBB6:  CALL   C582
0DBBA:  MOVLB  9
....................     periodic_command_clear_rx_flag(period, 40);          // PCIB 
0DBBC:  BSF    FD8.1
0DBBE:  MOVLW  09
0DBC0:  MOVWF  FEA
0DBC2:  MOVLW  F3
0DBC4:  MOVWF  FE9
0DBC6:  MOVFF  3C,A5E
0DBCA:  MOVFF  3B,A5D
0DBCE:  MOVFF  3A,A5C
0DBD2:  MOVFF  39,A5B
0DBD6:  MOVLB  A
0DBD8:  CLRF   x62
0DBDA:  CLRF   x61
0DBDC:  CLRF   x60
0DBDE:  MOVLW  64
0DBE0:  MOVWF  x5F
0DBE2:  MOVLB  0
0DBE4:  CALL   1E6C
0DBE8:  MOVFF  9F6,9FA
0DBEC:  MOVFF  9F5,9F9
0DBF0:  MOVFF  9F4,9F8
0DBF4:  MOVFF  9F3,9F7
0DBF8:  MOVLB  9
0DBFA:  MOVF   xF3,W
0DBFC:  SUBLW  28
0DBFE:  BNZ   DC12
0DC00:  MOVF   xF8,F
0DC02:  BNZ   DC12
0DC04:  MOVF   xF9,F
0DC06:  BNZ   DC12
0DC08:  MOVF   xFA,F
0DC0A:  BNZ   DC12
0DC0C:  MOVLB  6
0DC0E:  CLRF   x83
0DC10:  MOVLB  9
....................     periodic_command(period, 40, 0, { MSG_COMM, 0x92 }); // PCIB 
0DC12:  BSF    FD8.1
0DC14:  MOVLW  09
0DC16:  MOVWF  FEA
0DC18:  MOVLW  F3
0DC1A:  MOVWF  FE9
0DC1C:  MOVFF  3C,A5E
0DC20:  MOVFF  3B,A5D
0DC24:  MOVFF  3A,A5C
0DC28:  MOVFF  39,A5B
0DC2C:  MOVLB  A
0DC2E:  CLRF   x62
0DC30:  CLRF   x61
0DC32:  CLRF   x60
0DC34:  MOVLW  64
0DC36:  MOVWF  x5F
0DC38:  MOVLB  0
0DC3A:  CALL   1E6C
0DC3E:  MOVFF  9F6,9FA
0DC42:  MOVFF  9F5,9F9
0DC46:  MOVFF  9F4,9F8
0DC4A:  MOVFF  9F3,9F7
0DC4E:  MOVLB  9
0DC50:  MOVF   xF3,W
0DC52:  SUBLW  28
0DC54:  BNZ   DC86
0DC56:  MOVF   xF8,F
0DC58:  BNZ   DC86
0DC5A:  MOVF   xF9,F
0DC5C:  BNZ   DC86
0DC5E:  MOVF   xFA,F
0DC60:  BNZ   DC86
0DC62:  MOVLB  6
0DC64:  MOVF   x83,F
0DC66:  BNZ   DC84
0DC68:  MOVLW  C0
0DC6A:  MOVLB  9
0DC6C:  MOVWF  xDD
0DC6E:  MOVLW  92
0DC70:  MOVWF  xDE
0DC72:  MOVLW  09
0DC74:  MOVWF  xF4
0DC76:  MOVLW  DD
0DC78:  MOVWF  xF3
0DC7A:  SETF   xF5
0DC7C:  CLRF   xF6
0DC7E:  MOVLB  0
0DC80:  CALL   C582
0DC84:  MOVLB  9
....................     periodic_command(period, 44, 0, { MSG_COMM, 0x92 }); // PCIB 
0DC86:  BSF    FD8.1
0DC88:  MOVLW  09
0DC8A:  MOVWF  FEA
0DC8C:  MOVLW  F3
0DC8E:  MOVWF  FE9
0DC90:  MOVFF  3C,A5E
0DC94:  MOVFF  3B,A5D
0DC98:  MOVFF  3A,A5C
0DC9C:  MOVFF  39,A5B
0DCA0:  MOVLB  A
0DCA2:  CLRF   x62
0DCA4:  CLRF   x61
0DCA6:  CLRF   x60
0DCA8:  MOVLW  64
0DCAA:  MOVWF  x5F
0DCAC:  MOVLB  0
0DCAE:  CALL   1E6C
0DCB2:  MOVFF  9F6,9FA
0DCB6:  MOVFF  9F5,9F9
0DCBA:  MOVFF  9F4,9F8
0DCBE:  MOVFF  9F3,9F7
0DCC2:  MOVLB  9
0DCC4:  MOVF   xF3,W
0DCC6:  SUBLW  2C
0DCC8:  BNZ   DCFA
0DCCA:  MOVF   xF8,F
0DCCC:  BNZ   DCFA
0DCCE:  MOVF   xF9,F
0DCD0:  BNZ   DCFA
0DCD2:  MOVF   xFA,F
0DCD4:  BNZ   DCFA
0DCD6:  MOVLB  6
0DCD8:  MOVF   x83,F
0DCDA:  BNZ   DCF8
0DCDC:  MOVLW  C0
0DCDE:  MOVLB  9
0DCE0:  MOVWF  xDF
0DCE2:  MOVLW  92
0DCE4:  MOVWF  xE0
0DCE6:  MOVLW  09
0DCE8:  MOVWF  xF4
0DCEA:  MOVLW  DF
0DCEC:  MOVWF  xF3
0DCEE:  SETF   xF5
0DCF0:  CLRF   xF6
0DCF2:  MOVLB  0
0DCF4:  CALL   C582
0DCF8:  MOVLB  9
....................     periodic_command(period, 48, 0, { MSG_COMM, 0x92 }); // PCIB 
0DCFA:  BSF    FD8.1
0DCFC:  MOVLW  09
0DCFE:  MOVWF  FEA
0DD00:  MOVLW  F3
0DD02:  MOVWF  FE9
0DD04:  MOVFF  3C,A5E
0DD08:  MOVFF  3B,A5D
0DD0C:  MOVFF  3A,A5C
0DD10:  MOVFF  39,A5B
0DD14:  MOVLB  A
0DD16:  CLRF   x62
0DD18:  CLRF   x61
0DD1A:  CLRF   x60
0DD1C:  MOVLW  64
0DD1E:  MOVWF  x5F
0DD20:  MOVLB  0
0DD22:  CALL   1E6C
0DD26:  MOVFF  9F6,9FA
0DD2A:  MOVFF  9F5,9F9
0DD2E:  MOVFF  9F4,9F8
0DD32:  MOVFF  9F3,9F7
0DD36:  MOVLB  9
0DD38:  MOVF   xF3,W
0DD3A:  SUBLW  30
0DD3C:  BNZ   DD6E
0DD3E:  MOVF   xF8,F
0DD40:  BNZ   DD6E
0DD42:  MOVF   xF9,F
0DD44:  BNZ   DD6E
0DD46:  MOVF   xFA,F
0DD48:  BNZ   DD6E
0DD4A:  MOVLB  6
0DD4C:  MOVF   x83,F
0DD4E:  BNZ   DD6C
0DD50:  MOVLW  C0
0DD52:  MOVLB  9
0DD54:  MOVWF  xE1
0DD56:  MOVLW  92
0DD58:  MOVWF  xE2
0DD5A:  MOVLW  09
0DD5C:  MOVWF  xF4
0DD5E:  MOVLW  E1
0DD60:  MOVWF  xF3
0DD62:  SETF   xF5
0DD64:  CLRF   xF6
0DD66:  MOVLB  0
0DD68:  CALL   C582
0DD6C:  MOVLB  9
....................     periodic_command(period, 52, 0, { MSG_COMM, 0x92 }); // PCIB 
0DD6E:  BSF    FD8.1
0DD70:  MOVLW  09
0DD72:  MOVWF  FEA
0DD74:  MOVLW  F3
0DD76:  MOVWF  FE9
0DD78:  MOVFF  3C,A5E
0DD7C:  MOVFF  3B,A5D
0DD80:  MOVFF  3A,A5C
0DD84:  MOVFF  39,A5B
0DD88:  MOVLB  A
0DD8A:  CLRF   x62
0DD8C:  CLRF   x61
0DD8E:  CLRF   x60
0DD90:  MOVLW  64
0DD92:  MOVWF  x5F
0DD94:  MOVLB  0
0DD96:  CALL   1E6C
0DD9A:  MOVFF  9F6,9FA
0DD9E:  MOVFF  9F5,9F9
0DDA2:  MOVFF  9F4,9F8
0DDA6:  MOVFF  9F3,9F7
0DDAA:  MOVLB  9
0DDAC:  MOVF   xF3,W
0DDAE:  SUBLW  34
0DDB0:  BNZ   DDE2
0DDB2:  MOVF   xF8,F
0DDB4:  BNZ   DDE2
0DDB6:  MOVF   xF9,F
0DDB8:  BNZ   DDE2
0DDBA:  MOVF   xFA,F
0DDBC:  BNZ   DDE2
0DDBE:  MOVLB  6
0DDC0:  MOVF   x83,F
0DDC2:  BNZ   DDE0
0DDC4:  MOVLW  C0
0DDC6:  MOVLB  9
0DDC8:  MOVWF  xE3
0DDCA:  MOVLW  92
0DDCC:  MOVWF  xE4
0DDCE:  MOVLW  09
0DDD0:  MOVWF  xF4
0DDD2:  MOVLW  E3
0DDD4:  MOVWF  xF3
0DDD6:  SETF   xF5
0DDD8:  CLRF   xF6
0DDDA:  MOVLB  0
0DDDC:  CALL   C582
0DDE0:  MOVLB  9
....................     periodic_command(period, 54, 0, { MSG_COMM, 0x92 }); // PCIB 
0DDE2:  BSF    FD8.1
0DDE4:  MOVLW  09
0DDE6:  MOVWF  FEA
0DDE8:  MOVLW  F3
0DDEA:  MOVWF  FE9
0DDEC:  MOVFF  3C,A5E
0DDF0:  MOVFF  3B,A5D
0DDF4:  MOVFF  3A,A5C
0DDF8:  MOVFF  39,A5B
0DDFC:  MOVLB  A
0DDFE:  CLRF   x62
0DE00:  CLRF   x61
0DE02:  CLRF   x60
0DE04:  MOVLW  64
0DE06:  MOVWF  x5F
0DE08:  MOVLB  0
0DE0A:  CALL   1E6C
0DE0E:  MOVFF  9F6,9FA
0DE12:  MOVFF  9F5,9F9
0DE16:  MOVFF  9F4,9F8
0DE1A:  MOVFF  9F3,9F7
0DE1E:  MOVLB  9
0DE20:  MOVF   xF3,W
0DE22:  SUBLW  36
0DE24:  BNZ   DE56
0DE26:  MOVF   xF8,F
0DE28:  BNZ   DE56
0DE2A:  MOVF   xF9,F
0DE2C:  BNZ   DE56
0DE2E:  MOVF   xFA,F
0DE30:  BNZ   DE56
0DE32:  MOVLB  6
0DE34:  MOVF   x83,F
0DE36:  BNZ   DE54
0DE38:  MOVLW  C0
0DE3A:  MOVLB  9
0DE3C:  MOVWF  xE5
0DE3E:  MOVLW  92
0DE40:  MOVWF  xE6
0DE42:  MOVLW  09
0DE44:  MOVWF  xF4
0DE46:  MOVLW  E5
0DE48:  MOVWF  xF3
0DE4A:  SETF   xF5
0DE4C:  CLRF   xF6
0DE4E:  MOVLB  0
0DE50:  CALL   C582
0DE54:  MOVLB  9
....................     periodic_command_clear_rx_flag(period, 60);          // ADCS 
0DE56:  BSF    FD8.1
0DE58:  MOVLW  09
0DE5A:  MOVWF  FEA
0DE5C:  MOVLW  F3
0DE5E:  MOVWF  FE9
0DE60:  MOVFF  3C,A5E
0DE64:  MOVFF  3B,A5D
0DE68:  MOVFF  3A,A5C
0DE6C:  MOVFF  39,A5B
0DE70:  MOVLB  A
0DE72:  CLRF   x62
0DE74:  CLRF   x61
0DE76:  CLRF   x60
0DE78:  MOVLW  64
0DE7A:  MOVWF  x5F
0DE7C:  MOVLB  0
0DE7E:  CALL   1E6C
0DE82:  MOVFF  9F6,9FA
0DE86:  MOVFF  9F5,9F9
0DE8A:  MOVFF  9F4,9F8
0DE8E:  MOVFF  9F3,9F7
0DE92:  MOVLB  9
0DE94:  MOVF   xF3,W
0DE96:  SUBLW  3C
0DE98:  BNZ   DEAC
0DE9A:  MOVF   xF8,F
0DE9C:  BNZ   DEAC
0DE9E:  MOVF   xF9,F
0DEA0:  BNZ   DEAC
0DEA2:  MOVF   xFA,F
0DEA4:  BNZ   DEAC
0DEA6:  MOVLB  6
0DEA8:  CLRF   x83
0DEAA:  MOVLB  9
....................     periodic_command(period, 60, 0, { MSG_COMM, 0x93 }); // ADCS 
0DEAC:  BSF    FD8.1
0DEAE:  MOVLW  09
0DEB0:  MOVWF  FEA
0DEB2:  MOVLW  F3
0DEB4:  MOVWF  FE9
0DEB6:  MOVFF  3C,A5E
0DEBA:  MOVFF  3B,A5D
0DEBE:  MOVFF  3A,A5C
0DEC2:  MOVFF  39,A5B
0DEC6:  MOVLB  A
0DEC8:  CLRF   x62
0DECA:  CLRF   x61
0DECC:  CLRF   x60
0DECE:  MOVLW  64
0DED0:  MOVWF  x5F
0DED2:  MOVLB  0
0DED4:  CALL   1E6C
0DED8:  MOVFF  9F6,9FA
0DEDC:  MOVFF  9F5,9F9
0DEE0:  MOVFF  9F4,9F8
0DEE4:  MOVFF  9F3,9F7
0DEE8:  MOVLB  9
0DEEA:  MOVF   xF3,W
0DEEC:  SUBLW  3C
0DEEE:  BNZ   DF20
0DEF0:  MOVF   xF8,F
0DEF2:  BNZ   DF20
0DEF4:  MOVF   xF9,F
0DEF6:  BNZ   DF20
0DEF8:  MOVF   xFA,F
0DEFA:  BNZ   DF20
0DEFC:  MOVLB  6
0DEFE:  MOVF   x83,F
0DF00:  BNZ   DF1E
0DF02:  MOVLW  C0
0DF04:  MOVLB  9
0DF06:  MOVWF  xE7
0DF08:  MOVLW  93
0DF0A:  MOVWF  xE8
0DF0C:  MOVLW  09
0DF0E:  MOVWF  xF4
0DF10:  MOVLW  E7
0DF12:  MOVWF  xF3
0DF14:  SETF   xF5
0DF16:  CLRF   xF6
0DF18:  MOVLB  0
0DF1A:  CALL   C582
0DF1E:  MOVLB  9
....................     periodic_command(period, 64, 0, { MSG_COMM, 0x93 }); // ADCS 
0DF20:  BSF    FD8.1
0DF22:  MOVLW  09
0DF24:  MOVWF  FEA
0DF26:  MOVLW  F3
0DF28:  MOVWF  FE9
0DF2A:  MOVFF  3C,A5E
0DF2E:  MOVFF  3B,A5D
0DF32:  MOVFF  3A,A5C
0DF36:  MOVFF  39,A5B
0DF3A:  MOVLB  A
0DF3C:  CLRF   x62
0DF3E:  CLRF   x61
0DF40:  CLRF   x60
0DF42:  MOVLW  64
0DF44:  MOVWF  x5F
0DF46:  MOVLB  0
0DF48:  CALL   1E6C
0DF4C:  MOVFF  9F6,9FA
0DF50:  MOVFF  9F5,9F9
0DF54:  MOVFF  9F4,9F8
0DF58:  MOVFF  9F3,9F7
0DF5C:  MOVLB  9
0DF5E:  MOVF   xF3,W
0DF60:  SUBLW  40
0DF62:  BNZ   DF94
0DF64:  MOVF   xF8,F
0DF66:  BNZ   DF94
0DF68:  MOVF   xF9,F
0DF6A:  BNZ   DF94
0DF6C:  MOVF   xFA,F
0DF6E:  BNZ   DF94
0DF70:  MOVLB  6
0DF72:  MOVF   x83,F
0DF74:  BNZ   DF92
0DF76:  MOVLW  C0
0DF78:  MOVLB  9
0DF7A:  MOVWF  xE9
0DF7C:  MOVLW  93
0DF7E:  MOVWF  xEA
0DF80:  MOVLW  09
0DF82:  MOVWF  xF4
0DF84:  MOVLW  E9
0DF86:  MOVWF  xF3
0DF88:  SETF   xF5
0DF8A:  CLRF   xF6
0DF8C:  MOVLB  0
0DF8E:  CALL   C582
0DF92:  MOVLB  9
....................     periodic_command(period, 68, 0, { MSG_COMM, 0x93 }); // ADCS 
0DF94:  BSF    FD8.1
0DF96:  MOVLW  09
0DF98:  MOVWF  FEA
0DF9A:  MOVLW  F3
0DF9C:  MOVWF  FE9
0DF9E:  MOVFF  3C,A5E
0DFA2:  MOVFF  3B,A5D
0DFA6:  MOVFF  3A,A5C
0DFAA:  MOVFF  39,A5B
0DFAE:  MOVLB  A
0DFB0:  CLRF   x62
0DFB2:  CLRF   x61
0DFB4:  CLRF   x60
0DFB6:  MOVLW  64
0DFB8:  MOVWF  x5F
0DFBA:  MOVLB  0
0DFBC:  CALL   1E6C
0DFC0:  MOVFF  9F6,9FA
0DFC4:  MOVFF  9F5,9F9
0DFC8:  MOVFF  9F4,9F8
0DFCC:  MOVFF  9F3,9F7
0DFD0:  MOVLB  9
0DFD2:  MOVF   xF3,W
0DFD4:  SUBLW  44
0DFD6:  BNZ   E008
0DFD8:  MOVF   xF8,F
0DFDA:  BNZ   E008
0DFDC:  MOVF   xF9,F
0DFDE:  BNZ   E008
0DFE0:  MOVF   xFA,F
0DFE2:  BNZ   E008
0DFE4:  MOVLB  6
0DFE6:  MOVF   x83,F
0DFE8:  BNZ   E006
0DFEA:  MOVLW  C0
0DFEC:  MOVLB  9
0DFEE:  MOVWF  xEB
0DFF0:  MOVLW  93
0DFF2:  MOVWF  xEC
0DFF4:  MOVLW  09
0DFF6:  MOVWF  xF4
0DFF8:  MOVLW  EB
0DFFA:  MOVWF  xF3
0DFFC:  SETF   xF5
0DFFE:  CLRF   xF6
0E000:  MOVLB  0
0E002:  CALL   C582
0E006:  MOVLB  9
....................     periodic_command(period, 72, 0, { MSG_COMM, 0x93 }); // ADCS 
0E008:  BSF    FD8.1
0E00A:  MOVLW  09
0E00C:  MOVWF  FEA
0E00E:  MOVLW  F3
0E010:  MOVWF  FE9
0E012:  MOVFF  3C,A5E
0E016:  MOVFF  3B,A5D
0E01A:  MOVFF  3A,A5C
0E01E:  MOVFF  39,A5B
0E022:  MOVLB  A
0E024:  CLRF   x62
0E026:  CLRF   x61
0E028:  CLRF   x60
0E02A:  MOVLW  64
0E02C:  MOVWF  x5F
0E02E:  MOVLB  0
0E030:  CALL   1E6C
0E034:  MOVFF  9F6,9FA
0E038:  MOVFF  9F5,9F9
0E03C:  MOVFF  9F4,9F8
0E040:  MOVFF  9F3,9F7
0E044:  MOVLB  9
0E046:  MOVF   xF3,W
0E048:  SUBLW  48
0E04A:  BNZ   E07C
0E04C:  MOVF   xF8,F
0E04E:  BNZ   E07C
0E050:  MOVF   xF9,F
0E052:  BNZ   E07C
0E054:  MOVF   xFA,F
0E056:  BNZ   E07C
0E058:  MOVLB  6
0E05A:  MOVF   x83,F
0E05C:  BNZ   E07A
0E05E:  MOVLW  C0
0E060:  MOVLB  9
0E062:  MOVWF  xED
0E064:  MOVLW  93
0E066:  MOVWF  xEE
0E068:  MOVLW  09
0E06A:  MOVWF  xF4
0E06C:  MOVLW  ED
0E06E:  MOVWF  xF3
0E070:  SETF   xF5
0E072:  CLRF   xF6
0E074:  MOVLB  0
0E076:  CALL   C582
0E07A:  MOVLB  9
....................     periodic_command(period, 76, 0, { MSG_COMM, 0x93 }); // ADCS 
0E07C:  BSF    FD8.1
0E07E:  MOVLW  09
0E080:  MOVWF  FEA
0E082:  MOVLW  F3
0E084:  MOVWF  FE9
0E086:  MOVFF  3C,A5E
0E08A:  MOVFF  3B,A5D
0E08E:  MOVFF  3A,A5C
0E092:  MOVFF  39,A5B
0E096:  MOVLB  A
0E098:  CLRF   x62
0E09A:  CLRF   x61
0E09C:  CLRF   x60
0E09E:  MOVLW  64
0E0A0:  MOVWF  x5F
0E0A2:  MOVLB  0
0E0A4:  CALL   1E6C
0E0A8:  MOVFF  9F6,9FA
0E0AC:  MOVFF  9F5,9F9
0E0B0:  MOVFF  9F4,9F8
0E0B4:  MOVFF  9F3,9F7
0E0B8:  MOVLB  9
0E0BA:  MOVF   xF3,W
0E0BC:  SUBLW  4C
0E0BE:  BNZ   E0F0
0E0C0:  MOVF   xF8,F
0E0C2:  BNZ   E0F0
0E0C4:  MOVF   xF9,F
0E0C6:  BNZ   E0F0
0E0C8:  MOVF   xFA,F
0E0CA:  BNZ   E0F0
0E0CC:  MOVLB  6
0E0CE:  MOVF   x83,F
0E0D0:  BNZ   E0EE
0E0D2:  MOVLW  C0
0E0D4:  MOVLB  9
0E0D6:  MOVWF  xEF
0E0D8:  MOVLW  93
0E0DA:  MOVWF  xF0
0E0DC:  MOVLW  09
0E0DE:  MOVWF  xF4
0E0E0:  MOVLW  EF
0E0E2:  MOVWF  xF3
0E0E4:  SETF   xF5
0E0E6:  CLRF   xF6
0E0E8:  MOVLB  0
0E0EA:  CALL   C582
0E0EE:  MOVLB  9
....................     periodic_command_clear_rx_flag(period, 80);          // ADCS 
0E0F0:  BSF    FD8.1
0E0F2:  MOVLW  09
0E0F4:  MOVWF  FEA
0E0F6:  MOVLW  F3
0E0F8:  MOVWF  FE9
0E0FA:  MOVFF  3C,A5E
0E0FE:  MOVFF  3B,A5D
0E102:  MOVFF  3A,A5C
0E106:  MOVFF  39,A5B
0E10A:  MOVLB  A
0E10C:  CLRF   x62
0E10E:  CLRF   x61
0E110:  CLRF   x60
0E112:  MOVLW  64
0E114:  MOVWF  x5F
0E116:  MOVLB  0
0E118:  CALL   1E6C
0E11C:  MOVFF  9F6,9FA
0E120:  MOVFF  9F5,9F9
0E124:  MOVFF  9F4,9F8
0E128:  MOVFF  9F3,9F7
0E12C:  MOVLB  9
0E12E:  MOVF   xF3,W
0E130:  SUBLW  50
0E132:  BNZ   E146
0E134:  MOVF   xF8,F
0E136:  BNZ   E146
0E138:  MOVF   xF9,F
0E13A:  BNZ   E146
0E13C:  MOVF   xFA,F
0E13E:  BNZ   E146
0E140:  MOVLB  6
0E142:  CLRF   x83
0E144:  MOVLB  9
....................     periodic_command(period, 80, 1, { MSG_COMM, 0xF8 }); // Telemetry generation 
0E146:  BSF    FD8.1
0E148:  MOVLW  09
0E14A:  MOVWF  FEA
0E14C:  MOVLW  F3
0E14E:  MOVWF  FE9
0E150:  MOVFF  3C,A5E
0E154:  MOVFF  3B,A5D
0E158:  MOVFF  3A,A5C
0E15C:  MOVFF  39,A5B
0E160:  MOVLB  A
0E162:  CLRF   x62
0E164:  CLRF   x61
0E166:  CLRF   x60
0E168:  MOVLW  64
0E16A:  MOVWF  x5F
0E16C:  MOVLB  0
0E16E:  CALL   1E6C
0E172:  MOVFF  9F6,9FA
0E176:  MOVFF  9F5,9F9
0E17A:  MOVFF  9F4,9F8
0E17E:  MOVFF  9F3,9F7
0E182:  MOVLB  9
0E184:  MOVF   xF3,W
0E186:  SUBLW  50
0E188:  BNZ   E1BC
0E18A:  MOVF   xF8,F
0E18C:  BNZ   E1BC
0E18E:  MOVF   xF9,F
0E190:  BNZ   E1BC
0E192:  MOVF   xFA,F
0E194:  BNZ   E1BC
0E196:  MOVLB  6
0E198:  MOVF   x83,F
0E19A:  BNZ   E1BA
0E19C:  MOVLW  C0
0E19E:  MOVLB  9
0E1A0:  MOVWF  xF1
0E1A2:  MOVLW  F8
0E1A4:  MOVWF  xF2
0E1A6:  MOVLW  09
0E1A8:  MOVWF  xF4
0E1AA:  MOVLW  F1
0E1AC:  MOVWF  xF3
0E1AE:  SETF   xF5
0E1B0:  MOVLW  01
0E1B2:  MOVWF  xF6
0E1B4:  MOVLB  0
0E1B6:  CALL   C582
0E1BA:  MOVLB  9
0E1BC:  MOVLB  0
0E1BE:  GOTO   E214 (RETURN)
.................... } 
....................  
.................... void periodic_tasks() 
.................... { 
....................     if (clock_update) { 
0E1C2:  MOVLB  6
0E1C4:  MOVF   x81,F
0E1C6:  BTFSC  FD8.2
0E1C8:  BRA    E45E
....................         disable_interrupts(GLOBAL); 
0E1CA:  BCF    FF2.6
0E1CC:  BCF    FF2.7
0E1CE:  BTFSC  FF2.7
0E1D0:  BRA    E1CC
....................         clock_update = 0; 
0E1D2:  CLRF   x81
....................         current_time = time(0); 
0E1D4:  MOVLB  A
0E1D6:  CLRF   x19
0E1D8:  CLRF   x18
0E1DA:  MOVLB  0
0E1DC:  CALL   23A6
0E1E0:  MOVFF  03,3C
0E1E4:  MOVFF  02,3B
0E1E8:  MOVFF  01,3A
0E1EC:  MOVFF  00,39
....................         // ctime(&current_time, &current_time_str); 
....................         schedule_new_commands(); 
0E1F0:  GOTO   D180
....................         if (current_time != previous_time) { 
0E1F4:  MOVF   3D,W
0E1F6:  SUBWF  39,W
0E1F8:  BNZ   E20C
0E1FA:  MOVF   3E,W
0E1FC:  SUBWF  3A,W
0E1FE:  BNZ   E20C
0E200:  MOVF   3F,W
0E202:  SUBWF  3B,W
0E204:  BNZ   E20C
0E206:  MOVF   40,W
0E208:  SUBWF  3C,W
0E20A:  BZ    E214
....................             scheduled_command_check(); 
0E20C:  GOTO   D594
....................             periodic_requests_commands(); 
0E210:  GOTO   D68C
....................         } 
....................         struct_tm* local_time = localtime(&current_time); 
0E214:  MOVLB  A
0E216:  CLRF   x4D
0E218:  MOVLW  39
0E21A:  MOVWF  x4C
0E21C:  MOVLB  0
0E21E:  CALL   246E
0E222:  MOVFF  02,9C6
0E226:  MOVFF  01,9C5
....................         if (local_time->tm_hour == 23 && local_time->tm_min == 59 && local_time->tm_sec == 59) { 
0E22A:  MOVLW  02
0E22C:  MOVLB  9
0E22E:  ADDWF  xC5,W
0E230:  MOVWF  FE9
0E232:  MOVLW  00
0E234:  ADDWFC xC6,W
0E236:  MOVWF  FEA
0E238:  MOVF   FEF,W
0E23A:  SUBLW  17
0E23C:  BNZ   E28E
0E23E:  MOVLW  01
0E240:  ADDWF  xC5,W
0E242:  MOVWF  FE9
0E244:  MOVLW  00
0E246:  ADDWFC xC6,W
0E248:  MOVWF  FEA
0E24A:  MOVF   FEF,W
0E24C:  SUBLW  3B
0E24E:  BNZ   E28E
0E250:  MOVFF  9C5,FE9
0E254:  MOVFF  9C6,FEA
0E258:  MOVF   FEF,W
0E25A:  SUBLW  3B
0E25C:  BNZ   E28E
....................             execute(1, { MSG_COMM, 0x55 }); // Save state 
0E25E:  MOVLW  C0
0E260:  MOVWF  xC7
0E262:  MOVLW  55
0E264:  MOVWF  xC8
0E266:  MOVLW  09
0E268:  MOVWF  xF4
0E26A:  MOVLW  C7
0E26C:  MOVWF  xF3
0E26E:  SETF   xF5
0E270:  MOVLW  01
0E272:  MOVWF  xF6
0E274:  MOVLB  0
0E276:  CALL   C582
....................             fprintf(PC, "No 24h reset happened, doing soft reset instead.\r\n"); 
0E27A:  MOVLW  E4
0E27C:  MOVWF  FF6
0E27E:  MOVLW  19
0E280:  MOVWF  FF7
0E282:  MOVLW  00
0E284:  MOVWF  FF8
0E286:  CALL   1C7A
....................             reset_cpu(); 
0E28A:  RESET
0E28C:  MOVLB  9
....................         } 
....................         previous_time = current_time; 
0E28E:  MOVFF  3C,40
0E292:  MOVFF  3B,3F
0E296:  MOVFF  3A,3E
0E29A:  MOVFF  39,3D
....................         // clean HW uart: 
....................         uart_clean(PCIB); 
0E29E:  MOVLW  07
0E2A0:  MOVLB  B
0E2A2:  MOVWF  x3A
0E2A4:  MOVLW  EA
0E2A6:  MOVWF  x39
....................         uart_clean(COMM); 
*
0E30E:  MOVLW  08
0E310:  MOVWF  x3A
0E312:  MOVLW  23
0E314:  MOVWF  x39
....................         uart_clean(FAB); 
*
0E37C:  MOVLW  08
0E37E:  MOVWF  x3A
0E380:  MOVLW  91
0E382:  MOVWF  x39
....................         uart_clean(RST); 
*
0E3EA:  MOVLW  08
0E3EC:  MOVWF  x3A
0E3EE:  MOVLW  E2
0E3F0:  MOVWF  x39
....................         enable_interrupts(GLOBAL); 
*
0E458:  MOVLW  C0
0E45A:  IORWF  FF2,F
0E45C:  MOVLB  6
....................     } 
0E45E:  MOVLB  0
0E460:  GOTO   EC06 (RETURN)
.................... } 
.................... int main(int argc, char** argv) 
0E464:  CLRF   FF8
0E466:  BCF    FF1.2
0E468:  BCF    F9F.5
0E46A:  BSF    FA5.5
0E46C:  BCF    FA9.5
0E46E:  BCF    FA9.7
0E470:  BSF    FD0.7
0E472:  BSF    07.7
0E474:  MOVLB  E
0E476:  MOVLW  55
0E478:  MOVWF  F7E
0E47A:  MOVLW  AA
0E47C:  MOVWF  F7E
0E47E:  BCF    F66.6
0E480:  MOVLW  F6
0E482:  MOVWF  x2A
0E484:  MOVLW  F5
0E486:  MOVWF  x2B
0E488:  MOVLW  F8
0E48A:  MOVWF  x2C
0E48C:  MOVLW  F9
0E48E:  MOVWF  x2D
0E490:  MOVLW  20
0E492:  MOVWF  x1D
0E494:  MOVLW  01
0E496:  MOVWF  x1F
0E498:  MOVLW  30
0E49A:  MOVWF  x22
0E49C:  MOVLW  20
0E49E:  MOVWF  x24
0E4A0:  MOVLW  55
0E4A2:  MOVWF  F7E
0E4A4:  MOVLW  AA
0E4A6:  MOVWF  F7E
0E4A8:  BSF    F66.6
0E4AA:  CLRF   F9B
0E4AC:  CLRF   F64
0E4AE:  CLRF   F65
0E4B0:  CLRF   F66
0E4B2:  MOVLW  02
0E4B4:  MOVWF  FD3
0E4B6:  CLRF   30
0E4B8:  BSF    F67.3
0E4BA:  MOVLW  22
0E4BC:  MOVWF  FAF
0E4BE:  MOVLW  00
0E4C0:  MOVLB  F
0E4C2:  MOVWF  x30
0E4C4:  MOVLW  A6
0E4C6:  MOVWF  FAC
0E4C8:  MOVLW  90
0E4CA:  MOVWF  FAB
0E4CC:  BSF    x31.3
0E4CE:  MOVLW  A0
0E4D0:  MOVWF  x1F
0E4D2:  MOVLW  01
0E4D4:  MOVWF  x20
0E4D6:  MOVLW  A6
0E4D8:  MOVWF  x32
0E4DA:  MOVLW  90
0E4DC:  MOVWF  x33
0E4DE:  BSF    x2D.3
0E4E0:  MOVLW  A0
0E4E2:  MOVWF  x2B
0E4E4:  MOVLW  01
0E4E6:  MOVWF  x2C
0E4E8:  MOVLW  A6
0E4EA:  MOVWF  x2E
0E4EC:  MOVLW  90
0E4EE:  MOVWF  x2F
0E4F0:  MOVLB  E
0E4F2:  BCF    xFD.3
0E4F4:  MOVLW  0C
0E4F6:  MOVWF  xFB
0E4F8:  MOVLW  A2
0E4FA:  MOVWF  xFE
0E4FC:  MOVLW  90
0E4FE:  MOVWF  xFF
0E500:  BCF    F94.6
0E502:  BSF    F8B.6
0E504:  BCF    F95.5
0E506:  BSF    F8C.5
0E508:  BSF    F96.0
0E50A:  BCF    F96.6
0E50C:  BCF    F96.1
0E50E:  BCF    F8D.1
0E510:  BSF    F93.5
0E512:  BCF    F93.4
0E514:  BCF    F93.2
0E516:  BCF    F8A.2
0E518:  BSF    F92.0
0E51A:  BCF    F92.1
0E51C:  BCF    F92.3
0E51E:  BCF    F89.3
0E520:  MOVLB  4
0E522:  CLRF   xBF
0E524:  MOVLB  6
0E526:  CLRF   x80
0E528:  CLRF   x81
0E52A:  MOVLW  01
0E52C:  MOVWF  x82
0E52E:  CLRF   x83
0E530:  MOVLW  38
0E532:  MOVWF  x87
0E534:  MOVLW  6D
0E536:  MOVWF  x86
0E538:  MOVLW  43
0E53A:  MOVWF  x85
0E53C:  MOVLW  80
0E53E:  MOVWF  x84
0E540:  CLRF   x88
0E542:  CLRF   x89
0E544:  MOVLW  0C
0E546:  MOVWF  x8A
0E548:  MOVLW  07
0E54A:  MOVLB  7
0E54C:  MOVWF  xA3
0E54E:  MOVLW  93
0E550:  MOVWF  xA2
0E552:  MOVLW  07
0E554:  MOVWF  xA5
0E556:  MOVLW  96
0E558:  MOVWF  xA4
0E55A:  MOVLW  07
0E55C:  MOVWF  xA7
0E55E:  MOVLW  99
0E560:  MOVWF  xA6
0E562:  MOVLW  07
0E564:  MOVWF  xA9
0E566:  MOVLW  9C
0E568:  MOVWF  xA8
0E56A:  MOVLW  07
0E56C:  MOVWF  xAB
0E56E:  MOVLW  9F
0E570:  MOVWF  xAA
0E572:  CLRF   xAD
0E574:  CLRF   xAC
0E576:  MOVLB  9
0E578:  CLRF   x52
0E57A:  CLRF   x51
0E57C:  CLRF   x50
0E57E:  CLRF   x4F
0E580:  CLRF   x53
0E582:  MOVLB  E
0E584:  CLRF   xD9
0E586:  CLRF   xDA
0E588:  CLRF   x45
0E58A:  CLRF   x46
0E58C:  CLRF   x47
0E58E:  BCF    x8D.7
0E590:  BCF    x8D.6
0E592:  BCF    x8D.5
0E594:  MOVLB  1
0E596:  CLRF   x88
0E598:  MOVLB  F
0E59A:  CLRF   x53
0E59C:  CLRF   x38
0E59E:  CLRF   x37
0E5A0:  MOVLW  0B
0E5A2:  MOVWF  38
0E5A4:  MOVLW  42
0E5A6:  MOVWF  37
0E5A8:  MOVLW  02
0E5AA:  MOVLB  B
0E5AC:  MOVWF  x43
0E5AE:  MOVLW  B4
0E5B0:  MOVWF  x42
0E5B2:  CLRF   x45
0E5B4:  CLRF   x44
0E5B6:  MOVLB  0
0E5B8:  MOVLB  7
0E5BA:  CLRF   xE1
0E5BC:  CLRF   xE0
0E5BE:  MOVLW  2B
0E5C0:  MOVWF  xDF
0E5C2:  MOVLW  7E
0E5C4:  MOVWF  xDE
0E5C6:  CLRF   xE5
0E5C8:  CLRF   xE4
0E5CA:  MOVLW  2B
0E5CC:  MOVWF  xE3
0E5CE:  MOVLW  D2
0E5D0:  MOVWF  xE2
0E5D2:  CLRF   xE9
0E5D4:  CLRF   xE8
0E5D6:  MOVLW  29
0E5D8:  MOVWF  xE7
0E5DA:  MOVLW  EE
0E5DC:  MOVWF  xE6
0E5DE:  MOVLB  8
0E5E0:  CLRF   x1A
0E5E2:  CLRF   x19
0E5E4:  MOVLW  2B
0E5E6:  MOVWF  x18
0E5E8:  MOVLW  D8
0E5EA:  MOVWF  x17
0E5EC:  CLRF   x1E
0E5EE:  CLRF   x1D
0E5F0:  MOVLW  2B
0E5F2:  MOVWF  x1C
0E5F4:  MOVLW  E2
0E5F6:  MOVWF  x1B
0E5F8:  CLRF   x22
0E5FA:  CLRF   x21
0E5FC:  MOVLW  2A
0E5FE:  MOVWF  x20
0E600:  MOVLW  00
0E602:  MOVWF  x1F
0E604:  CLRF   x48
0E606:  CLRF   x47
0E608:  MOVLW  2B
0E60A:  MOVWF  x46
0E60C:  MOVLW  EA
0E60E:  MOVWF  x45
0E610:  CLRF   x4C
0E612:  CLRF   x4B
0E614:  MOVLW  2B
0E616:  MOVWF  x4A
0E618:  MOVLW  F4
0E61A:  MOVWF  x49
0E61C:  CLRF   x50
0E61E:  CLRF   x4F
0E620:  MOVLW  2A
0E622:  MOVWF  x4E
0E624:  MOVLW  16
0E626:  MOVWF  x4D
0E628:  CLRF   x88
0E62A:  CLRF   x87
0E62C:  MOVLW  2B
0E62E:  MOVWF  x86
0E630:  MOVLW  FC
0E632:  MOVWF  x85
0E634:  CLRF   x8C
0E636:  CLRF   x8B
0E638:  MOVLW  2C
0E63A:  MOVWF  x8A
0E63C:  MOVLW  50
0E63E:  MOVWF  x89
0E640:  CLRF   x90
0E642:  CLRF   x8F
0E644:  MOVLW  2A
0E646:  MOVWF  x8E
0E648:  MOVLW  66
0E64A:  MOVWF  x8D
0E64C:  CLRF   xD9
0E64E:  CLRF   xD8
0E650:  MOVLW  2C
0E652:  MOVWF  xD7
0E654:  MOVLW  56
0E656:  MOVWF  xD6
0E658:  CLRF   xDD
0E65A:  CLRF   xDC
0E65C:  MOVLW  2C
0E65E:  MOVWF  xDB
0E660:  MOVLW  60
0E662:  MOVWF  xDA
0E664:  CLRF   xE1
0E666:  CLRF   xE0
0E668:  MOVLW  2A
0E66A:  MOVWF  xDF
0E66C:  MOVLW  7A
0E66E:  MOVWF  xDE
0E670:  MOVLB  9
0E672:  CLRF   x12
0E674:  CLRF   x11
0E676:  MOVLW  2C
0E678:  MOVWF  x10
0E67A:  MOVLW  68
0E67C:  MOVWF  x0F
0E67E:  CLRF   x16
0E680:  CLRF   x15
0E682:  MOVLW  2C
0E684:  MOVWF  x14
0E686:  MOVLW  72
0E688:  MOVWF  x13
0E68A:  CLRF   x1A
0E68C:  CLRF   x19
0E68E:  MOVLW  2A
0E690:  MOVWF  x18
0E692:  MOVLW  90
0E694:  MOVWF  x17
0E696:  CLRF   x1E
0E698:  CLRF   x1D
0E69A:  MOVLW  2A
0E69C:  MOVWF  x1C
0E69E:  MOVLW  D6
0E6A0:  MOVWF  x1B
0E6A2:  CLRF   x22
0E6A4:  CLRF   x21
0E6A6:  MOVLW  2C
0E6A8:  MOVWF  x20
0E6AA:  MOVLW  7A
0E6AC:  MOVWF  x1F
0E6AE:  CLRF   x28
0E6B0:  CLRF   x27
0E6B2:  MOVLW  2B
0E6B4:  MOVWF  x26
0E6B6:  MOVLW  22
0E6B8:  MOVWF  x25
0E6BA:  CLRF   x2C
0E6BC:  CLRF   x2B
0E6BE:  MOVLW  2C
0E6C0:  MOVWF  x2A
0E6C2:  MOVLW  8C
0E6C4:  MOVWF  x29
0E6C6:  CLRF   x32
0E6C8:  CLRF   x31
0E6CA:  MOVLW  2B
0E6CC:  MOVWF  x30
0E6CE:  MOVLW  6E
0E6D0:  MOVWF  x2F
0E6D2:  CLRF   x36
0E6D4:  CLRF   x35
0E6D6:  MOVLW  2C
0E6D8:  MOVWF  x34
0E6DA:  MOVLW  9E
0E6DC:  MOVWF  x33
0E6DE:  BRA    E726
0E6E0:  DATA 02,00
0E6E2:  DATA 31,00
0E6E4:  DATA 00,0B
0E6E6:  DATA 00,ED
0E6E8:  DATA FF,00
0E6EA:  DATA 01,01
0E6EC:  DATA 00,00
0E6EE:  DATA 02,3F
0E6F0:  DATA 0C,48
0E6F2:  DATA 0C,27
0E6F4:  DATA C0,00
0E6F6:  DATA 0F,07
0E6F8:  DATA 93,C0
0E6FA:  DATA 19,01
0E6FC:  DATA AB,24
0E6FE:  DATA 01,B0
0E700:  DATA 24,00
0E702:  DATA E0,3C
0E704:  DATA 00,AD
0E706:  DATA 2B,01
0E708:  DATA 04,07
0E70A:  DATA B8,00
0E70C:  DATA 00,00
0E70E:  DATA 00,02
0E710:  DATA 09,23
0E712:  DATA 0B,7C
0E714:  DATA 02,09
0E716:  DATA 2D,22
0E718:  DATA 7C,02
0E71A:  DATA 09,37
0E71C:  DATA 02,7C
0E71E:  DATA 16,C0
0E720:  DATA 00,6C
0E722:  DATA 49,54
0E724:  DATA 00,00
0E726:  MOVLW  00
0E728:  MOVWF  FF8
0E72A:  MOVLW  E6
0E72C:  MOVWF  FF7
0E72E:  MOVLW  E0
0E730:  MOVWF  FF6
0E732:  TBLRD*+
0E734:  MOVF   FF5,W
0E736:  MOVWF  00
0E738:  XORLW  00
0E73A:  BZ    E762
0E73C:  TBLRD*+
0E73E:  MOVF   FF5,W
0E740:  MOVWF  01
0E742:  BTFSC  FE8.7
0E744:  BRA    E750
0E746:  ANDLW  0F
0E748:  MOVWF  FEA
0E74A:  TBLRD*+
0E74C:  MOVF   FF5,W
0E74E:  MOVWF  FE9
0E750:  BTFSC  01.6
0E752:  TBLRD*+
0E754:  BTFSS  01.6
0E756:  TBLRD*+
0E758:  MOVF   FF5,W
0E75A:  MOVWF  FEE
0E75C:  DCFSNZ 00,F
0E75E:  BRA    E732
0E760:  BRA    E754
0E762:  CLRF   FF8
.................... { 
....................     // UART configuration 
....................     uart_init(PC); 
0E764:  MOVLW  07
0E766:  MOVLB  7
0E768:  MOVWF  xBD
0E76A:  MOVLW  C5
0E76C:  MOVWF  xBC
0E76E:  MOVLW  19
0E770:  MOVWF  xBE
0E772:  MOVLW  07
0E774:  MOVLB  B
0E776:  MOVWF  x3A
0E778:  MOVLW  BC
0E77A:  MOVWF  x39
....................     uart_init(COMM); 
*
0E7E2:  MOVLW  08
0E7E4:  MOVLB  8
0E7E6:  MOVWF  x24
0E7E8:  MOVLW  2C
0E7EA:  MOVWF  x23
0E7EC:  MOVLW  19
0E7EE:  MOVWF  x25
0E7F0:  MOVLW  08
0E7F2:  MOVLB  B
0E7F4:  MOVWF  x3A
0E7F6:  MOVLW  23
0E7F8:  MOVWF  x39
....................     uart_init(RST); 
*
0E860:  MOVLW  08
0E862:  MOVLB  8
0E864:  MOVWF  xE3
0E866:  MOVLW  EB
0E868:  MOVWF  xE2
0E86A:  MOVLW  24
0E86C:  MOVWF  xE4
0E86E:  MOVLW  08
0E870:  MOVLB  B
0E872:  MOVWF  x3A
0E874:  MOVLW  E2
0E876:  MOVWF  x39
....................     uart_init(FAB); 
*
0E8DE:  MOVLW  08
0E8E0:  MOVLB  8
0E8E2:  MOVWF  x92
0E8E4:  MOVLW  9A
0E8E6:  MOVWF  x91
0E8E8:  MOVLW  3C
0E8EA:  MOVWF  x93
0E8EC:  MOVLW  08
0E8EE:  MOVLB  B
0E8F0:  MOVWF  x3A
0E8F2:  MOVLW  91
0E8F4:  MOVWF  x39
....................     uart_init(PCIB); 
*
0E95C:  MOVLW  07
0E95E:  MOVLB  7
0E960:  MOVWF  xEB
0E962:  MOVLW  F3
0E964:  MOVWF  xEA
0E966:  MOVLW  24
0E968:  MOVWF  xEC
0E96A:  MOVLW  07
0E96C:  MOVLB  B
0E96E:  MOVWF  x3A
0E970:  MOVLW  EA
0E972:  MOVWF  x39
....................     uart_init(ADCS); 
*
0E9DA:  MOVLW  08
0E9DC:  MOVLB  8
0E9DE:  MOVWF  x52
0E9E0:  MOVLW  5A
0E9E2:  MOVWF  x51
0E9E4:  MOVLW  2B
0E9E6:  MOVWF  x53
0E9E8:  MOVLW  08
0E9EA:  MOVLB  B
0E9EC:  MOVWF  x3A
0E9EE:  MOVLW  51
0E9F0:  MOVWF  x39
....................  
....................     fprintf(pc, "\r\n"); 
*
0EA58:  MOVLW  0D
0EA5A:  MOVWF  x1F
0EA5C:  MOVLB  0
0EA5E:  CALL   1C34
0EA62:  MOVLW  0A
0EA64:  MOVLB  B
0EA66:  MOVWF  x1F
0EA68:  MOVLB  0
0EA6A:  CALL   1C34
....................     fprintf(pc, "____   ________________________________________________________   _________\r\n"); 
0EA6E:  MOVLW  18
0EA70:  MOVWF  FF6
0EA72:  MOVLW  1A
0EA74:  MOVWF  FF7
0EA76:  MOVLW  00
0EA78:  MOVWF  FF8
0EA7A:  CALL   1C7A
....................     fprintf(pc, "\\   \\ /   /\\_   _____/\\______   \\__    ___/\\_   _____/\\_   ___ \\ /   _____/\r\n"); 
0EA7E:  MOVLW  66
0EA80:  MOVWF  FF6
0EA82:  MOVLW  1A
0EA84:  MOVWF  FF7
0EA86:  MOVLW  00
0EA88:  MOVWF  FF8
0EA8A:  CALL   1C7A
....................     fprintf(pc, " \\   y   /  |    __)_  |       _/ |    |    |    __)_ /    \\  \\/ \\_____  \\ \r\n"); 
0EA8E:  MOVLW  B4
0EA90:  MOVWF  FF6
0EA92:  MOVLW  1A
0EA94:  MOVWF  FF7
0EA96:  MOVLW  00
0EA98:  MOVWF  FF8
0EA9A:  CALL   1C7A
....................     fprintf(pc, "  \\     /   |        \\ |    |   \\ |    |    |        \\\\     \\____/        \\\r\n"); 
0EA9E:  MOVLW  02
0EAA0:  MOVWF  FF6
0EAA2:  MOVLW  1B
0EAA4:  MOVWF  FF7
0EAA6:  MOVLW  00
0EAA8:  MOVWF  FF8
0EAAA:  CALL   1C7A
....................     fprintf(pc, "   \\___/   /_______  / |____|_  / |____|   /_______  / \\______  /_______  /\r\n"); 
0EAAE:  MOVLW  50
0EAB0:  MOVWF  FF6
0EAB2:  MOVLW  1B
0EAB4:  MOVWF  FF7
0EAB6:  MOVLW  00
0EAB8:  MOVWF  FF8
0EABA:  CALL   1C7A
....................     fprintf(pc, "                   \\/         \\/                   \\/         \\/        \\/ \r\n\r\n"); 
0EABE:  MOVLW  9E
0EAC0:  MOVWF  FF6
0EAC2:  MOVLW  1B
0EAC4:  MOVWF  FF7
0EAC6:  MOVLW  00
0EAC8:  MOVWF  FF8
0EACA:  CALL   1C7A
....................     fprintf(PC, "Compiled on: "__DATE__ 
....................                 " "__TIME__ 
....................                 "\r\n\r\n"); 
....................  
....................     // Satellite time initialization 
0EACE:  MOVLW  EE
0EAD0:  MOVWF  FF6
0EAD2:  MOVLW  1B
0EAD4:  MOVWF  FF7
0EAD6:  MOVLW  00
0EAD8:  MOVWF  FF8
0EADA:  CALL   1C7A
....................     current_time = time(0); 
....................     // In case RTC registers have invalid data, load the initial time 
....................     if (current_time < T0 || current_time > Tn) { 
0EADE:  MOVLB  A
0EAE0:  CLRF   x19
0EAE2:  CLRF   x18
0EAE4:  MOVLB  0
0EAE6:  CALL   23A6
0EAEA:  MOVFF  03,3C
0EAEE:  MOVFF  02,3B
0EAF2:  MOVFF  01,3A
0EAF6:  MOVFF  00,39
....................         fprintf(PC, "> Invalid clock, recovering...\r\n"); 
....................         current_time = T0; 
0EAFA:  BTFSC  3C.7
0EAFC:  BRA    EB44
0EAFE:  MOVF   3C,W
0EB00:  SUBLW  38
0EB02:  BNC   EB1C
0EB04:  BNZ   EB44
0EB06:  MOVF   3B,W
0EB08:  SUBLW  6D
0EB0A:  BNC   EB1C
0EB0C:  BNZ   EB44
0EB0E:  MOVF   3A,W
0EB10:  SUBLW  43
0EB12:  BNC   EB1C
0EB14:  BNZ   EB44
0EB16:  MOVF   39,W
0EB18:  SUBLW  7F
0EB1A:  BC    EB44
0EB1C:  BTFSC  3C.7
0EB1E:  BRA    EB7C
0EB20:  MOVF   3C,W
0EB22:  SUBLW  7E
0EB24:  BC    EB7C
0EB26:  XORLW  FF
0EB28:  BNZ   EB44
0EB2A:  MOVF   3B,W
0EB2C:  SUBLW  FE
0EB2E:  BC    EB7C
0EB30:  XORLW  FF
0EB32:  BNZ   EB44
0EB34:  MOVF   3A,W
0EB36:  SUBLW  FE
0EB38:  BC    EB7C
0EB3A:  XORLW  FF
0EB3C:  BNZ   EB44
0EB3E:  MOVF   39,W
0EB40:  SUBLW  FE
0EB42:  BC    EB7C
....................         SetTimeSec(T0); 
0EB44:  MOVLW  12
0EB46:  MOVWF  FF6
0EB48:  MOVLW  1C
0EB4A:  MOVWF  FF7
0EB4C:  MOVLW  00
0EB4E:  MOVWF  FF8
0EB50:  CALL   1C7A
....................     } 
0EB54:  MOVLW  38
0EB56:  MOVWF  3C
0EB58:  MOVLW  6D
0EB5A:  MOVWF  3B
0EB5C:  MOVLW  43
0EB5E:  MOVWF  3A
0EB60:  MOVLW  80
0EB62:  MOVWF  39
....................     previous_time = current_time; 
0EB64:  MOVLW  38
0EB66:  MOVLB  A
0EB68:  MOVWF  x1F
0EB6A:  MOVLW  6D
0EB6C:  MOVWF  x1E
0EB6E:  MOVLW  43
0EB70:  MOVWF  x1D
0EB72:  MOVLW  80
0EB74:  MOVWF  x1C
0EB76:  MOVLB  0
0EB78:  CALL   2886
....................     // ctime(&current_time, &current_time_str); 
....................  
0EB7C:  MOVFF  3C,40
0EB80:  MOVFF  3B,3F
0EB84:  MOVFF  3A,3E
0EB88:  MOVFF  39,3D
0EB8C:  MOVLB  F
....................     // > RTC & Timers 
....................     setup_rtc(RTC_ENABLE | RTC_CLOCK_SOSC, 0x00); // enables internal RTC 
....................     setup_timer_0(T0_INTERNAL | T0_DIV_32); 
....................  
0EB8E:  MOVLB  F
0EB90:  MOVLW  55
0EB92:  MOVWF  F7E
0EB94:  MOVLW  AA
0EB96:  MOVWF  F7E
0EB98:  BSF    x5F.5
0EB9A:  CLRF   x5E
0EB9C:  CLRF   x57
0EB9E:  MOVLW  80
0EBA0:  MOVWF  x5F
0EBA2:  BCF    x5F.5
0EBA4:  BSF    F66.1
....................     // Telemetry initialization 
0EBA6:  MOVLW  94
0EBA8:  MOVWF  FD5
....................     initialize_telemetry(); 
....................  
....................     // Memory 
0EBAA:  MOVLB  0
0EBAC:  CALL   2982
....................     output_low(MUX_SEL_COM_SHARED_FM);  // COM SHARED FM to OBC side 
....................     output_high(MUX_SEL_MSN_SHARED_FM); // Mission SHARED FM 
....................     memory_setup(); 
0EBB0:  BCF    F94.5
0EBB2:  BCF    F8B.5
....................     print_flags(); 
0EBB4:  BCF    F92.5
0EBB6:  BSF    F89.5
....................  
0EBB8:  GOTO   48F0
....................     // Interrputions 
0EBBC:  CALL   4A28
....................     enable_interrupts(INT_TIMER0); 
....................     enable_interrupts(GLOBAL); 
....................     enable_interrupts(INT_RDA);  // PCIB 
0EBC0:  BSF    FF2.5
....................     enable_interrupts(INT_RDA2); // COMM 
0EBC2:  MOVLW  C0
0EBC4:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA3); // FAB 
0EBC6:  BSF    F9D.5
....................     enable_interrupts(INT_RDA4); // RST 
0EBC8:  BSF    FA3.5
....................  
0EBCA:  BSF    F61.5
....................     // OCPs 
0EBCC:  BSF    F61.7
....................     output_bit(OCP_EN_ADCS, obc_flags.adcs_on_off); // ADCS 
....................     output_bit(OCP_EN_PCIB, obc_flags.pcib_on_off); // PCIB 
....................  
0EBCE:  MOVF   xEF,F
0EBD0:  BNZ   EBD6
0EBD2:  BCF    F8F.4
0EBD4:  BRA    EBD8
0EBD6:  BSF    F8F.4
0EBD8:  BCF    F98.4
....................     execute(1, { MSG_PC, 0xFF }); // Reset log 
0EBDA:  MOVF   xF0,F
0EBDC:  BNZ   EBE2
0EBDE:  BCF    F8E.5
0EBE0:  BRA    EBE4
0EBE2:  BSF    F8E.5
0EBE4:  BCF    F97.5
....................  
....................     // > Main Loop 
0EBE6:  MOVLW  DB
0EBE8:  MOVLB  9
0EBEA:  MOVWF  xC3
0EBEC:  SETF   xC4
0EBEE:  MOVLW  09
0EBF0:  MOVWF  xF4
0EBF2:  MOVLW  C3
0EBF4:  MOVWF  xF3
0EBF6:  SETF   xF5
0EBF8:  MOVLW  01
0EBFA:  MOVWF  xF6
0EBFC:  MOVLB  0
0EBFE:  CALL   C582
....................     while (TRUE) { 
....................         // Periodic tasks: 
....................         periodic_tasks(); 
....................         // UART tasks: 
....................         switch (uart_mux) { 
0EC02:  GOTO   E1C2
....................         case 0: 
....................             if (kbhit(ADCS)) { 
0EC06:  MOVLB  6
0EC08:  MOVF   x82,W
0EC0A:  XORLW  00
0EC0C:  MOVLB  0
0EC0E:  BZ    EC1A
0EC10:  XORLW  01
0EC12:  BTFSC  FD8.2
0EC14:  BRA    EFD2
0EC16:  GOTO   F38A
....................                 uart_update(ADCS, message_ADCS); 
....................             } 
0EC1A:  BTFSC  F85.6
0EC1C:  BRA    EFD0
....................             break; 
0EC1E:  CALL   2C06
0EC22:  MOVFF  01,9C5
0EC26:  MOVLW  08
0EC28:  MOVLB  B
0EC2A:  MOVWF  x35
0EC2C:  MOVLW  51
0EC2E:  MOVWF  x34
0EC30:  MOVFF  7AB,B37
0EC34:  MOVFF  7AA,B36
0EC38:  MOVFF  9C5,B38
....................         case 1: 
....................             if (kbhit(PC)) { 
*
0EFD0:  BRA    F38A
....................                 uart_update(PC, message_COMM); // Receive the same messages as COMM 
....................             } 
0EFD2:  BTFSC  F82.7
0EFD4:  BRA    F388
....................             break; 
0EFD6:  CALL   2B88
0EFDA:  MOVFF  01,9C5
0EFDE:  MOVLW  07
0EFE0:  MOVLB  B
0EFE2:  MOVWF  x35
0EFE4:  MOVLW  BC
0EFE6:  MOVWF  x34
0EFE8:  MOVFF  7A3,B37
0EFEC:  MOVFF  7A2,B36
0EFF0:  MOVFF  9C5,B38
....................         default: 
....................             break; 
*
0F388:  BRA    F38A
....................         } 
....................     } 
....................     return 0; 
0F38A:  BRA    EC02
.................... } 
....................  
0F38C:  MOVLW  00
0F38E:  MOVWF  01
....................  
0F390:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
